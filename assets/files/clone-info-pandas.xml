<clones>
<systeminfo processor="nicad3" system="pandas" granularity="functions" threshold="30%" minlines="10" maxlines="2500"/>
<cloneinfo npcs="10040" npairs="365"/>
<runinfo ncompares="5634361" cputime="2968"/>
<classinfo nclasses="229"/>

<class classid="1" nclones="3" nlines="11" similarity="72">
<source file="pandas/asv_bench/benchmarks/io/hdf.py.pyindent" startline="137" endline="146" pcid="323">
    def setup(self, format):
        self.fname = '__test__.h5'
        N = 100000
        C = 5
        self.df = DataFrame(np.random.randn(N, C),
                            columns=['float{}'.format(i) for i in range(C)],
                            index=date_range('20000101', periods=N, freq='H'))
        self.df['object'] = tm.makeStringIndex(N)
        self.df.to_hdf(self.fname, 'df', format=format)

</source>
<source file="pandas/asv_bench/benchmarks/io/pickle.py.pyindent" startline="12" endline="21" pcid="347">
    def setup(self):
        self.fname = '__test__.pkl'
        N = 100000
        C = 5
        self.df = DataFrame(np.random.randn(N, C),
                            columns=['float{}'.format(i) for i in range(C)],
                            index=date_range('20000101', periods=N, freq='H'))
        self.df['object'] = tm.makeStringIndex(N)
        self.df.to_pickle(self.fname)

</source>
<source file="pandas/asv_bench/benchmarks/io/msgpack.py.pyindent" startline="12" endline="21" pcid="344">
    def setup(self):
        self.fname = '__test__.msg'
        N = 100000
        C = 5
        self.df = DataFrame(np.random.randn(N, C),
                            columns=['float{}'.format(i) for i in range(C)],
                            index=date_range('20000101', periods=N, freq='H'))
        self.df['object'] = tm.makeStringIndex(N)
        self.df.to_msgpack(self.fname)

</source>
</class>

<class classid="2" nclones="2" nlines="10" similarity="80">
<source file="pandas/asv_bench/benchmarks/io/json.py.pyindent" startline="15" endline="23" pcid="326">
    def setup(self, orient, index):
        N = 100000
        indexes = {'int': np.arange(N),
                   'datetime': date_range('20000101', periods=N, freq='H')}
        df = DataFrame(np.random.randn(N, 5),
                       columns=['float_{}'.format(i) for i in range(5)],
                       index=indexes[index])
        df.to_json(self.fname, orient=orient)

</source>
<source file="pandas/asv_bench/benchmarks/io/json.py.pyindent" startline="35" endline="43" pcid="328">
    def setup(self, index):
        N = 100000
        indexes = {'int': np.arange(N),
                   'datetime': date_range('20000101', periods=N, freq='H')}
        df = DataFrame(np.random.randn(N, 5),
                       columns=['float_{}'.format(i) for i in range(5)],
                       index=indexes[index])
        df.to_json(self.fname, orient='records', lines=True)

</source>
</class>

<class classid="3" nclones="4" nlines="20" similarity="71">
<source file="pandas/asv_bench/benchmarks/io/sql.py.pyindent" startline="17" endline="36" pcid="352">
    def setup(self, connection):
        N = 10000
        con = {'sqlalchemy': create_engine('sqlite:///:memory:'),
               'sqlite': sqlite3.connect(':memory:')}
        self.table_name = 'test_type'
        self.query_all = 'SELECT * FROM {}'.format(self.table_name)
        self.con = con[connection]
        self.df = DataFrame({'float': np.random.randn(N),
                             'float_with_nan': np.random.randn(N),
                             'string': ['foo'] * N,
                             'bool': [True] * N,
                             'int': np.random.randint(0, N, size=N),
                             'datetime': date_range('2000-01-01',
                                                    periods=N,
                                                    freq='s')},
                            index=tm.makeStringIndex(N))
        self.df.loc[1000:3000, 'float_with_nan'] = np.nan
        self.df['datetime_string'] = self.df['datetime'].astype(str)
        self.df.to_sql(self.table_name, self.con, if_exists='replace')

</source>
<source file="pandas/asv_bench/benchmarks/io/sql.py.pyindent" startline="82" endline="98" pcid="358">
    def setup(self):
        N = 10000
        self.table_name = 'test'
        self.con = create_engine('sqlite:///:memory:')
        self.df = DataFrame({'float': np.random.randn(N),
                             'float_with_nan': np.random.randn(N),
                             'string': ['foo'] * N,
                             'bool': [True] * N,
                             'int': np.random.randint(0, N, size=N),
                             'datetime': date_range('2000-01-01',
                                                    periods=N,
                                                    freq='s')},
                            index=tm.makeStringIndex(N))
        self.df.loc[1000:3000, 'float_with_nan'] = np.nan
        self.df['datetime_string'] = self.df['datetime'].astype(str)
        self.df.to_sql(self.table_name, self.con, if_exists='replace')

</source>
<source file="pandas/asv_bench/benchmarks/io/sql.py.pyindent" startline="114" endline="130" pcid="361">
    def setup(self, dtype):
        N = 10000
        self.table_name = 'test'
        self.con = create_engine('sqlite:///:memory:')
        self.df = DataFrame({'float': np.random.randn(N),
                             'float_with_nan': np.random.randn(N),
                             'string': ['foo'] * N,
                             'bool': [True] * N,
                             'int': np.random.randint(0, N, size=N),
                             'datetime': date_range('2000-01-01',
                                                    periods=N,
                                                    freq='s')},
                            index=tm.makeStringIndex(N))
        self.df.loc[1000:3000, 'float_with_nan'] = np.nan
        self.df['datetime_string'] = self.df['datetime'].astype(str)
        self.df.to_sql(self.table_name, self.con, if_exists='replace')

</source>
<source file="pandas/asv_bench/benchmarks/io/sql.py.pyindent" startline="51" endline="70" pcid="355">
    def setup(self, connection, dtype):
        N = 10000
        con = {'sqlalchemy': create_engine('sqlite:///:memory:'),
               'sqlite': sqlite3.connect(':memory:')}
        self.table_name = 'test_type'
        self.query_col = 'SELECT {} FROM {}'.format(dtype, self.table_name)
        self.con = con[connection]
        self.df = DataFrame({'float': np.random.randn(N),
                             'float_with_nan': np.random.randn(N),
                             'string': ['foo'] * N,
                             'bool': [True] * N,
                             'int': np.random.randint(0, N, size=N),
                             'datetime': date_range('2000-01-01',
                                                    periods=N,
                                                    freq='s')},
                            index=tm.makeStringIndex(N))
        self.df.loc[1000:3000, 'float_with_nan'] = np.nan
        self.df['datetime_string'] = self.df['datetime'].astype(str)
        self.df.to_sql(self.table_name, self.con, if_exists='replace')

</source>
</class>

<class classid="4" nclones="5" nlines="11" similarity="72">
<source file="pandas/asv_bench/benchmarks/pandas_vb_common.py.pyindent" startline="33" endline="41" pcid="446">
    def remove(self, f):
        """Remove created files"""
        try:
            os.remove(f)
        except:
            # On Windows, attempting to remove a file that is in use
            # causes an exception to be raised
            pass

</source>
<source file="pandas/pandas/compat/__init__.py.pyindent" startline="314" endline="319" pcid="996">
    def u_safe(s):
        try:
            return unicode(s, "unicode_escape")
        except:
            return s

</source>
<source file="pandas/scripts/validate_docstrings.py.pyindent" startline="120" endline="125" pcid="9998">
    def source_file_def_line(self):
        try:
            return inspect.getsourcelines(self.method_obj)[-1]
        except OSError:
            pass

</source>
<source file="pandas/pandas/core/sparse/array.py.pyindent" startline="306" endline="311" pcid="2337">
    def __len__(self):
        try:
            return self.sp_index.length
        except:
            return 0

</source>
<source file="pandas/pandas/io/sas/sas7bdat.py.pyindent" startline="105" endline="110" pcid="2858">
    def close(self):
        try:
            self.handle.close()
        except AttributeError:
            pass

</source>
</class>

<class classid="5" nclones="2" nlines="14" similarity="78">
<source file="pandas/asv_bench/benchmarks/stat_ops.py.pyindent" startline="17" endline="25" pcid="590">
    def setup(self, op, dtype, axis, use_bottleneck):
        df = pd.DataFrame(np.random.randn(100000, 4)).astype(dtype)
        try:
            pd.options.compute.use_bottleneck = use_bottleneck
        except:
            from pandas.core import nanops
            nanops._USE_BOTTLENECK = use_bottleneck
        self.df_func = getattr(df, op)

</source>
<source file="pandas/asv_bench/benchmarks/stat_ops.py.pyindent" startline="55" endline="63" pcid="594">
    def setup(self, op, dtype, use_bottleneck):
        s = pd.Series(np.random.randn(100000)).astype(dtype)
        try:
            pd.options.compute.use_bottleneck = use_bottleneck
        except:
            from pandas.core import nanops
            nanops._USE_BOTTLENECK = use_bottleneck
        self.s_func = getattr(s, op)

</source>
</class>

<class classid="6" nclones="2" nlines="10" similarity="80">
<source file="pandas/asv_bench/benchmarks/stat_ops.py.pyindent" startline="36" endline="44" pcid="592">
    def setup(self, level, op):
        levels = [np.arange(10), np.arange(100), np.arange(100)]
        labels = [np.arange(10).repeat(10000),
                  np.tile(np.arange(100).repeat(100), 10),
                  np.tile(np.tile(np.arange(100), 100), 10)]
        index = pd.MultiIndex(levels=levels, labels=labels)
        df = pd.DataFrame(np.random.randn(len(index), 4), index=index)
        self.df_func = getattr(df, op)

</source>
<source file="pandas/asv_bench/benchmarks/stat_ops.py.pyindent" startline="74" endline="82" pcid="596">
    def setup(self, level, op):
        levels = [np.arange(10), np.arange(100), np.arange(100)]
        labels = [np.arange(10).repeat(10000),
                  np.tile(np.arange(100).repeat(100), 10),
                  np.tile(np.tile(np.arange(100), 100), 10)]
        index = pd.MultiIndex(levels=levels, labels=labels)
        s = pd.Series(np.random.randn(len(index)), index=index)
        self.s_func = getattr(s, op)

</source>
</class>

<class classid="7" nclones="2" nlines="12" similarity="83">
<source file="pandas/doc/sphinxext/numpydoc/docscrape.py.pyindent" startline="390" endline="395" pcid="813">
    def _str_signature(self):
        if self['Signature']:
            return [self['Signature'].replace('*', '\*')] + ['']
        else:
            return ['']

</source>
<source file="pandas/doc/sphinxext/numpydoc/docscrape_sphinx.py.pyindent" startline="57" endline="63" pcid="837">
    def _str_signature(self):
        return ['']
        if self['Signature']:
            return ['``%s``' % self['Signature']] + ['']
        else:
            return ['']

</source>
</class>

<class classid="8" nclones="2" nlines="11" similarity="72">
<source file="pandas/doc/sphinxext/numpydoc/docscrape.py.pyindent" startline="396" endline="401" pcid="814">
    def _str_summary(self):
        if self['Summary']:
            return self['Summary'] + ['']
        else:
            return []

</source>
<source file="pandas/doc/sphinxext/numpydoc/docscrape.py.pyindent" startline="402" endline="407" pcid="815">
    def _str_extended_summary(self):
        if self['Extended Summary']:
            return self['Extended Summary'] + ['']
        else:
            return []

</source>
</class>

<class classid="9" nclones="2" nlines="12" similarity="83">
<source file="pandas/doc/sphinxext/numpydoc/docscrape.py.pyindent" startline="422" endline="429" pcid="817">
    def _str_section(self, name):
        out = []
        if self[name]:
            out += self._str_header(name)
            out += self[name]
            out += ['']
        return out

</source>
<source file="pandas/doc/sphinxext/numpydoc/docscrape_sphinx.py.pyindent" startline="275" endline="283" pcid="845">
    def _str_section(self, name):
        out = []
        if self[name]:
            out += self._str_header(name)
            content = textwrap.dedent("\n".join(self[name])).split("\n")
            out += content
            out += ['']
        return out

</source>
</class>

<class classid="10" nclones="2" nlines="12" similarity="75">
<source file="pandas/pandas/compat/chainmap.py.pyindent" startline="9" endline="15" pcid="919">
    def __setitem__(self, key, value):
        for mapping in self.maps:
            if key in mapping:
                mapping[key] = value
                return
        self.maps[0][key] = value

</source>
<source file="pandas/pandas/compat/chainmap.py.pyindent" startline="16" endline="23" pcid="920">
    def __delitem__(self, key):
        for mapping in self.maps:
            if key in mapping:
                del mapping[key]
                return
        raise KeyError(key)

    # override because the m parameter is introduced in Python 3.4
</source>
</class>

<class classid="11" nclones="2" nlines="12" similarity="83">
<source file="pandas/pandas/compat/chainmap_impl.py.pyindent" startline="120" endline="126" pcid="939">
    def __delitem__(self, key):
        try:
            del self.maps[0][key]
        except KeyError:
            raise KeyError('Key not found in the first mapping: {!r}'
                           .format(key))

</source>
<source file="pandas/pandas/compat/chainmap_impl.py.pyindent" startline="137" endline="147" pcid="941">
    def pop(self, key, *args):
        """
        Remove *key* from maps[0] and return its value. Raise KeyError if
        *key* not in maps[0].
        """
        try:
            return self.maps[0].pop(key, *args)
        except KeyError:
            raise KeyError('Key not found in the first mapping: {!r}'
                           .format(key))

</source>
</class>

<class classid="12" nclones="2" nlines="11" similarity="72">
<source file="pandas/pandas/compat/chainmap_impl.py.pyindent" startline="127" endline="136" pcid="940">
    def popitem(self):
        """
        Remove and return an item pair from maps[0]. Raise KeyError is maps[0]
        is empty.
        """
        try:
            return self.maps[0].popitem()
        except KeyError:
            raise KeyError('No keys found in the first mapping.')

</source>
<source file="pandas/pandas/core/sparse/scipy_sparse.py.pyindent" startline="60" endline="67" pcid="2376">
            def robust_get_level_values(i):
                # if index has labels (that are not None) use those,
                # else use the level location
                try:
                    return index.get_level_values(index.names[i])
                except KeyError:
                    return index.get_level_values(i)

</source>
</class>

<class classid="13" nclones="3" nlines="18" similarity="88">
<source file="pandas/pandas/compat/numpy/function.py.pyindent" startline="284" endline="297" pcid="953">
def validate_window_func(name, args, kwargs):
    numpy_args = ('axis', 'dtype', 'out')
    msg = ("numpy operations are not "
           "valid with window objects. "
           "Use .{func}() directly instead ".format(func=name))

    if len(args) > 0:
        raise UnsupportedFunctionCall(msg)

    for arg in numpy_args:
        if arg in kwargs:
            raise UnsupportedFunctionCall(msg)


</source>
<source file="pandas/pandas/compat/numpy/function.py.pyindent" startline="298" endline="311" pcid="954">
def validate_rolling_func(name, args, kwargs):
    numpy_args = ('axis', 'dtype', 'out')
    msg = ("numpy operations are not "
           "valid with window objects. "
           "Use .rolling(...).{func}() instead ".format(func=name))

    if len(args) > 0:
        raise UnsupportedFunctionCall(msg)

    for arg in numpy_args:
        if arg in kwargs:
            raise UnsupportedFunctionCall(msg)


</source>
<source file="pandas/pandas/compat/numpy/function.py.pyindent" startline="312" endline="325" pcid="955">
def validate_expanding_func(name, args, kwargs):
    numpy_args = ('axis', 'dtype', 'out')
    msg = ("numpy operations are not "
           "valid with window objects. "
           "Use .expanding(...).{func}() instead ".format(func=name))

    if len(args) > 0:
        raise UnsupportedFunctionCall(msg)

    for arg in numpy_args:
        if arg in kwargs:
            raise UnsupportedFunctionCall(msg)


</source>
</class>

<class classid="14" nclones="2" nlines="15" similarity="81">
<source file="pandas/pandas/core/arrays/base.py.pyindent" startline="289" endline="305" pcid="1150">
    def _values_for_argsort(self):
        # type: () -> ndarray
        """Return values for sorting.

        Returns
        -------
        ndarray
            The transformed values should maintain the ordering between values
            within the array.

        See Also
        --------
        ExtensionArray.argsort
        """
        # Note: this is used in `ExtensionArray.argsort`.
        return np.array(self)

</source>
<source file="pandas/pandas/core/arrays/integer.py.pyindent" startline="454" endline="471" pcid="1339">
    def _values_for_argsort(self):
        # type: () -> ndarray
        """Return values for sorting.

        Returns
        -------
        ndarray
            The transformed values should maintain the ordering between values
            within the array.

        See Also
        --------
        ExtensionArray.argsort
        """
        data = self._data.copy()
        data[self._mask] = data.min() - 1
        return data

</source>
</class>

<class classid="15" nclones="2" nlines="11" similarity="72">
<source file="pandas/pandas/core/arrays/categorical.py.pyindent" startline="2077" endline="2085" pcid="1242">
    def _reduce(self, op, name, axis=0, skipna=True, numeric_only=None,
                filter_type=None, **kwds):
        """ perform the reduction type operation """
        func = getattr(self, name, None)
        if func is None:
            msg = 'Categorical cannot perform the operation {op}'
            raise TypeError(msg.format(op=name))
        return func(numeric_only=numeric_only, **kwds)

</source>
<source file="pandas/pandas/core/base.py.pyindent" startline="879" endline="887" pcid="1444">
    def _reduce(self, op, name, axis=0, skipna=True, numeric_only=None,
                filter_type=None, **kwds):
        """ perform the reduction type operation if we can """
        func = getattr(self, name, None)
        if func is None:
            raise TypeError("{klass} cannot perform the operation {op}".format(
                            klass=self.__class__.__name__, op=name))
        return func(**kwds)

</source>
</class>

<class classid="16" nclones="2" nlines="21" similarity="80">
<source file="pandas/pandas/core/arrays/categorical.py.pyindent" startline="2086" endline="2110" pcid="1243">
    def min(self, numeric_only=None, **kwargs):
        """ The minimum value of the object.

        Only ordered `Categoricals` have a minimum!

        Raises
        ------
        TypeError
            If the `Categorical` is not `ordered`.

        Returns
        -------
        min : the minimum of this `Categorical`
        """
        self.check_for_ordered('min')
        if numeric_only:
            good = self._codes != -1
            pointer = self._codes[good].min(**kwargs)
        else:
            pointer = self._codes.min(**kwargs)
        if pointer == -1:
            return np.nan
        else:
            return self.categories[pointer]

</source>
<source file="pandas/pandas/core/arrays/categorical.py.pyindent" startline="2111" endline="2135" pcid="1244">
    def max(self, numeric_only=None, **kwargs):
        """ The maximum value of the object.

        Only ordered `Categoricals` have a maximum!

        Raises
        ------
        TypeError
            If the `Categorical` is not `ordered`.

        Returns
        -------
        max : the maximum of this `Categorical`
        """
        self.check_for_ordered('max')
        if numeric_only:
            good = self._codes != -1
            pointer = self._codes[good].max(**kwargs)
        else:
            pointer = self._codes.max(**kwargs)
        if pointer == -1:
            return np.nan
        else:
            return self.categories[pointer]

</source>
</class>

<class classid="17" nclones="2" nlines="15" similarity="86">
<source file="pandas/pandas/core/arrays/datetimes.py.pyindent" startline="792" endline="817" pcid="1300">
    def month_name(self, locale=None):
        """
        Return the month names of the DateTimeIndex with specified locale.

        Parameters
        ----------
        locale : string, default None (English locale)
            locale determining the language in which to return the month name

        Returns
        -------
        month_names : Index
            Index of month names

        .. versionadded:: 0.23.0
        """
        if self.tz is not None and self.tz is not utc:
            values = self._local_timestamps()
        else:
            values = self.asi8

        result = fields.get_date_name_field(values, 'month_name',
                                            locale=locale)
        result = self._maybe_mask_results(result)
        return result

</source>
<source file="pandas/pandas/core/arrays/datetimes.py.pyindent" startline="818" endline="843" pcid="1301">
    def day_name(self, locale=None):
        """
        Return the day names of the DateTimeIndex with specified locale.

        Parameters
        ----------
        locale : string, default None (English locale)
            locale determining the language in which to return the day name

        Returns
        -------
        month_names : Index
            Index of day names

        .. versionadded:: 0.23.0
        """
        if self.tz is not None and self.tz is not utc:
            values = self._local_timestamps()
        else:
            values = self.asi8

        result = fields.get_date_name_field(values, 'day_name',
                                            locale=locale)
        result = self._maybe_mask_results(result)
        return result

</source>
</class>

<class classid="18" nclones="2" nlines="12" similarity="83">
<source file="pandas/pandas/core/arrays/datetimes.py.pyindent" startline="845" endline="858" pcid="1302">
    def time(self):
        """
        Returns numpy array of datetime.time. The time part of the Timestamps.
        """
        # If the Timestamps have a timezone that is not UTC,
        # convert them into their i8 representation while
        # keeping their timezone and not using UTC
        if self.tz is not None and self.tz is not utc:
            timestamps = self._local_timestamps()
        else:
            timestamps = self.asi8

        return tslib.ints_to_pydatetime(timestamps, box="time")

</source>
<source file="pandas/pandas/core/arrays/datetimes.py.pyindent" startline="868" endline="882" pcid="1304">
    def date(self):
        """
        Returns numpy array of python datetime.date objects (namely, the date
        part of Timestamps without timezone information).
        """
        # If the Timestamps have a timezone that is not UTC,
        # convert them into their i8 representation while
        # keeping their timezone and not using UTC
        if self.tz is not None and self.tz is not utc:
            timestamps = self._local_timestamps()
        else:
            timestamps = self.asi8

        return tslib.ints_to_pydatetime(timestamps, box="date")

</source>
</class>

<class classid="19" nclones="3" nlines="11" similarity="72">
<source file="pandas/pandas/core/computation/common.py.pyindent" startline="13" endline="22" pcid="1469">
def _result_type_many(*arrays_and_dtypes):
    """ wrapper around numpy.result_type which overcomes the NPY_MAXARGS (32)
    argument limit """
    try:
        return np.result_type(*arrays_and_dtypes)
    except ValueError:
        # we have > NPY_MAXARGS terms in our expression
        return reduce(np.result_type, arrays_and_dtypes)


</source>
<source file="pandas/pandas/core/sparse/array.py.pyindent" startline="47" endline="55" pcid="2325">
def _get_fill(arr):
    # coerce fill_value to arr dtype if possible
    # int64 SparseArray can have NaN as fill_value if there is no missing
    try:
        return np.asarray(arr.fill_value, dtype=arr.dtype)
    except ValueError:
        return np.asarray(arr.fill_value)


</source>
<source file="pandas/pandas/io/sas/sas_xport.py.pyindent" startline="119" endline="127" pcid="2884">
def _parse_date(datestr):
    """ Given a date in xport format, return Python date. """
    try:
        # e.g. "16FEB11:10:07:55"
        return datetime.strptime(datestr, "%d%b%y:%H:%M:%S")
    except ValueError:
        return pd.NaT


</source>
</class>

<class classid="20" nclones="2" nlines="71" similarity="74">
<source file="pandas/pandas/core/computation/expr.py.pyindent" startline="542" endline="592" pcid="1526">
    def visit_Call_35(self, node, side=None, **kwargs):
        """ in 3.5 the starargs attribute was changed to be more flexible,
        #11097 """

        if isinstance(node.func, ast.Attribute):
            res = self.visit_Attribute(node.func)
        elif not isinstance(node.func, ast.Name):
            raise TypeError("Only named functions are supported")
        else:
            try:
                res = self.visit(node.func)
            except UndefinedVariableError:
                # Check if this is a supported function name
                try:
                    res = FuncNode(node.func.id)
                except ValueError:
                    # Raise original error
                    raise

        if res is None:
            raise ValueError("Invalid function call {func}"
                             .format(func=node.func.id))
        if hasattr(res, 'value'):
            res = res.value

        if isinstance(res, FuncNode):

            new_args = [self.visit(arg) for arg in node.args]

            if node.keywords:
                raise TypeError("Function \"{name}\" does not support keyword "
                                "arguments".format(name=res.name))

            return res(*new_args, **kwargs)

        else:

            new_args = [self.visit(arg).value for arg in node.args]

            for key in node.keywords:
                if not isinstance(key, ast.keyword):
                    raise ValueError("keyword error in function call "
                                     "'{func}'".format(func=node.func.id))

                if key.arg:
                    # TODO: bug?
                    kwargs.append(ast.keyword(
                        keyword.arg, self.visit(keyword.value)))  # noqa

            return self.const_type(res(*new_args, **kwargs), self.env)

</source>
<source file="pandas/pandas/core/computation/expr.py.pyindent" startline="593" endline="644" pcid="1527">
    def visit_Call_legacy(self, node, side=None, **kwargs):

        # this can happen with: datetime.datetime
        if isinstance(node.func, ast.Attribute):
            res = self.visit_Attribute(node.func)
        elif not isinstance(node.func, ast.Name):
            raise TypeError("Only named functions are supported")
        else:
            try:
                res = self.visit(node.func)
            except UndefinedVariableError:
                # Check if this is a supported function name
                try:
                    res = FuncNode(node.func.id)
                except ValueError:
                    # Raise original error
                    raise

        if res is None:
            raise ValueError("Invalid function call {func}"
                             .format(func=node.func.id))
        if hasattr(res, 'value'):
            res = res.value

        if isinstance(res, FuncNode):
            args = [self.visit(targ) for targ in node.args]

            if node.starargs is not None:
                args += self.visit(node.starargs)

            if node.keywords or node.kwargs:
                raise TypeError("Function \"{name}\" does not support keyword "
                                "arguments".format(name=res.name))

            return res(*args, **kwargs)

        else:
            args = [self.visit(targ).value for targ in node.args]
            if node.starargs is not None:
                args += self.visit(node.starargs).value

            keywords = {}
            for key in node.keywords:
                if not isinstance(key, ast.keyword):
                    raise ValueError("keyword error in function call "
                                     "'{func}'".format(func=node.func.id))
                keywords[key.arg] = self.visit(key.value).value
            if node.kwargs is not None:
                keywords.update(self.visit(node.kwargs).value)

            return self.const_type(res(*args, **keywords), self.env)

</source>
</class>

<class classid="21" nclones="2" nlines="12" similarity="83">
<source file="pandas/pandas/core/computation/ops.py.pyindent" startline="127" endline="134" pcid="1554">
    def is_datetime(self):
        try:
            t = self.type.type
        except AttributeError:
            t = self.type

        return issubclass(t, (datetime, np.datetime64))

</source>
<source file="pandas/pandas/core/computation/ops.py.pyindent" startline="221" endline="229" pcid="1571">
    def is_datetime(self):
        try:
            t = self.return_type.type
        except AttributeError:
            t = self.return_type

        return issubclass(t, (datetime, np.datetime64))


</source>
</class>

<class classid="22" nclones="2" nlines="22" similarity="81">
<source file="pandas/pandas/core/computation/ops.py.pyindent" startline="230" endline="244" pcid="1572">
def _in(x, y):
    """Compute the vectorized membership of ``x in y`` if possible, otherwise
    use Python.
    """
    try:
        return x.isin(y)
    except AttributeError:
        if is_list_like(x):
            try:
                return y.isin(x)
            except AttributeError:
                pass
        return x in y


</source>
<source file="pandas/pandas/core/computation/ops.py.pyindent" startline="245" endline="259" pcid="1573">
def _not_in(x, y):
    """Compute the vectorized membership of ``x not in y`` if possible,
    otherwise use Python.
    """
    try:
        return ~x.isin(y)
    except AttributeError:
        if is_list_like(x):
            try:
                return ~y.isin(x)
            except AttributeError:
                pass
        return x not in y


</source>
</class>

<class classid="23" nclones="2" nlines="13" similarity="100">
<source file="pandas/pandas/core/computation/ops.py.pyindent" startline="405" endline="412" pcid="1580">
        def stringify(value):
            if self.encoding is not None:
                encoder = partial(pprint_thing_encoded,
                                  encoding=self.encoding)
            else:
                encoder = pprint_thing
            return encoder(value)

</source>
<source file="pandas/pandas/core/computation/pytables.py.pyindent" startline="171" endline="178" pcid="1612">
        def stringify(value):
            if self.encoding is not None:
                encoder = partial(pprint_thing_encoded,
                                  encoding=self.encoding)
            else:
                encoder = pprint_thing
            return encoder(value)

</source>
</class>

<class classid="24" nclones="2" nlines="15" similarity="86">
<source file="pandas/pandas/core/dtypes/inference.py.pyindent" startline="222" endline="250" pcid="1754">
def is_re_compilable(obj):
    """
    Check if the object can be compiled into a regex pattern instance.

    Parameters
    ----------
    obj : The object to check.

    Returns
    -------
    is_regex_compilable : bool
        Whether `obj` can be compiled as a regex pattern.

    Examples
    --------
    >>> is_re_compilable(".*")
    True
    >>> is_re_compilable(1)
    False
    """

    try:
        re.compile(obj)
    except TypeError:
        return False
    else:
        return True


</source>
<source file="pandas/pandas/core/dtypes/inference.py.pyindent" startline="422" endline="453" pcid="1760">
def is_hashable(obj):
    """Return True if hash(obj) will succeed, False otherwise.

    Some types will pass a test against collections.Hashable but fail when they
    are actually hashed with hash().

    Distinguish between these and other types by trying the call to hash() and
    seeing if they raise TypeError.

    Examples
    --------
    >>> a = ([],)
    >>> isinstance(a, collections.Hashable)
    True
    >>> is_hashable(a)
    False
    """
    # Unfortunately, we can't use isinstance(obj, collections.Hashable), which
    # can be faster than calling hash. That is because numpy scalars on Python
    # 3 fail this test.

    # Reconsider this decision once this numpy bug is fixed:
    # https://github.com/numpy/numpy/issues/5562

    try:
        hash(obj)
    except TypeError:
        return False
    else:
        return True


</source>
</class>

<class classid="25" nclones="2" nlines="32" similarity="75">
<source file="pandas/pandas/core/dtypes/missing.py.pyindent" startline="112" endline="130" pcid="1763">
def _isna_new(obj):
    if is_scalar(obj):
        return libmissing.checknull(obj)
    # hack (for now) because MI registers as ndarray
    elif isinstance(obj, ABCMultiIndex):
        raise NotImplementedError("isna is not defined for MultiIndex")
    elif isinstance(obj, (ABCSeries, np.ndarray, ABCIndexClass,
                          ABCExtensionArray)):
        return _isna_ndarraylike(obj)
    elif isinstance(obj, ABCGeneric):
        return obj._constructor(obj._data.isna(func=isna))
    elif isinstance(obj, list):
        return _isna_ndarraylike(np.asarray(obj, dtype=object))
    elif hasattr(obj, '__array__'):
        return _isna_ndarraylike(np.asarray(obj))
    else:
        return obj is None


</source>
<source file="pandas/pandas/core/dtypes/missing.py.pyindent" startline="131" endline="158" pcid="1764">
def _isna_old(obj):
    """Detect missing values. Treat None, NaN, INF, -INF as null.

    Parameters
    ----------
    arr: ndarray or object value

    Returns
    -------
    boolean ndarray or boolean
    """
    if is_scalar(obj):
        return libmissing.checknull_old(obj)
    # hack (for now) because MI registers as ndarray
    elif isinstance(obj, ABCMultiIndex):
        raise NotImplementedError("isna is not defined for MultiIndex")
    elif isinstance(obj, (ABCSeries, np.ndarray, ABCIndexClass)):
        return _isna_ndarraylike_old(obj)
    elif isinstance(obj, ABCGeneric):
        return obj._constructor(obj._data.isna(func=_isna_old))
    elif isinstance(obj, list):
        return _isna_ndarraylike_old(np.asarray(obj, dtype=object))
    elif hasattr(obj, '__array__'):
        return _isna_ndarraylike_old(np.asarray(obj))
    else:
        return obj is None


</source>
</class>

<class classid="26" nclones="2" nlines="23" similarity="73">
<source file="pandas/pandas/core/groupby/ops.py.pyindent" startline="556" endline="572" pcid="1808">
    def _aggregate(self, result, counts, values, comp_ids, agg_func,
                   is_numeric, is_datetimelike, min_count=-1):
        if values.ndim > 3:
            # punting for now
            raise NotImplementedError("number of dimensions is currently "
                                      "limited to 3")
        elif values.ndim > 2:
            for i, chunk in enumerate(values.transpose(2, 0, 1)):

                chunk = chunk.squeeze()
                agg_func(result[:, :, i], counts, chunk, comp_ids,
                         min_count)
        else:
            agg_func(result, counts, values, comp_ids, min_count)

        return result

</source>
<source file="pandas/pandas/core/groupby/ops.py.pyindent" startline="573" endline="590" pcid="1809">
    def _transform(self, result, values, comp_ids, transform_func,
                   is_numeric, is_datetimelike, **kwargs):

        comp_ids, _, ngroups = self.group_info
        if values.ndim > 3:
            # punting for now
            raise NotImplementedError("number of dimensions is currently "
                                      "limited to 3")
        elif values.ndim > 2:
            for i, chunk in enumerate(values.transpose(2, 0, 1)):

                transform_func(result[:, :, i], values,
                               comp_ids, is_datetimelike, **kwargs)
        else:
            transform_func(result, values, comp_ids, is_datetimelike, **kwargs)

        return result

</source>
</class>

<class classid="27" nclones="3" nlines="11" similarity="72">
<source file="pandas/pandas/core/groupby/ops.py.pyindent" startline="591" endline="596" pcid="1810">
    def agg_series(self, obj, func):
        try:
            return self._aggregate_series_fast(obj, func)
        except Exception:
            return self._aggregate_series_pure_python(obj, func)

</source>
<source file="pandas/pandas/plotting/_core.py.pyindent" startline="392" endline="397" pcid="2919">
        def get_label(i):
            try:
                return pprint_thing(data.index[i])
            except Exception:
                return ''

</source>
<source file="pandas/pandas/tests/groupby/aggregate/test_other.py.pyindent" startline="342" endline="347" pcid="4793">
    def P1(a):
        try:
            return np.percentile(a.dropna(), q=1)
        except Exception:
            return np.nan

</source>
</class>

<class classid="28" nclones="2" nlines="28" similarity="75">
<source file="pandas/pandas/core/indexes/datetimelike.py.pyindent" startline="404" endline="430" pcid="1929">
    def min(self, axis=None, *args, **kwargs):
        """
        Return the minimum value of the Index or minimum along
        an axis.

        See also
        --------
        numpy.ndarray.min
        """
        nv.validate_min(args, kwargs)

        try:
            i8 = self.asi8

            # quick check
            if len(i8) and self.is_monotonic:
                if i8[0] != iNaT:
                    return self._box_func(i8[0])

            if self.hasnans:
                min_stamp = self[~self._isnan].asi8.min()
            else:
                min_stamp = i8.min()
            return self._box_func(min_stamp)
        except ValueError:
            return self._na_value

</source>
<source file="pandas/pandas/core/indexes/datetimelike.py.pyindent" startline="452" endline="478" pcid="1931">
    def max(self, axis=None, *args, **kwargs):
        """
        Return the maximum value of the Index or maximum along
        an axis.

        See also
        --------
        numpy.ndarray.max
        """
        nv.validate_max(args, kwargs)

        try:
            i8 = self.asi8

            # quick check
            if len(i8) and self.is_monotonic:
                if i8[-1] != iNaT:
                    return self._box_func(i8[-1])

            if self.hasnans:
                max_stamp = self[~self._isnan].asi8.max()
            else:
                max_stamp = i8.max()
            return self._box_func(max_stamp)
        except ValueError:
            return self._na_value

</source>
</class>

<class classid="29" nclones="2" nlines="16" similarity="75">
<source file="pandas/pandas/core/indexes/datetimelike.py.pyindent" startline="431" endline="451" pcid="1930">
    def argmin(self, axis=None, *args, **kwargs):
        """
        Returns the indices of the minimum values along an axis.
        See `numpy.ndarray.argmin` for more information on the
        `axis` parameter.

        See also
        --------
        numpy.ndarray.argmin
        """
        nv.validate_argmin(args, kwargs)

        i8 = self.asi8
        if self.hasnans:
            mask = self._isnan
            if mask.all():
                return -1
            i8 = i8.copy()
            i8[mask] = np.iinfo('int64').max
        return i8.argmin()

</source>
<source file="pandas/pandas/core/indexes/datetimelike.py.pyindent" startline="479" endline="499" pcid="1932">
    def argmax(self, axis=None, *args, **kwargs):
        """
        Returns the indices of the maximum values along an axis.
        See `numpy.ndarray.argmax` for more information on the
        `axis` parameter.

        See also
        --------
        numpy.ndarray.argmax
        """
        nv.validate_argmax(args, kwargs)

        i8 = self.asi8
        if self.hasnans:
            mask = self._isnan
            if mask.all():
                return -1
            i8 = i8.copy()
            i8[mask] = 0
        return i8.argmax()

</source>
</class>

<class classid="30" nclones="2" nlines="14" similarity="85">
<source file="pandas/pandas/core/indexes/datetimes.py.pyindent" startline="86" endline="100" pcid="1953">
def _dt_index_cmp(cls, op):
    """
    Wrap comparison operations to convert datetime-like to datetime64
    """
    opname = '__{name}__'.format(name=op.__name__)

    def wrapper(self, other):
        result = getattr(DatetimeArrayMixin, opname)(self, other)
        if is_bool_dtype(result):
            return result
        return Index(result)

    return compat.set_function_name(wrapper, opname, cls)


</source>
<source file="pandas/pandas/core/indexes/timedeltas.py.pyindent" startline="52" endline="67" pcid="2112">
def _td_index_cmp(cls, op):
    """
    Wrap comparison operations to convert timedelta-like to timedelta64
    """
    opname = '__{name}__'.format(name=op.__name__)

    def wrapper(self, other):
        result = getattr(TimedeltaArrayMixin, opname)(self, other)
        if is_bool_dtype(result):
            # support of bool dtype indexers
            return result
        return Index(result)

    return compat.set_function_name(wrapper, opname, cls)


</source>
</class>

<class classid="31" nclones="2" nlines="33" similarity="76">
<source file="pandas/pandas/core/indexes/datetimes.py.pyindent" startline="779" endline="812" pcid="1984">
    def union(self, other):
        """
        Specialized union for DatetimeIndex objects. If combine
        overlapping ranges with the same DateOffset, will be much
        faster than Index.union

        Parameters
        ----------
        other : DatetimeIndex or array-like

        Returns
        -------
        y : Index or DatetimeIndex
        """
        self._assert_can_do_setop(other)
        if not isinstance(other, DatetimeIndex):
            try:
                other = DatetimeIndex(other)
            except TypeError:
                pass

        this, other = self._maybe_utc_convert(other)

        if this._can_fast_union(other):
            return this._fast_union(other)
        else:
            result = Index.union(this, other)
            if isinstance(result, DatetimeIndex):
                result._tz = timezones.tz_standardize(this.tz)
                if (result.freq is None and
                        (this.freq is not None or other.freq is not None)):
                    result.freq = to_offset(result.inferred_freq)
            return result

</source>
<source file="pandas/pandas/core/indexes/timedeltas.py.pyindent" startline="293" endline="323" pcid="2126">
    def union(self, other):
        """
        Specialized union for TimedeltaIndex objects. If combine
        overlapping ranges with the same DateOffset, will be much
        faster than Index.union

        Parameters
        ----------
        other : TimedeltaIndex or array-like

        Returns
        -------
        y : Index or TimedeltaIndex
        """
        self._assert_can_do_setop(other)
        if not isinstance(other, TimedeltaIndex):
            try:
                other = TimedeltaIndex(other)
            except (TypeError, ValueError):
                pass
        this, other = self, other

        if this._can_fast_union(other):
            return this._fast_union(other)
        else:
            result = Index.union(this, other)
            if isinstance(result, TimedeltaIndex):
                if result.freq is None:
                    result.freq = to_offset(result.inferred_freq)
            return result

</source>
</class>

<class classid="32" nclones="2" nlines="35" similarity="78">
<source file="pandas/pandas/core/indexes/datetimes.py.pyindent" startline="906" endline="938" pcid="1990">
    def _can_fast_union(self, other):
        if not isinstance(other, DatetimeIndex):
            return False

        freq = self.freq

        if freq is None or freq != other.freq:
            return False

        if not self.is_monotonic or not other.is_monotonic:
            return False

        if len(self) == 0 or len(other) == 0:
            return True

        # to make our life easier, "sort" the two ranges
        if self[0] <= other[0]:
            left, right = self, other
        else:
            left, right = other, self

        right_start = right[0]
        left_end = left[-1]

        # Only need to "adjoin", not overlap
        try:
            return (right_start == left_end + freq) or right_start in left
        except (ValueError):

            # if we are comparing a freq that does not propagate timezones
            # this will raise
            return False

</source>
<source file="pandas/pandas/core/indexes/timedeltas.py.pyindent" startline="348" endline="374" pcid="2129">
    def _can_fast_union(self, other):
        if not isinstance(other, TimedeltaIndex):
            return False

        freq = self.freq

        if freq is None or freq != other.freq:
            return False

        if not self.is_monotonic or not other.is_monotonic:
            return False

        if len(self) == 0 or len(other) == 0:
            return True

        # to make our life easier, "sort" the two ranges
        if self[0] <= other[0]:
            left, right = self, other
        else:
            left, right = other, self

        right_start = right[0]
        left_end = left[-1]

        # Only need to "adjoin", not overlap
        return (right_start == left_end + freq) or right_start in left

</source>
</class>

<class classid="33" nclones="2" nlines="37" similarity="75">
<source file="pandas/pandas/core/indexes/datetimes.py.pyindent" startline="939" endline="968" pcid="1991">
    def _fast_union(self, other):
        if len(other) == 0:
            return self.view(type(self))

        if len(self) == 0:
            return other.view(type(self))

        # to make our life easier, "sort" the two ranges
        if self[0] <= other[0]:
            left, right = self, other
        else:
            left, right = other, self

        left_start, left_end = left[0], left[-1]
        right_end = right[-1]

        if not self.freq._should_cache():
            # concatenate dates
            if left_end < right_end:
                loc = right.searchsorted(left_end, side='right')
                right_chunk = right.values[loc:]
                dates = _concat._concat_compat((left.values, right_chunk))
                return self._shallow_copy(dates)
            else:
                return left
        else:
            return type(self)(start=left_start,
                              end=max(left_end, right_end),
                              freq=left.freq)

</source>
<source file="pandas/pandas/core/indexes/timedeltas.py.pyindent" startline="375" endline="399" pcid="2130">
    def _fast_union(self, other):
        if len(other) == 0:
            return self.view(type(self))

        if len(self) == 0:
            return other.view(type(self))

        # to make our life easier, "sort" the two ranges
        if self[0] <= other[0]:
            left, right = self, other
        else:
            left, right = other, self

        left_end = left[-1]
        right_end = right[-1]

        # concatenate
        if left_end < right_end:
            loc = right.searchsorted(left_end, side='right')
            right_chunk = right.values[loc:]
            dates = _concat._concat_compat((left.values, right_chunk))
            return self._shallow_copy(dates)
        else:
            return left

</source>
</class>

<class classid="34" nclones="2" nlines="37" similarity="75">
<source file="pandas/pandas/core/indexes/datetimes.py.pyindent" startline="1142" endline="1174" pcid="1997">
    def get_value(self, series, key):
        """
        Fast lookup of value from 1-dimensional ndarray. Only use this if you
        know what you're doing
        """

        if isinstance(key, datetime):

            # needed to localize naive datetimes
            if self.tz is not None:
                key = Timestamp(key, tz=self.tz)

            return self.get_value_maybe_box(series, key)

        if isinstance(key, time):
            locs = self.indexer_at_time(key)
            return series.take(locs)

        try:
            return com.maybe_box(self, Index.get_value(self, series, key),
                                 series, key)
        except KeyError:
            try:
                loc = self._get_string_slice(key)
                return series[loc]
            except (TypeError, ValueError, KeyError):
                pass

            try:
                return self.get_value_maybe_box(series, key)
            except (TypeError, ValueError, KeyError):
                raise KeyError(key)

</source>
<source file="pandas/pandas/core/indexes/timedeltas.py.pyindent" startline="451" endline="475" pcid="2134">
    def get_value(self, series, key):
        """
        Fast lookup of value from 1-dimensional ndarray. Only use this if you
        know what you're doing
        """

        if _is_convertible_to_td(key):
            key = Timedelta(key)
            return self.get_value_maybe_box(series, key)

        try:
            return com.maybe_box(self, Index.get_value(self, series, key),
                                 series, key)
        except KeyError:
            try:
                loc = self._get_string_slice(key)
                return series[loc]
            except (TypeError, ValueError, KeyError):
                pass

            try:
                return self.get_value_maybe_box(series, key)
            except (TypeError, ValueError, KeyError):
                raise KeyError(key)

</source>
</class>

<class classid="35" nclones="2" nlines="12" similarity="75">
<source file="pandas/pandas/core/indexes/datetimes.py.pyindent" startline="1366" endline="1373" pcid="2004">
    def searchsorted(self, value, side='left', sorter=None):
        if isinstance(value, (np.ndarray, Index)):
            value = np.array(value, dtype=_NS_DTYPE, copy=False)
        else:
            value = _to_m8(value, tz=self.tz)

        return self.values.searchsorted(value, side=side)

</source>
<source file="pandas/pandas/core/indexes/timedeltas.py.pyindent" startline="608" endline="615" pcid="2140">
    def searchsorted(self, value, side='left', sorter=None):
        if isinstance(value, (np.ndarray, Index)):
            value = np.array(value, dtype=_TD_DTYPE, copy=False)
        else:
            value = _to_m8(value)

        return self.values.searchsorted(value, side=side, sorter=sorter)

</source>
</class>

<class classid="36" nclones="2" nlines="28" similarity="89">
<source file="pandas/pandas/core/indexes/datetimes.py.pyindent" startline="1435" endline="1463" pcid="2009">
    def delete(self, loc):
        """
        Make a new DatetimeIndex with passed location(s) deleted.

        Parameters
        ----------
        loc: int, slice or array of ints
            Indicate which sub-arrays to remove.

        Returns
        -------
        new_index : DatetimeIndex
        """
        new_dates = np.delete(self.asi8, loc)

        freq = None
        if is_integer(loc):
            if loc in (0, -len(self), -1, len(self) - 1):
                freq = self.freq
        else:
            if is_list_like(loc):
                loc = lib.maybe_indices_to_slice(
                    ensure_int64(np.array(loc)), len(self))
            if isinstance(loc, slice) and loc.step in (1, None):
                if (loc.start in (0, None) or loc.stop in (len(self), None)):
                    freq = self.freq

        return DatetimeIndex(new_dates, name=self.name, freq=freq, tz=self.tz)

</source>
<source file="pandas/pandas/core/indexes/timedeltas.py.pyindent" startline="677" endline="706" pcid="2145">
    def delete(self, loc):
        """
        Make a new TimedeltaIndex with passed location(s) deleted.

        Parameters
        ----------
        loc: int, slice or array of ints
            Indicate which sub-arrays to remove.

        Returns
        -------
        new_index : TimedeltaIndex
        """
        new_tds = np.delete(self.asi8, loc)

        freq = 'infer'
        if is_integer(loc):
            if loc in (0, -len(self), -1, len(self) - 1):
                freq = self.freq
        else:
            if is_list_like(loc):
                loc = lib.maybe_indices_to_slice(
                    ensure_int64(np.array(loc)), len(self))
            if isinstance(loc, slice) and loc.step in (1, None):
                if (loc.start in (0, None) or loc.stop in (len(self), None)):
                    freq = self.freq

        return TimedeltaIndex(new_tds, name=self.name, freq=freq)


</source>
</class>

<class classid="37" nclones="2" nlines="10" similarity="90">
<source file="pandas/pandas/core/indexes/numeric.py.pyindent" startline="180" endline="188" pcid="2048">
    def _convert_scalar_indexer(self, key, kind=None):
        assert kind in ['ix', 'loc', 'getitem', 'iloc', None]

        # don't coerce ilocs to integers
        if kind != 'iloc':
            key = self._maybe_cast_indexer(key)
        return (super(Int64Index, self)
                ._convert_scalar_indexer(key, kind=kind))

</source>
<source file="pandas/pandas/core/indexes/numeric.py.pyindent" startline="238" endline="246" pcid="2053">
    def _convert_scalar_indexer(self, key, kind=None):
        assert kind in ['ix', 'loc', 'getitem', 'iloc', None]

        # don't coerce ilocs to integers
        if kind != 'iloc':
            key = self._maybe_cast_indexer(key)
        return (super(UInt64Index, self)
                ._convert_scalar_indexer(key, kind=kind))

</source>
</class>

<class classid="38" nclones="2" nlines="11" similarity="90">
<source file="pandas/pandas/core/indexes/numeric.py.pyindent" startline="194" endline="203" pcid="2050">
    def _assert_safe_casting(cls, data, subarr):
        """
        Ensure incoming data can be represented as ints.
        """
        if not issubclass(data.dtype.type, np.signedinteger):
            if not np.array_equal(data, subarr):
                raise TypeError('Unsafe NumPy casting, you must '
                                'explicitly cast')


</source>
<source file="pandas/pandas/core/indexes/numeric.py.pyindent" startline="271" endline="280" pcid="2057">
    def _assert_safe_casting(cls, data, subarr):
        """
        Ensure incoming data can be represented as uints.
        """
        if not issubclass(data.dtype.type, np.unsignedinteger):
            if not np.array_equal(data, subarr):
                raise TypeError('Unsafe NumPy casting, you must '
                                'explicitly cast')


</source>
</class>

<class classid="39" nclones="4" nlines="40" similarity="71">
<source file="pandas/pandas/core/missing.py.pyindent" startline="477" endline="502" pcid="2158">
def pad_1d(values, limit=None, mask=None, dtype=None):
    if dtype is None:
        dtype = values.dtype
    _method = None
    if is_float_dtype(values):
        name = 'pad_inplace_{name}'.format(name=dtype.name)
        _method = getattr(algos, name, None)
    elif is_datetime64_dtype(dtype) or is_datetime64tz_dtype(dtype):
        _method = _pad_1d_datetime
    elif is_integer_dtype(values):
        values = ensure_float64(values)
        _method = algos.pad_inplace_float64
    elif values.dtype == np.object_:
        _method = algos.pad_inplace_object

    if _method is None:
        raise ValueError('Invalid dtype for pad_1d [{name}]'
                         .format(name=dtype.name))

    if mask is None:
        mask = isna(values)
    mask = mask.view(np.uint8)
    _method(values, mask, limit=limit)
    return values


</source>
<source file="pandas/pandas/core/missing.py.pyindent" startline="503" endline="529" pcid="2159">
def backfill_1d(values, limit=None, mask=None, dtype=None):
    if dtype is None:
        dtype = values.dtype
    _method = None
    if is_float_dtype(values):
        name = 'backfill_inplace_{name}'.format(name=dtype.name)
        _method = getattr(algos, name, None)
    elif is_datetime64_dtype(dtype) or is_datetime64tz_dtype(dtype):
        _method = _backfill_1d_datetime
    elif is_integer_dtype(values):
        values = ensure_float64(values)
        _method = algos.backfill_inplace_float64
    elif values.dtype == np.object_:
        _method = algos.backfill_inplace_object

    if _method is None:
        raise ValueError('Invalid dtype for backfill_1d [{name}]'
                         .format(name=dtype.name))

    if mask is None:
        mask = isna(values)
    mask = mask.view(np.uint8)

    _method(values, mask, limit=limit)
    return values


</source>
<source file="pandas/pandas/core/missing.py.pyindent" startline="561" endline="591" pcid="2161">
def backfill_2d(values, limit=None, mask=None, dtype=None):
    if dtype is None:
        dtype = values.dtype
    _method = None
    if is_float_dtype(values):
        name = 'backfill_2d_inplace_{name}'.format(name=dtype.name)
        _method = getattr(algos, name, None)
    elif is_datetime64_dtype(dtype) or is_datetime64tz_dtype(dtype):
        _method = _backfill_2d_datetime
    elif is_integer_dtype(values):
        values = ensure_float64(values)
        _method = algos.backfill_2d_inplace_float64
    elif values.dtype == np.object_:
        _method = algos.backfill_2d_inplace_object

    if _method is None:
        raise ValueError('Invalid dtype for backfill_2d [{name}]'
                         .format(name=dtype.name))

    if mask is None:
        mask = isna(values)
    mask = mask.view(np.uint8)

    if np.all(values.shape):
        _method(values, mask, limit=limit)
    else:
        # for test coverage
        pass
    return values


</source>
<source file="pandas/pandas/core/missing.py.pyindent" startline="530" endline="560" pcid="2160">
def pad_2d(values, limit=None, mask=None, dtype=None):
    if dtype is None:
        dtype = values.dtype
    _method = None
    if is_float_dtype(values):
        name = 'pad_2d_inplace_{name}'.format(name=dtype.name)
        _method = getattr(algos, name, None)
    elif is_datetime64_dtype(dtype) or is_datetime64tz_dtype(dtype):
        _method = _pad_2d_datetime
    elif is_integer_dtype(values):
        values = ensure_float64(values)
        _method = algos.pad_2d_inplace_float64
    elif values.dtype == np.object_:
        _method = algos.pad_2d_inplace_object

    if _method is None:
        raise ValueError('Invalid dtype for pad_2d [{name}]'
                         .format(name=dtype.name))

    if mask is None:
        mask = isna(values)
    mask = mask.view(np.uint8)

    if np.all(values.shape):
        _method(values, mask, limit=limit)
    else:
        # for test coverage
        pass
    return values


</source>
</class>

<class classid="40" nclones="2" nlines="23" similarity="82">
<source file="pandas/pandas/core/nanops.py.pyindent" startline="744" endline="765" pcid="2208">
def nancorr(a, b, method='pearson', min_periods=None):
    """
    a, b: ndarrays
    """
    if len(a) != len(b):
        raise AssertionError('Operands to nancorr must have same size')

    if min_periods is None:
        min_periods = 1

    valid = notna(a) & notna(b)
    if not valid.all():
        a = a[valid]
        b = b[valid]

    if len(a) < min_periods:
        return np.nan

    f = get_corr_func(method)
    return f(a, b)


</source>
<source file="pandas/pandas/core/nanops.py.pyindent" startline="791" endline="808" pcid="2213">
def nancov(a, b, min_periods=None):
    if len(a) != len(b):
        raise AssertionError('Operands to nancov must have same size')

    if min_periods is None:
        min_periods = 1

    valid = notna(a) & notna(b)
    if not valid.all():
        a = a[valid]
        b = b[valid]

    if len(a) < min_periods:
        return np.nan

    return np.cov(a, b)[0, 1]


</source>
</class>

<class classid="41" nclones="2" nlines="11" similarity="100">
<source file="pandas/pandas/core/sparse/array.py.pyindent" startline="235" endline="240" pcid="2331">
    def kind(self):
        if isinstance(self.sp_index, BlockIndex):
            return 'block'
        elif isinstance(self.sp_index, IntIndex):
            return 'integer'

</source>
<source file="pandas/pandas/core/sparse/series.py.pyindent" startline="237" endline="242" pcid="2392">
    def kind(self):
        if isinstance(self.sp_index, BlockIndex):
            return 'block'
        elif isinstance(self.sp_index, IntIndex):
            return 'integer'

</source>
</class>

<class classid="42" nclones="2" nlines="19" similarity="75">
<source file="pandas/pandas/core/sparse/array.py.pyindent" startline="252" endline="280" pcid="2333">
    def __array_wrap__(self, out_arr, context=None):
        """
        NumPy calls this method when ufunc is applied

        Parameters
        ----------

        out_arr : ndarray
            ufunc result (note that ufunc is only applied to sp_values)
        context : tuple of 3 elements (ufunc, signature, domain)
            for example, following is a context when np.sin is applied to
            SparseArray,

            (<ufunc 'sin'>, (SparseArray,), 0))

        See http://docs.scipy.org/doc/numpy/user/basics.subclassing.html
        """
        if isinstance(context, tuple) and len(context) == 3:
            ufunc, args, domain = context
            # to apply ufunc only to fill_value (to avoid recursive call)
            args = [getattr(a, 'fill_value', a) for a in args]
            with np.errstate(all='ignore'):
                fill_value = ufunc(self.fill_value, *args[1:])
        else:
            fill_value = self.fill_value

        return self._simple_new(out_arr, sp_index=self.sp_index,
                                fill_value=fill_value)

</source>
<source file="pandas/pandas/core/sparse/series.py.pyindent" startline="267" endline="285" pcid="2397">
    def __array_wrap__(self, result, context=None):
        """
        Gets called prior to a ufunc (and after)

        See SparseArray.__array_wrap__ for detail.
        """
        if isinstance(context, tuple) and len(context) == 3:
            ufunc, args, domain = context
            args = [getattr(a, 'fill_value', a) for a in args]
            with np.errstate(all='ignore'):
                fill_value = ufunc(self.fill_value, *args[1:])
        else:
            fill_value = self.fill_value

        return self._constructor(result, index=self.index,
                                 sparse_index=self.sp_index,
                                 fill_value=fill_value,
                                 copy=False).__finalize__(self)

</source>
</class>

<class classid="43" nclones="2" nlines="14" similarity="78">
<source file="pandas/pandas/core/sparse/array.py.pyindent" startline="429" endline="436" pcid="2349">
    def __getslice__(self, i, j):
        if i < 0:
            i = 0
        if j < 0:
            j = 0
        slobj = slice(i, j)
        return self.__getitem__(slobj)

</source>
<source file="pandas/pandas/core/sparse/array.py.pyindent" startline="515" endline="531" pcid="2353">
    def __setslice__(self, i, j, value):
        if i < 0:
            i = 0
        if j < 0:
            j = 0
        slobj = slice(i, j)  # noqa

        # if not is_scalar(value):
        #    raise Exception("SparseArray does not support setting non-scalars
        # via slices")

        # x = self.values
        # x[slobj] = value
        # self.values = x
        raise TypeError("SparseArray does not support item assignment via "
                        "slices")

</source>
</class>

<class classid="44" nclones="2" nlines="11" similarity="81">
<source file="pandas/pandas/core/window.py.pyindent" startline="2508" endline="2513" pcid="2560">
    def _check_func(minp, window):
        if minp is None:
            return window
        else:
            return max(p, minp)

</source>
<source file="pandas/pandas/core/window.py.pyindent" startline="2517" endline="2523" pcid="2561">
def _use_window(minp, window):
    if minp is None:
        return window
    else:
        return minp


</source>
</class>

<class classid="45" nclones="2" nlines="56" similarity="78">
<source file="pandas/pandas/io/excel.py.pyindent" startline="286" endline="344" pcid="2611">
def read_excel(io,
               sheet_name=0,
               header=0,
               names=None,
               index_col=None,
               usecols=None,
               squeeze=False,
               dtype=None,
               engine=None,
               converters=None,
               true_values=None,
               false_values=None,
               skiprows=None,
               nrows=None,
               na_values=None,
               parse_dates=False,
               date_parser=None,
               thousands=None,
               comment=None,
               skipfooter=0,
               convert_float=True,
               **kwds):

    # Can't use _deprecate_kwarg since sheetname=None has a special meaning
    if is_integer(sheet_name) and sheet_name == 0 and 'sheetname' in kwds:
        warnings.warn("The `sheetname` keyword is deprecated, use "
                      "`sheet_name` instead", FutureWarning, stacklevel=2)
        sheet_name = kwds.pop("sheetname")

    if 'sheet' in kwds:
        raise TypeError("read_excel() got an unexpected keyword argument "
                        "`sheet`")

    if not isinstance(io, ExcelFile):
        io = ExcelFile(io, engine=engine)

    return io.parse(
        sheet_name=sheet_name,
        header=header,
        names=names,
        index_col=index_col,
        usecols=usecols,
        squeeze=squeeze,
        dtype=dtype,
        converters=converters,
        true_values=true_values,
        false_values=false_values,
        skiprows=skiprows,
        nrows=nrows,
        na_values=na_values,
        parse_dates=parse_dates,
        date_parser=date_parser,
        thousands=thousands,
        comment=comment,
        skipfooter=skipfooter,
        convert_float=convert_float,
        **kwds)


</source>
<source file="pandas/pandas/io/excel.py.pyindent" startline="415" endline="470" pcid="2614">
    def parse(self,
              sheet_name=0,
              header=0,
              names=None,
              index_col=None,
              usecols=None,
              squeeze=False,
              converters=None,
              true_values=None,
              false_values=None,
              skiprows=None,
              nrows=None,
              na_values=None,
              parse_dates=False,
              date_parser=None,
              thousands=None,
              comment=None,
              skipfooter=0,
              convert_float=True,
              **kwds):
        """
        Parse specified sheet(s) into a DataFrame

        Equivalent to read_excel(ExcelFile, ...)  See the read_excel
        docstring for more info on accepted parameters
        """

        # Can't use _deprecate_kwarg since sheetname=None has a special meaning
        if is_integer(sheet_name) and sheet_name == 0 and 'sheetname' in kwds:
            warnings.warn("The `sheetname` keyword is deprecated, use "
                          "`sheet_name` instead", FutureWarning, stacklevel=2)
            sheet_name = kwds.pop("sheetname")
        elif 'sheetname' in kwds:
            raise TypeError("Cannot specify both `sheet_name` "
                            "and `sheetname`. Use just `sheet_name`")

        return self._parse_excel(sheet_name=sheet_name,
                                 header=header,
                                 names=names,
                                 index_col=index_col,
                                 usecols=usecols,
                                 squeeze=squeeze,
                                 converters=converters,
                                 true_values=true_values,
                                 false_values=false_values,
                                 skiprows=skiprows,
                                 nrows=nrows,
                                 na_values=na_values,
                                 parse_dates=parse_dates,
                                 date_parser=date_parser,
                                 thousands=thousands,
                                 comment=comment,
                                 skipfooter=skipfooter,
                                 convert_float=convert_float,
                                 **kwds)

</source>
</class>

<class classid="46" nclones="2" nlines="53" similarity="83">
<source file="pandas/pandas/io/excel.py.pyindent" startline="1492" endline="1534" pcid="2657">
    def write_cells(self, cells, sheet_name=None, startrow=0, startcol=0,
                    freeze_panes=None):
        # Write the frame cells using xlwt.

        sheet_name = self._get_sheet_name(sheet_name)

        if sheet_name in self.sheets:
            wks = self.sheets[sheet_name]
        else:
            wks = self.book.add_sheet(sheet_name)
            self.sheets[sheet_name] = wks

        if _validate_freeze_panes(freeze_panes):
            wks.set_panes_frozen(True)
            wks.set_horz_split_pos(freeze_panes[0])
            wks.set_vert_split_pos(freeze_panes[1])

        style_dict = {}

        for cell in cells:
            val, fmt = self._value_with_fmt(cell.val)

            stylekey = json.dumps(cell.style)
            if fmt:
                stylekey += fmt

            if stylekey in style_dict:
                style = style_dict[stylekey]
            else:
                style = self._convert_to_style(cell.style, fmt)
                style_dict[stylekey] = style

            if cell.mergestart is not None and cell.mergeend is not None:
                wks.write_merge(startrow + cell.row,
                                startrow + cell.mergestart,
                                startcol + cell.col,
                                startcol + cell.mergeend,
                                val, style)
            else:
                wks.write(startrow + cell.row,
                          startcol + cell.col,
                          val, style)

</source>
<source file="pandas/pandas/io/excel.py.pyindent" startline="1765" endline="1806" pcid="2663">
    def write_cells(self, cells, sheet_name=None, startrow=0, startcol=0,
                    freeze_panes=None):
        # Write the frame cells using xlsxwriter.
        sheet_name = self._get_sheet_name(sheet_name)

        if sheet_name in self.sheets:
            wks = self.sheets[sheet_name]
        else:
            wks = self.book.add_worksheet(sheet_name)
            self.sheets[sheet_name] = wks

        style_dict = {'null': None}

        if _validate_freeze_panes(freeze_panes):
            wks.freeze_panes(*(freeze_panes))

        for cell in cells:
            val, fmt = self._value_with_fmt(cell.val)

            stylekey = json.dumps(cell.style)
            if fmt:
                stylekey += fmt

            if stylekey in style_dict:
                style = style_dict[stylekey]
            else:
                style = self.book.add_format(
                    _XlsxStyler.convert(cell.style, fmt))
                style_dict[stylekey] = style

            if cell.mergestart is not None and cell.mergeend is not None:
                wks.merge_range(startrow + cell.row,
                                startcol + cell.col,
                                startrow + cell.mergestart,
                                startcol + cell.mergeend,
                                cell.val, style)
            else:
                wks.write(startrow + cell.row,
                          startcol + cell.col,
                          val, style)


</source>
</class>

<class classid="47" nclones="2" nlines="19" similarity="89">
<source file="pandas/pandas/io/formats/console.py.pyindent" startline="107" endline="125" pcid="2668">
def in_qtconsole():
    """
    check if we're inside an IPython qtconsole

    .. deprecated:: 0.14.1
       This is no longer needed, or working, in IPython 3 and above.
    """
    try:
        ip = get_ipython()  # noqa
        front_end = (
            ip.config.get('KernelApp', {}).get('parent_appname', "") or
            ip.config.get('IPKernelApp', {}).get('parent_appname', ""))
        if 'qtconsole' in front_end.lower():
            return True
    except:
        return False
    return False


</source>
<source file="pandas/pandas/io/formats/console.py.pyindent" startline="126" endline="144" pcid="2669">
def in_ipnb():
    """
    check if we're inside an IPython Notebook

    .. deprecated:: 0.14.1
       This is no longer needed, or working, in IPython 3 and above.
    """
    try:
        ip = get_ipython()  # noqa
        front_end = (
            ip.config.get('KernelApp', {}).get('parent_appname', "") or
            ip.config.get('IPKernelApp', {}).get('parent_appname', ""))
        if 'notebook' in front_end.lower():
            return True
    except:
        return False
    return False


</source>
</class>

<class classid="48" nclones="2" nlines="13" similarity="84">
<source file="pandas/pandas/plotting/_core.py.pyindent" startline="785" endline="796" pcid="2942">
    def _get_axes_layout(self):
        axes = self._get_subplots()
        x_set = set()
        y_set = set()
        for ax in axes:
            # check axes coordinates to estimate layout
            points = ax.get_position().get_points()
            x_set.add(points[0][0])
            y_set.add(points[0][1])
        return (len(y_set), len(x_set))


</source>
<source file="pandas/pandas/tests/plotting/common.py.pyindent" startline="362" endline="371" pcid="7226">
    def _get_axes_layout(self, axes):
        x_set = set()
        y_set = set()
        for ax in axes:
            # check axes coordinates to estimate layout
            points = ax.get_position().get_points()
            x_set.add(points[0][0])
            y_set.add(points[0][1])
        return (len(y_set), len(x_set))

</source>
</class>

<class classid="49" nclones="2" nlines="11" similarity="72">
<source file="pandas/pandas/plotting/_core.py.pyindent" startline="1398" endline="1404" pcid="2983">
    def orientation(self):
        if self.kwds.get('orientation', None) == 'horizontal':
            return 'horizontal'
        else:
            return 'vertical'


</source>
<source file="pandas/pandas/plotting/_core.py.pyindent" startline="1715" endline="1720" pcid="3005">
    def orientation(self):
        if self.kwds.get('vert', True):
            return 'vertical'
        else:
            return 'horizontal'

</source>
</class>

<class classid="50" nclones="2" nlines="23" similarity="83">
<source file="pandas/pandas/tests/arithmetic/test_datetime64.py.pyindent" startline="302" endline="319" pcid="3136">
    def dti_cmp_non_datetime(self, tz_naive_fixture):
        # GH#19301 by convention datetime.date is not considered comparable
        # to Timestamp or DatetimeIndex.  This may change in the future.
        tz = tz_naive_fixture
        dti = pd.date_range('2016-01-01', periods=2, tz=tz)

        other = datetime(2016, 1, 1).date()
        assert not (dti == other).any()
        assert (dti != other).all()
        with pytest.raises(TypeError):
            dti < other
        with pytest.raises(TypeError):
            dti <= other
        with pytest.raises(TypeError):
            dti > other
        with pytest.raises(TypeError):
            dti >= other

</source>
<source file="pandas/pandas/tests/arithmetic/test_datetime64.py.pyindent" startline="335" endline="348" pcid="3139">
    def test_dti_cmp_null_scalar_inequality(self, tz_naive_fixture, other):
        # GH#19301
        tz = tz_naive_fixture
        dti = pd.date_range('2016-01-01', periods=2, tz=tz)

        with pytest.raises(TypeError):
            dti < other
        with pytest.raises(TypeError):
            dti <= other
        with pytest.raises(TypeError):
            dti > other
        with pytest.raises(TypeError):
            dti >= other

</source>
</class>

<class classid="51" nclones="2" nlines="25" similarity="80">
<source file="pandas/pandas/tests/arithmetic/test_datetime64.py.pyindent" startline="349" endline="375" pcid="3140">
    def test_dti_cmp_nat(self):
        left = pd.DatetimeIndex([pd.Timestamp('2011-01-01'), pd.NaT,
                                 pd.Timestamp('2011-01-03')])
        right = pd.DatetimeIndex([pd.NaT, pd.NaT, pd.Timestamp('2011-01-03')])

        for lhs, rhs in [(left, right),
                         (left.astype(object), right.astype(object))]:
            result = rhs == lhs
            expected = np.array([False, False, True])
            tm.assert_numpy_array_equal(result, expected)

            result = lhs != rhs
            expected = np.array([True, True, False])
            tm.assert_numpy_array_equal(result, expected)

            expected = np.array([False, False, False])
            tm.assert_numpy_array_equal(lhs == pd.NaT, expected)
            tm.assert_numpy_array_equal(pd.NaT == rhs, expected)

            expected = np.array([True, True, True])
            tm.assert_numpy_array_equal(lhs != pd.NaT, expected)
            tm.assert_numpy_array_equal(pd.NaT != lhs, expected)

            expected = np.array([False, False, False])
            tm.assert_numpy_array_equal(lhs < pd.NaT, expected)
            tm.assert_numpy_array_equal(pd.NaT > lhs, expected)

</source>
<source file="pandas/pandas/tests/test_arithmetic.py.pyindent" startline="102" endline="128" pcid="9017">
    def test_comp_nat(self):
        left = pd.TimedeltaIndex([pd.Timedelta('1 days'), pd.NaT,
                                  pd.Timedelta('3 days')])
        right = pd.TimedeltaIndex([pd.NaT, pd.NaT, pd.Timedelta('3 days')])

        for lhs, rhs in [(left, right),
                         (left.astype(object), right.astype(object))]:
            result = rhs == lhs
            expected = np.array([False, False, True])
            tm.assert_numpy_array_equal(result, expected)

            result = rhs != lhs
            expected = np.array([True, True, False])
            tm.assert_numpy_array_equal(result, expected)

            expected = np.array([False, False, False])
            tm.assert_numpy_array_equal(lhs == pd.NaT, expected)
            tm.assert_numpy_array_equal(pd.NaT == rhs, expected)

            expected = np.array([True, True, True])
            tm.assert_numpy_array_equal(lhs != pd.NaT, expected)
            tm.assert_numpy_array_equal(pd.NaT != lhs, expected)

            expected = np.array([False, False, False])
            tm.assert_numpy_array_equal(lhs < pd.NaT, expected)
            tm.assert_numpy_array_equal(pd.NaT > lhs, expected)

</source>
</class>

<class classid="52" nclones="3" nlines="20" similarity="70">
<source file="pandas/pandas/tests/arithmetic/test_datetime64.py.pyindent" startline="907" endline="919" pcid="3166">
    def test_dt64_mul_div_numeric_invalid(self, one, dt64_series):
        # multiplication
        with pytest.raises(TypeError):
            dt64_series * one
        with pytest.raises(TypeError):
            one * dt64_series

        # division
        with pytest.raises(TypeError):
            dt64_series / one
        with pytest.raises(TypeError):
            one / dt64_series

</source>
<source file="pandas/pandas/tests/scalar/timedelta/test_arithmetic.py.pyindent" startline="524" endline="542" pcid="7940">
    def test_rmod_invalid(self):
        # GH#19365
        td = Timedelta(minutes=3)

        with pytest.raises(TypeError):
            pd.Timestamp('2018-01-22') % td

        with pytest.raises(TypeError):
            15 % td

        with pytest.raises(TypeError):
            16.0 % td

        with pytest.raises(TypeError):
            np.array([22, 24]) % td

    # ----------------------------------------------------------------
    # Timedelta.__divmod__, __rdivmod__

</source>
<source file="pandas/pandas/tests/scalar/timedelta/test_arithmetic.py.pyindent" startline="604" endline="618" pcid="7947">
    def test_rdivmod_invalid(self):
        # GH#19365
        td = Timedelta(minutes=3)

        with pytest.raises(TypeError):
            divmod(pd.Timestamp('2018-01-22'), td)

        with pytest.raises(TypeError):
            divmod(15, td)

        with pytest.raises(TypeError):
            divmod(16.0, td)

        with pytest.raises(TypeError):
            divmod(np.array([22, 24]), td)
</source>
</class>

<class classid="53" nclones="4" nlines="10" similarity="70">
<source file="pandas/pandas/tests/arithmetic/test_datetime64.py.pyindent" startline="1033" endline="1042" pcid="3172">
    def test_dti_add_int(self, tz_naive_fixture, one):
        # Variants of `one` for #19012
        tz = tz_naive_fixture
        rng = pd.date_range('2000-01-01 09:00', freq='H',
                            periods=10, tz=tz)
        result = rng + one
        expected = pd.date_range('2000-01-01 10:00', freq='H',
                                 periods=10, tz=tz)
        tm.assert_index_equal(result, expected)

</source>
<source file="pandas/pandas/tests/arithmetic/test_datetime64.py.pyindent" startline="1052" endline="1060" pcid="3174">
    def test_dti_sub_int(self, tz_naive_fixture, one):
        tz = tz_naive_fixture
        rng = pd.date_range('2000-01-01 09:00', freq='H',
                            periods=10, tz=tz)
        result = rng - one
        expected = pd.date_range('2000-01-01 08:00', freq='H',
                                 periods=10, tz=tz)
        tm.assert_index_equal(result, expected)

</source>
<source file="pandas/pandas/tests/arithmetic/test_datetime64.py.pyindent" startline="1043" endline="1051" pcid="3173">
    def test_dti_iadd_int(self, tz_naive_fixture, one):
        tz = tz_naive_fixture
        rng = pd.date_range('2000-01-01 09:00', freq='H',
                            periods=10, tz=tz)
        expected = pd.date_range('2000-01-01 10:00', freq='H',
                                 periods=10, tz=tz)
        rng += one
        tm.assert_index_equal(rng, expected)

</source>
<source file="pandas/pandas/tests/arithmetic/test_datetime64.py.pyindent" startline="1061" endline="1072" pcid="3175">
    def test_dti_isub_int(self, tz_naive_fixture, one):
        tz = tz_naive_fixture
        rng = pd.date_range('2000-01-01 09:00', freq='H',
                            periods=10, tz=tz)
        expected = pd.date_range('2000-01-01 08:00', freq='H',
                                 periods=10, tz=tz)
        rng -= one
        tm.assert_index_equal(rng, expected)

    # -------------------------------------------------------------
    # __add__/__sub__ with integer arrays

</source>
</class>

<class classid="54" nclones="2" nlines="14" similarity="85">
<source file="pandas/pandas/tests/arithmetic/test_datetime64.py.pyindent" startline="1380" endline="1393" pcid="3195">
    def test_sub_period(self, freq, box):
        # GH#13078
        # not supported, check TypeError
        p = pd.Period('2011-01-01', freq='D')

        idx = pd.DatetimeIndex(['2011-01-01', '2011-01-02'], freq=freq)
        idx = tm.box_expected(idx, box)

        with pytest.raises(TypeError):
            idx - p

        with pytest.raises(TypeError):
            p - idx

</source>
<source file="pandas/pandas/tests/test_arithmetic.py.pyindent" startline="432" endline="444" pcid="9026">
    def test_td64arr_sub_period(self, box, freq):
        # GH#13078
        # not supported, check TypeError
        p = pd.Period('2011-01-01', freq='D')
        idx = TimedeltaIndex(['1 hours', '2 hours'], freq=freq)
        idx = tm.box_expected(idx, box)

        with pytest.raises(TypeError):
            idx - p

        with pytest.raises(TypeError):
            p - idx

</source>
</class>

<class classid="55" nclones="2" nlines="19" similarity="73">
<source file="pandas/pandas/tests/arithmetic/test_datetime64.py.pyindent" startline="1600" endline="1615" pcid="3203">
    def test_dti_add_offset_array(self, tz_naive_fixture):
        # GH#18849
        tz = tz_naive_fixture
        dti = pd.date_range('2017-01-01', periods=2, tz=tz)
        other = np.array([pd.offsets.MonthEnd(), pd.offsets.Day(n=2)])

        with tm.assert_produces_warning(PerformanceWarning):
            res = dti + other
        expected = DatetimeIndex([dti[n] + other[n] for n in range(len(dti))],
                                 name=dti.name, freq='infer')
        tm.assert_index_equal(res, expected)

        with tm.assert_produces_warning(PerformanceWarning):
            res2 = other + dti
        tm.assert_index_equal(res2, expected)

</source>
<source file="pandas/pandas/tests/arithmetic/test_datetime64.py.pyindent" startline="1619" endline="1635" pcid="3204">
    def test_dti_add_offset_index(self, tz_naive_fixture, names):
        # GH#18849, GH#19744
        tz = tz_naive_fixture
        dti = pd.date_range('2017-01-01', periods=2, tz=tz, name=names[0])
        other = pd.Index([pd.offsets.MonthEnd(), pd.offsets.Day(n=2)],
                         name=names[1])

        with tm.assert_produces_warning(PerformanceWarning):
            res = dti + other
        expected = DatetimeIndex([dti[n] + other[n] for n in range(len(dti))],
                                 name=names[2], freq='infer')
        tm.assert_index_equal(res, expected)

        with tm.assert_produces_warning(PerformanceWarning):
            res2 = other + dti
        tm.assert_index_equal(res2, expected)

</source>
</class>

<class classid="56" nclones="2" nlines="11" similarity="72">
<source file="pandas/pandas/tests/arithmetic/test_numeric.py.pyindent" startline="422" endline="427" pcid="3245">
    def test_mul_size_mismatch_raises(self, idx):
        with pytest.raises(ValueError):
            idx * idx[0:3]
        with pytest.raises(ValueError):
            idx * np.array([1, 2])

</source>
<source file="pandas/pandas/tests/scalar/timestamp/test_timestamp.py.pyindent" startline="475" endline="480" pcid="8028">
    def test_out_of_bounds_string(self):
        with pytest.raises(ValueError):
            Timestamp('1676-01-01')
        with pytest.raises(ValueError):
            Timestamp('2263-01-01')

</source>
</class>

<class classid="57" nclones="6" nlines="14" similarity="71">
<source file="pandas/pandas/tests/arithmetic/test_period.py.pyindent" startline="694" endline="702" pcid="3307">
    def test_pi_add_iadd_timedeltalike_freq_mismatch_daily(self, not_daily):
        other = not_daily
        rng = pd.period_range('2014-05-01', '2014-05-15', freq='D')
        msg = 'Input has different freq(=.+)? from PeriodIndex\\(freq=D\\)'
        with tm.assert_raises_regex(period.IncompatibleFrequency, msg):
            rng + other
        with tm.assert_raises_regex(period.IncompatibleFrequency, msg):
            rng += other

</source>
<source file="pandas/pandas/tests/arithmetic/test_period.py.pyindent" startline="722" endline="732" pcid="3310">
    def test_pi_add_timedeltalike_mismatched_freq_hourly(self, not_hourly):
        other = not_hourly
        rng = pd.period_range('2014-01-01 10:00', '2014-01-05 10:00', freq='H')
        msg = 'Input has different freq(=.+)? from PeriodIndex\\(freq=H\\)'

        with tm.assert_raises_regex(period.IncompatibleFrequency, msg):
            rng + other

        with tm.assert_raises_regex(period.IncompatibleFrequency, msg):
            rng += other

</source>
<source file="pandas/pandas/tests/arithmetic/test_period.py.pyindent" startline="785" endline="793" pcid="3316">
    def test_pi_add_iadd_timedeltalike_freq_mismatch_monthly(self, mismatched):
        other = mismatched
        rng = pd.period_range('2014-01', '2016-12', freq='M')
        msg = 'Input has different freq(=.+)? from PeriodIndex\\(freq=M\\)'
        with tm.assert_raises_regex(period.IncompatibleFrequency, msg):
            rng + other
        with tm.assert_raises_regex(period.IncompatibleFrequency, msg):
            rng += other

</source>
<source file="pandas/pandas/tests/arithmetic/test_period.py.pyindent" startline="794" endline="803" pcid="3317">
    def test_pi_sub_isub_timedeltalike_freq_mismatch_monthly(self, mismatched):
        other = mismatched
        rng = pd.period_range('2014-01', '2016-12', freq='M')
        msg = 'Input has different freq(=.+)? from PeriodIndex\\(freq=M\\)'
        with tm.assert_raises_regex(period.IncompatibleFrequency, msg):
            rng - other
        with tm.assert_raises_regex(period.IncompatibleFrequency, msg):
            rng -= other


</source>
<source file="pandas/pandas/tests/arithmetic/test_period.py.pyindent" startline="755" endline="764" pcid="3313">
    def test_pi_add_iadd_timedeltalike_freq_mismatch_annual(self, mismatched):
        other = mismatched
        rng = pd.period_range('2014', '2024', freq='A')
        msg = ('Input has different freq(=.+)? '
               'from PeriodIndex\\(freq=A-DEC\\)')
        with tm.assert_raises_regex(period.IncompatibleFrequency, msg):
            rng + other
        with tm.assert_raises_regex(period.IncompatibleFrequency, msg):
            rng += other

</source>
<source file="pandas/pandas/tests/arithmetic/test_period.py.pyindent" startline="765" endline="774" pcid="3314">
    def test_pi_sub_isub_timedeltalike_freq_mismatch_annual(self, mismatched):
        other = mismatched
        rng = pd.period_range('2014', '2024', freq='A')
        msg = ('Input has different freq(=.+)? '
               'from PeriodIndex\\(freq=A-DEC\\)')
        with tm.assert_raises_regex(period.IncompatibleFrequency, msg):
            rng - other
        with tm.assert_raises_regex(period.IncompatibleFrequency, msg):
            rng -= other

</source>
</class>

<class classid="58" nclones="2" nlines="17" similarity="88">
<source file="pandas/pandas/tests/arithmetic/test_period.py.pyindent" startline="851" endline="865" pcid="3320">
    def _check(self, values, func, expected):
        idx = pd.PeriodIndex(values)
        result = func(idx)
        if isinstance(expected, pd.Index):
            tm.assert_index_equal(result, expected)
        else:
            # comp op results in bool
            tm.assert_numpy_array_equal(result, expected)

        ser = pd.Series(values)
        result = func(ser)

        exp = pd.Series(expected, name=values.name)
        tm.assert_series_equal(result, exp)

</source>
<source file="pandas/pandas/tests/indexes/period/test_ops.py.pyindent" startline="420" endline="434" pcid="5826">
    def _check(self, values, func, expected):
        idx = pd.PeriodIndex(values)
        result = func(idx)
        if isinstance(expected, pd.Index):
            tm.assert_index_equal(result, expected)
        else:
            # comp op results in bool
            tm.assert_numpy_array_equal(result, expected)

        s = pd.Series(values)
        result = func(s)

        exp = pd.Series(expected, name=values.name)
        tm.assert_series_equal(result, exp)

</source>
</class>

<class classid="59" nclones="2" nlines="16" similarity="87">
<source file="pandas/pandas/tests/computation/test_eval.py.pyindent" startline="293" endline="307" pcid="3530">
    def check_alignment(self, result, nlhs, ghs, op):
        try:
            nlhs, ghs = nlhs.align(ghs)
        except (ValueError, TypeError, AttributeError):
            # ValueError: series frame or frame series align
            # TypeError, AttributeError: series or frame with scalar align
            pass
        else:

            # direct numpy comparison
            expected = self.ne.evaluate('nlhs {0} ghs'.format(op))
            tm.assert_numpy_array_equal(result.values, expected)

    # modulus, pow, and floor division require special casing

</source>
<source file="pandas/pandas/tests/computation/test_eval.py.pyindent" startline="752" endline="763" pcid="3556">
    def check_alignment(self, result, nlhs, ghs, op):
        try:
            nlhs, ghs = nlhs.align(ghs)
        except (ValueError, TypeError, AttributeError):
            # ValueError: series frame or frame series align
            # TypeError, AttributeError: series or frame with scalar align
            pass
        else:
            expected = eval('nlhs {0} ghs'.format(op))
            tm.assert_almost_equal(result, expected)


</source>
</class>

<class classid="60" nclones="2" nlines="52" similarity="86">
<source file="pandas/pandas/tests/computation/test_eval.py.pyindent" startline="407" endline="445" pcid="3538">
    def test_frame_invert(self):
        expr = self.ex('~')

        # ~ ##
        # frame
        # float always raises
        lhs = DataFrame(randn(5, 2))
        if self.engine == 'numexpr':
            with pytest.raises(NotImplementedError):
                result = pd.eval(expr, engine=self.engine, parser=self.parser)
        else:
            with pytest.raises(TypeError):
                result = pd.eval(expr, engine=self.engine, parser=self.parser)

        # int raises on numexpr
        lhs = DataFrame(randint(5, size=(5, 2)))
        if self.engine == 'numexpr':
            with pytest.raises(NotImplementedError):
                result = pd.eval(expr, engine=self.engine, parser=self.parser)
        else:
            expect = ~lhs
            result = pd.eval(expr, engine=self.engine, parser=self.parser)
            assert_frame_equal(expect, result)

        # bool always works
        lhs = DataFrame(rand(5, 2) > 0.5)
        expect = ~lhs
        result = pd.eval(expr, engine=self.engine, parser=self.parser)
        assert_frame_equal(expect, result)

        # object raises
        lhs = DataFrame({'b': ['a', 1, 2.0], 'c': rand(3) > 0.5})
        if self.engine == 'numexpr':
            with pytest.raises(ValueError):
                result = pd.eval(expr, engine=self.engine, parser=self.parser)
        else:
            with pytest.raises(TypeError):
                result = pd.eval(expr, engine=self.engine, parser=self.parser)

</source>
<source file="pandas/pandas/tests/computation/test_eval.py.pyindent" startline="446" endline="488" pcid="3539">
    def test_series_invert(self):
        # ~ ####
        expr = self.ex('~')

        # series
        # float raises
        lhs = Series(randn(5))
        if self.engine == 'numexpr':
            with pytest.raises(NotImplementedError):
                result = pd.eval(expr, engine=self.engine, parser=self.parser)
        else:
            with pytest.raises(TypeError):
                result = pd.eval(expr, engine=self.engine, parser=self.parser)

        # int raises on numexpr
        lhs = Series(randint(5, size=5))
        if self.engine == 'numexpr':
            with pytest.raises(NotImplementedError):
                result = pd.eval(expr, engine=self.engine, parser=self.parser)
        else:
            expect = ~lhs
            result = pd.eval(expr, engine=self.engine, parser=self.parser)
            assert_series_equal(expect, result)

        # bool
        lhs = Series(rand(5) > 0.5)
        expect = ~lhs
        result = pd.eval(expr, engine=self.engine, parser=self.parser)
        assert_series_equal(expect, result)

        # float
        # int
        # bool

        # object
        lhs = Series(['a', 1, 2.0])
        if self.engine == 'numexpr':
            with pytest.raises(ValueError):
                result = pd.eval(expr, engine=self.engine, parser=self.parser)
        else:
            with pytest.raises(TypeError):
                result = pd.eval(expr, engine=self.engine, parser=self.parser)

</source>
</class>

<class classid="61" nclones="2" nlines="26" similarity="73">
<source file="pandas/pandas/tests/computation/test_eval.py.pyindent" startline="489" endline="513" pcid="3540">
    def test_frame_negate(self):
        expr = self.ex('-')

        # float
        lhs = DataFrame(randn(5, 2))
        expect = -lhs
        result = pd.eval(expr, engine=self.engine, parser=self.parser)
        assert_frame_equal(expect, result)

        # int
        lhs = DataFrame(randint(5, size=(5, 2)))
        expect = -lhs
        result = pd.eval(expr, engine=self.engine, parser=self.parser)
        assert_frame_equal(expect, result)

        # bool doesn't work with numexpr but works elsewhere
        lhs = DataFrame(rand(5, 2) > 0.5)
        if self.engine == 'numexpr':
            with pytest.raises(NotImplementedError):
                result = pd.eval(expr, engine=self.engine, parser=self.parser)
        else:
            expect = -lhs
            result = pd.eval(expr, engine=self.engine, parser=self.parser)
            assert_frame_equal(expect, result)

</source>
<source file="pandas/pandas/tests/computation/test_eval.py.pyindent" startline="514" endline="538" pcid="3541">
    def test_series_negate(self):
        expr = self.ex('-')

        # float
        lhs = Series(randn(5))
        expect = -lhs
        result = pd.eval(expr, engine=self.engine, parser=self.parser)
        assert_series_equal(expect, result)

        # int
        lhs = Series(randint(5, size=5))
        expect = -lhs
        result = pd.eval(expr, engine=self.engine, parser=self.parser)
        assert_series_equal(expect, result)

        # bool doesn't work with numexpr but works elsewhere
        lhs = Series(rand(5) > 0.5)
        if self.engine == 'numexpr':
            with pytest.raises(NotImplementedError):
                result = pd.eval(expr, engine=self.engine, parser=self.parser)
        else:
            expect = -lhs
            result = pd.eval(expr, engine=self.engine, parser=self.parser)
            assert_series_equal(expect, result)

</source>
</class>

<class classid="62" nclones="2" nlines="27" similarity="77">
<source file="pandas/pandas/tests/computation/test_eval.py.pyindent" startline="881" endline="898" pcid="3567">
        def testit(r_idx_type, c_idx_type, index_name):
            df = mkdf(10, 10, data_gen_f=f, r_idx_type=r_idx_type,
                      c_idx_type=c_idx_type)
            index = getattr(df, index_name)
            s = Series(np.random.randn(5), index[:5])

            if should_warn(df.index, s.index):
                with tm.assert_produces_warning(RuntimeWarning):
                    res = pd.eval('df + s', engine=engine, parser=parser)
            else:
                res = pd.eval('df + s', engine=engine, parser=parser)

            if r_idx_type == 'dt' or c_idx_type == 'dt':
                expected = df.add(s) if engine == 'numexpr' else df + s
            else:
                expected = df + s
            assert_frame_equal(res, expected)

</source>
<source file="pandas/pandas/tests/computation/test_eval.py.pyindent" startline="907" endline="924" pcid="3569">
        def testit(r_idx_type, c_idx_type, index_name):
            df = mkdf(10, 7, data_gen_f=f, r_idx_type=r_idx_type,
                      c_idx_type=c_idx_type)
            index = getattr(df, index_name)
            s = Series(np.random.randn(5), index[:5])
            if should_warn(s.index, df.index):
                with tm.assert_produces_warning(RuntimeWarning):
                    res = pd.eval('s + df', engine=engine, parser=parser)
            else:
                res = pd.eval('s + df', engine=engine, parser=parser)

            if r_idx_type == 'dt' or c_idx_type == 'dt':
                expected = df.add(s) if engine == 'numexpr' else s + df
            else:
                expected = s + df
            assert_frame_equal(res, expected)

        # only test dt with dt, otherwise weird joins result
</source>
</class>

<class classid="63" nclones="2" nlines="11" similarity="72">
<source file="pandas/pandas/tests/computation/test_eval.py.pyindent" startline="1099" endline="1106" pcid="3577">
    def test_simple_bool_ops(self):
        for op, lhs, rhs in product(expr._bool_ops_syms, (True, False),
                                    (True, False)):
            ex = '{0} {1} {2}'.format(lhs, op, rhs)
            res = self.eval(ex)
            exp = eval(ex)
            assert res == exp

</source>
<source file="pandas/pandas/tests/computation/test_eval.py.pyindent" startline="1107" endline="1114" pcid="3578">
    def test_bool_ops_with_constants(self):
        for op, lhs, rhs in product(expr._bool_ops_syms, ('True', 'False'),
                                    ('True', 'False')):
            ex = '{0} {1} {2}'.format(lhs, op, rhs)
            res = self.eval(ex)
            exp = eval(ex)
            assert res == exp

</source>
</class>

<class classid="64" nclones="2" nlines="21" similarity="71">
<source file="pandas/pandas/tests/computation/test_eval.py.pyindent" startline="1553" endline="1564" pcid="3613">
    def test_bool_ops_with_constants(self):
        for op, lhs, rhs in product(expr._bool_ops_syms, ('True', 'False'),
                                    ('True', 'False')):
            ex = '{0} {1} {2}'.format(lhs, op, rhs)
            if op in ('and', 'or'):
                with pytest.raises(NotImplementedError):
                    self.eval(ex)
            else:
                res = self.eval(ex)
                exp = eval(ex)
                assert res == exp

</source>
<source file="pandas/pandas/tests/computation/test_eval.py.pyindent" startline="1565" endline="1577" pcid="3614">
    def test_simple_bool_ops(self):
        for op, lhs, rhs in product(expr._bool_ops_syms, (True, False),
                                    (True, False)):
            ex = 'lhs {0} rhs'.format(op)
            if op in ('and', 'or'):
                with pytest.raises(NotImplementedError):
                    pd.eval(ex, engine=self.engine, parser=self.parser)
            else:
                res = pd.eval(ex, engine=self.engine, parser=self.parser)
                exp = eval(ex)
                assert res == exp


</source>
</class>

<class classid="65" nclones="2" nlines="11" similarity="72">
<source file="pandas/pandas/tests/computation/test_eval.py.pyindent" startline="1641" endline="1650" pcid="3622">
    def test_df_use_case(self):
        df = DataFrame({'a': np.random.randn(10),
                        'b': np.random.randn(10)})
        df.eval("e = arctan2(sin(a), b)",
                engine=self.engine,
                parser=self.parser, inplace=True)
        got = df.e
        expect = np.arctan2(np.sin(df.a), df.b)
        tm.assert_series_equal(got, expect, check_names=False)

</source>
<source file="pandas/pandas/tests/computation/test_eval.py.pyindent" startline="1651" endline="1660" pcid="3623">
    def test_df_arithmetic_subexpression(self):
        df = DataFrame({'a': np.random.randn(10),
                        'b': np.random.randn(10)})
        df.eval("e = sin(a + b)",
                engine=self.engine,
                parser=self.parser, inplace=True)
        got = df.e
        expect = np.sin(df.a + df.b)
        tm.assert_series_equal(got, expect, check_names=False)

</source>
</class>

<class classid="66" nclones="2" nlines="11" similarity="90">
<source file="pandas/pandas/tests/computation/test_eval.py.pyindent" startline="1888" endline="1893" pcid="3648">
    def test_validate_bool_args(self):
        invalid_values = [1, "True", [1, 2, 3], 5.0]

        for value in invalid_values:
            with pytest.raises(ValueError):
                pd.eval("2+2", inplace=value)
</source>
<source file="pandas/pandas/tests/test_base.py.pyindent" startline="993" endline="1000" pcid="9125">
    def test_validate_bool_args(self):
        invalid_values = [1, "True", [1, 2, 3], 5.0]

        for value in invalid_values:
            with pytest.raises(ValueError):
                self.int_series.drop_duplicates(inplace=value)


</source>
</class>

<class classid="67" nclones="2" nlines="14" similarity="85">
<source file="pandas/pandas/tests/dtypes/test_dtypes.py.pyindent" startline="135" endline="148" pcid="3749">
    def test_hash_vs_equality(self):
        # make sure that we satisfy is semantics
        dtype = self.dtype
        dtype2 = DatetimeTZDtype('ns', 'US/Eastern')
        dtype3 = DatetimeTZDtype(dtype2)
        assert dtype == dtype2
        assert dtype2 == dtype
        assert dtype3 == dtype
        assert dtype is dtype2
        assert dtype2 is dtype
        assert dtype3 is dtype
        assert hash(dtype) == hash(dtype2)
        assert hash(dtype) == hash(dtype3)

</source>
<source file="pandas/pandas/tests/dtypes/test_dtypes.py.pyindent" startline="253" endline="266" pcid="3762">
    def test_hash_vs_equality(self):
        # make sure that we satisfy is semantics
        dtype = self.dtype
        dtype2 = PeriodDtype('D')
        dtype3 = PeriodDtype(dtype2)
        assert dtype == dtype2
        assert dtype2 == dtype
        assert dtype3 == dtype
        assert dtype is dtype2
        assert dtype2 is dtype
        assert dtype3 is dtype
        assert hash(dtype) == hash(dtype2)
        assert hash(dtype) == hash(dtype3)

</source>
</class>

<class classid="68" nclones="2" nlines="25" similarity="80">
<source file="pandas/pandas/tests/dtypes/test_missing.py.pyindent" startline="186" endline="210" pcid="3830">
    def test_datetime_other_units(self):
        idx = pd.DatetimeIndex(['2011-01-01', 'NaT', '2011-01-02'])
        exp = np.array([False, True, False])
        tm.assert_numpy_array_equal(isna(idx), exp)
        tm.assert_numpy_array_equal(notna(idx), ~exp)
        tm.assert_numpy_array_equal(isna(idx.values), exp)
        tm.assert_numpy_array_equal(notna(idx.values), ~exp)

        for dtype in ['datetime64[D]', 'datetime64[h]', 'datetime64[m]',
                      'datetime64[s]', 'datetime64[ms]', 'datetime64[us]',
                      'datetime64[ns]']:
            values = idx.values.astype(dtype)

            exp = np.array([False, True, False])
            tm.assert_numpy_array_equal(isna(values), exp)
            tm.assert_numpy_array_equal(notna(values), ~exp)

            exp = pd.Series([False, True, False])
            s = pd.Series(values)
            tm.assert_series_equal(isna(s), exp)
            tm.assert_series_equal(notna(s), ~exp)
            s = pd.Series(values, dtype=object)
            tm.assert_series_equal(isna(s), exp)
            tm.assert_series_equal(notna(s), ~exp)

</source>
<source file="pandas/pandas/tests/dtypes/test_missing.py.pyindent" startline="211" endline="235" pcid="3831">
    def test_timedelta_other_units(self):
        idx = pd.TimedeltaIndex(['1 days', 'NaT', '2 days'])
        exp = np.array([False, True, False])
        tm.assert_numpy_array_equal(isna(idx), exp)
        tm.assert_numpy_array_equal(notna(idx), ~exp)
        tm.assert_numpy_array_equal(isna(idx.values), exp)
        tm.assert_numpy_array_equal(notna(idx.values), ~exp)

        for dtype in ['timedelta64[D]', 'timedelta64[h]', 'timedelta64[m]',
                      'timedelta64[s]', 'timedelta64[ms]', 'timedelta64[us]',
                      'timedelta64[ns]']:
            values = idx.values.astype(dtype)

            exp = np.array([False, True, False])
            tm.assert_numpy_array_equal(isna(values), exp)
            tm.assert_numpy_array_equal(notna(values), ~exp)

            exp = pd.Series([False, True, False])
            s = pd.Series(values)
            tm.assert_series_equal(isna(s), exp)
            tm.assert_series_equal(notna(s), ~exp)
            s = pd.Series(values, dtype=object)
            tm.assert_series_equal(isna(s), exp)
            tm.assert_series_equal(notna(s), ~exp)

</source>
</class>

<class classid="69" nclones="3" nlines="16" similarity="81">
<source file="pandas/pandas/tests/extension/base/methods.py.pyindent" startline="14" endline="26" pcid="3900">
    def test_value_counts(self, all_data, dropna):
        all_data = all_data[:10]
        if dropna:
            other = np.array(all_data[~all_data.isna()])
        else:
            other = all_data

        result = pd.Series(all_data).value_counts(dropna=dropna).sort_index()
        expected = pd.Series(other).value_counts(
            dropna=dropna).sort_index()

        self.assert_series_equal(result, expected)

</source>
<source file="pandas/pandas/tests/extension/integer/test_integer.py.pyindent" startline="436" endline="449" pcid="4084">
    def test_value_counts(self, all_data, dropna):
        all_data = all_data[:10]
        if dropna:
            other = np.array(all_data[~all_data.isna()])
        else:
            other = all_data

        result = pd.Series(all_data).value_counts(dropna=dropna).sort_index()
        expected = pd.Series(other).value_counts(
            dropna=dropna).sort_index()
        expected.index = expected.index.astype(all_data.dtype)

        self.assert_series_equal(result, expected)

</source>
<source file="pandas/pandas/tests/extension/decimal/test_decimal.py.pyindent" startline="148" endline="160" pcid="4039">
    def test_value_counts(self, all_data, dropna):
        all_data = all_data[:10]
        if dropna:
            other = np.array(all_data[~all_data.isna()])
        else:
            other = all_data

        result = pd.Series(all_data).value_counts(dropna=dropna).sort_index()
        expected = pd.Series(other).value_counts(dropna=dropna).sort_index()

        tm.assert_series_equal(result, expected)


</source>
</class>

<class classid="70" nclones="2" nlines="21" similarity="100">
<source file="pandas/pandas/tests/extension/base/reshaping.py.pyindent" startline="44" endline="71" pcid="3938">
    def test_concat_mixed_dtypes(self, data):
        # https://github.com/pandas-dev/pandas/issues/20762
        df1 = pd.DataFrame({'A': data[:3]})
        df2 = pd.DataFrame({"A": [1, 2, 3]})
        df3 = pd.DataFrame({"A": ['a', 'b', 'c']}).astype('category')
        df4 = pd.DataFrame({"A": pd.SparseArray([1, 2, 3])})
        dfs = [df1, df2, df3, df4]

        # dataframes
        result = pd.concat(dfs)
        expected = pd.concat([x.astype(object) for x in dfs])
        self.assert_frame_equal(result, expected)

        # series
        result = pd.concat([x['A'] for x in dfs])
        expected = pd.concat([x['A'].astype(object) for x in dfs])
        self.assert_series_equal(result, expected)

        # simple test for just EA and one other
        result = pd.concat([df1, df2])
        expected = pd.concat([df1.astype('object'), df2.astype('object')])
        self.assert_frame_equal(result, expected)

        result = pd.concat([df1['A'], df2['A']])
        expected = pd.concat([df1['A'].astype('object'),
                              df2['A'].astype('object')])
        self.assert_series_equal(result, expected)

</source>
<source file="pandas/pandas/tests/extension/integer/test_integer.py.pyindent" startline="394" endline="424" pcid="4083">
    def test_concat_mixed_dtypes(self, data):
        # https://github.com/pandas-dev/pandas/issues/20762
        df1 = pd.DataFrame({'A': data[:3]})
        df2 = pd.DataFrame({"A": [1, 2, 3]})
        df3 = pd.DataFrame({"A": ['a', 'b', 'c']}).astype('category')
        df4 = pd.DataFrame({"A": pd.SparseArray([1, 2, 3])})
        dfs = [df1, df2, df3, df4]

        # dataframes
        result = pd.concat(dfs)
        expected = pd.concat([x.astype(object) for x in dfs])
        self.assert_frame_equal(result, expected)

        # series
        result = pd.concat([x['A'] for x in dfs])
        expected = pd.concat([x['A'].astype(object) for x in dfs])
        self.assert_series_equal(result, expected)

        result = pd.concat([df1, df2])
        expected = pd.concat([df1.astype('object'), df2.astype('object')])
        self.assert_frame_equal(result, expected)

        # concat of an Integer and Int coerces to object dtype
        # TODO(jreback) once integrated this would
        # be a result of Integer
        result = pd.concat([df1['A'], df2['A']])
        expected = pd.concat([df1['A'].astype('object'),
                              df2['A'].astype('object')])
        self.assert_series_equal(result, expected)


</source>
</class>

<class classid="71" nclones="5" nlines="11" similarity="81">
<source file="pandas/pandas/tests/extension/category/test_categorical.py.pyindent" startline="34" endline="41" pcid="3969">
def data_repeated():
    """Return different versions of data for count times"""
    def gen(count):
        for _ in range(count):
            yield Categorical(make_data())
    yield gen


</source>
<source file="pandas/pandas/tests/extension/integer/test_integer.py.pyindent" startline="43" endline="49" pcid="4055">
def data_repeated(data):
    def gen(count):
        for _ in range(count):
            yield data
    yield gen


</source>
<source file="pandas/pandas/tests/extension/interval/test_interval.py.pyindent" startline="52" endline="59" pcid="4104">
def data_repeated():
    """Return different versions of data for count times"""
    def gen(count):
        for _ in range(count):
            yield IntervalArray(make_data())
    yield gen


</source>
<source file="pandas/pandas/tests/extension/decimal/test_decimal.py.pyindent" startline="34" endline="40" pcid="4027">
def data_repeated():
    def gen(count):
        for _ in range(count):
            yield DecimalArray(make_data())
    yield gen


</source>
<source file="pandas/pandas/tests/extension/conftest.py.pyindent" startline="34" endline="41" pcid="4001">
def data_repeated():
    """Return different versions of data for count times"""
    def gen(count):
        for _ in range(count):
            yield NotImplementedError
    yield gen


</source>
</class>

<class classid="72" nclones="3" nlines="19" similarity="78">
<source file="pandas/pandas/tests/extension/decimal/test_decimal.py.pyindent" startline="86" endline="106" pcid="4035">
    def assert_frame_equal(self, left, right, *args, **kwargs):
        # TODO(EA): select_dtypes
        tm.assert_index_equal(
            left.columns, right.columns,
            exact=kwargs.get('check_column_type', 'equiv'),
            check_names=kwargs.get('check_names', True),
            check_exact=kwargs.get('check_exact', False),
            check_categorical=kwargs.get('check_categorical', True),
            obj='{obj}.columns'.format(obj=kwargs.get('obj', 'DataFrame')))

        decimals = (left.dtypes == 'decimal').index

        for col in decimals:
            self.assert_series_equal(left[col], right[col],
                                     *args, **kwargs)

        left = left.drop(columns=decimals)
        right = right.drop(columns=decimals)
        tm.assert_frame_equal(left, right, *args, **kwargs)


</source>
<source file="pandas/pandas/tests/extension/integer/test_integer.py.pyindent" startline="112" endline="132" pcid="4065">
    def assert_frame_equal(self, left, right, *args, **kwargs):
        # TODO(EA): select_dtypes
        tm.assert_index_equal(
            left.columns, right.columns,
            exact=kwargs.get('check_column_type', 'equiv'),
            check_names=kwargs.get('check_names', True),
            check_exact=kwargs.get('check_exact', False),
            check_categorical=kwargs.get('check_categorical', True),
            obj='{obj}.columns'.format(obj=kwargs.get('obj', 'DataFrame')))

        integers = (left.dtypes == 'integer').index

        for col in integers:
            self.assert_series_equal(left[col], right[col],
                                     *args, **kwargs)

        left = left.drop(columns=integers)
        right = right.drop(columns=integers)
        tm.assert_frame_equal(left, right, *args, **kwargs)


</source>
<source file="pandas/pandas/tests/extension/json/test_json.py.pyindent" startline="98" endline="117" pcid="4132">
    def assert_frame_equal(self, left, right, *args, **kwargs):
        tm.assert_index_equal(
            left.columns, right.columns,
            exact=kwargs.get('check_column_type', 'equiv'),
            check_names=kwargs.get('check_names', True),
            check_exact=kwargs.get('check_exact', False),
            check_categorical=kwargs.get('check_categorical', True),
            obj='{obj}.columns'.format(obj=kwargs.get('obj', 'DataFrame')))

        jsons = (left.dtypes == 'json').index

        for col in jsons:
            self.assert_series_equal(left[col], right[col],
                                     *args, **kwargs)

        left = left.drop(columns=jsons)
        right = right.drop(columns=jsons)
        tm.assert_frame_equal(left, right, *args, **kwargs)


</source>
</class>

<class classid="73" nclones="2" nlines="18" similarity="83">
<source file="pandas/pandas/tests/frame/test_block_internals.py.pyindent" startline="298" endline="315" pcid="4234">
    def test_copy_blocks(self):
        # API/ENH 9607
        df = DataFrame(self.frame, copy=True)
        column = df.columns[0]

        # use the default copy=True, change a column

        # deprecated 0.21.0
        with tm.assert_produces_warning(FutureWarning,
                                        check_stacklevel=False):
            blocks = df.as_blocks()
        for dtype, _df in blocks.items():
            if column in _df:
                _df.loc[:, column] = _df[column] + 1

        # make sure we did not change the original DataFrame
        assert not _df[column].equals(df[column])

</source>
<source file="pandas/pandas/tests/frame/test_block_internals.py.pyindent" startline="316" endline="333" pcid="4235">
    def test_no_copy_blocks(self):
        # API/ENH 9607
        df = DataFrame(self.frame, copy=True)
        column = df.columns[0]

        # use the copy=False, change a column

        # deprecated 0.21.0
        with tm.assert_produces_warning(FutureWarning,
                                        check_stacklevel=False):
            blocks = df.as_blocks(copy=False)
        for dtype, _df in blocks.items():
            if column in _df:
                _df.loc[:, column] = _df[column] + 1

        # make sure we did change the original DataFrame
        assert _df[column].equals(df[column])

</source>
</class>

<class classid="74" nclones="3" nlines="15" similarity="73">
<source file="pandas/pandas/tests/frame/test_combine_concat.py.pyindent" startline="201" endline="217" pcid="4254">
    def test_update(self):
        df = DataFrame([[1.5, nan, 3.],
                        [1.5, nan, 3.],
                        [1.5, nan, 3],
                        [1.5, nan, 3]])

        other = DataFrame([[3.6, 2., np.nan],
                           [np.nan, np.nan, 7]], index=[1, 3])

        df.update(other)

        expected = DataFrame([[1.5, nan, 3],
                              [3.6, 2, 3],
                              [1.5, nan, 3],
                              [1.5, nan, 7.]])
        assert_frame_equal(df, expected)

</source>
<source file="pandas/pandas/tests/frame/test_combine_concat.py.pyindent" startline="231" endline="247" pcid="4256">
    def test_update_nooverwrite(self):
        df = DataFrame([[1.5, nan, 3.],
                        [1.5, nan, 3.],
                        [1.5, nan, 3],
                        [1.5, nan, 3]])

        other = DataFrame([[3.6, 2., np.nan],
                           [np.nan, np.nan, 7]], index=[1, 3])

        df.update(other, overwrite=False)

        expected = DataFrame([[1.5, nan, 3],
                              [1.5, 2, 3],
                              [1.5, nan, 3],
                              [1.5, nan, 3.]])
        assert_frame_equal(df, expected)

</source>
<source file="pandas/pandas/tests/frame/test_combine_concat.py.pyindent" startline="248" endline="264" pcid="4257">
    def test_update_filtered(self):
        df = DataFrame([[1.5, nan, 3.],
                        [1.5, nan, 3.],
                        [1.5, nan, 3],
                        [1.5, nan, 3]])

        other = DataFrame([[3.6, 2., np.nan],
                           [np.nan, np.nan, 7]], index=[1, 3])

        df.update(other, filter_func=lambda x: x > 2)

        expected = DataFrame([[1.5, nan, 3],
                              [1.5, nan, 3],
                              [1.5, nan, 3],
                              [1.5, nan, 7.]])
        assert_frame_equal(df, expected)

</source>
</class>

<class classid="75" nclones="3" nlines="12" similarity="75">
<source file="pandas/pandas/tests/frame/test_missing.py.pyindent" startline="34" endline="41" pcid="4303">
def _skip_if_no_pchip():
    try:
        from scipy.interpolate import pchip_interpolate  # noqa
    except ImportError:
        import pytest
        pytest.skip('scipy.interpolate.pchip missing')


</source>
<source file="pandas/pandas/tests/series/test_missing.py.pyindent" startline="34" endline="41" pcid="8386">
def _skip_if_no_pchip():
    try:
        from scipy.interpolate import pchip_interpolate  # noqa
    except ImportError:
        import pytest
        pytest.skip('scipy.interpolate.pchip missing')


</source>
<source file="pandas/pandas/tests/series/test_missing.py.pyindent" startline="42" endline="49" pcid="8387">
def _skip_if_no_akima():
    try:
        from scipy.interpolate import Akima1DInterpolator  # noqa
    except ImportError:
        import pytest
        pytest.skip('scipy.interpolate.Akima1DInterpolator missing')


</source>
</class>

<class classid="76" nclones="3" nlines="12" similarity="76">
<source file="pandas/pandas/tests/frame/test_query_eval.py.pyindent" startline="382" endline="393" pcid="4408">
    def test_date_query_with_attribute_access(self):
        engine, parser = self.engine, self.parser
        skip_if_no_pandas_parser(parser)
        df = DataFrame(randn(5, 3))
        df['dates1'] = date_range('1/1/2012', periods=5)
        df['dates2'] = date_range('1/1/2013', periods=5)
        df['dates3'] = date_range('1/1/2014', periods=5)
        res = df.query('@df.dates1 < 20130101 < @df.dates3', engine=engine,
                       parser=parser)
        expec = df[(df.dates1 < '20130101') & ('20130101' < df.dates3)]
        assert_frame_equal(res, expec)

</source>
<source file="pandas/pandas/tests/frame/test_query_eval.py.pyindent" startline="394" endline="404" pcid="4409">
    def test_date_query_no_attribute_access(self):
        engine, parser = self.engine, self.parser
        df = DataFrame(randn(5, 3))
        df['dates1'] = date_range('1/1/2012', periods=5)
        df['dates2'] = date_range('1/1/2013', periods=5)
        df['dates3'] = date_range('1/1/2014', periods=5)
        res = df.query('dates1 < 20130101 < dates3', engine=engine,
                       parser=parser)
        expec = df[(df.dates1 < '20130101') & ('20130101' < df.dates3)]
        assert_frame_equal(res, expec)

</source>
<source file="pandas/pandas/tests/frame/test_query_eval.py.pyindent" startline="714" endline="724" pcid="4432">
    def test_date_query_no_attribute_access(self):
        engine, parser = self.engine, self.parser
        df = DataFrame(randn(5, 3))
        df['dates1'] = date_range('1/1/2012', periods=5)
        df['dates2'] = date_range('1/1/2013', periods=5)
        df['dates3'] = date_range('1/1/2014', periods=5)
        res = df.query('(dates1 < 20130101) & (20130101 < dates3)',
                       engine=engine, parser=parser)
        expec = df[(df.dates1 < '20130101') & ('20130101' < df.dates3)]
        assert_frame_equal(res, expec)

</source>
</class>

<class classid="77" nclones="2" nlines="15" similarity="86">
<source file="pandas/pandas/tests/frame/test_query_eval.py.pyindent" startline="405" endline="418" pcid="4410">
    def test_date_query_with_NaT(self):
        engine, parser = self.engine, self.parser
        n = 10
        df = DataFrame(randn(n, 3))
        df['dates1'] = date_range('1/1/2012', periods=n)
        df['dates2'] = date_range('1/1/2013', periods=n)
        df['dates3'] = date_range('1/1/2014', periods=n)
        df.loc[np.random.rand(n) > 0.5, 'dates1'] = pd.NaT
        df.loc[np.random.rand(n) > 0.5, 'dates3'] = pd.NaT
        res = df.query('dates1 < 20130101 < dates3', engine=engine,
                       parser=parser)
        expec = df[(df.dates1 < '20130101') & ('20130101' < df.dates3)]
        assert_frame_equal(res, expec)

</source>
<source file="pandas/pandas/tests/frame/test_query_eval.py.pyindent" startline="725" endline="738" pcid="4433">
    def test_date_query_with_NaT(self):
        engine, parser = self.engine, self.parser
        n = 10
        df = DataFrame(randn(n, 3))
        df['dates1'] = date_range('1/1/2012', periods=n)
        df['dates2'] = date_range('1/1/2013', periods=n)
        df['dates3'] = date_range('1/1/2014', periods=n)
        df.loc[np.random.rand(n) > 0.5, 'dates1'] = pd.NaT
        df.loc[np.random.rand(n) > 0.5, 'dates3'] = pd.NaT
        res = df.query('(dates1 < 20130101) & (20130101 < dates3)',
                       engine=engine, parser=parser)
        expec = df[(df.dates1 < '20130101') & ('20130101' < df.dates3)]
        assert_frame_equal(res, expec)

</source>
</class>

<class classid="78" nclones="4" nlines="13" similarity="71">
<source file="pandas/pandas/tests/frame/test_query_eval.py.pyindent" startline="419" endline="430" pcid="4411">
    def test_date_index_query(self):
        engine, parser = self.engine, self.parser
        n = 10
        df = DataFrame(randn(n, 3))
        df['dates1'] = date_range('1/1/2012', periods=n)
        df['dates3'] = date_range('1/1/2014', periods=n)
        df.set_index('dates1', inplace=True, drop=True)
        res = df.query('index < 20130101 < dates3', engine=engine,
                       parser=parser)
        expec = df[(df.index < '20130101') & ('20130101' < df.dates3)]
        assert_frame_equal(res, expec)

</source>
<source file="pandas/pandas/tests/frame/test_query_eval.py.pyindent" startline="739" endline="750" pcid="4434">
    def test_date_index_query(self):
        engine, parser = self.engine, self.parser
        n = 10
        df = DataFrame(randn(n, 3))
        df['dates1'] = date_range('1/1/2012', periods=n)
        df['dates3'] = date_range('1/1/2014', periods=n)
        df.set_index('dates1', inplace=True, drop=True)
        res = df.query('(index < 20130101) & (20130101 < dates3)',
                       engine=engine, parser=parser)
        expec = df[(df.index < '20130101') & ('20130101' < df.dates3)]
        assert_frame_equal(res, expec)

</source>
<source file="pandas/pandas/tests/frame/test_query_eval.py.pyindent" startline="431" endline="443" pcid="4412">
    def test_date_index_query_with_NaT(self):
        engine, parser = self.engine, self.parser
        n = 10
        df = DataFrame(randn(n, 3))
        df['dates1'] = date_range('1/1/2012', periods=n)
        df['dates3'] = date_range('1/1/2014', periods=n)
        df.iloc[0, 0] = pd.NaT
        df.set_index('dates1', inplace=True, drop=True)
        res = df.query('index < 20130101 < dates3', engine=engine,
                       parser=parser)
        expec = df[(df.index < '20130101') & ('20130101' < df.dates3)]
        assert_frame_equal(res, expec)

</source>
<source file="pandas/pandas/tests/frame/test_query_eval.py.pyindent" startline="751" endline="763" pcid="4435">
    def test_date_index_query_with_NaT(self):
        engine, parser = self.engine, self.parser
        n = 10
        df = DataFrame(randn(n, 3))
        df['dates1'] = date_range('1/1/2012', periods=n)
        df['dates3'] = date_range('1/1/2014', periods=n)
        df.iloc[0, 0] = pd.NaT
        df.set_index('dates1', inplace=True, drop=True)
        res = df.query('(index < 20130101) & (20130101 < dates3)',
                       engine=engine, parser=parser)
        expec = df[(df.index < '20130101') & ('20130101' < df.dates3)]
        assert_frame_equal(res, expec)

</source>
</class>

<class classid="79" nclones="2" nlines="10" similarity="100">
<source file="pandas/pandas/tests/frame/test_query_eval.py.pyindent" startline="814" endline="825" pcid="4439">
    def test_query_builtin(self):
        engine, parser = self.engine, self.parser

        n = m = 10
        df = DataFrame(np.random.randint(m, size=(n, 3)), columns=list('abc'))

        df.index.name = 'sin'
        expected = df[df.index > 5]
        result = df.query('sin > 5', engine=engine, parser=parser)
        assert_frame_equal(expected, result)


</source>
<source file="pandas/pandas/tests/frame/test_query_eval.py.pyindent" startline="834" endline="845" pcid="4441">
    def test_query_builtin(self):
        engine, parser = self.engine, self.parser

        n = m = 10
        df = DataFrame(np.random.randint(m, size=(n, 3)), columns=list('abc'))

        df.index.name = 'sin'
        expected = df[df.index > 5]
        result = df.query('sin > 5', engine=engine, parser=parser)
        assert_frame_equal(expected, result)


</source>
</class>

<class classid="80" nclones="2" nlines="35" similarity="75">
<source file="pandas/pandas/tests/frame/test_replace.py.pyindent" startline="234" endline="275" pcid="4459">
    def test_regex_replace_list_obj(self):
        obj = {'a': list('ab..'), 'b': list('efgh'), 'c': list('helo')}
        dfobj = DataFrame(obj)

        # lists of regexes and values
        # list of [re1, re2, ..., reN] -> [v1, v2, ..., vN]
        to_replace_res = [r'\s*\.\s*', r'e|f|g']
        values = [nan, 'crap']
        res = dfobj.replace(to_replace_res, values, regex=True)
        expec = DataFrame({'a': ['a', 'b', nan, nan], 'b': ['crap'] * 3 +
                           ['h'], 'c': ['h', 'crap', 'l', 'o']})
        assert_frame_equal(res, expec)

        # list of [re1, re2, ..., reN] -> [re1, re2, .., reN]
        to_replace_res = [r'\s*(\.)\s*', r'(e|f|g)']
        values = [r'\1\1', r'\1_crap']
        res = dfobj.replace(to_replace_res, values, regex=True)
        expec = DataFrame({'a': ['a', 'b', '..', '..'], 'b': ['e_crap',
                                                              'f_crap',
                                                              'g_crap', 'h'],
                           'c': ['h', 'e_crap', 'l', 'o']})

        assert_frame_equal(res, expec)

        # list of [re1, re2, ..., reN] -> [(re1 or v1), (re2 or v2), ..., (reN
        # or vN)]
        to_replace_res = [r'\s*(\.)\s*', r'e']
        values = [r'\1\1', r'crap']
        res = dfobj.replace(to_replace_res, values, regex=True)
        expec = DataFrame({'a': ['a', 'b', '..', '..'], 'b': ['crap', 'f', 'g',
                                                              'h'],
                           'c': ['h', 'crap', 'l', 'o']})
        assert_frame_equal(res, expec)

        to_replace_res = [r'\s*(\.)\s*', r'e']
        values = [r'\1\1', r'crap']
        res = dfobj.replace(value=values, regex=to_replace_res)
        expec = DataFrame({'a': ['a', 'b', '..', '..'], 'b': ['crap', 'f', 'g',
                                                              'h'],
                           'c': ['h', 'crap', 'l', 'o']})
        assert_frame_equal(res, expec)

</source>
<source file="pandas/pandas/tests/frame/test_replace.py.pyindent" startline="276" endline="323" pcid="4460">
    def test_regex_replace_list_obj_inplace(self):
        # same as above with inplace=True
        # lists of regexes and values
        obj = {'a': list('ab..'), 'b': list('efgh'), 'c': list('helo')}
        dfobj = DataFrame(obj)

        # lists of regexes and values
        # list of [re1, re2, ..., reN] -> [v1, v2, ..., vN]
        to_replace_res = [r'\s*\.\s*', r'e|f|g']
        values = [nan, 'crap']
        res = dfobj.copy()
        res.replace(to_replace_res, values, inplace=True, regex=True)
        expec = DataFrame({'a': ['a', 'b', nan, nan], 'b': ['crap'] * 3 +
                           ['h'], 'c': ['h', 'crap', 'l', 'o']})
        assert_frame_equal(res, expec)

        # list of [re1, re2, ..., reN] -> [re1, re2, .., reN]
        to_replace_res = [r'\s*(\.)\s*', r'(e|f|g)']
        values = [r'\1\1', r'\1_crap']
        res = dfobj.copy()
        res.replace(to_replace_res, values, inplace=True, regex=True)
        expec = DataFrame({'a': ['a', 'b', '..', '..'], 'b': ['e_crap',
                                                              'f_crap',
                                                              'g_crap', 'h'],
                           'c': ['h', 'e_crap', 'l', 'o']})

        assert_frame_equal(res, expec)

        # list of [re1, re2, ..., reN] -> [(re1 or v1), (re2 or v2), ..., (reN
        # or vN)]
        to_replace_res = [r'\s*(\.)\s*', r'e']
        values = [r'\1\1', r'crap']
        res = dfobj.copy()
        res.replace(to_replace_res, values, inplace=True, regex=True)
        expec = DataFrame({'a': ['a', 'b', '..', '..'], 'b': ['crap', 'f', 'g',
                                                              'h'],
                           'c': ['h', 'crap', 'l', 'o']})
        assert_frame_equal(res, expec)

        to_replace_res = [r'\s*(\.)\s*', r'e']
        values = [r'\1\1', r'crap']
        res = dfobj.copy()
        res.replace(value=values, regex=to_replace_res, inplace=True)
        expec = DataFrame({'a': ['a', 'b', '..', '..'], 'b': ['crap', 'f', 'g',
                                                              'h'],
                           'c': ['h', 'crap', 'l', 'o']})
        assert_frame_equal(res, expec)

</source>
</class>

<class classid="81" nclones="2" nlines="10" similarity="70">
<source file="pandas/pandas/tests/frame/test_replace.py.pyindent" startline="868" endline="876" pcid="4486">
    def test_replace_dict_no_regex(self):
        answer = Series({0: 'Strongly Agree', 1: 'Agree', 2: 'Neutral', 3:
                         'Disagree', 4: 'Strongly Disagree'})
        weights = {'Agree': 4, 'Disagree': 2, 'Neutral': 3, 'Strongly Agree':
                   5, 'Strongly Disagree': 1}
        expected = Series({0: 5, 1: 4, 2: 3, 3: 2, 4: 1})
        result = answer.replace(weights)
        assert_series_equal(result, expected)

</source>
<source file="pandas/pandas/tests/frame/test_replace.py.pyindent" startline="877" endline="885" pcid="4487">
    def test_replace_series_no_regex(self):
        answer = Series({0: 'Strongly Agree', 1: 'Agree', 2: 'Neutral', 3:
                         'Disagree', 4: 'Strongly Disagree'})
        weights = Series({'Agree': 4, 'Disagree': 2, 'Neutral': 3,
                          'Strongly Agree': 5, 'Strongly Disagree': 1})
        expected = Series({0: 5, 1: 4, 2: 3, 3: 2, 4: 1})
        result = answer.replace(weights)
        assert_series_equal(result, expected)

</source>
</class>

<class classid="82" nclones="4" nlines="12" similarity="75">
<source file="pandas/pandas/tests/frame/test_repr_info.py.pyindent" startline="144" endline="151" pcid="4511">
    def test_unicode_string_with_unicode(self):
        df = DataFrame({'A': [u("\u05d0")]})

        if compat.PY3:
            str(df)
        else:
            compat.text_type(df)

</source>
<source file="pandas/pandas/tests/series/test_repr.py.pyindent" startline="159" endline="165" pcid="8545">
    def test_unicode_string_with_unicode(self):
        df = Series([u("\u05d0")], name=u("\u05d1"))
        if compat.PY3:
            str(df)
        else:
            compat.text_type(df)

</source>
<source file="pandas/pandas/tests/frame/test_repr_info.py.pyindent" startline="152" endline="158" pcid="4512">
    def test_bytestring_with_unicode(self):
        df = DataFrame({'A': [u("\u05d0")]})
        if compat.PY3:
            bytes(df)
        else:
            str(df)

</source>
<source file="pandas/pandas/tests/series/test_repr.py.pyindent" startline="166" endline="172" pcid="8546">
    def test_bytestring_with_unicode(self):
        df = Series([u("\u05d0")], name=u("\u05d1"))
        if compat.PY3:
            bytes(df)
        else:
            str(df)

</source>
</class>

<class classid="83" nclones="2" nlines="11" similarity="72">
<source file="pandas/pandas/tests/frame/test_repr_info.py.pyindent" startline="398" endline="408" pcid="4524">
    def test_info_memory_usage_deep_not_pypy(self):
        df_with_object_index = pd.DataFrame({'a': [1]}, index=['foo'])
        assert (df_with_object_index.memory_usage(
                index=True, deep=True).sum() >
                df_with_object_index.memory_usage(
                    index=True).sum())

        df_object = pd.DataFrame({'a': ['a']})
        assert (df_object.memory_usage(deep=True).sum() >
                df_object.memory_usage().sum())

</source>
<source file="pandas/pandas/tests/frame/test_repr_info.py.pyindent" startline="411" endline="421" pcid="4525">
    def test_info_memory_usage_deep_pypy(self):
        df_with_object_index = pd.DataFrame({'a': [1]}, index=['foo'])
        assert (df_with_object_index.memory_usage(
                index=True, deep=True).sum() ==
                df_with_object_index.memory_usage(
                    index=True).sum())

        df_object = pd.DataFrame({'a': ['a']})
        assert (df_object.memory_usage(deep=True).sum() ==
                df_object.memory_usage().sum())

</source>
</class>

<class classid="84" nclones="2" nlines="34" similarity="73">
<source file="pandas/pandas/tests/frame/test_subclass.py.pyindent" startline="379" endline="417" pcid="4614">
    def test_subclass_unstack_multi(self):
        # GH 15564
        df = tm.SubclassedDataFrame([
            [10, 11, 12, 13],
            [20, 21, 22, 23],
            [30, 31, 32, 33],
            [40, 41, 42, 43]],
            index=MultiIndex.from_tuples(
                list(zip(list('AABB'), list('cdcd'))),
                names=['aaa', 'ccc']),
            columns=MultiIndex.from_tuples(
                list(zip(list('WWXX'), list('yzyz'))),
                names=['www', 'yyy']))

        exp = tm.SubclassedDataFrame([
            [10, 20, 11, 21, 12, 22, 13, 23],
            [30, 40, 31, 41, 32, 42, 33, 43]],
            index=Index(['A', 'B'], name='aaa'),
            columns=MultiIndex.from_tuples(list(zip(
                list('WWWWXXXX'), list('yyzzyyzz'), list('cdcdcdcd'))),
            names=['www', 'yyy', 'ccc']))

        res = df.unstack()
        tm.assert_frame_equal(res, exp)

        res = df.unstack('ccc')
        tm.assert_frame_equal(res, exp)

        exp = tm.SubclassedDataFrame([
            [10, 30, 11, 31, 12, 32, 13, 33],
            [20, 40, 21, 41, 22, 42, 23, 43]],
            index=Index(['c', 'd'], name='ccc'),
            columns=MultiIndex.from_tuples(list(zip(
                list('WWWWXXXX'), list('yyzzyyzz'), list('ABABABAB'))),
                names=['www', 'yyy', 'aaa']))

        res = df.unstack('aaa')
        tm.assert_frame_equal(res, exp)

</source>
<source file="pandas/pandas/tests/frame/test_subclass.py.pyindent" startline="418" endline="456" pcid="4615">
    def test_subclass_unstack_multi_mixed(self):
        # GH 15564
        df = tm.SubclassedDataFrame([
            [10, 11, 12.0, 13.0],
            [20, 21, 22.0, 23.0],
            [30, 31, 32.0, 33.0],
            [40, 41, 42.0, 43.0]],
            index=MultiIndex.from_tuples(
                list(zip(list('AABB'), list('cdcd'))),
                names=['aaa', 'ccc']),
            columns=MultiIndex.from_tuples(
                list(zip(list('WWXX'), list('yzyz'))),
                names=['www', 'yyy']))

        exp = tm.SubclassedDataFrame([
            [10, 20, 11, 21, 12.0, 22.0, 13.0, 23.0],
            [30, 40, 31, 41, 32.0, 42.0, 33.0, 43.0]],
            index=Index(['A', 'B'], name='aaa'),
            columns=MultiIndex.from_tuples(list(zip(
                list('WWWWXXXX'), list('yyzzyyzz'), list('cdcdcdcd'))),
            names=['www', 'yyy', 'ccc']))

        res = df.unstack()
        tm.assert_frame_equal(res, exp)

        res = df.unstack('ccc')
        tm.assert_frame_equal(res, exp)

        exp = tm.SubclassedDataFrame([
            [10, 30, 11, 31, 12.0, 32.0, 13.0, 33.0],
            [20, 40, 21, 41, 22.0, 42.0, 23.0, 43.0]],
            index=Index(['c', 'd'], name='ccc'),
            columns=MultiIndex.from_tuples(list(zip(
                list('WWWWXXXX'), list('yyzzyyzz'), list('ABABABAB'))),
                names=['www', 'yyy', 'aaa']))

        res = df.unstack('aaa')
        tm.assert_frame_equal(res, exp)

</source>
</class>

<class classid="85" nclones="2" nlines="17" similarity="70">
<source file="pandas/pandas/tests/frame/test_timeseries.py.pyindent" startline="555" endline="574" pcid="4650">
    def test_first_subset(self):
        ts = tm.makeTimeDataFrame(freq='12h')
        result = ts.first('10d')
        assert len(result) == 20

        ts = tm.makeTimeDataFrame(freq='D')
        result = ts.first('10d')
        assert len(result) == 10

        result = ts.first('3M')
        expected = ts[:'3/31/2000']
        assert_frame_equal(result, expected)

        result = ts.first('21D')
        expected = ts[:21]
        assert_frame_equal(result, expected)

        result = ts[:0].first('3M')
        assert_frame_equal(result, ts[:0])

</source>
<source file="pandas/pandas/tests/series/test_timeseries.py.pyindent" startline="616" endline="635" pcid="8602">
    def test_first_subset(self):
        ts = _simple_ts('1/1/2000', '1/1/2010', freq='12h')
        result = ts.first('10d')
        assert len(result) == 20

        ts = _simple_ts('1/1/2000', '1/1/2010')
        result = ts.first('10d')
        assert len(result) == 10

        result = ts.first('3M')
        expected = ts[:'3/31/2000']
        assert_series_equal(result, expected)

        result = ts.first('21D')
        expected = ts[:21]
        assert_series_equal(result, expected)

        result = ts[:0].first('3M')
        assert_series_equal(result, ts[:0])

</source>
</class>

<class classid="86" nclones="2" nlines="84" similarity="96">
<source file="pandas/pandas/tests/frame/test_timeseries.py.pyindent" startline="643" endline="702" pcid="4656">
    def test_between_time(self):
        rng = date_range('1/1/2000', '1/5/2000', freq='5min')
        ts = DataFrame(np.random.randn(len(rng), 2), index=rng)
        stime = time(0, 0)
        etime = time(1, 0)

        close_open = product([True, False], [True, False])
        for inc_start, inc_end in close_open:
            filtered = ts.between_time(stime, etime, inc_start, inc_end)
            exp_len = 13 * 4 + 1
            if not inc_start:
                exp_len -= 5
            if not inc_end:
                exp_len -= 4

            assert len(filtered) == exp_len
            for rs in filtered.index:
                t = rs.time()
                if inc_start:
                    assert t >= stime
                else:
                    assert t > stime

                if inc_end:
                    assert t <= etime
                else:
                    assert t < etime

        result = ts.between_time('00:00', '01:00')
        expected = ts.between_time(stime, etime)
        assert_frame_equal(result, expected)

        # across midnight
        rng = date_range('1/1/2000', '1/5/2000', freq='5min')
        ts = DataFrame(np.random.randn(len(rng), 2), index=rng)
        stime = time(22, 0)
        etime = time(9, 0)

        close_open = product([True, False], [True, False])
        for inc_start, inc_end in close_open:
            filtered = ts.between_time(stime, etime, inc_start, inc_end)
            exp_len = (12 * 11 + 1) * 4 + 1
            if not inc_start:
                exp_len -= 4
            if not inc_end:
                exp_len -= 4

            assert len(filtered) == exp_len
            for rs in filtered.index:
                t = rs.time()
                if inc_start:
                    assert (t >= stime) or (t <= etime)
                else:
                    assert (t > stime) or (t <= etime)

                if inc_end:
                    assert (t <= etime) or (t >= stime)
                else:
                    assert (t < etime) or (t >= stime)

</source>
<source file="pandas/pandas/tests/series/test_timeseries.py.pyindent" startline="730" endline="789" pcid="8610">
    def test_between_time(self):
        rng = date_range('1/1/2000', '1/5/2000', freq='5min')
        ts = Series(np.random.randn(len(rng)), index=rng)
        stime = time(0, 0)
        etime = time(1, 0)

        close_open = product([True, False], [True, False])
        for inc_start, inc_end in close_open:
            filtered = ts.between_time(stime, etime, inc_start, inc_end)
            exp_len = 13 * 4 + 1
            if not inc_start:
                exp_len -= 5
            if not inc_end:
                exp_len -= 4

            assert len(filtered) == exp_len
            for rs in filtered.index:
                t = rs.time()
                if inc_start:
                    assert t >= stime
                else:
                    assert t > stime

                if inc_end:
                    assert t <= etime
                else:
                    assert t < etime

        result = ts.between_time('00:00', '01:00')
        expected = ts.between_time(stime, etime)
        assert_series_equal(result, expected)

        # across midnight
        rng = date_range('1/1/2000', '1/5/2000', freq='5min')
        ts = Series(np.random.randn(len(rng)), index=rng)
        stime = time(22, 0)
        etime = time(9, 0)

        close_open = product([True, False], [True, False])
        for inc_start, inc_end in close_open:
            filtered = ts.between_time(stime, etime, inc_start, inc_end)
            exp_len = (12 * 11 + 1) * 4 + 1
            if not inc_start:
                exp_len -= 4
            if not inc_end:
                exp_len -= 4

            assert len(filtered) == exp_len
            for rs in filtered.index:
                t = rs.time()
                if inc_start:
                    assert (t >= stime) or (t <= etime)
                else:
                    assert (t > stime) or (t <= etime)

                if inc_end:
                    assert (t <= etime) or (t >= stime)
                else:
                    assert (t < etime) or (t >= stime)

</source>
</class>

<class classid="87" nclones="2" nlines="14" similarity="71">
<source file="pandas/pandas/tests/frame/test_to_csv.py.pyindent" startline="411" endline="426" pcid="4686">
    def test_to_csv_from_csv_w_some_infs(self):

        # test roundtrip with inf, -inf, nan, as full columns and mix
        self.frame['G'] = np.nan
        f = lambda x: [np.inf, np.nan][np.random.rand() < .5]
        self.frame['H'] = self.frame.index.map(f)

        with ensure_clean() as path:
            self.frame.to_csv(path)
            recons = self.read_csv(path)

            # TODO to_csv drops column name
            assert_frame_equal(self.frame, recons, check_names=False)
            assert_frame_equal(np.isinf(self.frame),
                               np.isinf(recons), check_names=False)

</source>
<source file="pandas/pandas/tests/frame/test_to_csv.py.pyindent" startline="427" endline="441" pcid="4687">
    def test_to_csv_from_csv_w_all_infs(self):

        # test roundtrip with inf, -inf, nan, as full columns and mix
        self.frame['E'] = np.inf
        self.frame['F'] = -np.inf

        with ensure_clean() as path:
            self.frame.to_csv(path)
            recons = self.read_csv(path)

            # TODO to_csv drops column name
            assert_frame_equal(self.frame, recons, check_names=False)
            assert_frame_equal(np.isinf(self.frame),
                               np.isinf(recons), check_names=False)

</source>
</class>

<class classid="88" nclones="3" nlines="18" similarity="72">
<source file="pandas/pandas/tests/generic/test_frame.py.pyindent" startline="120" endline="132" pcid="4725">
        def finalize(self, other, method=None, **kwargs):

            for name in self._metadata:
                if method == 'merge':
                    left, right = other.left, other.right
                    value = getattr(left, name, '') + '|' + getattr(right,
                                                                    name, '')
                    object.__setattr__(self, name, value)
                else:
                    object.__setattr__(self, name, getattr(other, name, ''))

            return self

</source>
<source file="pandas/pandas/tests/generic/test_series.py.pyindent" startline="154" endline="165" pcid="4742">
        def finalize(self, other, method=None, **kwargs):
            for name in self._metadata:
                if method == 'concat' and name == 'filename':
                    value = '+'.join([getattr(
                        o, name) for o in other.objs if getattr(o, name, None)
                    ])
                    object.__setattr__(self, name, value)
                else:
                    object.__setattr__(self, name, getattr(other, name, None))

            return self

</source>
<source file="pandas/pandas/tests/generic/test_frame.py.pyindent" startline="143" endline="154" pcid="4726">
        def finalize(self, other, method=None, **kwargs):
            for name in self._metadata:
                if method == 'concat':
                    value = '+'.join([getattr(
                        o, name) for o in other.objs if getattr(o, name, None)
                    ])
                    object.__setattr__(self, name, value)
                else:
                    object.__setattr__(self, name, getattr(other, name, None))

            return self

</source>
</class>

<class classid="89" nclones="2" nlines="11" similarity="72">
<source file="pandas/pandas/tests/groupby/test_apply.py.pyindent" startline="47" endline="60" pcid="4812">
def test_apply_trivial():
    # GH 20066
    # trivial apply: ignore input and return a constant dataframe.
    df = pd.DataFrame({'key': ['a', 'a', 'b', 'b', 'a'],
                       'data': [1.0, 2.0, 3.0, 4.0, 5.0]},
                      columns=['key', 'data'])
    expected = pd.concat([df.iloc[1:], df.iloc[1:]],
                         axis=1, keys=['float64', 'object'])
    result = df.groupby([str(x) for x in df.dtypes],
                        axis=1).apply(lambda x: df.iloc[1:])

    tm.assert_frame_equal(result, expected)


</source>
<source file="pandas/pandas/tests/groupby/test_apply.py.pyindent" startline="65" endline="79" pcid="4813">
def test_apply_trivial_fail():
    # GH 20066
    # trivial apply fails if the constant dataframe has the same index
    # with the one used to create GroupBy object.
    df = pd.DataFrame({'key': ['a', 'a', 'b', 'b', 'a'],
                       'data': [1.0, 2.0, 3.0, 4.0, 5.0]},
                      columns=['key', 'data'])
    expected = pd.concat([df, df],
                         axis=1, keys=['float64', 'object'])
    result = df.groupby([str(x) for x in df.dtypes],
                        axis=1).apply(lambda x: df)

    tm.assert_frame_equal(result, expected)


</source>
</class>

<class classid="90" nclones="2" nlines="17" similarity="76">
<source file="pandas/pandas/tests/groupby/test_apply.py.pyindent" startline="289" endline="307" pcid="4835">
def test_apply_typecast_fail():
    df = DataFrame({'d': [1., 1., 1., 2., 2., 2.],
                    'c': np.tile(
                        ['a', 'b', 'c'], 2),
                    'v': np.arange(1., 7.)})

    def f(group):
        v = group['v']
        group['v2'] = (v - v.min()) / (v.max() - v.min())
        return group

    result = df.groupby('d').apply(f)

    expected = df.copy()
    expected['v2'] = np.tile([0., 0.5, 1], 2)

    tm.assert_frame_equal(result, expected)


</source>
<source file="pandas/pandas/tests/groupby/test_apply.py.pyindent" startline="308" endline="327" pcid="4837">
def test_apply_multiindex_fail():
    index = MultiIndex.from_arrays([[0, 0, 0, 1, 1, 1], [1, 2, 3, 1, 2, 3]
                                    ])
    df = DataFrame({'d': [1., 1., 1., 2., 2., 2.],
                    'c': np.tile(['a', 'b', 'c'], 2),
                    'v': np.arange(1., 7.)}, index=index)

    def f(group):
        v = group['v']
        group['v2'] = (v - v.min()) / (v.max() - v.min())
        return group

    result = df.groupby('d').apply(f)

    expected = df.copy()
    expected['v2'] = np.tile([0., 0.5, 1], 2)

    tm.assert_frame_equal(result, expected)


</source>
</class>

<class classid="91" nclones="2" nlines="11" similarity="81">
<source file="pandas/pandas/tests/groupby/test_apply.py.pyindent" startline="342" endline="347" pcid="4841">
    def filt1(x):
        if x.shape[0] == 1:
            return x.copy()
        else:
            return x[x.category == 'c']

</source>
<source file="pandas/pandas/tests/groupby/test_apply.py.pyindent" startline="348" endline="353" pcid="4842">
    def filt2(x):
        if x.shape[0] == 1:
            return x
        else:
            return x[x.category == 'c']

</source>
</class>

<class classid="92" nclones="2" nlines="10" similarity="80">
<source file="pandas/pandas/tests/groupby/test_counting.py.pyindent" startline="35" endline="45" pcid="4897">
    def test_cumcount_dupe_index(self):
        df = DataFrame([['a'], ['a'], ['a'], ['b'], ['a']], columns=['A'],
                       index=[0] * 5)
        g = df.groupby('A')
        sg = g.A

        expected = Series([0, 1, 2, 0, 3], index=[0] * 5)

        assert_series_equal(expected, g.cumcount())
        assert_series_equal(expected, sg.cumcount())

</source>
<source file="pandas/pandas/tests/groupby/test_counting.py.pyindent" startline="58" endline="68" pcid="4899">
    def test_cumcount_groupby_not_col(self):
        df = DataFrame([['a'], ['a'], ['a'], ['b'], ['a']], columns=['A'],
                       index=[0] * 5)
        g = df.groupby([0, 0, 0, 1, 0])
        sg = g.A

        expected = Series([0, 1, 2, 0, 3], index=[0] * 5)

        assert_series_equal(expected, g.cumcount())
        assert_series_equal(expected, sg.cumcount())

</source>
</class>

<class classid="93" nclones="5" nlines="29" similarity="84">
<source file="pandas/pandas/tests/groupby/test_filters.py.pyindent" startline="319" endline="359" pcid="4930">
def test_filter_and_transform_with_non_unique_int_index():
    # GH4620
    index = [1, 1, 1, 2, 1, 1, 0, 1]
    df = DataFrame({'pid': [1, 1, 1, 2, 2, 3, 3, 3],
                    'tag': [23, 45, 62, 24, 45, 34, 25, 62]}, index=index)
    grouped_df = df.groupby('tag')
    ser = df['pid']
    grouped_ser = ser.groupby(df['tag'])
    expected_indexes = [1, 2, 4, 7]

    # Filter DataFrame
    actual = grouped_df.filter(lambda x: len(x) > 1)
    expected = df.iloc[expected_indexes]
    tm.assert_frame_equal(actual, expected)

    actual = grouped_df.filter(lambda x: len(x) > 1, dropna=False)
    expected = df.copy()
    expected.iloc[[0, 3, 5, 6]] = np.nan
    tm.assert_frame_equal(actual, expected)

    # Filter Series
    actual = grouped_ser.filter(lambda x: len(x) > 1)
    expected = ser.take(expected_indexes)
    tm.assert_series_equal(actual, expected)

    actual = grouped_ser.filter(lambda x: len(x) > 1, dropna=False)
    NA = np.nan
    expected = Series([NA, 1, 1, NA, 2, NA, NA, 3], index, name='pid')
    # ^ made manually because this can get confusing!
    tm.assert_series_equal(actual, expected)

    # Transform Series
    actual = grouped_ser.transform(len)
    expected = Series([1, 2, 2, 1, 2, 1, 1, 2], index, name='pid')
    tm.assert_series_equal(actual, expected)

    # Transform (a column from) DataFrameGroupBy
    actual = grouped_df.pid.transform(len)
    tm.assert_series_equal(actual, expected)


</source>
<source file="pandas/pandas/tests/groupby/test_filters.py.pyindent" startline="442" endline="485" pcid="4933">
def test_filter_and_transform_with_non_unique_timestamp_index():
    # GH4620
    t0 = Timestamp('2013-09-30 00:05:00')
    t1 = Timestamp('2013-10-30 00:05:00')
    t2 = Timestamp('2013-11-30 00:05:00')
    index = [t1, t1, t1, t2, t1, t1, t0, t1]
    df = DataFrame({'pid': [1, 1, 1, 2, 2, 3, 3, 3],
                    'tag': [23, 45, 62, 24, 45, 34, 25, 62]}, index=index)
    grouped_df = df.groupby('tag')
    ser = df['pid']
    grouped_ser = ser.groupby(df['tag'])
    expected_indexes = [1, 2, 4, 7]

    # Filter DataFrame
    actual = grouped_df.filter(lambda x: len(x) > 1)
    expected = df.iloc[expected_indexes]
    tm.assert_frame_equal(actual, expected)

    actual = grouped_df.filter(lambda x: len(x) > 1, dropna=False)
    expected = df.copy()
    expected.iloc[[0, 3, 5, 6]] = np.nan
    tm.assert_frame_equal(actual, expected)

    # Filter Series
    actual = grouped_ser.filter(lambda x: len(x) > 1)
    expected = ser.take(expected_indexes)
    tm.assert_series_equal(actual, expected)

    actual = grouped_ser.filter(lambda x: len(x) > 1, dropna=False)
    NA = np.nan
    expected = Series([NA, 1, 1, NA, 2, NA, NA, 3], index, name='pid')
    # ^ made manually because this can get confusing!
    tm.assert_series_equal(actual, expected)

    # Transform Series
    actual = grouped_ser.transform(len)
    expected = Series([1, 2, 2, 1, 2, 1, 1, 2], index, name='pid')
    tm.assert_series_equal(actual, expected)

    # Transform (a column from) DataFrameGroupBy
    actual = grouped_df.pid.transform(len)
    tm.assert_series_equal(actual, expected)


</source>
<source file="pandas/pandas/tests/groupby/test_filters.py.pyindent" startline="486" endline="526" pcid="4934">
def test_filter_and_transform_with_non_unique_string_index():
    # GH4620
    index = list('bbbcbbab')
    df = DataFrame({'pid': [1, 1, 1, 2, 2, 3, 3, 3],
                    'tag': [23, 45, 62, 24, 45, 34, 25, 62]}, index=index)
    grouped_df = df.groupby('tag')
    ser = df['pid']
    grouped_ser = ser.groupby(df['tag'])
    expected_indexes = [1, 2, 4, 7]

    # Filter DataFrame
    actual = grouped_df.filter(lambda x: len(x) > 1)
    expected = df.iloc[expected_indexes]
    tm.assert_frame_equal(actual, expected)

    actual = grouped_df.filter(lambda x: len(x) > 1, dropna=False)
    expected = df.copy()
    expected.iloc[[0, 3, 5, 6]] = np.nan
    tm.assert_frame_equal(actual, expected)

    # Filter Series
    actual = grouped_ser.filter(lambda x: len(x) > 1)
    expected = ser.take(expected_indexes)
    tm.assert_series_equal(actual, expected)

    actual = grouped_ser.filter(lambda x: len(x) > 1, dropna=False)
    NA = np.nan
    expected = Series([NA, 1, 1, NA, 2, NA, NA, 3], index, name='pid')
    # ^ made manually because this can get confusing!
    tm.assert_series_equal(actual, expected)

    # Transform Series
    actual = grouped_ser.transform(len)
    expected = Series([1, 2, 2, 1, 2, 1, 1, 2], index, name='pid')
    tm.assert_series_equal(actual, expected)

    # Transform (a column from) DataFrameGroupBy
    actual = grouped_df.pid.transform(len)
    tm.assert_series_equal(actual, expected)


</source>
<source file="pandas/pandas/tests/groupby/test_filters.py.pyindent" startline="401" endline="441" pcid="4932">
def test_filter_and_transform_with_non_unique_float_index():
    # GH4620
    index = np.array([1, 1, 1, 2, 1, 1, 0, 1], dtype=float)
    df = DataFrame({'pid': [1, 1, 1, 2, 2, 3, 3, 3],
                    'tag': [23, 45, 62, 24, 45, 34, 25, 62]}, index=index)
    grouped_df = df.groupby('tag')
    ser = df['pid']
    grouped_ser = ser.groupby(df['tag'])
    expected_indexes = [1, 2, 4, 7]

    # Filter DataFrame
    actual = grouped_df.filter(lambda x: len(x) > 1)
    expected = df.iloc[expected_indexes]
    tm.assert_frame_equal(actual, expected)

    actual = grouped_df.filter(lambda x: len(x) > 1, dropna=False)
    expected = df.copy()
    expected.iloc[[0, 3, 5, 6]] = np.nan
    tm.assert_frame_equal(actual, expected)

    # Filter Series
    actual = grouped_ser.filter(lambda x: len(x) > 1)
    expected = ser.take(expected_indexes)
    tm.assert_series_equal(actual, expected)

    actual = grouped_ser.filter(lambda x: len(x) > 1, dropna=False)
    NA = np.nan
    expected = Series([NA, 1, 1, NA, 2, NA, NA, 3], index, name='pid')
    # ^ made manually because this can get confusing!
    tm.assert_series_equal(actual, expected)

    # Transform Series
    actual = grouped_ser.transform(len)
    expected = Series([1, 2, 2, 1, 2, 1, 1, 2], index, name='pid')
    tm.assert_series_equal(actual, expected)

    # Transform (a column from) DataFrameGroupBy
    actual = grouped_df.pid.transform(len)
    tm.assert_series_equal(actual, expected)


</source>
<source file="pandas/pandas/tests/groupby/test_filters.py.pyindent" startline="360" endline="400" pcid="4931">
def test_filter_and_transform_with_multiple_non_unique_int_index():
    # GH4620
    index = [1, 1, 1, 2, 0, 0, 0, 1]
    df = DataFrame({'pid': [1, 1, 1, 2, 2, 3, 3, 3],
                    'tag': [23, 45, 62, 24, 45, 34, 25, 62]}, index=index)
    grouped_df = df.groupby('tag')
    ser = df['pid']
    grouped_ser = ser.groupby(df['tag'])
    expected_indexes = [1, 2, 4, 7]

    # Filter DataFrame
    actual = grouped_df.filter(lambda x: len(x) > 1)
    expected = df.iloc[expected_indexes]
    tm.assert_frame_equal(actual, expected)

    actual = grouped_df.filter(lambda x: len(x) > 1, dropna=False)
    expected = df.copy()
    expected.iloc[[0, 3, 5, 6]] = np.nan
    tm.assert_frame_equal(actual, expected)

    # Filter Series
    actual = grouped_ser.filter(lambda x: len(x) > 1)
    expected = ser.take(expected_indexes)
    tm.assert_series_equal(actual, expected)

    actual = grouped_ser.filter(lambda x: len(x) > 1, dropna=False)
    NA = np.nan
    expected = Series([NA, 1, 1, NA, 2, NA, NA, 3], index, name='pid')
    # ^ made manually because this can get confusing!
    tm.assert_series_equal(actual, expected)

    # Transform Series
    actual = grouped_ser.transform(len)
    expected = Series([1, 2, 2, 1, 2, 1, 1, 2], index, name='pid')
    tm.assert_series_equal(actual, expected)

    # Transform (a column from) DataFrameGroupBy
    actual = grouped_df.pid.transform(len)
    tm.assert_series_equal(actual, expected)


</source>
</class>

<class classid="94" nclones="3" nlines="11" similarity="72">
<source file="pandas/pandas/tests/groupby/test_rank.py.pyindent" startline="66" endline="76" pcid="5049">
def test_rank_args(grps, vals, ties_method, ascending, pct, exp):
    key = np.repeat(grps, len(vals))
    vals = vals * len(grps)
    df = DataFrame({'key': key, 'val': vals})
    result = df.groupby('key').rank(method=ties_method,
                                    ascending=ascending, pct=pct)

    exp_df = DataFrame(exp * len(grps), columns=['val'])
    tm.assert_frame_equal(result, exp_df)


</source>
<source file="pandas/pandas/tests/groupby/test_rank.py.pyindent" startline="114" endline="125" pcid="5050">
def test_infs_n_nans(grps, vals, ties_method, ascending, na_option, exp):
    # GH 20561
    key = np.repeat(grps, len(vals))
    vals = vals * len(grps)
    df = DataFrame({'key': key, 'val': vals})
    result = df.groupby('key').rank(method=ties_method,
                                    ascending=ascending,
                                    na_option=na_option)
    exp_df = DataFrame(exp * len(grps), columns=['val'])
    tm.assert_frame_equal(result, exp_df)


</source>
<source file="pandas/pandas/tests/groupby/test_rank.py.pyindent" startline="206" endline="218" pcid="5051">
def test_rank_args_missing(grps, vals, ties_method, ascending,
                           na_option, pct, exp):
    key = np.repeat(grps, len(vals))
    vals = vals * len(grps)
    df = DataFrame({'key': key, 'val': vals})
    result = df.groupby('key').rank(method=ties_method,
                                    ascending=ascending,
                                    na_option=na_option, pct=pct)

    exp_df = DataFrame(exp * len(grps), columns=['val'])
    tm.assert_frame_equal(result, exp_df)


</source>
</class>

<class classid="95" nclones="2" nlines="11" similarity="72">
<source file="pandas/pandas/tests/groupby/test_rank.py.pyindent" startline="248" endline="257" pcid="5054">
def test_rank_object_raises(ties_method, ascending, na_option,
                            pct, vals):
    df = DataFrame({'key': ['foo'] * 5, 'val': vals})

    with tm.assert_raises_regex(TypeError, "not callable"):
        df.groupby('key').rank(method=ties_method,
                               ascending=ascending,
                               na_option=na_option, pct=pct)


</source>
<source file="pandas/pandas/tests/groupby/test_rank.py.pyindent" startline="268" endline="275" pcid="5055">
def test_rank_naoption_raises(ties_method, ascending, na_option, pct, vals):
    df = DataFrame({'key': ['foo'] * 5, 'val': vals})
    msg = "na_option must be one of 'keep', 'top', or 'bottom'"

    with tm.assert_raises_regex(ValueError, msg):
        df.groupby('key').rank(method=ties_method,
                               ascending=ascending,
                               na_option=na_option, pct=pct)
</source>
</class>

<class classid="96" nclones="3" nlines="21" similarity="80">
<source file="pandas/pandas/tests/indexes/datetimes/test_astype.py.pyindent" startline="175" endline="191" pcid="5118">
    def test_index_convert_to_datetime_array(self):
        def _check_rng(rng):
            converted = rng.to_pydatetime()
            assert isinstance(converted, np.ndarray)
            for x, stamp in zip(converted, rng):
                assert isinstance(x, datetime)
                assert x == stamp.to_pydatetime()
                assert x.tzinfo == stamp.tzinfo

        rng = date_range('20090415', '20090519')
        rng_eastern = date_range('20090415', '20090519', tz='US/Eastern')
        rng_utc = date_range('20090415', '20090519', tz='utc')

        _check_rng(rng)
        _check_rng(rng_eastern)
        _check_rng(rng_utc)

</source>
<source file="pandas/pandas/tests/indexes/datetimes/test_astype.py.pyindent" startline="192" endline="209" pcid="5120">
    def test_index_convert_to_datetime_array_explicit_pytz(self):
        def _check_rng(rng):
            converted = rng.to_pydatetime()
            assert isinstance(converted, np.ndarray)
            for x, stamp in zip(converted, rng):
                assert isinstance(x, datetime)
                assert x == stamp.to_pydatetime()
                assert x.tzinfo == stamp.tzinfo

        rng = date_range('20090415', '20090519')
        rng_eastern = date_range('20090415', '20090519',
                                 tz=pytz.timezone('US/Eastern'))
        rng_utc = date_range('20090415', '20090519', tz=pytz.utc)

        _check_rng(rng)
        _check_rng(rng_eastern)
        _check_rng(rng_utc)

</source>
<source file="pandas/pandas/tests/indexes/datetimes/test_astype.py.pyindent" startline="210" endline="227" pcid="5122">
    def test_index_convert_to_datetime_array_dateutil(self):
        def _check_rng(rng):
            converted = rng.to_pydatetime()
            assert isinstance(converted, np.ndarray)
            for x, stamp in zip(converted, rng):
                assert isinstance(x, datetime)
                assert x == stamp.to_pydatetime()
                assert x.tzinfo == stamp.tzinfo

        rng = date_range('20090415', '20090519')
        rng_eastern = date_range('20090415', '20090519',
                                 tz='dateutil/US/Eastern')
        rng_utc = date_range('20090415', '20090519', tz=dateutil.tz.tzutc())

        _check_rng(rng)
        _check_rng(rng_eastern)
        _check_rng(rng_utc)

</source>
</class>

<class classid="97" nclones="3" nlines="20" similarity="80">
<source file="pandas/pandas/tests/indexes/datetimes/test_astype.py.pyindent" startline="262" endline="290" pcid="5128">
    def test_to_period_tz_pytz(self):
        from pytz import utc as UTC

        xp = date_range('1/1/2000', '4/1/2000').to_period()

        ts = date_range('1/1/2000', '4/1/2000', tz='US/Eastern')

        result = ts.to_period()[0]
        expected = ts[0].to_period()

        assert result == expected
        tm.assert_index_equal(ts.to_period(), xp)

        ts = date_range('1/1/2000', '4/1/2000', tz=UTC)

        result = ts.to_period()[0]
        expected = ts[0].to_period()

        assert result == expected
        tm.assert_index_equal(ts.to_period(), xp)

        ts = date_range('1/1/2000', '4/1/2000', tz=tzlocal())

        result = ts.to_period()[0]
        expected = ts[0].to_period()

        assert result == expected
        tm.assert_index_equal(ts.to_period(), xp)

</source>
<source file="pandas/pandas/tests/indexes/datetimes/test_astype.py.pyindent" startline="318" endline="344" pcid="5130">
    def test_to_period_tz_dateutil(self):
        xp = date_range('1/1/2000', '4/1/2000').to_period()

        ts = date_range('1/1/2000', '4/1/2000', tz='dateutil/US/Eastern')

        result = ts.to_period()[0]
        expected = ts[0].to_period()

        assert result == expected
        tm.assert_index_equal(ts.to_period(), xp)

        ts = date_range('1/1/2000', '4/1/2000', tz=dateutil.tz.tzutc())

        result = ts.to_period()[0]
        expected = ts[0].to_period()

        assert result == expected
        tm.assert_index_equal(ts.to_period(), xp)

        ts = date_range('1/1/2000', '4/1/2000', tz=tzlocal())

        result = ts.to_period()[0]
        expected = ts[0].to_period()

        assert result == expected
        tm.assert_index_equal(ts.to_period(), xp)

</source>
<source file="pandas/pandas/tests/indexes/datetimes/test_astype.py.pyindent" startline="291" endline="317" pcid="5129">
    def test_to_period_tz_explicit_pytz(self):
        xp = date_range('1/1/2000', '4/1/2000').to_period()

        ts = date_range('1/1/2000', '4/1/2000', tz=pytz.timezone('US/Eastern'))

        result = ts.to_period()[0]
        expected = ts[0].to_period()

        assert result == expected
        tm.assert_index_equal(ts.to_period(), xp)

        ts = date_range('1/1/2000', '4/1/2000', tz=pytz.utc)

        result = ts.to_period()[0]
        expected = ts[0].to_period()

        assert result == expected
        tm.assert_index_equal(ts.to_period(), xp)

        ts = date_range('1/1/2000', '4/1/2000', tz=tzlocal())

        result = ts.to_period()[0]
        expected = ts[0].to_period()

        assert result == expected
        tm.assert_index_equal(ts.to_period(), xp)

</source>
</class>

<class classid="98" nclones="2" nlines="11" similarity="72">
<source file="pandas/pandas/tests/indexes/datetimes/test_datetime.py.pyindent" startline="200" endline="210" pcid="5147">
    def test_get_duplicates(self):
        idx = DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-02',
                             '2000-01-03', '2000-01-03', '2000-01-04'])

        with warnings.catch_warnings(record=True):
            # Deprecated - see GH20239
            result = idx.get_duplicates()

        ex = DatetimeIndex(['2000-01-02', '2000-01-03'])
        tm.assert_index_equal(result, ex)

</source>
<source file="pandas/pandas/tests/indexes/timedeltas/test_timedelta.py.pyindent" startline="146" endline="156" pcid="6188">
    def test_get_duplicates(self):
        idx = TimedeltaIndex(['1 day', '2 day', '2 day', '3 day', '3day',
                              '4day'])

        with warnings.catch_warnings(record=True):
            # Deprecated - see GH20239
            result = idx.get_duplicates()

        ex = TimedeltaIndex(['2 day', '3day'])
        tm.assert_index_equal(result, ex)

</source>
</class>

<class classid="99" nclones="2" nlines="10" similarity="90">
<source file="pandas/pandas/tests/indexes/datetimes/test_datetime.py.pyindent" startline="258" endline="268" pcid="5153">
    def test_isin(self):
        index = tm.makeDateIndex(4)
        result = index.isin(index)
        assert result.all()

        result = index.isin(list(index))
        assert result.all()

        assert_almost_equal(index.isin([index[2], 5]),
                            np.array([False, False, True, False]))

</source>
<source file="pandas/pandas/tests/indexes/timedeltas/test_timedelta.py.pyindent" startline="73" endline="84" pcid="6183">
    def test_isin(self):

        index = tm.makeTimedeltaIndex(4)
        result = index.isin(index)
        assert result.all()

        result = index.isin(list(index))
        assert result.all()

        assert_almost_equal(index.isin([index[2], 5]),
                            np.array([False, False, True, False]))

</source>
</class>

<class classid="100" nclones="2" nlines="12" similarity="75">
<source file="pandas/pandas/tests/indexes/datetimes/test_datetime.py.pyindent" startline="269" endline="278" pcid="5154">
    def test_does_not_convert_mixed_integer(self):
        df = tm.makeCustomDataframe(10, 10,
                                    data_gen_f=lambda *args, **kwargs: randn(),
                                    r_idx_type='i', c_idx_type='dt')
        cols = df.columns.join(df.index, how='outer')
        joined = cols.join(df.columns)
        assert cols.dtype == np.dtype('O')
        assert cols.dtype == joined.dtype
        tm.assert_numpy_array_equal(cols.values, joined.values)

</source>
<source file="pandas/pandas/tests/indexes/timedeltas/test_timedelta.py.pyindent" startline="112" endline="123" pcid="6186">
    def test_does_not_convert_mixed_integer(self):
        df = tm.makeCustomDataframe(10, 10,
                                    data_gen_f=lambda *args, **kwargs: randn(),
                                    r_idx_type='i', c_idx_type='td')
        str(df)

        cols = df.columns.join(df.index, how='outer')
        joined = cols.join(df.columns)
        assert cols.dtype == np.dtype('O')
        assert cols.dtype == joined.dtype
        tm.assert_index_equal(cols, joined)

</source>
</class>

<class classid="101" nclones="2" nlines="11" similarity="72">
<source file="pandas/pandas/tests/indexes/datetimes/test_date_range.py.pyindent" startline="574" endline="581" pcid="5212">
    def test_mismatching_tz_raises_err(self, start, end):
        # issue 18488
        with pytest.raises(TypeError):
            pd.date_range(start, end)
        with pytest.raises(TypeError):
            pd.DatetimeIndex(start, end, freq=BDay())


</source>
<source file="pandas/pandas/tests/indexes/period/test_construction.py.pyindent" startline="290" endline="297" pcid="5765">
    def test_constructor_floats(self, floats):
        # GH#13079
        with pytest.raises(TypeError):
            pd.PeriodIndex._simple_new(floats, freq='M')

        with pytest.raises(TypeError):
            pd.PeriodIndex(floats, freq='M')

</source>
</class>

<class classid="102" nclones="2" nlines="26" similarity="76">
<source file="pandas/pandas/tests/indexes/datetimes/test_formats.py.pyindent" startline="13" endline="53" pcid="5229">
def test_to_native_types():
    index = DatetimeIndex(freq='1D', periods=3, start='2017-01-01')

    # First, with no arguments.
    expected = np.array(['2017-01-01', '2017-01-02',
                         '2017-01-03'], dtype=object)

    result = index.to_native_types()
    tm.assert_numpy_array_equal(result, expected)

    # No NaN values, so na_rep has no effect
    result = index.to_native_types(na_rep='pandas')
    tm.assert_numpy_array_equal(result, expected)

    # Make sure slicing works
    expected = np.array(['2017-01-01', '2017-01-03'], dtype=object)

    result = index.to_native_types([0, 2])
    tm.assert_numpy_array_equal(result, expected)

    # Make sure date formatting works
    expected = np.array(['01-2017-01', '01-2017-02',
                         '01-2017-03'], dtype=object)

    result = index.to_native_types(date_format='%m-%Y-%d')
    tm.assert_numpy_array_equal(result, expected)

    # NULL object handling should work
    index = DatetimeIndex(['2017-01-01', pd.NaT, '2017-01-03'])
    expected = np.array(['2017-01-01', 'NaT', '2017-01-03'], dtype=object)

    result = index.to_native_types()
    tm.assert_numpy_array_equal(result, expected)

    expected = np.array(['2017-01-01', 'pandas',
                         '2017-01-03'], dtype=object)

    result = index.to_native_types(na_rep='pandas')
    tm.assert_numpy_array_equal(result, expected)


</source>
<source file="pandas/pandas/tests/indexes/period/test_formats.py.pyindent" startline="10" endline="51" pcid="5778">
def test_to_native_types():
    index = PeriodIndex(['2017-01-01', '2017-01-02',
                         '2017-01-03'], freq='D')

    # First, with no arguments.
    expected = np.array(['2017-01-01', '2017-01-02',
                         '2017-01-03'], dtype='=U10')

    result = index.to_native_types()
    tm.assert_numpy_array_equal(result, expected)

    # No NaN values, so na_rep has no effect
    result = index.to_native_types(na_rep='pandas')
    tm.assert_numpy_array_equal(result, expected)

    # Make sure slicing works
    expected = np.array(['2017-01-01', '2017-01-03'], dtype='=U10')

    result = index.to_native_types([0, 2])
    tm.assert_numpy_array_equal(result, expected)

    # Make sure date formatting works
    expected = np.array(['01-2017-01', '01-2017-02',
                         '01-2017-03'], dtype='=U10')

    result = index.to_native_types(date_format='%m-%Y-%d')
    tm.assert_numpy_array_equal(result, expected)

    # NULL object handling should work
    index = PeriodIndex(['2017-01-01', pd.NaT, '2017-01-03'], freq='D')
    expected = np.array(['2017-01-01', 'NaT', '2017-01-03'], dtype=object)

    result = index.to_native_types()
    tm.assert_numpy_array_equal(result, expected)

    expected = np.array(['2017-01-01', 'pandas',
                         '2017-01-03'], dtype=object)

    result = index.to_native_types(na_rep='pandas')
    tm.assert_numpy_array_equal(result, expected)


</source>
</class>

<class classid="103" nclones="2" nlines="15" similarity="80">
<source file="pandas/pandas/tests/indexes/datetimes/test_indexing.py.pyindent" startline="50" endline="68" pcid="5243">
    def test_dti_business_getitem(self):
        rng = pd.bdate_range(START, END)
        smaller = rng[:5]
        exp = DatetimeIndex(rng.view(np.ndarray)[:5])
        tm.assert_index_equal(smaller, exp)

        assert smaller.freq == rng.freq

        sliced = rng[::5]
        assert sliced.freq == BDay() * 5

        fancy_indexed = rng[[4, 3, 2, 1, 0]]
        assert len(fancy_indexed) == 5
        assert isinstance(fancy_indexed, DatetimeIndex)
        assert fancy_indexed.freq is None

        # 32-bit vs. 64-bit platforms
        assert rng[4] == rng[np.int_(4)]

</source>
<source file="pandas/pandas/tests/indexes/datetimes/test_indexing.py.pyindent" startline="75" endline="92" pcid="5245">
    def test_dti_custom_getitem(self):
        rng = pd.bdate_range(START, END, freq='C')
        smaller = rng[:5]
        exp = DatetimeIndex(rng.view(np.ndarray)[:5])
        tm.assert_index_equal(smaller, exp)
        assert smaller.freq == rng.freq

        sliced = rng[::5]
        assert sliced.freq == CDay() * 5

        fancy_indexed = rng[[4, 3, 2, 1, 0]]
        assert len(fancy_indexed) == 5
        assert isinstance(fancy_indexed, DatetimeIndex)
        assert fancy_indexed.freq is None

        # 32-bit vs. 64-bit platforms
        assert rng[4] == rng[np.int_(4)]

</source>
</class>

<class classid="104" nclones="2" nlines="19" similarity="75">
<source file="pandas/pandas/tests/indexes/datetimes/test_indexing.py.pyindent" startline="101" endline="119" pcid="5247">
    def test_where_other(self):
        # other is ndarray or Index
        i = pd.date_range('20130101', periods=3, tz='US/Eastern')

        for arr in [np.nan, pd.NaT]:
            result = i.where(notna(i), other=np.nan)
            expected = i
            tm.assert_index_equal(result, expected)

        i2 = i.copy()
        i2 = Index([pd.NaT, pd.NaT] + i[2:].tolist())
        result = i.where(notna(i2), i2)
        tm.assert_index_equal(result, i2)

        i2 = i.copy()
        i2 = Index([pd.NaT, pd.NaT] + i[2:].tolist())
        result = i.where(notna(i2), i2.values)
        tm.assert_index_equal(result, i2)

</source>
<source file="pandas/pandas/tests/indexes/period/test_indexing.py.pyindent" startline="207" endline="226" pcid="5791">
    def test_where_other(self):
        i = period_range('20130101', periods=5, freq='D')
        for arr in [np.nan, pd.NaT]:
            result = i.where(notna(i), other=np.nan)
            expected = i
            tm.assert_index_equal(result, expected)

        i2 = i.copy()
        i2 = pd.PeriodIndex([pd.NaT, pd.NaT] + i[2:].tolist(),
                            freq='D')
        result = i.where(notna(i2), i2)
        tm.assert_index_equal(result, i2)

        i2 = i.copy()
        i2 = pd.PeriodIndex([pd.NaT, pd.NaT] + i[2:].tolist(),
                            freq='D')
        result = i.where(notna(i2), i2.values)
        tm.assert_index_equal(result, i2)


</source>
</class>

<class classid="105" nclones="3" nlines="14" similarity="85">
<source file="pandas/pandas/tests/indexes/datetimes/test_indexing.py.pyindent" startline="176" endline="192" pcid="5250">
    def test_take_invalid_kwargs(self):
        idx = pd.date_range('2011-01-01', '2011-01-31', freq='D', name='idx')
        indices = [1, 6, 5, 9, 10, 13, 15, 3]

        msg = r"take\(\) got an unexpected keyword argument 'foo'"
        tm.assert_raises_regex(TypeError, msg, idx.take,
                               indices, foo=2)

        msg = "the 'out' parameter is not supported"
        tm.assert_raises_regex(ValueError, msg, idx.take,
                               indices, out=indices)

        msg = "the 'mode' parameter is not supported"
        tm.assert_raises_regex(ValueError, msg, idx.take,
                               indices, mode='clip')

    # TODO: This method came from test_datetime; de-dup with version above
</source>
<source file="pandas/pandas/tests/indexes/timedeltas/test_indexing.py.pyindent" startline="90" endline="106" pcid="6140">
    def test_take_invalid_kwargs(self):
        idx = timedelta_range('1 day', '31 day', freq='D', name='idx')
        indices = [1, 6, 5, 9, 10, 13, 15, 3]

        msg = r"take\(\) got an unexpected keyword argument 'foo'"
        tm.assert_raises_regex(TypeError, msg, idx.take,
                               indices, foo=2)

        msg = "the 'out' parameter is not supported"
        tm.assert_raises_regex(ValueError, msg, idx.take,
                               indices, out=indices)

        msg = "the 'mode' parameter is not supported"
        tm.assert_raises_regex(ValueError, msg, idx.take,
                               indices, mode='clip')

    # TODO: This method came from test_timedelta; de-dup with version above
</source>
<source file="pandas/pandas/tests/indexes/test_category.py.pyindent" startline="1099" endline="1113" pcid="5963">
    def test_take_invalid_kwargs(self):
        idx = pd.CategoricalIndex([1, 2, 3], name='foo')
        indices = [1, 0, -1]

        msg = r"take\(\) got an unexpected keyword argument 'foo'"
        tm.assert_raises_regex(TypeError, msg, idx.take,
                               indices, foo=2)

        msg = "the 'out' parameter is not supported"
        tm.assert_raises_regex(ValueError, msg, idx.take,
                               indices, out=indices)

        msg = "the 'mode' parameter is not supported"
        tm.assert_raises_regex(ValueError, msg, idx.take,
                               indices, mode='clip')
</source>
</class>

<class classid="106" nclones="6" nlines="31" similarity="75">
<source file="pandas/pandas/tests/indexes/datetimes/test_indexing.py.pyindent" startline="213" endline="244" pcid="5252">
    def test_take_fill_value(self):
        # GH#12631
        idx = pd.DatetimeIndex(['2011-01-01', '2011-02-01', '2011-03-01'],
                               name='xxx')
        result = idx.take(np.array([1, 0, -1]))
        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', '2011-03-01'],
                                    name='xxx')
        tm.assert_index_equal(result, expected)

        # fill_value
        result = idx.take(np.array([1, 0, -1]), fill_value=True)
        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', 'NaT'],
                                    name='xxx')
        tm.assert_index_equal(result, expected)

        # allow_fill=False
        result = idx.take(np.array([1, 0, -1]), allow_fill=False,
                          fill_value=True)
        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', '2011-03-01'],
                                    name='xxx')
        tm.assert_index_equal(result, expected)

        msg = ('When allow_fill=True and fill_value is not None, '
               'all indices must be >= -1')
        with tm.assert_raises_regex(ValueError, msg):
            idx.take(np.array([1, 0, -2]), fill_value=True)
        with tm.assert_raises_regex(ValueError, msg):
            idx.take(np.array([1, 0, -5]), fill_value=True)

        with pytest.raises(IndexError):
            idx.take(np.array([1, -5]))

</source>
<source file="pandas/pandas/tests/indexes/test_numeric.py.pyindent" startline="378" endline="406" pcid="6001">
    def test_take_fill_value(self):
        # GH 12631
        idx = pd.Float64Index([1., 2., 3.], name='xxx')
        result = idx.take(np.array([1, 0, -1]))
        expected = pd.Float64Index([2., 1., 3.], name='xxx')
        tm.assert_index_equal(result, expected)

        # fill_value
        result = idx.take(np.array([1, 0, -1]), fill_value=True)
        expected = pd.Float64Index([2., 1., np.nan], name='xxx')
        tm.assert_index_equal(result, expected)

        # allow_fill=False
        result = idx.take(np.array([1, 0, -1]), allow_fill=False,
                          fill_value=True)
        expected = pd.Float64Index([2., 1., 3.], name='xxx')
        tm.assert_index_equal(result, expected)

        msg = ('When allow_fill=True and fill_value is not None, '
               'all indices must be >= -1')
        with tm.assert_raises_regex(ValueError, msg):
            idx.take(np.array([1, 0, -2]), fill_value=True)
        with tm.assert_raises_regex(ValueError, msg):
            idx.take(np.array([1, 0, -5]), fill_value=True)

        with pytest.raises(IndexError):
            idx.take(np.array([1, -5]))


</source>
<source file="pandas/pandas/tests/indexes/period/test_indexing.py.pyindent" startline="292" endline="324" pcid="5794">
    def test_take_fill_value(self):
        # GH#12631
        idx = pd.PeriodIndex(['2011-01-01', '2011-02-01', '2011-03-01'],
                             name='xxx', freq='D')
        result = idx.take(np.array([1, 0, -1]))
        expected = pd.PeriodIndex(['2011-02-01', '2011-01-01', '2011-03-01'],
                                  name='xxx', freq='D')
        tm.assert_index_equal(result, expected)

        # fill_value
        result = idx.take(np.array([1, 0, -1]), fill_value=True)
        expected = pd.PeriodIndex(['2011-02-01', '2011-01-01', 'NaT'],
                                  name='xxx', freq='D')
        tm.assert_index_equal(result, expected)

        # allow_fill=False
        result = idx.take(np.array([1, 0, -1]), allow_fill=False,
                          fill_value=True)
        expected = pd.PeriodIndex(['2011-02-01', '2011-01-01', '2011-03-01'],
                                  name='xxx', freq='D')
        tm.assert_index_equal(result, expected)

        msg = ('When allow_fill=True and fill_value is not None, '
               'all indices must be >= -1')
        with tm.assert_raises_regex(ValueError, msg):
            idx.take(np.array([1, 0, -2]), fill_value=True)
        with tm.assert_raises_regex(ValueError, msg):
            idx.take(np.array([1, 0, -5]), fill_value=True)

        with pytest.raises(IndexError):
            idx.take(np.array([1, -5]))


</source>
<source file="pandas/pandas/tests/indexes/test_category.py.pyindent" startline="1061" endline="1098" pcid="5962">
    def test_take_fill_value_datetime(self):

        # datetime category
        idx = pd.DatetimeIndex(['2011-01-01', '2011-02-01', '2011-03-01'],
                               name='xxx')
        idx = pd.CategoricalIndex(idx)
        result = idx.take(np.array([1, 0, -1]))
        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', '2011-03-01'],
                                    name='xxx')
        expected = pd.CategoricalIndex(expected)
        tm.assert_index_equal(result, expected)

        # fill_value
        result = idx.take(np.array([1, 0, -1]), fill_value=True)
        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', 'NaT'],
                                    name='xxx')
        exp_cats = pd.DatetimeIndex(['2011-01-01', '2011-02-01', '2011-03-01'])
        expected = pd.CategoricalIndex(expected, categories=exp_cats)
        tm.assert_index_equal(result, expected)

        # allow_fill=False
        result = idx.take(np.array([1, 0, -1]), allow_fill=False,
                          fill_value=True)
        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', '2011-03-01'],
                                    name='xxx')
        expected = pd.CategoricalIndex(expected)
        tm.assert_index_equal(result, expected)

        msg = ('When allow_fill=True and fill_value is not None, '
               'all indices must be >= -1')
        with tm.assert_raises_regex(ValueError, msg):
            idx.take(np.array([1, 0, -2]), fill_value=True)
        with tm.assert_raises_regex(ValueError, msg):
            idx.take(np.array([1, 0, -5]), fill_value=True)

        with pytest.raises(IndexError):
            idx.take(np.array([1, -5]))

</source>
<source file="pandas/pandas/tests/indexes/timedeltas/test_indexing.py.pyindent" startline="121" endline="153" pcid="6142">
    def test_take_fill_value(self):
        # GH 12631
        idx = TimedeltaIndex(['1 days', '2 days', '3 days'],
                             name='xxx')
        result = idx.take(np.array([1, 0, -1]))
        expected = TimedeltaIndex(['2 days', '1 days', '3 days'],
                                  name='xxx')
        tm.assert_index_equal(result, expected)

        # fill_value
        result = idx.take(np.array([1, 0, -1]), fill_value=True)
        expected = TimedeltaIndex(['2 days', '1 days', 'NaT'],
                                  name='xxx')
        tm.assert_index_equal(result, expected)

        # allow_fill=False
        result = idx.take(np.array([1, 0, -1]), allow_fill=False,
                          fill_value=True)
        expected = TimedeltaIndex(['2 days', '1 days', '3 days'],
                                  name='xxx')
        tm.assert_index_equal(result, expected)

        msg = ('When allow_fill=True and fill_value is not None, '
               'all indices must be >= -1')
        with tm.assert_raises_regex(ValueError, msg):
            idx.take(np.array([1, 0, -2]), fill_value=True)
        with tm.assert_raises_regex(ValueError, msg):
            idx.take(np.array([1, 0, -5]), fill_value=True)

        with pytest.raises(IndexError):
            idx.take(np.array([1, -5]))


</source>
<source file="pandas/pandas/tests/indexes/datetimes/test_indexing.py.pyindent" startline="245" endline="276" pcid="5253">
    def test_take_fill_value_with_timezone(self):
        idx = pd.DatetimeIndex(['2011-01-01', '2011-02-01', '2011-03-01'],
                               name='xxx', tz='US/Eastern')
        result = idx.take(np.array([1, 0, -1]))
        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', '2011-03-01'],
                                    name='xxx', tz='US/Eastern')
        tm.assert_index_equal(result, expected)

        # fill_value
        result = idx.take(np.array([1, 0, -1]), fill_value=True)
        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', 'NaT'],
                                    name='xxx', tz='US/Eastern')
        tm.assert_index_equal(result, expected)

        # allow_fill=False
        result = idx.take(np.array([1, 0, -1]), allow_fill=False,
                          fill_value=True)
        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', '2011-03-01'],
                                    name='xxx', tz='US/Eastern')
        tm.assert_index_equal(result, expected)

        msg = ('When allow_fill=True and fill_value is not None, '
               'all indices must be >= -1')
        with tm.assert_raises_regex(ValueError, msg):
            idx.take(np.array([1, 0, -2]), fill_value=True)
        with tm.assert_raises_regex(ValueError, msg):
            idx.take(np.array([1, 0, -5]), fill_value=True)

        with pytest.raises(IndexError):
            idx.take(np.array([1, -5]))


</source>
</class>

<class classid="107" nclones="3" nlines="12" similarity="75">
<source file="pandas/pandas/tests/indexes/datetimes/test_ops.py.pyindent" startline="297" endline="309" pcid="5280">
    def test_drop_duplicates_metadata(self):
        # GH 10115
        idx = pd.date_range('2011-01-01', '2011-01-31', freq='D', name='idx')
        result = idx.drop_duplicates()
        tm.assert_index_equal(idx, result)
        assert idx.freq == result.freq

        idx_dup = idx.append(idx)
        assert idx_dup.freq is None  # freq is reset
        result = idx_dup.drop_duplicates()
        tm.assert_index_equal(idx, result)
        assert result.freq is None

</source>
<source file="pandas/pandas/tests/indexes/timedeltas/test_ops.py.pyindent" startline="198" endline="210" pcid="6157">
    def test_drop_duplicates_metadata(self):
        # GH 10115
        idx = pd.timedelta_range('1 day', '31 day', freq='D', name='idx')
        result = idx.drop_duplicates()
        tm.assert_index_equal(idx, result)
        assert idx.freq == result.freq

        idx_dup = idx.append(idx)
        assert idx_dup.freq is None  # freq is reset
        result = idx_dup.drop_duplicates()
        tm.assert_index_equal(idx, result)
        assert result.freq is None

</source>
<source file="pandas/pandas/tests/indexes/period/test_ops.py.pyindent" startline="135" endline="146" pcid="5815">
    def test_drop_duplicates_metadata(self):
        # GH 10115
        idx = pd.period_range('2011-01-01', '2011-01-31', freq='D', name='idx')
        result = idx.drop_duplicates()
        tm.assert_index_equal(idx, result)
        assert idx.freq == result.freq

        idx_dup = idx.append(idx)  # freq will not be reset
        result = idx_dup.drop_duplicates()
        tm.assert_index_equal(idx, result)
        assert idx.freq == result.freq

</source>
</class>

<class classid="108" nclones="3" nlines="18" similarity="89">
<source file="pandas/pandas/tests/indexes/datetimes/test_ops.py.pyindent" startline="310" endline="330" pcid="5281">
    def test_drop_duplicates(self):
        # to check Index/Series compat
        base = pd.date_range('2011-01-01', '2011-01-31', freq='D', name='idx')
        idx = base.append(base[:5])

        res = idx.drop_duplicates()
        tm.assert_index_equal(res, base)
        res = Series(idx).drop_duplicates()
        tm.assert_series_equal(res, Series(base))

        res = idx.drop_duplicates(keep='last')
        exp = base[5:].append(base[:5])
        tm.assert_index_equal(res, exp)
        res = Series(idx).drop_duplicates(keep='last')
        tm.assert_series_equal(res, Series(exp, index=np.arange(5, 36)))

        res = idx.drop_duplicates(keep=False)
        tm.assert_index_equal(res, base[5:])
        res = Series(idx).drop_duplicates(keep=False)
        tm.assert_series_equal(res, Series(base[5:], index=np.arange(5, 31)))

</source>
<source file="pandas/pandas/tests/indexes/period/test_ops.py.pyindent" startline="147" endline="168" pcid="5816">
    def test_drop_duplicates(self):
        # to check Index/Series compat
        base = pd.period_range('2011-01-01', '2011-01-31', freq='D',
                               name='idx')
        idx = base.append(base[:5])

        res = idx.drop_duplicates()
        tm.assert_index_equal(res, base)
        res = Series(idx).drop_duplicates()
        tm.assert_series_equal(res, Series(base))

        res = idx.drop_duplicates(keep='last')
        exp = base[5:].append(base[:5])
        tm.assert_index_equal(res, exp)
        res = Series(idx).drop_duplicates(keep='last')
        tm.assert_series_equal(res, Series(exp, index=np.arange(5, 36)))

        res = idx.drop_duplicates(keep=False)
        tm.assert_index_equal(res, base[5:])
        res = Series(idx).drop_duplicates(keep=False)
        tm.assert_series_equal(res, Series(base[5:], index=np.arange(5, 31)))

</source>
<source file="pandas/pandas/tests/indexes/timedeltas/test_ops.py.pyindent" startline="211" endline="231" pcid="6158">
    def test_drop_duplicates(self):
        # to check Index/Series compat
        base = pd.timedelta_range('1 day', '31 day', freq='D', name='idx')
        idx = base.append(base[:5])

        res = idx.drop_duplicates()
        tm.assert_index_equal(res, base)
        res = Series(idx).drop_duplicates()
        tm.assert_series_equal(res, Series(base))

        res = idx.drop_duplicates(keep='last')
        exp = base[5:].append(base[:5])
        tm.assert_index_equal(res, exp)
        res = Series(idx).drop_duplicates(keep='last')
        tm.assert_series_equal(res, Series(exp, index=np.arange(5, 36)))

        res = idx.drop_duplicates(keep=False)
        tm.assert_index_equal(res, base[5:])
        res = Series(idx).drop_duplicates(keep=False)
        tm.assert_series_equal(res, Series(base[5:], index=np.arange(5, 31)))

</source>
</class>

<class classid="109" nclones="3" nlines="10" similarity="70">
<source file="pandas/pandas/tests/indexes/datetimes/test_ops.py.pyindent" startline="342" endline="351" pcid="5283">
    def test_nat_new(self):
        idx = pd.date_range('2011-01-01', freq='D', periods=5, name='x')
        result = idx._nat_new()
        exp = pd.DatetimeIndex([pd.NaT] * 5, name='x')
        tm.assert_index_equal(result, exp)

        result = idx._nat_new(box=False)
        exp = np.array([tslib.iNaT] * 5, dtype=np.int64)
        tm.assert_numpy_array_equal(result, exp)

</source>
<source file="pandas/pandas/tests/indexes/timedeltas/test_ops.py.pyindent" startline="242" endline="252" pcid="6160">
    def test_nat_new(self):

        idx = pd.timedelta_range('1', freq='D', periods=5, name='x')
        result = idx._nat_new()
        exp = pd.TimedeltaIndex([pd.NaT] * 5, name='x')
        tm.assert_index_equal(result, exp)

        result = idx._nat_new(box=False)
        exp = np.array([iNaT] * 5, dtype=np.int64)
        tm.assert_numpy_array_equal(result, exp)

</source>
<source file="pandas/pandas/tests/indexes/period/test_ops.py.pyindent" startline="317" endline="327" pcid="5820">
    def test_nat_new(self):

        idx = pd.period_range('2011-01', freq='M', periods=5, name='x')
        result = idx._nat_new()
        exp = pd.PeriodIndex([pd.NaT] * 5, freq='M', name='x')
        tm.assert_index_equal(result, exp)

        result = idx._nat_new(box=False)
        exp = np.array([tslib.iNaT] * 5, dtype=np.int64)
        tm.assert_numpy_array_equal(result, exp)

</source>
</class>

<class classid="110" nclones="2" nlines="28" similarity="78">
<source file="pandas/pandas/tests/indexes/datetimes/test_ops.py.pyindent" startline="373" endline="402" pcid="5285">
    def test_equals(self):
        # GH 13107
        idx = pd.DatetimeIndex(['2011-01-01', '2011-01-02', 'NaT'])
        assert idx.equals(idx)
        assert idx.equals(idx.copy())
        assert idx.equals(idx.astype(object))
        assert idx.astype(object).equals(idx)
        assert idx.astype(object).equals(idx.astype(object))
        assert not idx.equals(list(idx))
        assert not idx.equals(pd.Series(idx))

        idx2 = pd.DatetimeIndex(['2011-01-01', '2011-01-02', 'NaT'],
                                tz='US/Pacific')
        assert not idx.equals(idx2)
        assert not idx.equals(idx2.copy())
        assert not idx.equals(idx2.astype(object))
        assert not idx.astype(object).equals(idx2)
        assert not idx.equals(list(idx2))
        assert not idx.equals(pd.Series(idx2))

        # same internal, different tz
        idx3 = pd.DatetimeIndex._simple_new(idx.asi8, tz='US/Pacific')
        tm.assert_numpy_array_equal(idx.asi8, idx3.asi8)
        assert not idx.equals(idx3)
        assert not idx.equals(idx3.copy())
        assert not idx.equals(idx3.astype(object))
        assert not idx.astype(object).equals(idx3)
        assert not idx.equals(list(idx3))
        assert not idx.equals(pd.Series(idx3))

</source>
<source file="pandas/pandas/tests/indexes/period/test_ops.py.pyindent" startline="373" endline="403" pcid="5824">
    def test_equals(self, freq):
        # GH#13107
        idx = pd.PeriodIndex(['2011-01-01', '2011-01-02', 'NaT'],
                             freq=freq)
        assert idx.equals(idx)
        assert idx.equals(idx.copy())
        assert idx.equals(idx.astype(object))
        assert idx.astype(object).equals(idx)
        assert idx.astype(object).equals(idx.astype(object))
        assert not idx.equals(list(idx))
        assert not idx.equals(pd.Series(idx))

        idx2 = pd.PeriodIndex(['2011-01-01', '2011-01-02', 'NaT'],
                              freq='H')
        assert not idx.equals(idx2)
        assert not idx.equals(idx2.copy())
        assert not idx.equals(idx2.astype(object))
        assert not idx.astype(object).equals(idx2)
        assert not idx.equals(list(idx2))
        assert not idx.equals(pd.Series(idx2))

        # same internal, different tz
        idx3 = pd.PeriodIndex._simple_new(idx.asi8, freq='H')
        tm.assert_numpy_array_equal(idx.asi8, idx3.asi8)
        assert not idx.equals(idx3)
        assert not idx.equals(idx3.copy())
        assert not idx.equals(idx3.astype(object))
        assert not idx.astype(object).equals(idx3)
        assert not idx.equals(list(idx3))
        assert not idx.equals(pd.Series(idx3))

</source>
</class>

<class classid="111" nclones="2" nlines="17" similarity="72">
<source file="pandas/pandas/tests/indexes/datetimes/test_ops.py.pyindent" startline="469" endline="485" pcid="5293">
    def test_shift(self):
        shifted = self.rng.shift(5)
        assert shifted[0] == self.rng[5]
        assert shifted.freq == self.rng.freq

        shifted = self.rng.shift(-5)
        assert shifted[5] == self.rng[0]
        assert shifted.freq == self.rng.freq

        shifted = self.rng.shift(0)
        assert shifted[0] == self.rng[0]
        assert shifted.freq == self.rng.freq

        rng = date_range(START, END, freq=BMonthEnd())
        shifted = rng.shift(1, freq=BDay())
        assert shifted[0] == rng[0] + BDay()

</source>
<source file="pandas/pandas/tests/indexes/datetimes/test_ops.py.pyindent" startline="523" endline="542" pcid="5299">
    def test_shift(self):

        shifted = self.rng.shift(5)
        assert shifted[0] == self.rng[5]
        assert shifted.freq == self.rng.freq

        shifted = self.rng.shift(-5)
        assert shifted[5] == self.rng[0]
        assert shifted.freq == self.rng.freq

        shifted = self.rng.shift(0)
        assert shifted[0] == self.rng[0]
        assert shifted.freq == self.rng.freq

        # PerformanceWarning
        with warnings.catch_warnings(record=True):
            rng = date_range(START, END, freq=BMonthEnd())
            shifted = rng.shift(1, freq=CDay())
            assert shifted[0] == rng[0] + CDay()

</source>
</class>

<class classid="112" nclones="2" nlines="11" similarity="90">
<source file="pandas/pandas/tests/indexes/datetimes/test_partial_slicing.py.pyindent" startline="67" endline="76" pcid="5306">
    def test_slice_with_zero_step_raises(self):
        ts = Series(np.arange(20),
                    date_range('2014-01-01', periods=20, freq='MS'))
        tm.assert_raises_regex(ValueError, 'slice step cannot be zero',
                               lambda: ts[::0])
        tm.assert_raises_regex(ValueError, 'slice step cannot be zero',
                               lambda: ts.loc[::0])
        tm.assert_raises_regex(ValueError, 'slice step cannot be zero',
                               lambda: ts.loc[::0])

</source>
<source file="pandas/pandas/tests/indexes/period/test_partial_slicing.py.pyindent" startline="42" endline="51" pcid="5832">
    def test_slice_with_zero_step_raises(self):
        ts = Series(np.arange(20),
                    period_range('2014-01', periods=20, freq='M'))
        tm.assert_raises_regex(ValueError, 'slice step cannot be zero',
                               lambda: ts[::0])
        tm.assert_raises_regex(ValueError, 'slice step cannot be zero',
                               lambda: ts.loc[::0])
        tm.assert_raises_regex(ValueError, 'slice step cannot be zero',
                               lambda: ts.loc[::0])

</source>
</class>

<class classid="113" nclones="2" nlines="19" similarity="73">
<source file="pandas/pandas/tests/indexes/datetimes/test_setops.py.pyindent" startline="35" endline="54" pcid="5340">
    def test_union(self, tz):
        rng1 = pd.date_range('1/1/2000', freq='D', periods=5, tz=tz)
        other1 = pd.date_range('1/6/2000', freq='D', periods=5, tz=tz)
        expected1 = pd.date_range('1/1/2000', freq='D', periods=10, tz=tz)

        rng2 = pd.date_range('1/1/2000', freq='D', periods=5, tz=tz)
        other2 = pd.date_range('1/4/2000', freq='D', periods=5, tz=tz)
        expected2 = pd.date_range('1/1/2000', freq='D', periods=8, tz=tz)

        rng3 = pd.date_range('1/1/2000', freq='D', periods=5, tz=tz)
        other3 = pd.DatetimeIndex([], tz=tz)
        expected3 = pd.date_range('1/1/2000', freq='D', periods=5, tz=tz)

        for rng, other, expected in [(rng1, other1, expected1),
                                     (rng2, other2, expected2),
                                     (rng3, other3, expected3)]:

            result_union = rng.union(other)
            tm.assert_index_equal(result_union, expected)

</source>
<source file="pandas/pandas/tests/indexes/datetimes/test_setops.py.pyindent" startline="209" endline="227" pcid="5352">
    def test_difference(self, tz):
        rng1 = pd.date_range('1/1/2000', freq='D', periods=5, tz=tz)
        other1 = pd.date_range('1/6/2000', freq='D', periods=5, tz=tz)
        expected1 = pd.date_range('1/1/2000', freq='D', periods=5, tz=tz)

        rng2 = pd.date_range('1/1/2000', freq='D', periods=5, tz=tz)
        other2 = pd.date_range('1/4/2000', freq='D', periods=5, tz=tz)
        expected2 = pd.date_range('1/1/2000', freq='D', periods=3, tz=tz)

        rng3 = pd.date_range('1/1/2000', freq='D', periods=5, tz=tz)
        other3 = pd.DatetimeIndex([], tz=tz)
        expected3 = pd.date_range('1/1/2000', freq='D', periods=5, tz=tz)

        for rng, other, expected in [(rng1, other1, expected1),
                                     (rng2, other2, expected2),
                                     (rng3, other3, expected3)]:
            result_diff = rng.difference(other)
            tm.assert_index_equal(result_diff, expected)

</source>
</class>

<class classid="114" nclones="2" nlines="10" similarity="80">
<source file="pandas/pandas/tests/indexes/datetimes/test_setops.py.pyindent" startline="55" endline="64" pcid="5341">
    def test_union_coverage(self):
        idx = DatetimeIndex(['2000-01-03', '2000-01-01', '2000-01-02'])
        ordered = DatetimeIndex(idx.sort_values(), freq='infer')
        result = ordered.union(idx)
        tm.assert_index_equal(result, ordered)

        result = ordered[:0].union(ordered)
        tm.assert_index_equal(result, ordered)
        assert result.freq == ordered.freq

</source>
<source file="pandas/pandas/tests/indexes/timedeltas/test_setops.py.pyindent" startline="23" endline="33" pcid="6171">
    def test_union_coverage(self):

        idx = TimedeltaIndex(['3d', '1d', '2d'])
        ordered = TimedeltaIndex(idx.sort_values(), freq='infer')
        result = ordered.union(idx)
        tm.assert_index_equal(result, ordered)

        result = ordered[:0].union(ordered)
        tm.assert_index_equal(result, ordered)
        assert result.freq == ordered.freq

</source>
</class>

<class classid="115" nclones="2" nlines="19" similarity="100">
<source file="pandas/pandas/tests/indexes/datetimes/test_setops.py.pyindent" startline="276" endline="306" pcid="5358">
    def test_union(self):
        # overlapping
        left = self.rng[:10]
        right = self.rng[5:10]

        the_union = left.union(right)
        assert isinstance(the_union, DatetimeIndex)

        # non-overlapping, gap in middle
        left = self.rng[:5]
        right = self.rng[10:]

        the_union = left.union(right)
        assert isinstance(the_union, Index)

        # non-overlapping, no gap
        left = self.rng[:5]
        right = self.rng[5:10]

        the_union = left.union(right)
        assert isinstance(the_union, DatetimeIndex)

        # order does not matter
        tm.assert_index_equal(right.union(left), the_union)

        # overlapping, but different offset
        rng = date_range(START, END, freq=BMonthEnd())

        the_union = self.rng.union(rng)
        assert isinstance(the_union, DatetimeIndex)

</source>
<source file="pandas/pandas/tests/indexes/datetimes/test_setops.py.pyindent" startline="418" endline="448" pcid="5366">
    def test_union(self):
        # overlapping
        left = self.rng[:10]
        right = self.rng[5:10]

        the_union = left.union(right)
        assert isinstance(the_union, DatetimeIndex)

        # non-overlapping, gap in middle
        left = self.rng[:5]
        right = self.rng[10:]

        the_union = left.union(right)
        assert isinstance(the_union, Index)

        # non-overlapping, no gap
        left = self.rng[:5]
        right = self.rng[5:10]

        the_union = left.union(right)
        assert isinstance(the_union, DatetimeIndex)

        # order does not matter
        tm.assert_index_equal(right.union(left), the_union)

        # overlapping, but different offset
        rng = date_range(START, END, freq=BMonthEnd())

        the_union = self.rng.union(rng)
        assert isinstance(the_union, DatetimeIndex)

</source>
</class>

<class classid="116" nclones="2" nlines="20" similarity="100">
<source file="pandas/pandas/tests/indexes/datetimes/test_setops.py.pyindent" startline="307" endline="338" pcid="5359">
    def test_outer_join(self):
        # should just behave as union

        # overlapping
        left = self.rng[:10]
        right = self.rng[5:10]

        the_join = left.join(right, how='outer')
        assert isinstance(the_join, DatetimeIndex)

        # non-overlapping, gap in middle
        left = self.rng[:5]
        right = self.rng[10:]

        the_join = left.join(right, how='outer')
        assert isinstance(the_join, DatetimeIndex)
        assert the_join.freq is None

        # non-overlapping, no gap
        left = self.rng[:5]
        right = self.rng[5:10]

        the_join = left.join(right, how='outer')
        assert isinstance(the_join, DatetimeIndex)

        # overlapping, but different offset
        rng = date_range(START, END, freq=BMonthEnd())

        the_join = self.rng.join(rng, how='outer')
        assert isinstance(the_join, DatetimeIndex)
        assert the_join.freq is None

</source>
<source file="pandas/pandas/tests/indexes/datetimes/test_setops.py.pyindent" startline="449" endline="480" pcid="5367">
    def test_outer_join(self):
        # should just behave as union

        # overlapping
        left = self.rng[:10]
        right = self.rng[5:10]

        the_join = left.join(right, how='outer')
        assert isinstance(the_join, DatetimeIndex)

        # non-overlapping, gap in middle
        left = self.rng[:5]
        right = self.rng[10:]

        the_join = left.join(right, how='outer')
        assert isinstance(the_join, DatetimeIndex)
        assert the_join.freq is None

        # non-overlapping, no gap
        left = self.rng[:5]
        right = self.rng[5:10]

        the_join = left.join(right, how='outer')
        assert isinstance(the_join, DatetimeIndex)

        # overlapping, but different offset
        rng = date_range(START, END, freq=BMonthEnd())

        the_join = self.rng.join(rng, how='outer')
        assert isinstance(the_join, DatetimeIndex)
        assert the_join.freq is None

</source>
</class>

<class classid="117" nclones="2" nlines="14" similarity="78">
<source file="pandas/pandas/tests/indexes/datetimes/test_setops.py.pyindent" startline="377" endline="393" pcid="5363">
    def test_month_range_union_tz_pytz(self):
        from pytz import timezone
        tz = timezone('US/Eastern')

        early_start = datetime(2011, 1, 1)
        early_end = datetime(2011, 3, 1)

        late_start = datetime(2011, 3, 1)
        late_end = datetime(2011, 5, 1)

        early_dr = date_range(start=early_start, end=early_end, tz=tz,
                              freq=MonthEnd())
        late_dr = date_range(start=late_start, end=late_end, tz=tz,
                             freq=MonthEnd())

        early_dr.union(late_dr)

</source>
<source file="pandas/pandas/tests/indexes/datetimes/test_setops.py.pyindent" startline="395" endline="412" pcid="5364">
    def test_month_range_union_tz_dateutil(self):
        from pandas._libs.tslibs.timezones import dateutil_gettz
        tz = dateutil_gettz('US/Eastern')

        early_start = datetime(2011, 1, 1)
        early_end = datetime(2011, 3, 1)

        late_start = datetime(2011, 3, 1)
        late_end = datetime(2011, 5, 1)

        early_dr = date_range(start=early_start, end=early_end, tz=tz,
                              freq=MonthEnd())
        late_dr = date_range(start=late_start, end=late_end, tz=tz,
                             freq=MonthEnd())

        early_dr.union(late_dr)


</source>
</class>

<class classid="118" nclones="2" nlines="17" similarity="70">
<source file="pandas/pandas/tests/indexes/interval/test_construction.py.pyindent" startline="243" endline="257" pcid="5467">
    def get_kwargs_from_breaks(self, breaks, closed='right'):
        """
        converts intervals in breaks format to a dictionary of kwargs to
        specific to the format expected by IntervalIndex.from_tuples
        """
        if len(breaks) == 0:
            return {'data': breaks}

        tuples = lzip(breaks[:-1], breaks[1:])
        if isinstance(breaks, (list, tuple)):
            return {'data': tuples}
        elif is_categorical_dtype(breaks):
            return {'data': breaks._constructor(tuples)}
        return {'data': com.asarray_tuplesafe(tuples)}

</source>
<source file="pandas/pandas/tests/indexes/interval/test_construction.py.pyindent" startline="291" endline="307" pcid="5471">
    def get_kwargs_from_breaks(self, breaks, closed='right'):
        """
        converts intervals in breaks format to a dictionary of kwargs to
        specific to the format expected by the IntervalIndex/Index constructors
        """
        if len(breaks) == 0:
            return {'data': breaks}

        ivs = [Interval(l, r, closed) if notna(l) else l
               for l, r in zip(breaks[:-1], breaks[1:])]

        if isinstance(breaks, list):
            return {'data': ivs}
        elif is_categorical_dtype(breaks):
            return {'data': breaks._constructor(ivs)}
        return {'data': np.array(ivs, dtype=object)}

</source>
</class>

<class classid="119" nclones="2" nlines="18" similarity="83">
<source file="pandas/pandas/tests/indexes/interval/test_interval_range.py.pyindent" startline="23" endline="47" pcid="5495">
    def test_constructor_numeric(self, closed, name, freq, periods):
        start, end = 0, 100
        breaks = np.arange(101, step=freq)
        expected = IntervalIndex.from_breaks(breaks, name=name, closed=closed)

        # defined from start/end/freq
        result = interval_range(
            start=start, end=end, freq=freq, name=name, closed=closed)
        tm.assert_index_equal(result, expected)

        # defined from start/periods/freq
        result = interval_range(
            start=start, periods=periods, freq=freq, name=name, closed=closed)
        tm.assert_index_equal(result, expected)

        # defined from end/periods/freq
        result = interval_range(
            end=end, periods=periods, freq=freq, name=name, closed=closed)
        tm.assert_index_equal(result, expected)

        # GH 20976: linspace behavior defined from start/end/periods
        result = interval_range(
            start=start, end=end, periods=periods, name=name, closed=closed)
        tm.assert_index_equal(result, expected)

</source>
<source file="pandas/pandas/tests/indexes/interval/test_interval_range.py.pyindent" startline="81" endline="105" pcid="5497">
    def test_constructor_timedelta(self, closed, name, freq, periods):
        start, end = Timedelta('0 days'), Timedelta('100 days')
        breaks = timedelta_range(start=start, end=end, freq=freq)
        expected = IntervalIndex.from_breaks(breaks, name=name, closed=closed)

        # defined from start/end/freq
        result = interval_range(
            start=start, end=end, freq=freq, name=name, closed=closed)
        tm.assert_index_equal(result, expected)

        # defined from start/periods/freq
        result = interval_range(
            start=start, periods=periods, freq=freq, name=name, closed=closed)
        tm.assert_index_equal(result, expected)

        # defined from end/periods/freq
        result = interval_range(
            end=end, periods=periods, freq=freq, name=name, closed=closed)
        tm.assert_index_equal(result, expected)

        # GH 20976: linspace behavior defined from start/end/periods
        result = interval_range(
            start=start, end=end, periods=periods, name=name, closed=closed)
        tm.assert_index_equal(result, expected)

</source>
</class>

<class classid="120" nclones="2" nlines="12" similarity="83">
<source file="pandas/pandas/tests/indexes/multi/conftest.py.pyindent" startline="9" endline="23" pcid="5512">
def idx():
    # a MultiIndex used to test the general functionality of the
    # general functionality of this object
    major_axis = Index(['foo', 'bar', 'baz', 'qux'])
    minor_axis = Index(['one', 'two'])

    major_labels = np.array([0, 0, 1, 2, 3, 3])
    minor_labels = np.array([0, 1, 0, 1, 0, 1])
    index_names = ['first', 'second']
    mi = MultiIndex(levels=[major_axis, minor_axis],
                    labels=[major_labels, minor_labels],
                    names=index_names, verify_integrity=False)
    return mi


</source>
<source file="pandas/pandas/tests/indexes/multi/conftest.py.pyindent" startline="25" endline="38" pcid="5513">
def idx_dup():
    # compare tests/indexes/multi/conftest.py
    major_axis = Index(['foo', 'bar', 'baz', 'qux'])
    minor_axis = Index(['one', 'two'])

    major_labels = np.array([0, 0, 1, 0, 1, 1])
    minor_labels = np.array([0, 1, 0, 1, 0, 1])
    index_names = ['first', 'second']
    mi = MultiIndex(levels=[major_axis, minor_axis],
                    labels=[major_labels, minor_labels],
                    names=index_names, verify_integrity=False)
    return mi


</source>
</class>

<class classid="121" nclones="2" nlines="12" similarity="75">
<source file="pandas/pandas/tests/indexes/multi/test_constructor.py.pyindent" startline="142" endline="155" pcid="5535">
def test_from_arrays_index_series_timedelta():
    idx1 = pd.timedelta_range('1 days', freq='D', periods=3)
    idx2 = pd.timedelta_range('2 hours', freq='H', periods=3)
    result = pd.MultiIndex.from_arrays([idx1, idx2])
    tm.assert_index_equal(result.get_level_values(0), idx1)
    tm.assert_index_equal(result.get_level_values(1), idx2)

    result2 = pd.MultiIndex.from_arrays([pd.Series(idx1), pd.Series(idx2)])
    tm.assert_index_equal(result2.get_level_values(0), idx1)
    tm.assert_index_equal(result2.get_level_values(1), idx2)

    tm.assert_index_equal(result, result2)


</source>
<source file="pandas/pandas/tests/indexes/multi/test_constructor.py.pyindent" startline="156" endline="169" pcid="5536">
def test_from_arrays_index_series_period():
    idx1 = pd.period_range('2011-01-01', freq='D', periods=3)
    idx2 = pd.period_range('2015-01-01', freq='H', periods=3)
    result = pd.MultiIndex.from_arrays([idx1, idx2])
    tm.assert_index_equal(result.get_level_values(0), idx1)
    tm.assert_index_equal(result.get_level_values(1), idx2)

    result2 = pd.MultiIndex.from_arrays([pd.Series(idx1), pd.Series(idx2)])
    tm.assert_index_equal(result2.get_level_values(0), idx1)
    tm.assert_index_equal(result2.get_level_values(1), idx2)

    tm.assert_index_equal(result, result2)


</source>
</class>

<class classid="122" nclones="2" nlines="13" similarity="76">
<source file="pandas/pandas/tests/indexes/multi/test_format.py.pyindent" startline="103" endline="112" pcid="5615">
def test_unicode_string_with_unicode():
    d = {"a": [u("\u05d0"), 2, 3], "b": [4, 5, 6], "c": [7, 8, 9]}
    idx = pd.DataFrame(d).set_index(["a", "b"]).index

    if PY3:
        str(idx)
    else:
        compat.text_type(idx)


</source>
<source file="pandas/pandas/tests/indexes/multi/test_format.py.pyindent" startline="113" endline="122" pcid="5616">
def test_bytestring_with_unicode():
    d = {"a": [u("\u05d0"), 2, 3], "b": [4, 5, 6], "c": [7, 8, 9]}
    idx = pd.DataFrame(d).set_index(["a", "b"]).index

    if PY3:
        bytes(idx)
    else:
        str(idx)


</source>
</class>

<class classid="123" nclones="2" nlines="18" similarity="77">
<source file="pandas/pandas/tests/indexes/multi/test_sorting.py.pyindent" startline="11" endline="34" pcid="5720">
def test_sortlevel(idx):
    import random

    tuples = list(idx)
    random.shuffle(tuples)

    index = MultiIndex.from_tuples(tuples)

    sorted_idx, _ = index.sortlevel(0)
    expected = MultiIndex.from_tuples(sorted(tuples))
    assert sorted_idx.equals(expected)

    sorted_idx, _ = index.sortlevel(0, ascending=False)
    assert sorted_idx.equals(expected[::-1])

    sorted_idx, _ = index.sortlevel(1)
    by1 = sorted(tuples, key=lambda x: (x[1], x[0]))
    expected = MultiIndex.from_tuples(by1)
    assert sorted_idx.equals(expected)

    sorted_idx, _ = index.sortlevel(1, ascending=False)
    assert sorted_idx.equals(expected[::-1])


</source>
<source file="pandas/pandas/tests/indexes/multi/test_sorting.py.pyindent" startline="41" endline="62" pcid="5722">
def test_sortlevel_deterministic():
    tuples = [('bar', 'one'), ('foo', 'two'), ('qux', 'two'),
              ('foo', 'one'), ('baz', 'two'), ('qux', 'one')]

    index = MultiIndex.from_tuples(tuples)

    sorted_idx, _ = index.sortlevel(0)
    expected = MultiIndex.from_tuples(sorted(tuples))
    assert sorted_idx.equals(expected)

    sorted_idx, _ = index.sortlevel(0, ascending=False)
    assert sorted_idx.equals(expected[::-1])

    sorted_idx, _ = index.sortlevel(1)
    by1 = sorted(tuples, key=lambda x: (x[1], x[0]))
    expected = MultiIndex.from_tuples(by1)
    assert sorted_idx.equals(expected)

    sorted_idx, _ = index.sortlevel(1, ascending=False)
    assert sorted_idx.equals(expected[::-1])


</source>
</class>

<class classid="124" nclones="3" nlines="12" similarity="75">
<source file="pandas/pandas/tests/indexes/period/test_indexing.py.pyindent" startline="195" endline="206" pcid="5790">
    def test_where(self, klass):
        i = period_range('20130101', periods=5, freq='D')
        cond = [True] * len(i)
        expected = i
        result = i.where(klass(cond))
        tm.assert_index_equal(result, expected)

        cond = [False] + [True] * (len(i) - 1)
        expected = PeriodIndex([pd.NaT] + i[1:].tolist(), freq='D')
        result = i.where(klass(cond))
        tm.assert_index_equal(result, expected)

</source>
<source file="pandas/pandas/tests/indexes/test_numeric.py.pyindent" startline="87" endline="97" pcid="5976">
    def test_where(self, klass):
        i = self.create_index()
        cond = [True] * len(i)
        expected = i
        result = i.where(klass(cond))

        cond = [False] + [True] * (len(i) - 1)
        expected = Float64Index([i._na_value] + i[1:].tolist())
        result = i.where(klass(cond))
        tm.assert_index_equal(result, expected)

</source>
<source file="pandas/pandas/tests/indexes/test_category.py.pyindent" startline="310" endline="322" pcid="5936">
    def test_where(self, klass):
        i = self.create_index()
        cond = [True] * len(i)
        expected = i
        result = i.where(klass(cond))
        tm.assert_index_equal(result, expected)

        cond = [False] + [True] * (len(i) - 1)
        expected = CategoricalIndex([np.nan] + i[1:].tolist(),
                                    categories=i.categories)
        result = i.where(klass(cond))
        tm.assert_index_equal(result, expected)

</source>
</class>

<class classid="125" nclones="2" nlines="17" similarity="76">
<source file="pandas/pandas/tests/indexes/period/test_ops.py.pyindent" startline="352" endline="371" pcid="5823">
    def test_nat(self):
        assert pd.PeriodIndex._na_value is pd.NaT
        assert pd.PeriodIndex([], freq='M')._na_value is pd.NaT

        idx = pd.PeriodIndex(['2011-01-01', '2011-01-02'], freq='D')
        assert idx._can_hold_na

        tm.assert_numpy_array_equal(idx._isnan, np.array([False, False]))
        assert not idx.hasnans
        tm.assert_numpy_array_equal(idx._nan_idxs,
                                    np.array([], dtype=np.intp))

        idx = pd.PeriodIndex(['2011-01-01', 'NaT'], freq='D')
        assert idx._can_hold_na

        tm.assert_numpy_array_equal(idx._isnan, np.array([False, True]))
        assert idx.hasnans
        tm.assert_numpy_array_equal(idx._nan_idxs,
                                    np.array([1], dtype=np.intp))

</source>
<source file="pandas/pandas/tests/indexes/timedeltas/test_ops.py.pyindent" startline="271" endline="290" pcid="6163">
    def test_nat(self):
        assert pd.TimedeltaIndex._na_value is pd.NaT
        assert pd.TimedeltaIndex([])._na_value is pd.NaT

        idx = pd.TimedeltaIndex(['1 days', '2 days'])
        assert idx._can_hold_na

        tm.assert_numpy_array_equal(idx._isnan, np.array([False, False]))
        assert not idx.hasnans
        tm.assert_numpy_array_equal(idx._nan_idxs,
                                    np.array([], dtype=np.intp))

        idx = pd.TimedeltaIndex(['1 days', 'NaT'])
        assert idx._can_hold_na

        tm.assert_numpy_array_equal(idx._isnan, np.array([False, True]))
        assert idx.hasnans
        tm.assert_numpy_array_equal(idx._nan_idxs,
                                    np.array([1], dtype=np.intp))

</source>
</class>

<class classid="126" nclones="2" nlines="18" similarity="94">
<source file="pandas/pandas/tests/indexes/test_numeric.py.pyindent" startline="31" endline="55" pcid="5973">
    def test_explicit_conversions(self):

        # GH 8608
        # add/sub are overridden explicitly for Float/Int Index
        idx = self._holder(np.arange(5, dtype='int64'))

        # float conversions
        arr = np.arange(5, dtype='int64') * 3.2
        expected = Float64Index(arr)
        fidx = idx * 3.2
        tm.assert_index_equal(fidx, expected)
        fidx = 3.2 * idx
        tm.assert_index_equal(fidx, expected)

        # interops with numpy arrays
        expected = Float64Index(arr)
        a = np.zeros(5, dtype='float64')
        result = fidx - a
        tm.assert_index_equal(result, expected)

        expected = Float64Index(-arr)
        a = np.zeros(5, dtype='float64')
        result = a - fidx
        tm.assert_index_equal(result, expected)

</source>
<source file="pandas/pandas/tests/indexes/test_range.py.pyindent" startline="784" endline="808" pcid="6086">
    def test_explicit_conversions(self):

        # GH 8608
        # add/sub are overridden explicitly for Float/Int Index
        idx = RangeIndex(5)

        # float conversions
        arr = np.arange(5, dtype='int64') * 3.2
        expected = Float64Index(arr)
        fidx = idx * 3.2
        tm.assert_index_equal(fidx, expected)
        fidx = 3.2 * idx
        tm.assert_index_equal(fidx, expected)

        # interops with numpy arrays
        expected = Float64Index(arr)
        a = np.zeros(5, dtype='float64')
        result = fidx - a
        tm.assert_index_equal(result, expected)

        expected = Float64Index(-arr)
        a = np.zeros(5, dtype='float64')
        result = a - fidx
        tm.assert_index_equal(result, expected)

</source>
</class>

<class classid="127" nclones="2" nlines="12" similarity="100">
<source file="pandas/pandas/tests/indexes/test_numeric.py.pyindent" startline="499" endline="511" pcid="6009">
    def test_union_noncomparable(self):
        from datetime import datetime, timedelta
        # corner case, non-Int64Index
        now = datetime.now()
        other = Index([now + timedelta(i) for i in range(4)], dtype=object)
        result = self.index.union(other)
        expected = Index(np.concatenate((self.index, other)))
        tm.assert_index_equal(result, expected)

        result = other.union(self.index)
        expected = Index(np.concatenate((other, self.index)))
        tm.assert_index_equal(result, expected)

</source>
<source file="pandas/pandas/tests/indexes/test_range.py.pyindent" startline="669" endline="681" pcid="6075">
    def test_union_noncomparable(self):
        from datetime import datetime, timedelta
        # corner case, non-Int64Index
        now = datetime.now()
        other = Index([now + timedelta(i) for i in range(4)], dtype=object)
        result = self.index.union(other)
        expected = Index(np.concatenate((self.index, other)))
        tm.assert_index_equal(result, expected)

        result = other.union(self.index)
        expected = Index(np.concatenate((other, self.index)))
        tm.assert_index_equal(result, expected)

</source>
</class>

<class classid="128" nclones="2" nlines="30" similarity="80">
<source file="pandas/pandas/tests/indexes/test_numeric.py.pyindent" startline="533" endline="561" pcid="6014">
    def test_take_fill_value(self):
        # see gh-12631
        idx = self._holder([1, 2, 3], name='xxx')
        result = idx.take(np.array([1, 0, -1]))
        expected = self._holder([2, 1, 3], name='xxx')
        tm.assert_index_equal(result, expected)

        name = self._holder.__name__
        msg = ("Unable to fill values because "
               "{name} cannot contain NA").format(name=name)

        # fill_value=True
        with tm.assert_raises_regex(ValueError, msg):
            idx.take(np.array([1, 0, -1]), fill_value=True)

        # allow_fill=False
        result = idx.take(np.array([1, 0, -1]), allow_fill=False,
                          fill_value=True)
        expected = self._holder([2, 1, 3], name='xxx')
        tm.assert_index_equal(result, expected)

        with tm.assert_raises_regex(ValueError, msg):
            idx.take(np.array([1, 0, -2]), fill_value=True)
        with tm.assert_raises_regex(ValueError, msg):
            idx.take(np.array([1, 0, -5]), fill_value=True)

        with pytest.raises(IndexError):
            idx.take(np.array([1, -5]))

</source>
<source file="pandas/pandas/tests/indexes/test_range.py.pyindent" startline="744" endline="770" pcid="6082">
    def test_take_fill_value(self):
        # GH 12631
        idx = pd.RangeIndex(1, 4, name='xxx')
        result = idx.take(np.array([1, 0, -1]))
        expected = pd.Int64Index([2, 1, 3], name='xxx')
        tm.assert_index_equal(result, expected)

        # fill_value
        msg = "Unable to fill values because RangeIndex cannot contain NA"
        with tm.assert_raises_regex(ValueError, msg):
            idx.take(np.array([1, 0, -1]), fill_value=True)

        # allow_fill=False
        result = idx.take(np.array([1, 0, -1]), allow_fill=False,
                          fill_value=True)
        expected = pd.Int64Index([2, 1, 3], name='xxx')
        tm.assert_index_equal(result, expected)

        msg = "Unable to fill values because RangeIndex cannot contain NA"
        with tm.assert_raises_regex(ValueError, msg):
            idx.take(np.array([1, 0, -2]), fill_value=True)
        with tm.assert_raises_regex(ValueError, msg):
            idx.take(np.array([1, 0, -5]), fill_value=True)

        with pytest.raises(IndexError):
            idx.take(np.array([1, -5]))

</source>
</class>

<class classid="129" nclones="2" nlines="12" similarity="91">
<source file="pandas/pandas/tests/indexes/test_numeric.py.pyindent" startline="692" endline="703" pcid="6024">
    def test_intersection(self):
        other = Index([1, 2, 3, 4, 5])
        result = self.index.intersection(other)
        expected = Index(np.sort(np.intersect1d(self.index.values,
                                                other.values)))
        tm.assert_index_equal(result, expected)

        result = other.intersection(self.index)
        expected = Index(np.sort(np.asarray(np.intersect1d(self.index.values,
                                                           other.values))))
        tm.assert_index_equal(result, expected)

</source>
<source file="pandas/pandas/tests/indexes/test_numeric.py.pyindent" startline="929" endline="940" pcid="6034">
    def test_intersection(self):
        other = Index([2**63, 2**63 + 5, 2**63 + 10, 2**63 + 15, 2**63 + 20])
        result = self.index.intersection(other)
        expected = Index(np.sort(np.intersect1d(self.index.values,
                                                other.values)))
        tm.assert_index_equal(result, expected)

        result = other.intersection(self.index)
        expected = Index(np.sort(np.asarray(np.intersect1d(self.index.values,
                                                           other.values))))
        tm.assert_index_equal(result, expected)

</source>
</class>

<class classid="130" nclones="3" nlines="22" similarity="79">
<source file="pandas/pandas/tests/indexes/test_numeric.py.pyindent" startline="814" endline="840" pcid="6028">
    def test_join_non_int_index(self):
        other = Index([3, 6, 7, 8, 10], dtype=object)

        outer = self.index.join(other, how='outer')
        outer2 = other.join(self.index, how='outer')
        expected = Index([0, 2, 3, 4, 6, 7, 8, 10, 12, 14, 16, 18])
        tm.assert_index_equal(outer, outer2)
        tm.assert_index_equal(outer, expected)

        inner = self.index.join(other, how='inner')
        inner2 = other.join(self.index, how='inner')
        expected = Index([6, 8, 10])
        tm.assert_index_equal(inner, inner2)
        tm.assert_index_equal(inner, expected)

        left = self.index.join(other, how='left')
        tm.assert_index_equal(left, self.index.astype(object))

        left2 = other.join(self.index, how='left')
        tm.assert_index_equal(left2, other)

        right = self.index.join(other, how='right')
        tm.assert_index_equal(right, other)

        right2 = other.join(self.index, how='right')
        tm.assert_index_equal(right2, self.index.astype(object))

</source>
<source file="pandas/pandas/tests/indexes/test_range.py.pyindent" startline="551" endline="577" pcid="6071">
    def test_join_non_int_index(self):
        other = Index([3, 6, 7, 8, 10], dtype=object)

        outer = self.index.join(other, how='outer')
        outer2 = other.join(self.index, how='outer')
        expected = Index([0, 2, 3, 4, 6, 7, 8, 10, 12, 14, 16, 18])
        tm.assert_index_equal(outer, outer2)
        tm.assert_index_equal(outer, expected)

        inner = self.index.join(other, how='inner')
        inner2 = other.join(self.index, how='inner')
        expected = Index([6, 8, 10])
        tm.assert_index_equal(inner, inner2)
        tm.assert_index_equal(inner, expected)

        left = self.index.join(other, how='left')
        tm.assert_index_equal(left, self.index.astype(object))

        left2 = other.join(self.index, how='left')
        tm.assert_index_equal(left2, other)

        right = self.index.join(other, how='right')
        tm.assert_index_equal(right, other)

        right2 = other.join(self.index, how='right')
        tm.assert_index_equal(right2, self.index.astype(object))

</source>
<source file="pandas/pandas/tests/indexes/test_numeric.py.pyindent" startline="1066" endline="1094" pcid="6038">
    def test_join_non_int_index(self):
        other = Index(2**63 + np.array(
            [1, 5, 7, 10, 20], dtype='uint64'), dtype=object)

        outer = self.index.join(other, how='outer')
        outer2 = other.join(self.index, how='outer')
        expected = Index(2**63 + np.array(
            [0, 1, 5, 7, 10, 15, 20, 25], dtype='uint64'))
        tm.assert_index_equal(outer, outer2)
        tm.assert_index_equal(outer, expected)

        inner = self.index.join(other, how='inner')
        inner2 = other.join(self.index, how='inner')
        expected = Index(2**63 + np.array([10, 20], dtype='uint64'))
        tm.assert_index_equal(inner, inner2)
        tm.assert_index_equal(inner, expected)

        left = self.index.join(other, how='left')
        tm.assert_index_equal(left, self.index.astype(object))

        left2 = other.join(self.index, how='left')
        tm.assert_index_equal(left2, other)

        right = self.index.join(other, how='right')
        tm.assert_index_equal(right, other)

        right2 = other.join(self.index, how='right')
        tm.assert_index_equal(right2, self.index.astype(object))

</source>
</class>

<class classid="131" nclones="2" nlines="10" similarity="100">
<source file="pandas/pandas/tests/indexing/interval/test_interval.py.pyindent" startline="182" endline="195" pcid="6215">
    def test_non_unique(self):

        idx = IntervalIndex.from_tuples([(1, 3), (3, 7)])

        s = Series(range(len(idx)), index=idx)

        result = s.loc[Interval(1, 3)]
        assert result == 0

        result = s.loc[[Interval(1, 3)]]
        expected = s.iloc[0:1]
        tm.assert_series_equal(expected, result)

    # To be removed, replaced by test_interval_new.py (see #16316, #16386)
</source>
<source file="pandas/pandas/tests/indexing/interval/test_interval_new.py.pyindent" startline="216" endline="227" pcid="6225">
    def test_non_unique(self):

        idx = IntervalIndex.from_tuples([(1, 3), (3, 7)])
        s = Series(range(len(idx)), index=idx)

        result = s.loc[Interval(1, 3)]
        assert result == 0

        result = s.loc[[Interval(1, 3)]]
        expected = s.iloc[0:1]
        tm.assert_series_equal(expected, result)

</source>
</class>

<class classid="132" nclones="4" nlines="10" similarity="80">
<source file="pandas/pandas/tests/indexing/test_indexing.py.pyindent" startline="908" endline="915" pcid="6360">
    def test_coercion_with_setitem(self):
        for start_data, expected_result in self.EXPECTED_RESULTS:
            start_series = Series(start_data)
            start_series[0] = None

            expected_series = Series(expected_result)
            tm.assert_series_equal(start_series, expected_series)

</source>
<source file="pandas/pandas/tests/indexing/test_indexing.py.pyindent" startline="916" endline="923" pcid="6361">
    def test_coercion_with_loc_setitem(self):
        for start_data, expected_result in self.EXPECTED_RESULTS:
            start_series = Series(start_data)
            start_series.loc[0] = None

            expected_series = Series(expected_result)
            tm.assert_series_equal(start_series, expected_series)

</source>
<source file="pandas/pandas/tests/indexing/test_indexing.py.pyindent" startline="924" endline="931" pcid="6362">
    def test_coercion_with_setitem_and_series(self):
        for start_data, expected_result in self.EXPECTED_RESULTS:
            start_series = Series(start_data)
            start_series[start_series == start_series[0]] = None

            expected_series = Series(expected_result)
            tm.assert_series_equal(start_series, expected_series)

</source>
<source file="pandas/pandas/tests/indexing/test_indexing.py.pyindent" startline="932" endline="940" pcid="6363">
    def test_coercion_with_loc_and_series(self):
        for start_data, expected_result in self.EXPECTED_RESULTS:
            start_series = Series(start_data)
            start_series.loc[start_series == start_series[0]] = None

            expected_series = Series(expected_result)
            tm.assert_series_equal(start_series, expected_series)


</source>
</class>

<class classid="133" nclones="3" nlines="11" similarity="72">
<source file="pandas/pandas/tests/indexing/test_indexing.py.pyindent" startline="955" endline="962" pcid="6364">
    def test_coercion_with_loc(self):
        for start_data, expected_result, in self.EXPECTED_SINGLE_ROW_RESULTS:
            start_dataframe = DataFrame({'foo': start_data})
            start_dataframe.loc[0, ['foo']] = None

            expected_dataframe = DataFrame({'foo': expected_result})
            tm.assert_frame_equal(start_dataframe, expected_dataframe)

</source>
<source file="pandas/pandas/tests/indexing/test_indexing.py.pyindent" startline="963" endline="971" pcid="6365">
    def test_coercion_with_setitem_and_dataframe(self):
        for start_data, expected_result, in self.EXPECTED_SINGLE_ROW_RESULTS:
            start_dataframe = DataFrame({'foo': start_data})
            start_dataframe[start_dataframe['foo'] == start_dataframe['foo'][
                0]] = None

            expected_dataframe = DataFrame({'foo': expected_result})
            tm.assert_frame_equal(start_dataframe, expected_dataframe)

</source>
<source file="pandas/pandas/tests/indexing/test_indexing.py.pyindent" startline="972" endline="980" pcid="6366">
    def test_none_coercion_loc_and_dataframe(self):
        for start_data, expected_result, in self.EXPECTED_SINGLE_ROW_RESULTS:
            start_dataframe = DataFrame({'foo': start_data})
            start_dataframe.loc[start_dataframe['foo'] == start_dataframe[
                'foo'][0]] = None

            expected_dataframe = DataFrame({'foo': expected_result})
            tm.assert_frame_equal(start_dataframe, expected_dataframe)

</source>
</class>

<class classid="134" nclones="2" nlines="36" similarity="83">
<source file="pandas/pandas/tests/indexing/test_scalar.py.pyindent" startline="15" endline="41" pcid="6503">
    def test_at_and_iat_get(self):
        def _check(f, func, values=False):

            if f is not None:
                indicies = self.generate_indices(f, values)
                for i in indicies:
                    result = getattr(f, func)[i]
                    expected = self.get_value(f, i, values)
                    tm.assert_almost_equal(result, expected)

        for o in self._objs:

            d = getattr(self, o)

            # iat
            for f in [d['ints'], d['uints']]:
                _check(f, 'iat', values=True)

            for f in [d['labels'], d['ts'], d['floats']]:
                if f is not None:
                    pytest.raises(ValueError, self.check_values, f, 'iat')

            # at
            for f in [d['ints'], d['uints'], d['labels'],
                      d['ts'], d['floats']]:
                _check(f, 'at')

</source>
<source file="pandas/pandas/tests/indexing/test_scalar.py.pyindent" startline="42" endline="68" pcid="6505">
    def test_at_and_iat_set(self):
        def _check(f, func, values=False):

            if f is not None:
                indicies = self.generate_indices(f, values)
                for i in indicies:
                    getattr(f, func)[i] = 1
                    expected = self.get_value(f, i, values)
                    tm.assert_almost_equal(expected, 1)

        for t in self._objs:

            d = getattr(self, t)

            # iat
            for f in [d['ints'], d['uints']]:
                _check(f, 'iat', values=True)

            for f in [d['labels'], d['ts'], d['floats']]:
                if f is not None:
                    pytest.raises(ValueError, _check, f, 'iat')

            # at
            for f in [d['ints'], d['uints'], d['labels'],
                      d['ts'], d['floats']]:
                _check(f, 'at')

</source>
</class>

<class classid="135" nclones="2" nlines="13" similarity="92">
<source file="pandas/pandas/tests/io/formats/test_css.py.pyindent" startline="147" endline="155" pcid="6530">
def test_css_absolute_font_size(size, relative_to, resolved):
    if relative_to is None:
        inherited = None
    else:
        inherited = {'font-size': relative_to}
    assert_resolves('font-size: {size}'.format(size=size),
                    {'font-size': resolved}, inherited=inherited)


</source>
<source file="pandas/pandas/tests/io/formats/test_css.py.pyindent" startline="180" endline="186" pcid="6531">
def test_css_relative_font_size(size, relative_to, resolved):
    if relative_to is None:
        inherited = None
    else:
        inherited = {'font-size': relative_to}
    assert_resolves('font-size: {size}'.format(size=size),
                    {'font-size': resolved}, inherited=inherited)
</source>
</class>

<class classid="136" nclones="2" nlines="29" similarity="82">
<source file="pandas/pandas/tests/io/formats/test_to_csv.py.pyindent" startline="325" endline="353" pcid="6555">
    def test_to_csv_compression(self, compression_only,
                                read_infer, to_infer):
        # see gh-15008
        compression = compression_only

        if compression == "zip":
            pytest.skip("{compression} is not supported "
                        "for to_csv".format(compression=compression))

        # We'll complete file extension subsequently.
        filename = "test."

        if compression == "gzip":
            filename += "gz"
        else:
            # xz --> .xz
            # bz2 --> .bz2
            filename += compression

        df = DataFrame({"A": [1]})

        to_compression = "infer" if to_infer else compression
        read_compression = "infer" if read_infer else compression

        with tm.ensure_clean(filename) as path:
            df.to_csv(path, compression=to_compression)
            result = pd.read_csv(path, index_col=0,
                                 compression=read_compression)
            tm.assert_frame_equal(result, df)
</source>
<source file="pandas/pandas/tests/io/json/test_compression.py.pyindent" startline="97" endline="124" pcid="6601">
def test_to_json_compression(compression_only,
                             read_infer, to_infer):
    # see gh-15008
    compression = compression_only

    if compression == "zip":
        pytest.skip("{compression} is not supported "
                    "for to_csv".format(compression=compression))

    # We'll complete file extension subsequently.
    filename = "test."

    if compression == "gzip":
        filename += "gz"
    else:
        # xz --> .xz
        # bz2 --> .bz2
        filename += compression

    df = pd.DataFrame({"A": [1]})

    to_compression = "infer" if to_infer else compression
    read_compression = "infer" if read_infer else compression

    with tm.ensure_clean(filename) as path:
        df.to_json(path, compression=to_compression)
        result = pd.read_json(path, compression=read_compression)
        tm.assert_frame_equal(result, df)
</source>
</class>

<class classid="137" nclones="2" nlines="103" similarity="85">
<source file="pandas/pandas/tests/io/formats/test_to_html.py.pyindent" startline="198" endline="307" pcid="6564">
    def test_to_html_multiindex_sparsify_false_multi_sparse(self):
        with option_context('display.multi_sparse', False):
            index = MultiIndex.from_arrays([[0, 0, 1, 1], [0, 1, 0, 1]],
                                           names=['foo', None])

            df = DataFrame([[0, 1], [2, 3], [4, 5], [6, 7]], index=index)

            result = df.to_html()
            expected = """\
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>0</th>
      <th>1</th>
    </tr>
    <tr>
      <th>foo</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <th>0</th>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>0</th>
      <th>1</th>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>1</th>
      <th>0</th>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <th>1</th>
      <th>1</th>
      <td>6</td>
      <td>7</td>
    </tr>
  </tbody>
</table>"""

            assert result == expected

            df = DataFrame([[0, 1], [2, 3], [4, 5], [6, 7]],
                           columns=index[::2], index=index)

            result = df.to_html()
            expected = """\
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>foo</th>
      <th>0</th>
      <th>1</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>0</th>
      <th>0</th>
    </tr>
    <tr>
      <th>foo</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <th>0</th>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>0</th>
      <th>1</th>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>1</th>
      <th>0</th>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <th>1</th>
      <th>1</th>
      <td>6</td>
      <td>7</td>
    </tr>
  </tbody>
</table>"""

            assert result == expected

</source>
<source file="pandas/pandas/tests/io/formats/test_to_html.py.pyindent" startline="308" endline="411" pcid="6565">
    def test_to_html_multiindex_sparsify(self):
        index = MultiIndex.from_arrays([[0, 0, 1, 1], [0, 1, 0, 1]],
                                       names=['foo', None])

        df = DataFrame([[0, 1], [2, 3], [4, 5], [6, 7]], index=index)

        result = df.to_html()
        expected = """<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>0</th>
      <th>1</th>
    </tr>
    <tr>
      <th>foo</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">0</th>
      <th>0</th>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">1</th>
      <th>0</th>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <th>1</th>
      <td>6</td>
      <td>7</td>
    </tr>
  </tbody>
</table>"""

        assert result == expected

        df = DataFrame([[0, 1], [2, 3], [4, 5], [6, 7]], columns=index[::2],
                       index=index)

        result = df.to_html()
        expected = """\
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>foo</th>
      <th>0</th>
      <th>1</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>0</th>
      <th>0</th>
    </tr>
    <tr>
      <th>foo</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">0</th>
      <th>0</th>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">1</th>
      <th>0</th>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <th>1</th>
      <td>6</td>
      <td>7</td>
    </tr>
  </tbody>
</table>"""

        assert result == expected

</source>
</class>

<class classid="138" nclones="2" nlines="30" similarity="73">
<source file="pandas/pandas/tests/io/formats/test_to_html.py.pyindent" startline="1001" endline="1028" pcid="6568">
    def test_to_html_datetime64_monthformatter(self):
        months = [datetime(2016, 1, 1), datetime(2016, 2, 2)]
        x = DataFrame({'months': months})

        def format_func(x):
            return x.strftime('%Y-%m')
        result = x.to_html(formatters={'months': format_func})
        expected = """\
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>months</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2016-01</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2016-02</td>
    </tr>
  </tbody>
</table>"""
        assert result == expected

</source>
<source file="pandas/pandas/tests/io/formats/test_to_html.py.pyindent" startline="1029" endline="1057" pcid="6570">
    def test_to_html_datetime64_hourformatter(self):

        x = DataFrame({'hod': pd.to_datetime(['10:10:10.100', '12:12:12.120'],
                                             format='%H:%M:%S.%f')})

        def format_func(x):
            return x.strftime('%H:%M')
        result = x.to_html(formatters={'hod': format_func})
        expected = """\
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>hod</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>10:10</td>
    </tr>
    <tr>
      <th>1</th>
      <td>12:12</td>
    </tr>
  </tbody>
</table>"""
        assert result == expected

</source>
</class>

<class classid="139" nclones="2" nlines="117" similarity="86">
<source file="pandas/pandas/tests/io/formats/test_to_html.py.pyindent" startline="1169" endline="1285" pcid="6574">
    def test_to_html_truncate_multi_index(self):
        pytest.skip("unreliable on travis")
        arrays = [['bar', 'bar', 'baz', 'baz', 'foo', 'foo', 'qux', 'qux'],
                  ['one', 'two', 'one', 'two', 'one', 'two', 'one', 'two']]
        df = DataFrame(index=arrays, columns=arrays)
        fmt.set_option('display.max_rows', 7)
        fmt.set_option('display.max_columns', 7)
        result = df._repr_html_()
        expected = '''\
<div{0}>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th colspan="2" halign="left">bar</th>
      <th>baz</th>
      <th>...</th>
      <th>foo</th>
      <th colspan="2" halign="left">qux</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>one</th>
      <th>two</th>
      <th>one</th>
      <th>...</th>
      <th>two</th>
      <th>one</th>
      <th>two</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">bar</th>
      <th>one</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>two</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>baz</th>
      <th>one</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>...</th>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>foo</th>
      <th>two</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">qux</th>
      <th>one</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>two</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
<p>8 rows × 8 columns</p>
</div>'''.format(div_style)
        if compat.PY2:
            expected = expected.decode('utf-8')
        assert result == expected

</source>
<source file="pandas/pandas/tests/io/formats/test_to_html.py.pyindent" startline="1286" endline="1396" pcid="6575">
    def test_to_html_truncate_multi_index_sparse_off(self):
        pytest.skip("unreliable on travis")
        arrays = [['bar', 'bar', 'baz', 'baz', 'foo', 'foo', 'qux', 'qux'],
                  ['one', 'two', 'one', 'two', 'one', 'two', 'one', 'two']]
        df = DataFrame(index=arrays, columns=arrays)
        fmt.set_option('display.max_rows', 7)
        fmt.set_option('display.max_columns', 7)
        fmt.set_option('display.multi_sparse', False)
        result = df._repr_html_()
        expected = '''\
<div{0}>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>bar</th>
      <th>bar</th>
      <th>baz</th>
      <th>...</th>
      <th>foo</th>
      <th>qux</th>
      <th>qux</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>one</th>
      <th>two</th>
      <th>one</th>
      <th>...</th>
      <th>two</th>
      <th>one</th>
      <th>two</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>bar</th>
      <th>one</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>bar</th>
      <th>two</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>baz</th>
      <th>one</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>foo</th>
      <th>two</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>qux</th>
      <th>one</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>qux</th>
      <th>two</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
<p>8 rows × 8 columns</p>
</div>'''.format(div_style)
        if compat.PY2:
            expected = expected.decode('utf-8')
        assert result == expected

</source>
</class>

<class classid="140" nclones="2" nlines="18" similarity="72">
<source file="pandas/pandas/tests/io/json/test_normalize.py.pyindent" startline="81" endline="99" pcid="6649">
    def test_simple_normalize(self, state_data):
        result = json_normalize(state_data[0], 'counties')
        expected = DataFrame(state_data[0]['counties'])
        tm.assert_frame_equal(result, expected)

        result = json_normalize(state_data, 'counties')

        expected = []
        for rec in state_data:
            expected.extend(rec['counties'])
        expected = DataFrame(expected)

        tm.assert_frame_equal(result, expected)

        result = json_normalize(state_data, 'counties', meta='state')
        expected['state'] = np.array(['Florida', 'Ohio']).repeat([3, 2])

        tm.assert_frame_equal(result, expected)

</source>
<source file="pandas/pandas/tests/io/json/test_normalize.py.pyindent" startline="208" endline="225" pcid="6657">
    def test_record_prefix(self, state_data):
        result = json_normalize(state_data[0], 'counties')
        expected = DataFrame(state_data[0]['counties'])
        tm.assert_frame_equal(result, expected)

        result = json_normalize(state_data, 'counties',
                                meta='state',
                                record_prefix='county_')

        expected = []
        for rec in state_data:
            expected.extend(rec['counties'])
        expected = DataFrame(expected)
        expected = expected.rename(columns=lambda x: 'county_' + x)
        expected['state'] = np.array(['Florida', 'Ohio']).repeat([3, 2])

        tm.assert_frame_equal(result, expected)

</source>
</class>

<class classid="141" nclones="2" nlines="26" similarity="81">
<source file="pandas/pandas/tests/io/json/test_normalize.py.pyindent" startline="386" endline="413" pcid="6665">
    def test_nonetype_top_level_bottom_level(self):
        # GH21158: If inner level json has a key with a null value
        # make sure it doesnt do a new_d.pop twice and except
        data = {
            "id": None,
            "location": {
                "country": {
                    "state": {
                        "id": None,
                        "town.info": {
                            "id": None,
                            "region": None,
                            "x": 49.151580810546875,
                            "y": -33.148521423339844,
                            "z": 27.572303771972656}}}
            }
        }
        result = nested_to_record(data)
        expected = {
            'id': None,
            'location.country.state.id': None,
            'location.country.state.town.info.id': None,
            'location.country.state.town.info.region': None,
            'location.country.state.town.info.x': 49.151580810546875,
            'location.country.state.town.info.y': -33.148521423339844,
            'location.country.state.town.info.z': 27.572303771972656}
        assert result == expected

</source>
<source file="pandas/pandas/tests/io/json/test_normalize.py.pyindent" startline="414" endline="442" pcid="6666">
    def test_nonetype_multiple_levels(self):
        # GH21158: If inner level json has a key with a null value
        # make sure it doesnt do a new_d.pop twice and except
        data = {
            "id": None,
            "location": {
                "id": None,
                "country": {
                    "id": None,
                    "state": {
                        "id": None,
                        "town.info": {
                            "region": None,
                            "x": 49.151580810546875,
                            "y": -33.148521423339844,
                            "z": 27.572303771972656}}}
            }
        }
        result = nested_to_record(data)
        expected = {
            'id': None,
            'location.id': None,
            'location.country.id': None,
            'location.country.state.id': None,
            'location.country.state.town.info.region': None,
            'location.country.state.town.info.x': 49.151580810546875,
            'location.country.state.town.info.y': -33.148521423339844,
            'location.country.state.town.info.z': 27.572303771972656}
        assert result == expected
</source>
</class>

<class classid="142" nclones="3" nlines="14" similarity="73">
<source file="pandas/pandas/tests/io/parser/comment.py.pyindent" startline="57" endline="70" pcid="6751">
    def test_comment_skiprows(self):
        data = """# empty
random line
# second empty line
1,2,3
A,B,C
1,2.,4.
5.,NaN,10.0
"""
        # this should ignore the first four lines (including comments)
        expected = np.array([[1., 2., 4.], [5., np.nan, 10.]])
        df = self.read_csv(StringIO(data), comment='#', skiprows=4)
        tm.assert_numpy_array_equal(df.values, expected)

</source>
<source file="pandas/pandas/tests/io/parser/comment.py.pyindent" startline="84" endline="100" pcid="6753">
    def test_comment_skiprows_header(self):
        data = """# empty
# second empty line
# third empty line
X,Y,Z
1,2,3
A,B,C
1,2.,4.
5.,NaN,10.0
"""
        # skiprows should skip the first 4 lines (including comments), while
        # header should start from the second non-commented line starting
        # with line 5
        expected = np.array([[1., 2., 4.], [5., np.nan, 10.]])
        df = self.read_csv(StringIO(data), comment='#', skiprows=4, header=1)
        tm.assert_numpy_array_equal(df.values, expected)

</source>
<source file="pandas/pandas/tests/io/parser/comment.py.pyindent" startline="71" endline="83" pcid="6752">
    def test_comment_header(self):
        data = """# empty
# second empty line
1,2,3
A,B,C
1,2.,4.
5.,NaN,10.0
"""
        # header should begin at the second non-comment line
        expected = np.array([[1., 2., 4.], [5., np.nan, 10.]])
        df = self.read_csv(StringIO(data), comment='#', header=1)
        tm.assert_numpy_array_equal(df.values, expected)

</source>
</class>

<class classid="143" nclones="2" nlines="12" similarity="76">
<source file="pandas/pandas/tests/io/parser/converters.py.pyindent" startline="61" endline="72" pcid="6764">
    def test_converters_euro_decimal_format(self):
        data = """Id;Number1;Number2;Text1;Text2;Number3
1;1521,1541;187101,9543;ABC;poi;4,738797819
2;121,12;14897,76;DEF;uyt;0,377320872
3;878,158;108013,434;GHI;rez;2,735694704"""
        f = lambda x: float(x.replace(",", "."))
        converter = {'Number1': f, 'Number2': f, 'Number3': f}
        df2 = self.read_csv(StringIO(data), sep=';', converters=converter)
        assert df2['Number1'].dtype == float
        assert df2['Number2'].dtype == float
        assert df2['Number3'].dtype == float

</source>
<source file="pandas/pandas/tests/io/parser/converters.py.pyindent" startline="73" endline="83" pcid="6765">
    def test_converter_return_string_bug(self):
        # see gh-583
        data = """Id;Number1;Number2;Text1;Text2;Number3
1;1521,1541;187101,9543;ABC;poi;4,738797819
2;121,12;14897,76;DEF;uyt;0,377320872
3;878,158;108013,434;GHI;rez;2,735694704"""
        f = lambda x: float(x.replace(",", "."))
        converter = {'Number1': f, 'Number2': f, 'Number3': f}
        df2 = self.read_csv(StringIO(data), sep=';', converters=converter)
        assert df2['Number1'].dtype == float

</source>
</class>

<class classid="144" nclones="2" nlines="18" similarity="94">
<source file="pandas/pandas/tests/io/parser/converters.py.pyindent" startline="96" endline="107" pcid="6767">
        def convert_days(x):
            x = x.strip()
            if not x:
                return np.nan

            is_plus = x.endswith('+')
            if is_plus:
                x = int(x[:-1]) + 1
            else:
                x = int(x)
            return x

</source>
<source file="pandas/pandas/tests/io/parser/converters.py.pyindent" startline="108" endline="119" pcid="6768">
        def convert_days_sentinel(x):
            x = x.strip()
            if not x:
                return np.nan

            is_plus = x.endswith('+')
            if is_plus:
                x = int(x[:-1]) + 1
            else:
                x = int(x)
            return x

</source>
</class>

<class classid="145" nclones="2" nlines="18" similarity="75">
<source file="pandas/pandas/tests/io/parser/header.py.pyindent" startline="28" endline="41" pcid="6824">
    def test_bool_header_arg(self):
        # see gh-6114
        data = """\
MyColumn
   a
   b
   a
   b"""
        for arg in [True, False]:
            with pytest.raises(TypeError):
                self.read_csv(StringIO(data), header=arg)
            with pytest.raises(TypeError):
                self.read_table(StringIO(data), header=arg)

</source>
<source file="pandas/pandas/tests/io/parser/test_read_fwf.py.pyindent" startline="239" endline="250" pcid="6903">
    def test_bool_header_arg(self):
        # see gh-6114
        data = """\
MyColumn
   a
   b
   a
   b"""
        for arg in [True, False]:
            with pytest.raises(TypeError):
                read_fwf(StringIO(data), header=arg)

</source>
</class>

<class classid="146" nclones="2" nlines="12" similarity="75">
<source file="pandas/pandas/tests/io/parser/python_parser_only.py.pyindent" startline="92" endline="101" pcid="6853">
    def test_BytesIO_input(self):
        if not compat.PY3:
            pytest.skip(
                "Bytes-related test - only needs to work on Python 3")

        data = BytesIO("שלום::1234\n562::123".encode('cp1255'))
        result = self.read_table(data, sep="::", encoding='cp1255')
        expected = DataFrame([[562, 123]], columns=["שלום", "1234"])
        tm.assert_frame_equal(result, expected)

</source>
<source file="pandas/pandas/tests/io/parser/test_read_fwf.py.pyindent" startline="77" endline="86" pcid="6894">
    def test_BytesIO_input(self):
        if not compat.PY3:
            pytest.skip(
                "Bytes-related test - only needs to work on Python 3")

        result = read_fwf(BytesIO("שלום\nשלום".encode('utf8')), widths=[
            2, 2], encoding='utf8')
        expected = DataFrame([["של", "ום"]], columns=["של", "ום"])
        tm.assert_frame_equal(result, expected)

</source>
</class>

<class classid="147" nclones="2" nlines="22" similarity="70">
<source file="pandas/pandas/tests/io/parser/skiprows.py.pyindent" startline="21" endline="46" pcid="6871">
    def test_skiprows_bug(self):
        # see gh-505
        text = """#foo,a,b,c
#foo,a,b,c
#foo,a,b,c
#foo,a,b,c
#foo,a,b,c
#foo,a,b,c
1/1/2000,1.,2.,3.
1/2/2000,4,5,6
1/3/2000,7,8,9
"""
        data = self.read_csv(StringIO(text), skiprows=lrange(6), header=None,
                             index_col=0, parse_dates=True)

        data2 = self.read_csv(StringIO(text), skiprows=6, header=None,
                              index_col=0, parse_dates=True)

        expected = DataFrame(np.arange(1., 10.).reshape((3, 3)),
                             columns=[1, 2, 3],
                             index=[datetime(2000, 1, 1), datetime(2000, 1, 2),
                                    datetime(2000, 1, 3)])
        expected.index.name = 0
        tm.assert_frame_equal(data, expected)
        tm.assert_frame_equal(data, data2)

</source>
<source file="pandas/pandas/tests/io/parser/skiprows.py.pyindent" startline="57" endline="78" pcid="6873">
    def test_skiprows_blank(self):
        # see gh-9832
        text = """#foo,a,b,c
#foo,a,b,c

#foo,a,b,c
#foo,a,b,c

1/1/2000,1.,2.,3.
1/2/2000,4,5,6
1/3/2000,7,8,9
"""
        data = self.read_csv(StringIO(text), skiprows=6, header=None,
                             index_col=0, parse_dates=True)

        expected = DataFrame(np.arange(1., 10.).reshape((3, 3)),
                             columns=[1, 2, 3],
                             index=[datetime(2000, 1, 1), datetime(2000, 1, 2),
                                    datetime(2000, 1, 3)])
        expected.index.name = 0
        tm.assert_frame_equal(data, expected)

</source>
</class>

<class classid="148" nclones="3" nlines="11" similarity="90">
<source file="pandas/pandas/tests/io/parser/test_parsers.py.pyindent" startline="69" endline="77" pcid="6885">
    def read_table(self, *args, **kwds):
        kwds = kwds.copy()
        kwds['engine'] = self.engine
        kwds['low_memory'] = self.low_memory
        with tm.assert_produces_warning(FutureWarning):
            df = read_table(*args, **kwds)
        return df


</source>
<source file="pandas/pandas/tests/io/parser/test_parsers.py.pyindent" startline="89" endline="97" pcid="6887">
    def read_table(self, *args, **kwds):
        kwds = kwds.copy()
        kwds['engine'] = self.engine
        kwds['low_memory'] = True
        with tm.assert_produces_warning(FutureWarning):
            df = read_table(*args, **kwds)
        return df


</source>
<source file="pandas/pandas/tests/io/parser/test_parsers.py.pyindent" startline="107" endline="114" pcid="6889">
    def read_table(self, *args, **kwds):
        kwds = kwds.copy()
        kwds['engine'] = self.engine
        with tm.assert_produces_warning(FutureWarning):
            df = read_table(*args, **kwds)
        return df


</source>
</class>

<class classid="149" nclones="2" nlines="18" similarity="72">
<source file="pandas/pandas/tests/io/parser/test_read_fwf.py.pyindent" startline="87" endline="102" pcid="6895">
    def test_fwf_colspecs_is_list_or_tuple(self):
        data = """index,A,B,C,D
foo,2,3,4,5
bar,7,8,9,10
baz,12,13,14,15
qux,12,13,14,15
foo2,12,13,14,15
bar2,12,13,14,15
"""

        with tm.assert_raises_regex(TypeError,
                                    'column specifications must '
                                    'be a list or tuple.+'):
            pd.io.parsers.FixedWidthReader(StringIO(data),
                                           {'a': 1}, ',', '#')

</source>
<source file="pandas/pandas/tests/io/parser/test_read_fwf.py.pyindent" startline="103" endline="117" pcid="6896">
    def test_fwf_colspecs_is_list_or_tuple_of_two_element_tuples(self):
        data = """index,A,B,C,D
foo,2,3,4,5
bar,7,8,9,10
baz,12,13,14,15
qux,12,13,14,15
foo2,12,13,14,15
bar2,12,13,14,15
"""

        with tm.assert_raises_regex(TypeError,
                                    'Each column specification '
                                    'must be.+'):
            read_fwf(StringIO(data), [('a', 1)])

</source>
</class>

<class classid="150" nclones="2" nlines="14" similarity="71">
<source file="pandas/pandas/tests/io/parser/test_read_fwf.py.pyindent" startline="251" endline="264" pcid="6904">
    def test_full_file(self):
        # File with all values
        test = """index                             A    B    C
2000-01-03T00:00:00  0.980268513777    3  foo
2000-01-04T00:00:00  1.04791624281    -4  bar
2000-01-05T00:00:00  0.498580885705   73  baz
2000-01-06T00:00:00  1.12020151869     1  foo
2000-01-07T00:00:00  0.487094399463    0  bar
2000-01-10T00:00:00  0.836648671666    2  baz
2000-01-11T00:00:00  0.157160753327   34  foo"""
        colspecs = ((0, 19), (21, 35), (38, 40), (42, 45))
        expected = read_fwf(StringIO(test), colspecs=colspecs)
        tm.assert_frame_equal(expected, read_fwf(StringIO(test)))

</source>
<source file="pandas/pandas/tests/io/parser/test_read_fwf.py.pyindent" startline="265" endline="278" pcid="6905">
    def test_full_file_with_missing(self):
        # File with missing values
        test = """index                             A    B    C
2000-01-03T00:00:00  0.980268513777    3  foo
2000-01-04T00:00:00  1.04791624281    -4  bar
                     0.498580885705   73  baz
2000-01-06T00:00:00  1.12020151869     1  foo
2000-01-07T00:00:00                    0  bar
2000-01-10T00:00:00  0.836648671666    2  baz
                                      34"""
        colspecs = ((0, 19), (21, 35), (38, 40), (42, 45))
        expected = read_fwf(StringIO(test), colspecs=colspecs)
        tm.assert_frame_equal(expected, read_fwf(StringIO(test)))

</source>
</class>

<class classid="151" nclones="2" nlines="21" similarity="90">
<source file="pandas/pandas/tests/io/parser/usecols.py.pyindent" startline="263" endline="288" pcid="6965">
    def test_usecols_with_parse_dates_and_full_names(self):
        # See gh-9755
        s = """0,1,20140101,0900,4
        0,1,20140102,1000,4"""
        parse_dates = [[1, 2]]
        names = list('abcde')

        cols = {
            'a': [0, 0],
            'c_d': [
                Timestamp('2014-01-01 09:00:00'),
                Timestamp('2014-01-02 10:00:00')
            ]
        }
        expected = DataFrame(cols, columns=['c_d', 'a'])

        df = self.read_csv(StringIO(s), names=names,
                           usecols=[0, 2, 3],
                           parse_dates=parse_dates)
        tm.assert_frame_equal(df, expected)

        df = self.read_csv(StringIO(s), names=names,
                           usecols=[3, 0, 2],
                           parse_dates=parse_dates)
        tm.assert_frame_equal(df, expected)

</source>
<source file="pandas/pandas/tests/io/parser/usecols.py.pyindent" startline="289" endline="314" pcid="6966">
    def test_usecols_with_parse_dates_and_usecol_names(self):
        # See gh-9755
        s = """0,1,20140101,0900,4
        0,1,20140102,1000,4"""
        parse_dates = [[1, 2]]
        names = list('acd')

        cols = {
            'a': [0, 0],
            'c_d': [
                Timestamp('2014-01-01 09:00:00'),
                Timestamp('2014-01-02 10:00:00')
            ]
        }
        expected = DataFrame(cols, columns=['c_d', 'a'])

        df = self.read_csv(StringIO(s), names=names,
                           usecols=[0, 2, 3],
                           parse_dates=parse_dates)
        tm.assert_frame_equal(df, expected)

        df = self.read_csv(StringIO(s), names=names,
                           usecols=[3, 0, 2],
                           parse_dates=parse_dates)
        tm.assert_frame_equal(df, expected)

</source>
</class>

<class classid="152" nclones="4" nlines="17" similarity="70">
<source file="pandas/pandas/tests/io/parser/usecols.py.pyindent" startline="315" endline="336" pcid="6967">
    def test_usecols_with_unicode_strings(self):
        # see gh-13219

        s = '''AAA,BBB,CCC,DDD
        0.056674973,8,True,a
        2.613230982,2,False,b
        3.568935038,7,False,a
        '''

        data = {
            'AAA': {
                0: 0.056674972999999997,
                1: 2.6132309819999997,
                2: 3.5689350380000002
            },
            'BBB': {0: 8, 1: 2, 2: 7}
        }
        expected = DataFrame(data)

        df = self.read_csv(StringIO(s), usecols=[u'AAA', u'BBB'])
        tm.assert_frame_equal(df, expected)

</source>
<source file="pandas/pandas/tests/io/parser/usecols.py.pyindent" startline="337" endline="358" pcid="6968">
    def test_usecols_with_single_byte_unicode_strings(self):
        # see gh-13219

        s = '''A,B,C,D
        0.056674973,8,True,a
        2.613230982,2,False,b
        3.568935038,7,False,a
        '''

        data = {
            'A': {
                0: 0.056674972999999997,
                1: 2.6132309819999997,
                2: 3.5689350380000002
            },
            'B': {0: 8, 1: 2, 2: 7}
        }
        expected = DataFrame(data)

        df = self.read_csv(StringIO(s), usecols=[u'A', u'B'])
        tm.assert_frame_equal(df, expected)

</source>
<source file="pandas/pandas/tests/io/parser/usecols.py.pyindent" startline="372" endline="390" pcid="6970">
    def test_usecols_with_multibyte_characters(self):
        s = '''あああ,いい,ううう,ええええ
        0.056674973,8,True,a
        2.613230982,2,False,b
        3.568935038,7,False,a
        '''
        data = {
            'あああ': {
                0: 0.056674972999999997,
                1: 2.6132309819999997,
                2: 3.5689350380000002
            },
            'いい': {0: 8, 1: 2, 2: 7}
        }
        expected = DataFrame(data)

        df = self.read_csv(StringIO(s), usecols=['あああ', 'いい'])
        tm.assert_frame_equal(df, expected)

</source>
<source file="pandas/pandas/tests/io/parser/usecols.py.pyindent" startline="391" endline="411" pcid="6971">
    def test_usecols_with_multibyte_unicode_characters(self):
        pytest.skip('TODO: see gh-13253')

        s = '''あああ,いい,ううう,ええええ
        0.056674973,8,True,a
        2.613230982,2,False,b
        3.568935038,7,False,a
        '''
        data = {
            'あああ': {
                0: 0.056674972999999997,
                1: 2.6132309819999997,
                2: 3.5689350380000002
            },
            'いい': {0: 8, 1: 2, 2: 7}
        }
        expected = DataFrame(data)

        df = self.read_csv(StringIO(s), usecols=[u'あああ', u'いい'])
        tm.assert_frame_equal(df, expected)

</source>
</class>

<class classid="153" nclones="3" nlines="15" similarity="73">
<source file="pandas/pandas/tests/io/sas/test_sas7bdat.py.pyindent" startline="39" endline="47" pcid="6980">
    def test_from_file(self):
        for j in 0, 1:
            df0 = self.data[j]
            for k in self.test_ix[j]:
                fname = os.path.join(
                    self.dirpath, "test{k}.sas7bdat".format(k=k))
                df = pd.read_sas(fname, encoding='utf-8')
                tm.assert_frame_equal(df, df0)

</source>
<source file="pandas/pandas/tests/io/sas/test_sas7bdat.py.pyindent" startline="88" endline="97" pcid="6984">
    def test_path_localpath(self):
        from py.path import local as LocalPath
        for j in 0, 1:
            df0 = self.data[j]
            for k in self.test_ix[j]:
                fname = LocalPath(os.path.join(
                    self.dirpath, "test{k}.sas7bdat".format(k=k)))
                df = pd.read_sas(fname, encoding='utf-8')
                tm.assert_frame_equal(df, df0)

</source>
<source file="pandas/pandas/tests/io/sas/test_sas7bdat.py.pyindent" startline="77" endline="86" pcid="6983">
    def test_path_pathlib(self):
        from pathlib import Path
        for j in 0, 1:
            df0 = self.data[j]
            for k in self.test_ix[j]:
                fname = Path(os.path.join(
                    self.dirpath, "test{k}.sas7bdat".format(k=k)))
                df = pd.read_sas(fname, encoding='utf-8')
                tm.assert_frame_equal(df, df0)

</source>
</class>

<class classid="154" nclones="2" nlines="11" similarity="90">
<source file="pandas/pandas/tests/io/test_excel.py.pyindent" startline="2097" endline="2104" pcid="7124">
    def test_write_append_mode_raises(self, merge_cells, ext, engine):
        msg = "Append mode is not supported with xlwt!"

        with ensure_clean(ext) as f:
            with tm.assert_raises_regex(ValueError, msg):
                ExcelWriter(f, engine=engine, mode='a')


</source>
<source file="pandas/pandas/tests/io/test_excel.py.pyindent" startline="2155" endline="2162" pcid="7126">
    def test_write_append_mode_raises(self, merge_cells, ext, engine):
        msg = "Append mode is not supported with xlsxwriter!"

        with ensure_clean(ext) as f:
            with tm.assert_raises_regex(ValueError, msg):
                ExcelWriter(f, engine=engine, mode='a')


</source>
</class>

<class classid="155" nclones="2" nlines="12" similarity="75">
<source file="pandas/pandas/tests/io/test_parquet.py.pyindent" startline="50" endline="57" pcid="7168">
def pa_lt_070():
    if not _HAVE_PYARROW:
        pytest.skip("pyarrow is not installed")
    if LooseVersion(pyarrow.__version__) >= LooseVersion('0.7.0'):
        pytest.skip("pyarrow is >= 0.7.0")
    return 'pyarrow'


</source>
<source file="pandas/pandas/tests/io/test_parquet.py.pyindent" startline="59" endline="66" pcid="7169">
def pa_ge_070():
    if not _HAVE_PYARROW:
        pytest.skip("pyarrow is not installed")
    if LooseVersion(pyarrow.__version__) < LooseVersion('0.7.0'):
        pytest.skip("pyarrow is < 0.7.0")
    return 'pyarrow'


</source>
</class>

<class classid="156" nclones="2" nlines="11" similarity="72">
<source file="pandas/pandas/tests/plotting/common.py.pyindent" startline="28" endline="34" pcid="7210">
def _skip_if_no_scipy_gaussian_kde():
    try:
        from scipy.stats import gaussian_kde  # noqa
    except ImportError:
        pytest.skip("scipy version doesn't support gaussian_kde")


</source>
<source file="pandas/pandas/util/_test_decorators.py.pyindent" startline="120" endline="126" pcid="9960">
def _skip_if_no_lzma():
    try:
        import_lzma()
    except ImportError:
        return True


</source>
</class>

<class classid="157" nclones="2" nlines="15" similarity="80">
<source file="pandas/pandas/tests/plotting/test_boxplot_method.py.pyindent" startline="191" endline="203" pcid="7246">
    def test_boxplot_legacy2(self):
        tuples = lzip(string.ascii_letters[:10], range(10))
        df = DataFrame(np.random.rand(10, 3),
                       index=MultiIndex.from_tuples(tuples))
        grouped = df.groupby(level=1)
        with tm.assert_produces_warning(UserWarning):
            axes = _check_plot_works(grouped.boxplot, return_type='axes')
        self._check_axes_shape(list(axes.values), axes_num=10, layout=(4, 3))

        axes = _check_plot_works(grouped.boxplot, subplots=False,
                                 return_type='axes')
        self._check_axes_shape(axes, axes_num=1, layout=(1, 1))

</source>
<source file="pandas/pandas/tests/plotting/test_boxplot_method.py.pyindent" startline="205" endline="216" pcid="7247">
    def test_boxplot_legacy3(self):
        tuples = lzip(string.ascii_letters[:10], range(10))
        df = DataFrame(np.random.rand(10, 3),
                       index=MultiIndex.from_tuples(tuples))
        grouped = df.unstack(level=1).groupby(level=0, axis=1)
        with tm.assert_produces_warning(UserWarning):
            axes = _check_plot_works(grouped.boxplot, return_type='axes')
        self._check_axes_shape(list(axes.values), axes_num=3, layout=(2, 2))
        axes = _check_plot_works(grouped.boxplot, subplots=False,
                                 return_type='axes')
        self._check_axes_shape(axes, axes_num=1, layout=(1, 1))

</source>
</class>

<class classid="158" nclones="3" nlines="30" similarity="70">
<source file="pandas/pandas/tests/plotting/test_datetimelike.py.pyindent" startline="403" endline="427" pcid="7310">
    def test_finder_daily(self):
        day_lst = [10, 40, 252, 400, 950, 2750, 10000]

        if self.mpl_ge_2_0_0:
            xpl1 = [7565, 7564, 7553, 7546, 7518, 7428, 7066]
            xpl2 = [7566, 7564, 7554, 7546, 7519, 7429, 7066]
        else:
            xpl1 = xpl2 = [Period('1999-1-1', freq='B').ordinal] * len(day_lst)

        for i, n in enumerate(day_lst):
            xp = xpl1[i]
            rng = bdate_range('1999-1-1', periods=n)
            ser = Series(np.random.randn(len(rng)), rng)
            _, ax = self.plt.subplots()
            ser.plot(ax=ax)
            xaxis = ax.get_xaxis()
            rs = xaxis.get_majorticklocs()[0]
            assert xp == rs
            xp = xpl2[i]
            vmin, vmax = ax.get_xlim()
            ax.set_xlim(vmin + 0.9, vmax)
            rs = xaxis.get_majorticklocs()[0]
            assert xp == rs
            self.plt.close(ax.get_figure())

</source>
<source file="pandas/pandas/tests/plotting/test_datetimelike.py.pyindent" startline="429" endline="453" pcid="7311">
    def test_finder_quarterly(self):
        yrs = [3.5, 11]

        if self.mpl_ge_2_0_0:
            xpl1 = [68, 68]
            xpl2 = [72, 68]
        else:
            xpl1 = xpl2 = [Period('1988Q1').ordinal] * len(yrs)

        for i, n in enumerate(yrs):
            xp = xpl1[i]
            rng = period_range('1987Q2', periods=int(n * 4), freq='Q')
            ser = Series(np.random.randn(len(rng)), rng)
            _, ax = self.plt.subplots()
            ser.plot(ax=ax)
            xaxis = ax.get_xaxis()
            rs = xaxis.get_majorticklocs()[0]
            assert rs == xp
            xp = xpl2[i]
            (vmin, vmax) = ax.get_xlim()
            ax.set_xlim(vmin + 0.9, vmax)
            rs = xaxis.get_majorticklocs()[0]
            assert xp == rs
            self.plt.close(ax.get_figure())

</source>
<source file="pandas/pandas/tests/plotting/test_datetimelike.py.pyindent" startline="455" endline="479" pcid="7312">
    def test_finder_monthly(self):
        yrs = [1.15, 2.5, 4, 11]

        if self.mpl_ge_2_0_0:
            xpl1 = [216, 216, 204, 204]
            xpl2 = [216, 216, 216, 204]
        else:
            xpl1 = xpl2 = [Period('Jan 1988').ordinal] * len(yrs)

        for i, n in enumerate(yrs):
            xp = xpl1[i]
            rng = period_range('1987Q2', periods=int(n * 12), freq='M')
            ser = Series(np.random.randn(len(rng)), rng)
            _, ax = self.plt.subplots()
            ser.plot(ax=ax)
            xaxis = ax.get_xaxis()
            rs = xaxis.get_majorticklocs()[0]
            assert rs == xp
            xp = xpl2[i]
            vmin, vmax = ax.get_xlim()
            ax.set_xlim(vmin + 0.9, vmax)
            rs = xaxis.get_majorticklocs()[0]
            assert xp == rs
            self.plt.close(ax.get_figure())

</source>
</class>

<class classid="159" nclones="2" nlines="19" similarity="73">
<source file="pandas/pandas/tests/plotting/test_datetimelike.py.pyindent" startline="508" endline="521" pcid="7315">
    def test_finder_minutely(self):
        nminutes = 50 * 24 * 60
        rng = date_range('1/1/1999', freq='Min', periods=nminutes)
        ser = Series(np.random.randn(len(rng)), rng)
        _, ax = self.plt.subplots()
        ser.plot(ax=ax)
        xaxis = ax.get_xaxis()
        rs = xaxis.get_majorticklocs()[0]
        if self.mpl_ge_2_0_0:
            xp = Period('1998-12-29 12:00', freq='Min').ordinal
        else:
            xp = Period('1/1/1999', freq='Min').ordinal
        assert rs == xp

</source>
<source file="pandas/pandas/tests/plotting/test_datetimelike.py.pyindent" startline="522" endline="535" pcid="7316">
    def test_finder_hourly(self):
        nhours = 23
        rng = date_range('1/1/1999', freq='H', periods=nhours)
        ser = Series(np.random.randn(len(rng)), rng)
        _, ax = self.plt.subplots()
        ser.plot(ax=ax)
        xaxis = ax.get_xaxis()
        rs = xaxis.get_majorticklocs()[0]
        if self.mpl_ge_2_0_0:
            xp = Period('1998-12-31 22:00', freq='H').ordinal
        else:
            xp = Period('1/1/1999', freq='H').ordinal
        assert rs == xp

</source>
</class>

<class classid="160" nclones="2" nlines="27" similarity="71">
<source file="pandas/pandas/tests/plotting/test_datetimelike.py.pyindent" startline="603" endline="631" pcid="7319">
    def test_secondary_y(self):
        ser = Series(np.random.randn(10))
        ser2 = Series(np.random.randn(10))
        fig, _ = self.plt.subplots()
        ax = ser.plot(secondary_y=True)
        assert hasattr(ax, 'left_ax')
        assert not hasattr(ax, 'right_ax')
        axes = fig.get_axes()
        l = ax.get_lines()[0]
        xp = Series(l.get_ydata(), l.get_xdata())
        assert_series_equal(ser, xp)
        assert ax.get_yaxis().get_ticks_position() == 'right'
        assert not axes[0].get_yaxis().get_visible()
        self.plt.close(fig)

        _, ax2 = self.plt.subplots()
        ser2.plot(ax=ax2)
        assert (ax2.get_yaxis().get_ticks_position() ==
                self.default_tick_position)
        self.plt.close(ax2.get_figure())

        ax = ser2.plot()
        ax2 = ser.plot(secondary_y=True)
        assert ax.get_yaxis().get_visible()
        assert not hasattr(ax, 'left_ax')
        assert hasattr(ax, 'right_ax')
        assert hasattr(ax2, 'left_ax')
        assert not hasattr(ax2, 'right_ax')

</source>
<source file="pandas/pandas/tests/plotting/test_datetimelike.py.pyindent" startline="633" endline="658" pcid="7320">
    def test_secondary_y_ts(self):
        idx = date_range('1/1/2000', periods=10)
        ser = Series(np.random.randn(10), idx)
        ser2 = Series(np.random.randn(10), idx)
        fig, _ = self.plt.subplots()
        ax = ser.plot(secondary_y=True)
        assert hasattr(ax, 'left_ax')
        assert not hasattr(ax, 'right_ax')
        axes = fig.get_axes()
        l = ax.get_lines()[0]
        xp = Series(l.get_ydata(), l.get_xdata()).to_timestamp()
        assert_series_equal(ser, xp)
        assert ax.get_yaxis().get_ticks_position() == 'right'
        assert not axes[0].get_yaxis().get_visible()
        self.plt.close(fig)

        _, ax2 = self.plt.subplots()
        ser2.plot(ax=ax2)
        assert (ax2.get_yaxis().get_ticks_position() ==
                self.default_tick_position)
        self.plt.close(ax2.get_figure())

        ax = ser2.plot()
        ax2 = ser.plot(secondary_y=True)
        assert ax.get_yaxis().get_visible()

</source>
</class>

<class classid="161" nclones="2" nlines="17" similarity="70">
<source file="pandas/pandas/tests/plotting/test_datetimelike.py.pyindent" startline="700" endline="721" pcid="7325">
    def test_mixed_freq_regular_first(self):
        # TODO
        s1 = tm.makeTimeSeries()
        s2 = s1[[0, 5, 10, 11, 12, 13, 14, 15]]

        # it works!
        _, ax = self.plt.subplots()
        s1.plot(ax=ax)

        ax2 = s2.plot(style='g', ax=ax)
        lines = ax2.get_lines()
        idx1 = PeriodIndex(lines[0].get_xdata())
        idx2 = PeriodIndex(lines[1].get_xdata())

        tm.assert_index_equal(idx1, s1.index.to_period('B'))
        tm.assert_index_equal(idx2, s2.index.to_period('B'))

        left, right = ax2.get_xlim()
        pidx = s1.index.to_period()
        assert left <= pidx[0].ordinal
        assert right >= pidx[-1].ordinal

</source>
<source file="pandas/pandas/tests/plotting/test_datetimelike.py.pyindent" startline="736" endline="752" pcid="7327">
    def test_mixed_freq_regular_first_df(self):
        # GH 9852
        s1 = tm.makeTimeSeries().to_frame()
        s2 = s1.iloc[[0, 5, 10, 11, 12, 13, 14, 15], :]
        _, ax = self.plt.subplots()
        s1.plot(ax=ax)
        ax2 = s2.plot(style='g', ax=ax)
        lines = ax2.get_lines()
        idx1 = PeriodIndex(lines[0].get_xdata())
        idx2 = PeriodIndex(lines[1].get_xdata())
        assert idx1.equals(s1.index.to_period('B'))
        assert idx2.equals(s2.index.to_period('B'))
        left, right = ax2.get_xlim()
        pidx = s1.index.to_period()
        assert left <= pidx[0].ordinal
        assert right >= pidx[-1].ordinal

</source>
</class>

<class classid="162" nclones="2" nlines="14" similarity="78">
<source file="pandas/pandas/tests/plotting/test_datetimelike.py.pyindent" startline="723" endline="735" pcid="7326">
    def test_mixed_freq_irregular_first(self):
        s1 = tm.makeTimeSeries()
        s2 = s1[[0, 5, 10, 11, 12, 13, 14, 15]]
        _, ax = self.plt.subplots()
        s2.plot(style='g', ax=ax)
        s1.plot(ax=ax)
        assert not hasattr(ax, 'freq')
        lines = ax.get_lines()
        x1 = lines[0].get_xdata()
        tm.assert_numpy_array_equal(x1, s2.index.astype(object).values)
        x2 = lines[1].get_xdata()
        tm.assert_numpy_array_equal(x2, s1.index.astype(object).values)

</source>
<source file="pandas/pandas/tests/plotting/test_datetimelike.py.pyindent" startline="754" endline="767" pcid="7328">
    def test_mixed_freq_irregular_first_df(self):
        # GH 9852
        s1 = tm.makeTimeSeries().to_frame()
        s2 = s1.iloc[[0, 5, 10, 11, 12, 13, 14, 15], :]
        _, ax = self.plt.subplots()
        s2.plot(style='g', ax=ax)
        s1.plot(ax=ax)
        assert not hasattr(ax, 'freq')
        lines = ax.get_lines()
        x1 = lines[0].get_xdata()
        tm.assert_numpy_array_equal(x1, s2.index.astype(object).values)
        x2 = lines[1].get_xdata()
        tm.assert_numpy_array_equal(x2, s1.index.astype(object).values)

</source>
</class>

<class classid="163" nclones="2" nlines="12" similarity="75">
<source file="pandas/pandas/tests/plotting/test_datetimelike.py.pyindent" startline="1269" endline="1283" pcid="7347">
    def test_irregular_ts_shared_ax_xlim(self):
        # GH 2960
        ts = tm.makeTimeSeries()[:20]
        ts_irregular = ts[[1, 4, 5, 6, 8, 9, 10, 12, 13, 14, 15, 17, 18]]

        # plot the left section of the irregular series, then the right section
        _, ax = self.plt.subplots()
        ts_irregular[:5].plot(ax=ax)
        ts_irregular[5:].plot(ax=ax)

        # check that axis limits are correct
        left, right = ax.get_xlim()
        assert left <= ts_irregular.index.min().toordinal()
        assert right >= ts_irregular.index.max().toordinal()

</source>
<source file="pandas/pandas/tests/plotting/test_datetimelike.py.pyindent" startline="1335" endline="1350" pcid="7351">
    def test_secondary_y_irregular_ts_xlim(self):
        # GH 3490 - irregular-timeseries with secondary y
        ts = tm.makeTimeSeries()[:20]
        ts_irregular = ts[[1, 4, 5, 6, 8, 9, 10, 12, 13, 14, 15, 17, 18]]

        _, ax = self.plt.subplots()
        ts_irregular[:5].plot(ax=ax)
        # plot higher-x values on secondary axis
        ts_irregular[5:].plot(secondary_y=True, ax=ax)
        # ensure secondary limits aren't overwritten by plot on primary
        ts_irregular[:5].plot(ax=ax)

        left, right = ax.get_xlim()
        assert left <= ts_irregular.index.min().toordinal()
        assert right >= ts_irregular.index.max().toordinal()

</source>
</class>

<class classid="164" nclones="2" nlines="14" similarity="78">
<source file="pandas/pandas/tests/plotting/test_datetimelike.py.pyindent" startline="1285" endline="1300" pcid="7348">
    def test_secondary_y_non_ts_xlim(self):
        # GH 3490 - non-timeseries with secondary y
        index_1 = [1, 2, 3, 4]
        index_2 = [5, 6, 7, 8]
        s1 = Series(1, index=index_1)
        s2 = Series(2, index=index_2)

        _, ax = self.plt.subplots()
        s1.plot(ax=ax)
        left_before, right_before = ax.get_xlim()
        s2.plot(secondary_y=True, ax=ax)
        left_after, right_after = ax.get_xlim()

        assert left_before >= left_after
        assert right_before < right_after

</source>
<source file="pandas/pandas/tests/plotting/test_datetimelike.py.pyindent" startline="1302" endline="1317" pcid="7349">
    def test_secondary_y_regular_ts_xlim(self):
        # GH 3490 - regular-timeseries with secondary y
        index_1 = date_range(start='2000-01-01', periods=4, freq='D')
        index_2 = date_range(start='2000-01-05', periods=4, freq='D')
        s1 = Series(1, index=index_1)
        s2 = Series(2, index=index_2)

        _, ax = self.plt.subplots()
        s1.plot(ax=ax)
        left_before, right_before = ax.get_xlim()
        s2.plot(secondary_y=True, ax=ax)
        left_after, right_after = ax.get_xlim()

        assert left_before >= left_after
        assert right_before < right_after

</source>
</class>

<class classid="165" nclones="3" nlines="16" similarity="75">
<source file="pandas/pandas/tests/plotting/test_frame.py.pyindent" startline="2263" endline="2270" pcid="7453">
    def test_all_invalid_plot_data(self):
        df = DataFrame(list('abcd'))
        for kind in plotting._core._common_kinds:
            if not _ok_for_gaussian_kde(kind):
                continue
            with pytest.raises(TypeError):
                df.plot(kind=kind)

</source>
<source file="pandas/pandas/tests/plotting/test_series.py.pyindent" startline="712" endline="720" pcid="7561">
    def test_invalid_plot_data(self):
        s = Series(list('abcd'))
        _, ax = self.plt.subplots()
        for kind in plotting._core._common_kinds:
            if not _ok_for_gaussian_kde(kind):
                continue
            with pytest.raises(TypeError):
                s.plot(kind=kind, ax=ax)

</source>
<source file="pandas/pandas/tests/plotting/test_series.py.pyindent" startline="729" endline="737" pcid="7563">
    def test_partially_invalid_plot_data(self):
        s = Series(['a', 'b', 1.0, 2])
        _, ax = self.plt.subplots()
        for kind in plotting._core._common_kinds:
            if not _ok_for_gaussian_kde(kind):
                continue
            with pytest.raises(TypeError):
                s.plot(kind=kind, ax=ax)

</source>
</class>

<class classid="166" nclones="2" nlines="57" similarity="75">
<source file="pandas/pandas/tests/plotting/test_frame.py.pyindent" startline="2667" endline="2717" pcid="7475">
    def test_sharex_and_ax(self):
        # https://github.com/pandas-dev/pandas/issues/9737 using gridspec,
        # the axis in fig.get_axis() are sorted differently than pandas
        # expected them, so make sure that only the right ones are removed
        import matplotlib.pyplot as plt
        plt.close('all')
        gs, axes = _generate_4_axes_via_gridspec()

        df = DataFrame({"a": [1, 2, 3, 4, 5, 6],
                        "b": [1, 2, 3, 4, 5, 6],
                        "c": [1, 2, 3, 4, 5, 6],
                        "d": [1, 2, 3, 4, 5, 6]})

        def _check(axes):
            for ax in axes:
                assert len(ax.lines) == 1
                self._check_visible(ax.get_yticklabels(), visible=True)
            for ax in [axes[0], axes[2]]:
                self._check_visible(ax.get_xticklabels(), visible=False)
                self._check_visible(
                    ax.get_xticklabels(minor=True), visible=False)
            for ax in [axes[1], axes[3]]:
                self._check_visible(ax.get_xticklabels(), visible=True)
                self._check_visible(
                    ax.get_xticklabels(minor=True), visible=True)

        for ax in axes:
            df.plot(x="a", y="b", title="title", ax=ax, sharex=True)
        gs.tight_layout(plt.gcf())
        _check(axes)
        tm.close()

        gs, axes = _generate_4_axes_via_gridspec()
        with tm.assert_produces_warning(UserWarning):
            axes = df.plot(subplots=True, ax=axes, sharex=True)
        _check(axes)
        tm.close()

        gs, axes = _generate_4_axes_via_gridspec()
        # without sharex, no labels should be touched!
        for ax in axes:
            df.plot(x="a", y="b", title="title", ax=ax)

        gs.tight_layout(plt.gcf())
        for ax in axes:
            assert len(ax.lines) == 1
            self._check_visible(ax.get_yticklabels(), visible=True)
            self._check_visible(ax.get_xticklabels(), visible=True)
            self._check_visible(ax.get_xticklabels(minor=True), visible=True)
        tm.close()

</source>
<source file="pandas/pandas/tests/plotting/test_frame.py.pyindent" startline="2719" endline="2768" pcid="7477">
    def test_sharey_and_ax(self):
        # https://github.com/pandas-dev/pandas/issues/9737 using gridspec,
        # the axis in fig.get_axis() are sorted differently than pandas
        # expected them, so make sure that only the right ones are removed
        import matplotlib.pyplot as plt

        gs, axes = _generate_4_axes_via_gridspec()

        df = DataFrame({"a": [1, 2, 3, 4, 5, 6],
                        "b": [1, 2, 3, 4, 5, 6],
                        "c": [1, 2, 3, 4, 5, 6],
                        "d": [1, 2, 3, 4, 5, 6]})

        def _check(axes):
            for ax in axes:
                assert len(ax.lines) == 1
                self._check_visible(ax.get_xticklabels(), visible=True)
                self._check_visible(
                    ax.get_xticklabels(minor=True), visible=True)
            for ax in [axes[0], axes[1]]:
                self._check_visible(ax.get_yticklabels(), visible=True)
            for ax in [axes[2], axes[3]]:
                self._check_visible(ax.get_yticklabels(), visible=False)

        for ax in axes:
            df.plot(x="a", y="b", title="title", ax=ax, sharey=True)
        gs.tight_layout(plt.gcf())
        _check(axes)
        tm.close()

        gs, axes = _generate_4_axes_via_gridspec()
        with tm.assert_produces_warning(UserWarning):
            axes = df.plot(subplots=True, ax=axes, sharey=True)

        gs.tight_layout(plt.gcf())
        _check(axes)
        tm.close()

        gs, axes = _generate_4_axes_via_gridspec()
        # without sharex, no labels should be touched!
        for ax in axes:
            df.plot(x="a", y="b", title="title", ax=ax)

        gs.tight_layout(plt.gcf())
        for ax in axes:
            assert len(ax.lines) == 1
            self._check_visible(ax.get_yticklabels(), visible=True)
            self._check_visible(ax.get_xticklabels(), visible=True)
            self._check_visible(ax.get_xticklabels(minor=True), visible=True)

</source>
</class>

<class classid="167" nclones="2" nlines="27" similarity="85">
<source file="pandas/pandas/tests/plotting/test_hist_method.py.pyindent" startline="30" endline="52" pcid="7498">
    def test_hist_legacy(self):
        _check_plot_works(self.ts.hist)
        _check_plot_works(self.ts.hist, grid=False)
        _check_plot_works(self.ts.hist, figsize=(8, 10))
        # _check_plot_works adds an ax so catch warning. see GH #13188
        with tm.assert_produces_warning(UserWarning):
            _check_plot_works(self.ts.hist, by=self.ts.index.month)
        with tm.assert_produces_warning(UserWarning):
            _check_plot_works(self.ts.hist, by=self.ts.index.month, bins=5)

        fig, ax = self.plt.subplots(1, 1)
        _check_plot_works(self.ts.hist, ax=ax)
        _check_plot_works(self.ts.hist, ax=ax, figure=fig)
        _check_plot_works(self.ts.hist, figure=fig)
        tm.close()

        fig, (ax1, ax2) = self.plt.subplots(1, 2)
        _check_plot_works(self.ts.hist, figure=fig, ax=ax1)
        _check_plot_works(self.ts.hist, figure=fig, ax=ax2)

        with pytest.raises(ValueError):
            self.ts.hist(by=self.ts.index, figure=fig)

</source>
<source file="pandas/pandas/tests/plotting/test_series.py.pyindent" startline="383" endline="407" pcid="7546">
    def test_hist_legacy(self):
        _check_plot_works(self.ts.hist)
        _check_plot_works(self.ts.hist, grid=False)
        _check_plot_works(self.ts.hist, figsize=(8, 10))
        # _check_plot_works adds an ax so catch warning. see GH #13188
        with tm.assert_produces_warning(UserWarning):
            _check_plot_works(self.ts.hist,
                              by=self.ts.index.month)
        with tm.assert_produces_warning(UserWarning):
            _check_plot_works(self.ts.hist,
                              by=self.ts.index.month, bins=5)

        fig, ax = self.plt.subplots(1, 1)
        _check_plot_works(self.ts.hist, ax=ax)
        _check_plot_works(self.ts.hist, ax=ax, figure=fig)
        _check_plot_works(self.ts.hist, figure=fig)
        tm.close()

        fig, (ax1, ax2) = self.plt.subplots(1, 2)
        _check_plot_works(self.ts.hist, figure=fig, ax=ax1)
        _check_plot_works(self.ts.hist, figure=fig, ax=ax2)

        with pytest.raises(ValueError):
            self.ts.hist(by=self.ts.index, figure=fig)

</source>
</class>

<class classid="168" nclones="2" nlines="12" similarity="100">
<source file="pandas/pandas/tests/plotting/test_hist_method.py.pyindent" startline="60" endline="67" pcid="7500">
    def test_hist_layout(self):
        df = self.hist_df
        with pytest.raises(ValueError):
            df.height.hist(layout=(1, 1))

        with pytest.raises(ValueError):
            df.height.hist(layout=[1, 1])

</source>
<source file="pandas/pandas/tests/plotting/test_series.py.pyindent" startline="415" endline="422" pcid="7548">
    def test_hist_layout(self):
        df = self.hist_df
        with pytest.raises(ValueError):
            df.height.hist(layout=(1, 1))

        with pytest.raises(ValueError):
            df.height.hist(layout=[1, 1])

</source>
</class>

<class classid="169" nclones="2" nlines="13" similarity="100">
<source file="pandas/pandas/tests/plotting/test_hist_method.py.pyindent" startline="115" endline="126" pcid="7502">
    def test_hist_no_overlap(self):
        from matplotlib.pyplot import subplot, gcf
        x = Series(randn(2))
        y = Series(randn(2))
        subplot(121)
        x.hist()
        subplot(122)
        y.hist()
        fig = gcf()
        axes = fig.axes if self.mpl_ge_1_5_0 else fig.get_axes()
        assert len(axes) == 2

</source>
<source file="pandas/pandas/tests/plotting/test_series.py.pyindent" startline="468" endline="479" pcid="7550">
    def test_hist_no_overlap(self):
        from matplotlib.pyplot import subplot, gcf
        x = Series(randn(2))
        y = Series(randn(2))
        subplot(121)
        x.hist()
        subplot(122)
        y.hist()
        fig = gcf()
        axes = fig.axes if self.mpl_ge_1_5_0 else fig.get_axes()
        assert len(axes) == 2

</source>
</class>

<class classid="170" nclones="3" nlines="12" similarity="75">
<source file="pandas/pandas/tests/reshape/merge/test_merge_asof.py.pyindent" startline="37" endline="51" pcid="7578">
    def test_examples1(self):
        """ doc-string examples """

        left = pd.DataFrame({'a': [1, 5, 10],
                             'left_val': ['a', 'b', 'c']})
        right = pd.DataFrame({'a': [1, 2, 3, 6, 7],
                              'right_val': [1, 2, 3, 6, 7]})

        expected = pd.DataFrame({'a': [1, 5, 10],
                                 'left_val': ['a', 'b', 'c'],
                                 'right_val': [1, 3, 7]})

        result = pd.merge_asof(left, right, on='a')
        assert_frame_equal(result, expected)

</source>
<source file="pandas/pandas/tests/reshape/merge/test_merge_asof.py.pyindent" startline="137" endline="152" pcid="7581">
    def test_examples4(self):
        """ doc-string examples """
        # GH14887

        left = pd.DataFrame({'a': [1, 5, 10],
                             'left_val': ['a', 'b', 'c']})
        right = pd.DataFrame({'a': [1, 2, 3, 6, 7],
                              'right_val': [1, 2, 3, 6, 7]})

        expected = pd.DataFrame({'a': [1, 5, 10],
                                 'left_val': ['a', 'b', 'c'],
                                 'right_val': [1, 6, 7]})

        result = pd.merge_asof(left, right, on='a', direction='nearest')
        assert_frame_equal(result, expected)

</source>
<source file="pandas/pandas/tests/reshape/merge/test_merge_asof.py.pyindent" startline="121" endline="136" pcid="7580">
    def test_examples3(self):
        """ doc-string examples """
        # GH14887

        left = pd.DataFrame({'a': [1, 5, 10],
                             'left_val': ['a', 'b', 'c']})
        right = pd.DataFrame({'a': [1, 2, 3, 6, 7],
                              'right_val': [1, 2, 3, 6, 7]})

        expected = pd.DataFrame({'a': [1, 5, 10],
                                 'left_val': ['a', 'b', 'c'],
                                 'right_val': [1, 6, np.nan]})

        result = pd.merge_asof(left, right, on='a', direction='forward')
        assert_frame_equal(result, expected)

</source>
</class>

<class classid="171" nclones="2" nlines="11" similarity="72">
<source file="pandas/pandas/tests/reshape/merge/test_merge_asof.py.pyindent" startline="153" endline="163" pcid="7582">
    def test_basic(self):

        expected = self.asof
        trades = self.trades
        quotes = self.quotes

        result = merge_asof(trades, quotes,
                            on='time',
                            by='ticker')
        assert_frame_equal(result, expected)

</source>
<source file="pandas/pandas/tests/reshape/merge/test_merge_asof.py.pyindent" startline="255" endline="267" pcid="7589">
    def test_basic_left_by_right_by(self):

        # GH14253
        expected = self.asof
        trades = self.trades
        quotes = self.quotes

        result = merge_asof(trades, quotes,
                            on='time',
                            left_by='ticker',
                            right_by='ticker')
        assert_frame_equal(result, expected)

</source>
</class>

<class classid="172" nclones="2" nlines="20" similarity="76">
<source file="pandas/pandas/tests/reshape/merge/test_merge_asof.py.pyindent" startline="219" endline="235" pcid="7587">
    def test_multi_index(self):

        # MultiIndex is prohibited
        trades = self.trades.set_index(['time', 'price'])
        quotes = self.quotes.set_index('time')
        with pytest.raises(MergeError):
            merge_asof(trades, quotes,
                       left_index=True,
                       right_index=True)

        trades = self.trades.set_index('time')
        quotes = self.quotes.set_index(['time', 'bid'])
        with pytest.raises(MergeError):
            merge_asof(trades, quotes,
                       left_index=True,
                       right_index=True)

</source>
<source file="pandas/pandas/tests/reshape/merge/test_merge_asof.py.pyindent" startline="236" endline="254" pcid="7588">
    def test_on_and_index(self):

        # 'on' parameter and index together is prohibited
        trades = self.trades.set_index('time')
        quotes = self.quotes.set_index('time')
        with pytest.raises(MergeError):
            merge_asof(trades, quotes,
                       left_on='price',
                       left_index=True,
                       right_index=True)

        trades = self.trades.set_index('time')
        quotes = self.quotes.set_index('time')
        with pytest.raises(MergeError):
            merge_asof(trades, quotes,
                       right_on='bid',
                       left_index=True,
                       right_index=True)

</source>
</class>

<class classid="173" nclones="2" nlines="53" similarity="87">
<source file="pandas/pandas/tests/reshape/merge/test_merge_asof.py.pyindent" startline="281" endline="337" pcid="7591">
    def test_multiby(self):
        # GH13936
        trades = pd.DataFrame({
            'time': pd.to_datetime(['20160525 13:30:00.023',
                                    '20160525 13:30:00.023',
                                    '20160525 13:30:00.046',
                                    '20160525 13:30:00.048',
                                    '20160525 13:30:00.050']),
            'ticker': ['MSFT', 'MSFT',
                       'GOOG', 'GOOG', 'AAPL'],
            'exch': ['ARCA', 'NSDQ', 'NSDQ', 'BATS', 'NSDQ'],
            'price': [51.95, 51.95,
                      720.77, 720.92, 98.00],
            'quantity': [75, 155,
                         100, 100, 100]},
            columns=['time', 'ticker', 'exch',
                     'price', 'quantity'])

        quotes = pd.DataFrame({
            'time': pd.to_datetime(['20160525 13:30:00.023',
                                    '20160525 13:30:00.023',
                                    '20160525 13:30:00.030',
                                    '20160525 13:30:00.041',
                                    '20160525 13:30:00.045',
                                    '20160525 13:30:00.049']),
            'ticker': ['GOOG', 'MSFT', 'MSFT',
                       'MSFT', 'GOOG', 'AAPL'],
            'exch': ['BATS', 'NSDQ', 'ARCA', 'ARCA',
                     'NSDQ', 'ARCA'],
            'bid': [720.51, 51.95, 51.97, 51.99,
                    720.50, 97.99],
            'ask': [720.92, 51.96, 51.98, 52.00,
                    720.93, 98.01]},
            columns=['time', 'ticker', 'exch', 'bid', 'ask'])

        expected = pd.DataFrame({
            'time': pd.to_datetime(['20160525 13:30:00.023',
                                    '20160525 13:30:00.023',
                                    '20160525 13:30:00.046',
                                    '20160525 13:30:00.048',
                                    '20160525 13:30:00.050']),
            'ticker': ['MSFT', 'MSFT',
                       'GOOG', 'GOOG', 'AAPL'],
            'exch': ['ARCA', 'NSDQ', 'NSDQ', 'BATS', 'NSDQ'],
            'price': [51.95, 51.95,
                      720.77, 720.92, 98.00],
            'quantity': [75, 155,
                         100, 100, 100],
            'bid': [np.nan, 51.95, 720.50, 720.51, np.nan],
            'ask': [np.nan, 51.96, 720.93, 720.92, np.nan]},
            columns=['time', 'ticker', 'exch',
                     'price', 'quantity', 'bid', 'ask'])

        result = pd.merge_asof(trades, quotes, on='time',
                               by=['ticker', 'exch'])
        assert_frame_equal(result, expected)

</source>
<source file="pandas/pandas/tests/reshape/merge/test_merge_asof.py.pyindent" startline="338" endline="391" pcid="7592">
    def test_multiby_heterogeneous_types(self):
        # GH13936
        trades = pd.DataFrame({
            'time': pd.to_datetime(['20160525 13:30:00.023',
                                    '20160525 13:30:00.023',
                                    '20160525 13:30:00.046',
                                    '20160525 13:30:00.048',
                                    '20160525 13:30:00.050']),
            'ticker': [0, 0, 1, 1, 2],
            'exch': ['ARCA', 'NSDQ', 'NSDQ', 'BATS', 'NSDQ'],
            'price': [51.95, 51.95,
                      720.77, 720.92, 98.00],
            'quantity': [75, 155,
                         100, 100, 100]},
            columns=['time', 'ticker', 'exch',
                     'price', 'quantity'])

        quotes = pd.DataFrame({
            'time': pd.to_datetime(['20160525 13:30:00.023',
                                    '20160525 13:30:00.023',
                                    '20160525 13:30:00.030',
                                    '20160525 13:30:00.041',
                                    '20160525 13:30:00.045',
                                    '20160525 13:30:00.049']),
            'ticker': [1, 0, 0, 0, 1, 2],
            'exch': ['BATS', 'NSDQ', 'ARCA', 'ARCA',
                     'NSDQ', 'ARCA'],
            'bid': [720.51, 51.95, 51.97, 51.99,
                    720.50, 97.99],
            'ask': [720.92, 51.96, 51.98, 52.00,
                    720.93, 98.01]},
            columns=['time', 'ticker', 'exch', 'bid', 'ask'])

        expected = pd.DataFrame({
            'time': pd.to_datetime(['20160525 13:30:00.023',
                                    '20160525 13:30:00.023',
                                    '20160525 13:30:00.046',
                                    '20160525 13:30:00.048',
                                    '20160525 13:30:00.050']),
            'ticker': [0, 0, 1, 1, 2],
            'exch': ['ARCA', 'NSDQ', 'NSDQ', 'BATS', 'NSDQ'],
            'price': [51.95, 51.95,
                      720.77, 720.92, 98.00],
            'quantity': [75, 155,
                         100, 100, 100],
            'bid': [np.nan, 51.95, 720.50, 720.51, np.nan],
            'ask': [np.nan, 51.96, 720.93, 720.92, np.nan]},
            columns=['time', 'ticker', 'exch',
                     'price', 'quantity', 'bid', 'ask'])

        result = pd.merge_asof(trades, quotes, on='time',
                               by=['ticker', 'exch'])
        assert_frame_equal(result, expected)

</source>
</class>

<class classid="174" nclones="4" nlines="13" similarity="76">
<source file="pandas/pandas/tests/reshape/merge/test_merge_asof.py.pyindent" startline="589" endline="604" pcid="7603">
    def test_tolerance_forward(self):
        # GH14887

        left = pd.DataFrame({'a': [1, 5, 10],
                             'left_val': ['a', 'b', 'c']})
        right = pd.DataFrame({'a': [1, 2, 3, 7, 11],
                              'right_val': [1, 2, 3, 7, 11]})

        expected = pd.DataFrame({'a': [1, 5, 10],
                                 'left_val': ['a', 'b', 'c'],
                                 'right_val': [1, np.nan, 11]})

        result = pd.merge_asof(left, right, on='a', direction='forward',
                               tolerance=1)
        assert_frame_equal(result, expected)

</source>
<source file="pandas/pandas/tests/reshape/merge/test_merge_asof.py.pyindent" startline="605" endline="620" pcid="7604">
    def test_tolerance_nearest(self):
        # GH14887

        left = pd.DataFrame({'a': [1, 5, 10],
                             'left_val': ['a', 'b', 'c']})
        right = pd.DataFrame({'a': [1, 2, 3, 7, 11],
                              'right_val': [1, 2, 3, 7, 11]})

        expected = pd.DataFrame({'a': [1, 5, 10],
                                 'left_val': ['a', 'b', 'c'],
                                 'right_val': [1, np.nan, 11]})

        result = pd.merge_asof(left, right, on='a', direction='nearest',
                               tolerance=1)
        assert_frame_equal(result, expected)

</source>
<source file="pandas/pandas/tests/reshape/merge/test_merge_asof.py.pyindent" startline="666" endline="681" pcid="7608">
    def test_allow_exact_matches_forward(self):
        # GH14887

        left = pd.DataFrame({'a': [1, 5, 10],
                             'left_val': ['a', 'b', 'c']})
        right = pd.DataFrame({'a': [1, 2, 3, 7, 11],
                              'right_val': [1, 2, 3, 7, 11]})

        expected = pd.DataFrame({'a': [1, 5, 10],
                                 'left_val': ['a', 'b', 'c'],
                                 'right_val': [2, 7, 11]})

        result = pd.merge_asof(left, right, on='a', direction='forward',
                               allow_exact_matches=False)
        assert_frame_equal(result, expected)

</source>
<source file="pandas/pandas/tests/reshape/merge/test_merge_asof.py.pyindent" startline="682" endline="697" pcid="7609">
    def test_allow_exact_matches_nearest(self):
        # GH14887

        left = pd.DataFrame({'a': [1, 5, 10],
                             'left_val': ['a', 'b', 'c']})
        right = pd.DataFrame({'a': [1, 2, 3, 7, 11],
                              'right_val': [1, 2, 3, 7, 11]})

        expected = pd.DataFrame({'a': [1, 5, 10],
                                 'left_val': ['a', 'b', 'c'],
                                 'right_val': [2, 3, 11]})

        result = pd.merge_asof(left, right, on='a', direction='nearest',
                               allow_exact_matches=False)
        assert_frame_equal(result, expected)

</source>
</class>

<class classid="175" nclones="2" nlines="29" similarity="79">
<source file="pandas/pandas/tests/reshape/test_melt.py.pyindent" startline="311" endline="338" pcid="7655">
    def test_simple(self):
        np.random.seed(123)
        x = np.random.randn(3)
        df = pd.DataFrame({"A1970": {0: "a",
                                     1: "b",
                                     2: "c"},
                           "A1980": {0: "d",
                                     1: "e",
                                     2: "f"},
                           "B1970": {0: 2.5,
                                     1: 1.2,
                                     2: .7},
                           "B1980": {0: 3.2,
                                     1: 1.3,
                                     2: .1},
                           "X": dict(zip(
                               range(3), x))})
        df["id"] = df.index
        exp_data = {"X": x.tolist() + x.tolist(),
                    "A": ['a', 'b', 'c', 'd', 'e', 'f'],
                    "B": [2.5, 1.2, 0.7, 3.2, 1.3, 0.1],
                    "year": [1970, 1970, 1970, 1980, 1980, 1980],
                    "id": [0, 1, 2, 0, 1, 2]}
        expected = DataFrame(exp_data)
        expected = expected.set_index(['id', 'year'])[["X", "A", "B"]]
        result = wide_to_long(df, ["A", "B"], i="id", j="year")
        tm.assert_frame_equal(result, expected)

</source>
<source file="pandas/pandas/tests/reshape/test_melt.py.pyindent" startline="350" endline="378" pcid="7657">
    def test_separating_character(self):
        # GH14779
        np.random.seed(123)
        x = np.random.randn(3)
        df = pd.DataFrame({"A.1970": {0: "a",
                                      1: "b",
                                      2: "c"},
                           "A.1980": {0: "d",
                                      1: "e",
                                      2: "f"},
                           "B.1970": {0: 2.5,
                                      1: 1.2,
                                      2: .7},
                           "B.1980": {0: 3.2,
                                      1: 1.3,
                                      2: .1},
                           "X": dict(zip(
                               range(3), x))})
        df["id"] = df.index
        exp_data = {"X": x.tolist() + x.tolist(),
                    "A": ['a', 'b', 'c', 'd', 'e', 'f'],
                    "B": [2.5, 1.2, 0.7, 3.2, 1.3, 0.1],
                    "year": [1970, 1970, 1970, 1980, 1980, 1980],
                    "id": [0, 1, 2, 0, 1, 2]}
        expected = DataFrame(exp_data)
        expected = expected.set_index(['id', 'year'])[["X", "A", "B"]]
        result = wide_to_long(df, ["A", "B"], i="id", j="year", sep=".")
        tm.assert_frame_equal(result, expected)

</source>
</class>

<class classid="176" nclones="2" nlines="26" similarity="76">
<source file="pandas/pandas/tests/reshape/test_melt.py.pyindent" startline="426" endline="452" pcid="7660">
    def test_character_overlap(self):
        # Test we handle overlapping characters in both id_vars and value_vars
        df = pd.DataFrame({
            'A11': ['a11', 'a22', 'a33'],
            'A12': ['a21', 'a22', 'a23'],
            'B11': ['b11', 'b12', 'b13'],
            'B12': ['b21', 'b22', 'b23'],
            'BB11': [1, 2, 3],
            'BB12': [4, 5, 6],
            'BBBX': [91, 92, 93],
            'BBBZ': [91, 92, 93]
        })
        df['id'] = df.index
        expected = pd.DataFrame({
            'BBBX': [91, 92, 93, 91, 92, 93],
            'BBBZ': [91, 92, 93, 91, 92, 93],
            'A': ['a11', 'a22', 'a33', 'a21', 'a22', 'a23'],
            'B': ['b11', 'b12', 'b13', 'b21', 'b22', 'b23'],
            'BB': [1, 2, 3, 4, 5, 6],
            'id': [0, 1, 2, 0, 1, 2],
            'year': [11, 11, 11, 12, 12, 12]})
        expected = expected.set_index(['id', 'year'])[
            ['BBBX', 'BBBZ', 'A', 'B', 'BB']]
        result = wide_to_long(df, ['A', 'B', 'BB'], i='id', j='year')
        tm.assert_frame_equal(result.sort_index(axis=1),
                              expected.sort_index(axis=1))

</source>
<source file="pandas/pandas/tests/reshape/test_melt.py.pyindent" startline="477" endline="504" pcid="7662">
    def test_num_string_disambiguation(self):
        # Test that we can disambiguate number value_vars from
        # string value_vars
        df = pd.DataFrame({
            'A11': ['a11', 'a22', 'a33'],
            'A12': ['a21', 'a22', 'a23'],
            'B11': ['b11', 'b12', 'b13'],
            'B12': ['b21', 'b22', 'b23'],
            'BB11': [1, 2, 3],
            'BB12': [4, 5, 6],
            'Arating': [91, 92, 93],
            'Arating_old': [91, 92, 93]
        })
        df['id'] = df.index
        expected = pd.DataFrame({
            'Arating': [91, 92, 93, 91, 92, 93],
            'Arating_old': [91, 92, 93, 91, 92, 93],
            'A': ['a11', 'a22', 'a33', 'a21', 'a22', 'a23'],
            'B': ['b11', 'b12', 'b13', 'b21', 'b22', 'b23'],
            'BB': [1, 2, 3, 4, 5, 6],
            'id': [0, 1, 2, 0, 1, 2],
            'year': [11, 11, 11, 12, 12, 12]})
        expected = expected.set_index(['id', 'year'])[
            ['Arating', 'Arating_old', 'A', 'B', 'BB']]
        result = wide_to_long(df, ['A', 'B', 'BB'], i='id', j='year')
        tm.assert_frame_equal(result.sort_index(axis=1),
                              expected.sort_index(axis=1))

</source>
</class>

<class classid="177" nclones="2" nlines="11" similarity="81">
<source file="pandas/pandas/tests/reshape/test_tile.py.pyindent" startline="29" endline="39" pcid="7707">
    def test_bins(self):
        data = np.array([.2, 1.4, 2.5, 6.2, 9.7, 2.1])
        result, bins = cut(data, 3, retbins=True)

        intervals = IntervalIndex.from_breaks(bins.round(3))
        intervals = intervals.take([0, 0, 0, 1, 2, 0])
        expected = Categorical(intervals, ordered=True)
        tm.assert_categorical_equal(result, expected)
        tm.assert_almost_equal(bins, np.array([0.1905, 3.36666667,
                                               6.53333333, 9.7]))

</source>
<source file="pandas/pandas/tests/reshape/test_tile.py.pyindent" startline="60" endline="69" pcid="7710">
    def test_arraylike(self):
        data = [.2, 1.4, 2.5, 6.2, 9.7, 2.1]
        result, bins = cut(data, 3, retbins=True)
        intervals = IntervalIndex.from_breaks(bins.round(3))
        intervals = intervals.take([0, 0, 0, 1, 2, 0])
        expected = Categorical(intervals, ordered=True)
        tm.assert_categorical_equal(result, expected)
        tm.assert_almost_equal(bins, np.array([0.1905, 3.36666667,
                                               6.53333333, 9.7]))

</source>
</class>

<class classid="178" nclones="2" nlines="12" similarity="75">
<source file="pandas/pandas/tests/scalar/timedelta/test_arithmetic.py.pyindent" startline="155" endline="161" pcid="7906">
    def test_td_sub_numeric_raises(self):
        td = td = Timedelta(10, unit='d')
        with pytest.raises(TypeError):
            td - 2
        with pytest.raises(TypeError):
            td - 2.0

</source>
<source file="pandas/pandas/tests/scalar/timedelta/test_arithmetic.py.pyindent" startline="196" endline="203" pcid="7912">
    def test_td_rsub_numeric_raises(self):
        td = td = Timedelta(10, unit='d')
        with pytest.raises(TypeError):
            2 - td
        with pytest.raises(TypeError):
            2.0 - td


</source>
</class>

<class classid="179" nclones="3" nlines="23" similarity="91">
<source file="pandas/pandas/tests/scalar/timestamp/test_comparisons.py.pyindent" startline="92" endline="112" pcid="8000">
    def test_cant_compare_tz_naive_w_aware(self):
        # see gh-1404
        a = Timestamp('3/12/2012')
        b = Timestamp('3/12/2012', tz='utc')

        pytest.raises(Exception, a.__eq__, b)
        pytest.raises(Exception, a.__ne__, b)
        pytest.raises(Exception, a.__lt__, b)
        pytest.raises(Exception, a.__gt__, b)
        pytest.raises(Exception, b.__eq__, a)
        pytest.raises(Exception, b.__ne__, a)
        pytest.raises(Exception, b.__lt__, a)
        pytest.raises(Exception, b.__gt__, a)

        if PY2:
            pytest.raises(Exception, a.__eq__, b.to_pydatetime())
            pytest.raises(Exception, a.to_pydatetime().__eq__, b)
        else:
            assert not a == b.to_pydatetime()
            assert not a.to_pydatetime() == b

</source>
<source file="pandas/pandas/tests/scalar/timestamp/test_comparisons.py.pyindent" startline="113" endline="133" pcid="8001">
    def test_cant_compare_tz_naive_w_aware_explicit_pytz(self):
        # see gh-1404
        a = Timestamp('3/12/2012')
        b = Timestamp('3/12/2012', tz=utc)

        pytest.raises(Exception, a.__eq__, b)
        pytest.raises(Exception, a.__ne__, b)
        pytest.raises(Exception, a.__lt__, b)
        pytest.raises(Exception, a.__gt__, b)
        pytest.raises(Exception, b.__eq__, a)
        pytest.raises(Exception, b.__ne__, a)
        pytest.raises(Exception, b.__lt__, a)
        pytest.raises(Exception, b.__gt__, a)

        if PY2:
            pytest.raises(Exception, a.__eq__, b.to_pydatetime())
            pytest.raises(Exception, a.to_pydatetime().__eq__, b)
        else:
            assert not a == b.to_pydatetime()
            assert not a.to_pydatetime() == b

</source>
<source file="pandas/pandas/tests/scalar/timestamp/test_comparisons.py.pyindent" startline="134" endline="154" pcid="8002">
    def test_cant_compare_tz_naive_w_aware_dateutil(self):
        # see gh-1404
        a = Timestamp('3/12/2012')
        b = Timestamp('3/12/2012', tz=tzutc())

        pytest.raises(Exception, a.__eq__, b)
        pytest.raises(Exception, a.__ne__, b)
        pytest.raises(Exception, a.__lt__, b)
        pytest.raises(Exception, a.__gt__, b)
        pytest.raises(Exception, b.__eq__, a)
        pytest.raises(Exception, b.__ne__, a)
        pytest.raises(Exception, b.__lt__, a)
        pytest.raises(Exception, b.__gt__, a)

        if PY2:
            pytest.raises(Exception, a.__eq__, b.to_pydatetime())
            pytest.raises(Exception, a.to_pydatetime().__eq__, b)
        else:
            assert not a == b.to_pydatetime()
            assert not a.to_pydatetime() == b

</source>
</class>

<class classid="180" nclones="2" nlines="21" similarity="80">
<source file="pandas/pandas/tests/scalar/timestamp/test_timestamp.py.pyindent" startline="608" endline="627" pcid="8041">
    def test_class_ops_pytz(self):
        def compare(x, y):
            assert (int(Timestamp(x).value / 1e9) ==
                    int(Timestamp(y).value / 1e9))

        compare(Timestamp.now(), datetime.now())
        compare(Timestamp.now('UTC'), datetime.now(timezone('UTC')))
        compare(Timestamp.utcnow(), datetime.utcnow())
        compare(Timestamp.today(), datetime.today())
        current_time = calendar.timegm(datetime.now().utctimetuple())
        compare(Timestamp.utcfromtimestamp(current_time),
                datetime.utcfromtimestamp(current_time))
        compare(Timestamp.fromtimestamp(current_time),
                datetime.fromtimestamp(current_time))

        date_component = datetime.utcnow()
        time_component = (date_component + timedelta(minutes=10)).time()
        compare(Timestamp.combine(date_component, time_component),
                datetime.combine(date_component, time_component))

</source>
<source file="pandas/pandas/tests/scalar/timestamp/test_timestamp.py.pyindent" startline="628" endline="647" pcid="8043">
    def test_class_ops_dateutil(self):
        def compare(x, y):
            assert (int(np.round(Timestamp(x).value / 1e9)) ==
                    int(np.round(Timestamp(y).value / 1e9)))

        compare(Timestamp.now(), datetime.now())
        compare(Timestamp.now('UTC'), datetime.now(tzutc()))
        compare(Timestamp.utcnow(), datetime.utcnow())
        compare(Timestamp.today(), datetime.today())
        current_time = calendar.timegm(datetime.now().utctimetuple())
        compare(Timestamp.utcfromtimestamp(current_time),
                datetime.utcfromtimestamp(current_time))
        compare(Timestamp.fromtimestamp(current_time),
                datetime.fromtimestamp(current_time))

        date_component = datetime.utcnow()
        time_component = (date_component + timedelta(minutes=10)).time()
        compare(Timestamp.combine(date_component, time_component),
                datetime.combine(date_component, time_component))

</source>
</class>

<class classid="181" nclones="2" nlines="32" similarity="84">
<source file="pandas/pandas/tests/series/test_apply.py.pyindent" startline="94" endline="131" pcid="8259">
    def test_apply_box(self):
        # ufunc will not be boxed. Same test cases as the test_map_box
        vals = [pd.Timestamp('2011-01-01'), pd.Timestamp('2011-01-02')]
        s = pd.Series(vals)
        assert s.dtype == 'datetime64[ns]'
        # boxed value must be Timestamp instance
        res = s.apply(lambda x: '{0}_{1}_{2}'.format(x.__class__.__name__,
                                                     x.day, x.tz))
        exp = pd.Series(['Timestamp_1_None', 'Timestamp_2_None'])
        tm.assert_series_equal(res, exp)

        vals = [pd.Timestamp('2011-01-01', tz='US/Eastern'),
                pd.Timestamp('2011-01-02', tz='US/Eastern')]
        s = pd.Series(vals)
        assert s.dtype == 'datetime64[ns, US/Eastern]'
        res = s.apply(lambda x: '{0}_{1}_{2}'.format(x.__class__.__name__,
                                                     x.day, x.tz))
        exp = pd.Series(['Timestamp_1_US/Eastern', 'Timestamp_2_US/Eastern'])
        tm.assert_series_equal(res, exp)

        # timedelta
        vals = [pd.Timedelta('1 days'), pd.Timedelta('2 days')]
        s = pd.Series(vals)
        assert s.dtype == 'timedelta64[ns]'
        res = s.apply(lambda x: '{0}_{1}'.format(x.__class__.__name__, x.days))
        exp = pd.Series(['Timedelta_1', 'Timedelta_2'])
        tm.assert_series_equal(res, exp)

        # period (object dtype, not boxed)
        vals = [pd.Period('2011-01-01', freq='M'),
                pd.Period('2011-01-02', freq='M')]
        s = pd.Series(vals)
        assert s.dtype == 'object'
        res = s.apply(lambda x: '{0}_{1}'.format(x.__class__.__name__,
                                                 x.freqstr))
        exp = pd.Series(['Period_M', 'Period_M'])
        tm.assert_series_equal(res, exp)

</source>
<source file="pandas/pandas/tests/series/test_apply.py.pyindent" startline="574" endline="610" pcid="8292">
    def test_map_box(self):
        vals = [pd.Timestamp('2011-01-01'), pd.Timestamp('2011-01-02')]
        s = pd.Series(vals)
        assert s.dtype == 'datetime64[ns]'
        # boxed value must be Timestamp instance
        res = s.map(lambda x: '{0}_{1}_{2}'.format(x.__class__.__name__,
                                                   x.day, x.tz))
        exp = pd.Series(['Timestamp_1_None', 'Timestamp_2_None'])
        tm.assert_series_equal(res, exp)

        vals = [pd.Timestamp('2011-01-01', tz='US/Eastern'),
                pd.Timestamp('2011-01-02', tz='US/Eastern')]
        s = pd.Series(vals)
        assert s.dtype == 'datetime64[ns, US/Eastern]'
        res = s.map(lambda x: '{0}_{1}_{2}'.format(x.__class__.__name__,
                                                   x.day, x.tz))
        exp = pd.Series(['Timestamp_1_US/Eastern', 'Timestamp_2_US/Eastern'])
        tm.assert_series_equal(res, exp)

        # timedelta
        vals = [pd.Timedelta('1 days'), pd.Timedelta('2 days')]
        s = pd.Series(vals)
        assert s.dtype == 'timedelta64[ns]'
        res = s.map(lambda x: '{0}_{1}'.format(x.__class__.__name__, x.days))
        exp = pd.Series(['Timedelta_1', 'Timedelta_2'])
        tm.assert_series_equal(res, exp)

        # period (object dtype, not boxed)
        vals = [pd.Period('2011-01-01', freq='M'),
                pd.Period('2011-01-02', freq='M')]
        s = pd.Series(vals)
        assert s.dtype == 'object'
        res = s.map(lambda x: '{0}_{1}'.format(x.__class__.__name__,
                                               x.freqstr))
        exp = pd.Series(['Period_M', 'Period_M'])
        tm.assert_series_equal(res, exp)

</source>
</class>

<class classid="182" nclones="2" nlines="27" similarity="75">
<source file="pandas/pandas/tests/series/test_apply.py.pyindent" startline="132" endline="158" pcid="8260">
    def test_apply_datetimetz(self):
        values = pd.date_range('2011-01-01', '2011-01-02',
                               freq='H').tz_localize('Asia/Tokyo')
        s = pd.Series(values, name='XX')

        result = s.apply(lambda x: x + pd.offsets.Day())
        exp_values = pd.date_range('2011-01-02', '2011-01-03',
                                   freq='H').tz_localize('Asia/Tokyo')
        exp = pd.Series(exp_values, name='XX')
        tm.assert_series_equal(result, exp)

        # change dtype
        # GH 14506 : Returned dtype changed from int32 to int64
        result = s.apply(lambda x: x.hour)
        exp = pd.Series(list(range(24)) + [0], name='XX', dtype=np.int64)
        tm.assert_series_equal(result, exp)

        # not vectorized
        def f(x):
            if not isinstance(x, pd.Timestamp):
                raise ValueError
            return str(x.tz)

        result = s.map(f)
        exp = pd.Series(['Asia/Tokyo'] * 25, name='XX')
        tm.assert_series_equal(result, exp)

</source>
<source file="pandas/pandas/tests/series/test_apply.py.pyindent" startline="631" endline="661" pcid="8294">
    def test_map_datetimetz(self):
        values = pd.date_range('2011-01-01', '2011-01-02',
                               freq='H').tz_localize('Asia/Tokyo')
        s = pd.Series(values, name='XX')

        # keep tz
        result = s.map(lambda x: x + pd.offsets.Day())
        exp_values = pd.date_range('2011-01-02', '2011-01-03',
                                   freq='H').tz_localize('Asia/Tokyo')
        exp = pd.Series(exp_values, name='XX')
        tm.assert_series_equal(result, exp)

        # change dtype
        # GH 14506 : Returned dtype changed from int32 to int64
        result = s.map(lambda x: x.hour)
        exp = pd.Series(list(range(24)) + [0], name='XX', dtype=np.int64)
        tm.assert_series_equal(result, exp)

        with pytest.raises(NotImplementedError):
            s.map(lambda x: x, na_action='ignore')

        # not vectorized
        def f(x):
            if not isinstance(x, pd.Timestamp):
                raise ValueError
            return str(x.tz)

        result = s.map(f)
        exp = pd.Series(['Asia/Tokyo'] * 25, name='XX')
        tm.assert_series_equal(result, exp)

</source>
</class>

<class classid="183" nclones="2" nlines="10" similarity="70">
<source file="pandas/pandas/tests/series/test_internals.py.pyindent" startline="133" endline="139" pcid="8362">
    def test_convert_objects_preserve_bool(self):
        s = Series([1, True, 3, 5], dtype=object)
        with tm.assert_produces_warning(FutureWarning):
            r = s.convert_objects(convert_numeric=True)
        e = Series([1, 1, 3, 5], dtype='i8')
        tm.assert_series_equal(r, e)

</source>
<source file="pandas/pandas/tests/series/test_internals.py.pyindent" startline="140" endline="147" pcid="8363">
    def test_convert_objects_preserve_all_bool(self):
        s = Series([False, True, False, False], dtype=object)
        with tm.assert_produces_warning(FutureWarning):
            r = s.convert_objects(convert_numeric=True)
        e = Series([False, True, False, False], dtype=bool)
        tm.assert_series_equal(r, e)

    # GH 10265
</source>
</class>

<class classid="184" nclones="2" nlines="13" similarity="84">
<source file="pandas/pandas/tests/series/test_missing.py.pyindent" startline="469" endline="478" pcid="8403">
    def test_isna_for_inf(self):
        s = Series(['a', np.inf, np.nan, 1.0])
        with pd.option_context('mode.use_inf_as_na', True):
            r = s.isna()
            dr = s.dropna()
        e = Series([False, True, True, False])
        de = Series(['a', 1.0], index=[0, 3])
        tm.assert_series_equal(r, e)
        tm.assert_series_equal(dr, de)

</source>
<source file="pandas/pandas/tests/series/test_missing.py.pyindent" startline="480" endline="491" pcid="8404">
    def test_isnull_for_inf_deprecated(self):
        # gh-17115
        s = Series(['a', np.inf, np.nan, 1.0])
        with pd.option_context('mode.use_inf_as_null', True):
            r = s.isna()
            dr = s.dropna()

        e = Series([False, True, True, False])
        de = Series(['a', 1.0], index=[0, 3])
        tm.assert_series_equal(r, e)
        tm.assert_series_equal(dr, de)

</source>
</class>

<class classid="185" nclones="3" nlines="12" similarity="75">
<source file="pandas/pandas/tests/series/test_missing.py.pyindent" startline="868" endline="881" pcid="8430">
    def test_interpolate_akima(self):
        _skip_if_no_akima()

        ser = Series([10, 11, 12, 13])

        expected = Series([11.00, 11.25, 11.50, 11.75,
                           12.00, 12.25, 12.50, 12.75, 13.00],
                          index=Index([1.0, 1.25, 1.5, 1.75,
                                       2.0, 2.25, 2.5, 2.75, 3.0]))
        # interpolate at new_index
        new_index = ser.index.union(Index([1.25, 1.5, 1.75, 2.25, 2.5, 2.75]))
        interp_s = ser.reindex(new_index).interpolate(method='akima')
        assert_series_equal(interp_s[1:3], expected)

</source>
<source file="pandas/pandas/tests/series/test_missing.py.pyindent" startline="897" endline="909" pcid="8432">
    def test_interpolate_from_derivatives(self):
        ser = Series([10, 11, 12, 13])

        expected = Series([11.00, 11.25, 11.50, 11.75,
                           12.00, 12.25, 12.50, 12.75, 13.00],
                          index=Index([1.0, 1.25, 1.5, 1.75,
                                       2.0, 2.25, 2.5, 2.75, 3.0]))
        # interpolate at new_index
        new_index = ser.index.union(Index([1.25, 1.5, 1.75, 2.25, 2.5, 2.75]))
        interp_s = ser.reindex(new_index).interpolate(
            method='from_derivatives')
        assert_series_equal(interp_s[1:3], expected)

</source>
<source file="pandas/pandas/tests/series/test_missing.py.pyindent" startline="883" endline="895" pcid="8431">
    def test_interpolate_piecewise_polynomial(self):
        ser = Series([10, 11, 12, 13])

        expected = Series([11.00, 11.25, 11.50, 11.75,
                           12.00, 12.25, 12.50, 12.75, 13.00],
                          index=Index([1.0, 1.25, 1.5, 1.75,
                                       2.0, 2.25, 2.5, 2.75, 3.0]))
        # interpolate at new_index
        new_index = ser.index.union(Index([1.25, 1.5, 1.75, 2.25, 2.5, 2.75]))
        interp_s = ser.reindex(new_index).interpolate(
            method='piecewise_polynomial')
        assert_series_equal(interp_s[1:3], expected)

</source>
</class>

<class classid="186" nclones="2" nlines="24" similarity="79">
<source file="pandas/pandas/tests/series/test_repr.py.pyindent" startline="254" endline="279" pcid="8552">
    def test_categorical_series_repr(self):
        s = Series(Categorical([1, 2, 3]))
        exp = """0    1
1    2
2    3
dtype: category
Categories (3, int64): [1, 2, 3]"""

        assert repr(s) == exp

        s = Series(Categorical(np.arange(10)))
        exp = """0    0
1    1
2    2
3    3
4    4
5    5
6    6
7    7
8    8
9    9
dtype: category
Categories (10, int64): [0, 1, 2, 3, ..., 6, 7, 8, 9]"""

        assert repr(s) == exp

</source>
<source file="pandas/pandas/tests/series/test_repr.py.pyindent" startline="280" endline="305" pcid="8553">
    def test_categorical_series_repr_ordered(self):
        s = Series(Categorical([1, 2, 3], ordered=True))
        exp = """0    1
1    2
2    3
dtype: category
Categories (3, int64): [1 < 2 < 3]"""

        assert repr(s) == exp

        s = Series(Categorical(np.arange(10), ordered=True))
        exp = """0    0
1    1
2    2
3    3
4    4
5    5
6    6
7    7
8    8
9    9
dtype: category
Categories (10, int64): [0 < 1 < 2 < 3 ... 6 < 7 < 8 < 9]"""

        assert repr(s) == exp

</source>
</class>

<class classid="187" nclones="2" nlines="27" similarity="74">
<source file="pandas/pandas/tests/series/test_repr.py.pyindent" startline="306" endline="334" pcid="8554">
    def test_categorical_series_repr_datetime(self):
        idx = date_range('2011-01-01 09:00', freq='H', periods=5)
        s = Series(Categorical(idx))
        exp = """0   2011-01-01 09:00:00
1   2011-01-01 10:00:00
2   2011-01-01 11:00:00
3   2011-01-01 12:00:00
4   2011-01-01 13:00:00
dtype: category
Categories (5, datetime64[ns]): [2011-01-01 09:00:00, 2011-01-01 10:00:00, 2011-01-01 11:00:00,
                                 2011-01-01 12:00:00, 2011-01-01 13:00:00]"""  # noqa

        assert repr(s) == exp

        idx = date_range('2011-01-01 09:00', freq='H', periods=5,
                         tz='US/Eastern')
        s = Series(Categorical(idx))
        exp = """0   2011-01-01 09:00:00-05:00
1   2011-01-01 10:00:00-05:00
2   2011-01-01 11:00:00-05:00
3   2011-01-01 12:00:00-05:00
4   2011-01-01 13:00:00-05:00
dtype: category
Categories (5, datetime64[ns, US/Eastern]): [2011-01-01 09:00:00-05:00, 2011-01-01 10:00:00-05:00,
                                             2011-01-01 11:00:00-05:00, 2011-01-01 12:00:00-05:00,
                                             2011-01-01 13:00:00-05:00]"""  # noqa

        assert repr(s) == exp

</source>
<source file="pandas/pandas/tests/series/test_repr.py.pyindent" startline="335" endline="363" pcid="8555">
    def test_categorical_series_repr_datetime_ordered(self):
        idx = date_range('2011-01-01 09:00', freq='H', periods=5)
        s = Series(Categorical(idx, ordered=True))
        exp = """0   2011-01-01 09:00:00
1   2011-01-01 10:00:00
2   2011-01-01 11:00:00
3   2011-01-01 12:00:00
4   2011-01-01 13:00:00
dtype: category
Categories (5, datetime64[ns]): [2011-01-01 09:00:00 < 2011-01-01 10:00:00 < 2011-01-01 11:00:00 <
                                 2011-01-01 12:00:00 < 2011-01-01 13:00:00]"""  # noqa

        assert repr(s) == exp

        idx = date_range('2011-01-01 09:00', freq='H', periods=5,
                         tz='US/Eastern')
        s = Series(Categorical(idx, ordered=True))
        exp = """0   2011-01-01 09:00:00-05:00
1   2011-01-01 10:00:00-05:00
2   2011-01-01 11:00:00-05:00
3   2011-01-01 12:00:00-05:00
4   2011-01-01 13:00:00-05:00
dtype: category
Categories (5, datetime64[ns, US/Eastern]): [2011-01-01 09:00:00-05:00 < 2011-01-01 10:00:00-05:00 <
                                             2011-01-01 11:00:00-05:00 < 2011-01-01 12:00:00-05:00 <
                                             2011-01-01 13:00:00-05:00]"""  # noqa

        assert repr(s) == exp

</source>
</class>

<class classid="188" nclones="2" nlines="24" similarity="79">
<source file="pandas/pandas/tests/series/test_repr.py.pyindent" startline="364" endline="389" pcid="8556">
    def test_categorical_series_repr_period(self):
        idx = period_range('2011-01-01 09:00', freq='H', periods=5)
        s = Series(Categorical(idx))
        exp = """0   2011-01-01 09:00
1   2011-01-01 10:00
2   2011-01-01 11:00
3   2011-01-01 12:00
4   2011-01-01 13:00
dtype: category
Categories (5, period[H]): [2011-01-01 09:00, 2011-01-01 10:00, 2011-01-01 11:00, 2011-01-01 12:00,
                            2011-01-01 13:00]"""  # noqa

        assert repr(s) == exp

        idx = period_range('2011-01', freq='M', periods=5)
        s = Series(Categorical(idx))
        exp = """0   2011-01
1   2011-02
2   2011-03
3   2011-04
4   2011-05
dtype: category
Categories (5, period[M]): [2011-01, 2011-02, 2011-03, 2011-04, 2011-05]"""

        assert repr(s) == exp

</source>
<source file="pandas/pandas/tests/series/test_repr.py.pyindent" startline="390" endline="415" pcid="8557">
    def test_categorical_series_repr_period_ordered(self):
        idx = period_range('2011-01-01 09:00', freq='H', periods=5)
        s = Series(Categorical(idx, ordered=True))
        exp = """0   2011-01-01 09:00
1   2011-01-01 10:00
2   2011-01-01 11:00
3   2011-01-01 12:00
4   2011-01-01 13:00
dtype: category
Categories (5, period[H]): [2011-01-01 09:00 < 2011-01-01 10:00 < 2011-01-01 11:00 < 2011-01-01 12:00 <
                            2011-01-01 13:00]"""  # noqa

        assert repr(s) == exp

        idx = period_range('2011-01', freq='M', periods=5)
        s = Series(Categorical(idx, ordered=True))
        exp = """0   2011-01
1   2011-02
2   2011-03
3   2011-04
4   2011-05
dtype: category
Categories (5, period[M]): [2011-01 < 2011-02 < 2011-03 < 2011-04 < 2011-05]"""

        assert repr(s) == exp

</source>
</class>

<class classid="189" nclones="2" nlines="30" similarity="76">
<source file="pandas/pandas/tests/series/test_repr.py.pyindent" startline="416" endline="447" pcid="8558">
    def test_categorical_series_repr_timedelta(self):
        idx = timedelta_range('1 days', periods=5)
        s = Series(Categorical(idx))
        exp = """0   1 days
1   2 days
2   3 days
3   4 days
4   5 days
dtype: category
Categories (5, timedelta64[ns]): [1 days, 2 days, 3 days, 4 days, 5 days]"""

        assert repr(s) == exp

        idx = timedelta_range('1 hours', periods=10)
        s = Series(Categorical(idx))
        exp = """0   0 days 01:00:00
1   1 days 01:00:00
2   2 days 01:00:00
3   3 days 01:00:00
4   4 days 01:00:00
5   5 days 01:00:00
6   6 days 01:00:00
7   7 days 01:00:00
8   8 days 01:00:00
9   9 days 01:00:00
dtype: category
Categories (10, timedelta64[ns]): [0 days 01:00:00, 1 days 01:00:00, 2 days 01:00:00,
                                   3 days 01:00:00, ..., 6 days 01:00:00, 7 days 01:00:00,
                                   8 days 01:00:00, 9 days 01:00:00]"""  # noqa

        assert repr(s) == exp

</source>
<source file="pandas/pandas/tests/series/test_repr.py.pyindent" startline="448" endline="478" pcid="8559">
    def test_categorical_series_repr_timedelta_ordered(self):
        idx = timedelta_range('1 days', periods=5)
        s = Series(Categorical(idx, ordered=True))
        exp = """0   1 days
1   2 days
2   3 days
3   4 days
4   5 days
dtype: category
Categories (5, timedelta64[ns]): [1 days < 2 days < 3 days < 4 days < 5 days]"""  # noqa

        assert repr(s) == exp

        idx = timedelta_range('1 hours', periods=10)
        s = Series(Categorical(idx, ordered=True))
        exp = """0   0 days 01:00:00
1   1 days 01:00:00
2   2 days 01:00:00
3   3 days 01:00:00
4   4 days 01:00:00
5   5 days 01:00:00
6   6 days 01:00:00
7   7 days 01:00:00
8   8 days 01:00:00
9   9 days 01:00:00
dtype: category
Categories (10, timedelta64[ns]): [0 days 01:00:00 < 1 days 01:00:00 < 2 days 01:00:00 <
                                   3 days 01:00:00 ... 6 days 01:00:00 < 7 days 01:00:00 <
                                   8 days 01:00:00 < 9 days 01:00:00]"""  # noqa

        assert repr(s) == exp
</source>
</class>

<class classid="190" nclones="2" nlines="12" similarity="83">
<source file="pandas/pandas/tests/sparse/frame/test_analytics.py.pyindent" startline="9" endline="24" pcid="8646">
def test_quantile():
    # GH 17386
    data = [[1, 1], [2, 10], [3, 100], [np.nan, np.nan]]
    q = 0.1

    sparse_df = SparseDataFrame(data)
    result = sparse_df.quantile(q)

    dense_df = DataFrame(data)
    dense_expected = dense_df.quantile(q)
    sparse_expected = SparseSeries(dense_expected)

    tm.assert_series_equal(result, dense_expected)
    tm.assert_sp_series_equal(result, sparse_expected)


</source>
<source file="pandas/pandas/tests/sparse/frame/test_frame.py.pyindent" startline="1263" endline="1277" pcid="8744">
    def test_quantile(self):
        # GH 17386
        data = [[1, 1], [2, 10], [3, 100], [nan, nan]]
        q = 0.1

        sparse_df = SparseDataFrame(data)
        result = sparse_df.quantile(q)

        dense_df = DataFrame(data)
        dense_expected = dense_df.quantile(q)
        sparse_expected = SparseSeries(dense_expected)

        tm.assert_series_equal(result, dense_expected)
        tm.assert_sp_series_equal(result, sparse_expected)

</source>
</class>

<class classid="191" nclones="2" nlines="12" similarity="83">
<source file="pandas/pandas/tests/sparse/frame/test_analytics.py.pyindent" startline="27" endline="40" pcid="8647">
def test_quantile_multi():
    # GH 17386
    data = [[1, 1], [2, 10], [3, 100], [np.nan, np.nan]]
    q = [0.1, 0.5]

    sparse_df = SparseDataFrame(data)
    result = sparse_df.quantile(q)

    dense_df = DataFrame(data)
    dense_expected = dense_df.quantile(q)
    sparse_expected = SparseDataFrame(dense_expected)

    tm.assert_frame_equal(result, dense_expected)
    tm.assert_sp_frame_equal(result, sparse_expected)
</source>
<source file="pandas/pandas/tests/sparse/frame/test_frame.py.pyindent" startline="1280" endline="1294" pcid="8745">
    def test_quantile_multi(self):
        # GH 17386
        data = [[1, 1], [2, 10], [3, 100], [nan, nan]]
        q = [0.1, 0.5]

        sparse_df = SparseDataFrame(data)
        result = sparse_df.quantile(q)

        dense_df = DataFrame(data)
        dense_expected = dense_df.quantile(q)
        sparse_expected = SparseDataFrame(dense_expected)

        tm.assert_frame_equal(result, dense_expected)
        tm.assert_sp_frame_equal(result, sparse_expected)

</source>
</class>

<class classid="192" nclones="2" nlines="19" similarity="75">
<source file="pandas/pandas/tests/sparse/frame/test_frame.py.pyindent" startline="754" endline="774" pcid="8708">
    def test_sparse_frame_pad_backfill_limit(self):
        index = np.arange(10)
        df = DataFrame(np.random.randn(10, 4), index=index)
        sdf = df.to_sparse()

        result = sdf[:2].reindex(index, method='pad', limit=5)

        expected = sdf[:2].reindex(index).fillna(method='pad')
        expected = expected.to_dense()
        expected.values[-3:] = np.nan
        expected = expected.to_sparse()
        tm.assert_frame_equal(result, expected)

        result = sdf[-2:].reindex(index, method='backfill', limit=5)

        expected = sdf[-2:].reindex(index).fillna(method='backfill')
        expected = expected.to_dense()
        expected.values[:3] = np.nan
        expected = expected.to_sparse()
        tm.assert_frame_equal(result, expected)

</source>
<source file="pandas/pandas/tests/sparse/frame/test_frame.py.pyindent" startline="775" endline="797" pcid="8709">
    def test_sparse_frame_fillna_limit(self):
        index = np.arange(10)
        df = DataFrame(np.random.randn(10, 4), index=index)
        sdf = df.to_sparse()

        result = sdf[:2].reindex(index)
        result = result.fillna(method='pad', limit=5)

        expected = sdf[:2].reindex(index).fillna(method='pad')
        expected = expected.to_dense()
        expected.values[-3:] = np.nan
        expected = expected.to_sparse()
        tm.assert_frame_equal(result, expected)

        result = sdf[-2:].reindex(index)
        result = result.fillna(method='backfill', limit=5)

        expected = sdf[-2:].reindex(index).fillna(method='backfill')
        expected = expected.to_dense()
        expected.values[:3] = np.nan
        expected = expected.to_sparse()
        tm.assert_frame_equal(result, expected)

</source>
</class>

<class classid="193" nclones="2" nlines="20" similarity="100">
<source file="pandas/pandas/tests/sparse/series/test_series.py.pyindent" startline="1163" endline="1183" pcid="8848">
    def test_concat(self):
        val1 = np.array([1, 2, np.nan, np.nan, 0, np.nan])
        val2 = np.array([3, np.nan, 4, 0, 0])

        for kind in ['integer', 'block']:
            sparse1 = pd.SparseSeries(val1, name='x', kind=kind)
            sparse2 = pd.SparseSeries(val2, name='y', kind=kind)

            res = pd.concat([sparse1, sparse2])
            exp = pd.concat([pd.Series(val1), pd.Series(val2)])
            exp = pd.SparseSeries(exp, kind=kind)
            tm.assert_sp_series_equal(res, exp)

            sparse1 = pd.SparseSeries(val1, fill_value=0, name='x', kind=kind)
            sparse2 = pd.SparseSeries(val2, fill_value=0, name='y', kind=kind)

            res = pd.concat([sparse1, sparse2])
            exp = pd.concat([pd.Series(val1), pd.Series(val2)])
            exp = pd.SparseSeries(exp, fill_value=0, kind=kind)
            tm.assert_sp_series_equal(res, exp)

</source>
<source file="pandas/pandas/tests/sparse/test_combine_concat.py.pyindent" startline="12" endline="32" pcid="8887">
    def test_concat(self):
        val1 = np.array([1, 2, np.nan, np.nan, 0, np.nan])
        val2 = np.array([3, np.nan, 4, 0, 0])

        for kind in ['integer', 'block']:
            sparse1 = pd.SparseSeries(val1, name='x', kind=kind)
            sparse2 = pd.SparseSeries(val2, name='y', kind=kind)

            res = pd.concat([sparse1, sparse2])
            exp = pd.concat([pd.Series(val1), pd.Series(val2)])
            exp = pd.SparseSeries(exp, kind=kind)
            tm.assert_sp_series_equal(res, exp)

            sparse1 = pd.SparseSeries(val1, fill_value=0, name='x', kind=kind)
            sparse2 = pd.SparseSeries(val2, fill_value=0, name='y', kind=kind)

            res = pd.concat([sparse1, sparse2])
            exp = pd.concat([pd.Series(val1), pd.Series(val2)])
            exp = pd.SparseSeries(exp, fill_value=0, kind=kind)
            tm.assert_sp_series_equal(res, exp)

</source>
</class>

<class classid="194" nclones="2" nlines="12" similarity="100">
<source file="pandas/pandas/tests/sparse/series/test_series.py.pyindent" startline="1184" endline="1196" pcid="8849">
    def test_concat_axis1(self):
        val1 = np.array([1, 2, np.nan, np.nan, 0, np.nan])
        val2 = np.array([3, np.nan, 4, 0, 0])

        sparse1 = pd.SparseSeries(val1, name='x')
        sparse2 = pd.SparseSeries(val2, name='y')

        res = pd.concat([sparse1, sparse2], axis=1)
        exp = pd.concat([pd.Series(val1, name='x'),
                         pd.Series(val2, name='y')], axis=1)
        exp = pd.SparseDataFrame(exp)
        tm.assert_sp_frame_equal(res, exp)

</source>
<source file="pandas/pandas/tests/sparse/test_combine_concat.py.pyindent" startline="33" endline="45" pcid="8888">
    def test_concat_axis1(self):
        val1 = np.array([1, 2, np.nan, np.nan, 0, np.nan])
        val2 = np.array([3, np.nan, 4, 0, 0])

        sparse1 = pd.SparseSeries(val1, name='x')
        sparse2 = pd.SparseSeries(val2, name='y')

        res = pd.concat([sparse1, sparse2], axis=1)
        exp = pd.concat([pd.Series(val1, name='x'),
                         pd.Series(val2, name='y')], axis=1)
        exp = pd.SparseDataFrame(exp)
        tm.assert_sp_frame_equal(res, exp)

</source>
</class>

<class classid="195" nclones="2" nlines="18" similarity="100">
<source file="pandas/pandas/tests/sparse/series/test_series.py.pyindent" startline="1197" endline="1214" pcid="8850">
    def test_concat_different_fill(self):
        val1 = np.array([1, 2, np.nan, np.nan, 0, np.nan])
        val2 = np.array([3, np.nan, 4, 0, 0])

        for kind in ['integer', 'block']:
            sparse1 = pd.SparseSeries(val1, name='x', kind=kind)
            sparse2 = pd.SparseSeries(val2, name='y', kind=kind, fill_value=0)

            res = pd.concat([sparse1, sparse2])
            exp = pd.concat([pd.Series(val1), pd.Series(val2)])
            exp = pd.SparseSeries(exp, kind=kind)
            tm.assert_sp_series_equal(res, exp)

            res = pd.concat([sparse2, sparse1])
            exp = pd.concat([pd.Series(val2), pd.Series(val1)])
            exp = pd.SparseSeries(exp, kind=kind, fill_value=0)
            tm.assert_sp_series_equal(res, exp)

</source>
<source file="pandas/pandas/tests/sparse/test_combine_concat.py.pyindent" startline="46" endline="63" pcid="8889">
    def test_concat_different_fill(self):
        val1 = np.array([1, 2, np.nan, np.nan, 0, np.nan])
        val2 = np.array([3, np.nan, 4, 0, 0])

        for kind in ['integer', 'block']:
            sparse1 = pd.SparseSeries(val1, name='x', kind=kind)
            sparse2 = pd.SparseSeries(val2, name='y', kind=kind, fill_value=0)

            res = pd.concat([sparse1, sparse2])
            exp = pd.concat([pd.Series(val1), pd.Series(val2)])
            exp = pd.SparseSeries(exp, kind=kind)
            tm.assert_sp_series_equal(res, exp)

            res = pd.concat([sparse2, sparse1])
            exp = pd.concat([pd.Series(val2), pd.Series(val1)])
            exp = pd.SparseSeries(exp, kind=kind, fill_value=0)
            tm.assert_sp_series_equal(res, exp)

</source>
</class>

<class classid="196" nclones="2" nlines="12" similarity="100">
<source file="pandas/pandas/tests/sparse/series/test_series.py.pyindent" startline="1215" endline="1227" pcid="8851">
    def test_concat_axis1_different_fill(self):
        val1 = np.array([1, 2, np.nan, np.nan, 0, np.nan])
        val2 = np.array([3, np.nan, 4, 0, 0])

        sparse1 = pd.SparseSeries(val1, name='x')
        sparse2 = pd.SparseSeries(val2, name='y', fill_value=0)

        res = pd.concat([sparse1, sparse2], axis=1)
        exp = pd.concat([pd.Series(val1, name='x'),
                         pd.Series(val2, name='y')], axis=1)
        assert isinstance(res, pd.SparseDataFrame)
        tm.assert_frame_equal(res.to_dense(), exp)

</source>
<source file="pandas/pandas/tests/sparse/test_combine_concat.py.pyindent" startline="64" endline="76" pcid="8890">
    def test_concat_axis1_different_fill(self):
        val1 = np.array([1, 2, np.nan, np.nan, 0, np.nan])
        val2 = np.array([3, np.nan, 4, 0, 0])

        sparse1 = pd.SparseSeries(val1, name='x')
        sparse2 = pd.SparseSeries(val2, name='y', fill_value=0)

        res = pd.concat([sparse1, sparse2], axis=1)
        exp = pd.concat([pd.Series(val1, name='x'),
                         pd.Series(val2, name='y')], axis=1)
        assert isinstance(res, pd.SparseDataFrame)
        tm.assert_frame_equal(res.to_dense(), exp)

</source>
</class>

<class classid="197" nclones="2" nlines="15" similarity="100">
<source file="pandas/pandas/tests/sparse/series/test_series.py.pyindent" startline="1228" endline="1244" pcid="8852">
    def test_concat_different_kind(self):
        val1 = np.array([1, 2, np.nan, np.nan, 0, np.nan])
        val2 = np.array([3, np.nan, 4, 0, 0])

        sparse1 = pd.SparseSeries(val1, name='x', kind='integer')
        sparse2 = pd.SparseSeries(val2, name='y', kind='block', fill_value=0)

        res = pd.concat([sparse1, sparse2])
        exp = pd.concat([pd.Series(val1), pd.Series(val2)])
        exp = pd.SparseSeries(exp, kind='integer')
        tm.assert_sp_series_equal(res, exp)

        res = pd.concat([sparse2, sparse1])
        exp = pd.concat([pd.Series(val2), pd.Series(val1)])
        exp = pd.SparseSeries(exp, kind='block', fill_value=0)
        tm.assert_sp_series_equal(res, exp)

</source>
<source file="pandas/pandas/tests/sparse/test_combine_concat.py.pyindent" startline="77" endline="93" pcid="8891">
    def test_concat_different_kind(self):
        val1 = np.array([1, 2, np.nan, np.nan, 0, np.nan])
        val2 = np.array([3, np.nan, 4, 0, 0])

        sparse1 = pd.SparseSeries(val1, name='x', kind='integer')
        sparse2 = pd.SparseSeries(val2, name='y', kind='block', fill_value=0)

        res = pd.concat([sparse1, sparse2])
        exp = pd.concat([pd.Series(val1), pd.Series(val2)])
        exp = pd.SparseSeries(exp, kind='integer')
        tm.assert_sp_series_equal(res, exp)

        res = pd.concat([sparse2, sparse1])
        exp = pd.concat([pd.Series(val2), pd.Series(val1)])
        exp = pd.SparseSeries(exp, kind='block', fill_value=0)
        tm.assert_sp_series_equal(res, exp)

</source>
</class>

<class classid="198" nclones="2" nlines="28" similarity="100">
<source file="pandas/pandas/tests/sparse/series/test_series.py.pyindent" startline="1245" endline="1276" pcid="8853">
    def test_concat_sparse_dense(self):
        # use first input's fill_value
        val1 = np.array([1, 2, np.nan, np.nan, 0, np.nan])
        val2 = np.array([3, np.nan, 4, 0, 0])

        for kind in ['integer', 'block']:
            sparse = pd.SparseSeries(val1, name='x', kind=kind)
            dense = pd.Series(val2, name='y')

            res = pd.concat([sparse, dense])
            exp = pd.concat([pd.Series(val1), dense])
            exp = pd.SparseSeries(exp, kind=kind)
            tm.assert_sp_series_equal(res, exp)

            res = pd.concat([dense, sparse, dense])
            exp = pd.concat([dense, pd.Series(val1), dense])
            exp = pd.SparseSeries(exp, kind=kind)
            tm.assert_sp_series_equal(res, exp)

            sparse = pd.SparseSeries(val1, name='x', kind=kind, fill_value=0)
            dense = pd.Series(val2, name='y')

            res = pd.concat([sparse, dense])
            exp = pd.concat([pd.Series(val1), dense])
            exp = pd.SparseSeries(exp, kind=kind, fill_value=0)
            tm.assert_sp_series_equal(res, exp)

            res = pd.concat([dense, sparse, dense])
            exp = pd.concat([dense, pd.Series(val1), dense])
            exp = pd.SparseSeries(exp, kind=kind, fill_value=0)
            tm.assert_sp_series_equal(res, exp)

</source>
<source file="pandas/pandas/tests/sparse/test_combine_concat.py.pyindent" startline="94" endline="126" pcid="8892">
    def test_concat_sparse_dense(self):
        # use first input's fill_value
        val1 = np.array([1, 2, np.nan, np.nan, 0, np.nan])
        val2 = np.array([3, np.nan, 4, 0, 0])

        for kind in ['integer', 'block']:
            sparse = pd.SparseSeries(val1, name='x', kind=kind)
            dense = pd.Series(val2, name='y')

            res = pd.concat([sparse, dense])
            exp = pd.concat([pd.Series(val1), dense])
            exp = pd.SparseSeries(exp, kind=kind)
            tm.assert_sp_series_equal(res, exp)

            res = pd.concat([dense, sparse, dense])
            exp = pd.concat([dense, pd.Series(val1), dense])
            exp = pd.SparseSeries(exp, kind=kind)
            tm.assert_sp_series_equal(res, exp)

            sparse = pd.SparseSeries(val1, name='x', kind=kind, fill_value=0)
            dense = pd.Series(val2, name='y')

            res = pd.concat([sparse, dense])
            exp = pd.concat([pd.Series(val1), dense])
            exp = pd.SparseSeries(exp, kind=kind, fill_value=0)
            tm.assert_sp_series_equal(res, exp)

            res = pd.concat([dense, sparse, dense])
            exp = pd.concat([dense, pd.Series(val1), dense])
            exp = pd.SparseSeries(exp, kind=kind, fill_value=0)
            tm.assert_sp_series_equal(res, exp)


</source>
</class>

<class classid="199" nclones="2" nlines="15" similarity="86">
<source file="pandas/pandas/tests/sparse/series/test_series.py.pyindent" startline="1277" endline="1292" pcid="8854">
    def test_value_counts(self):
        vals = [1, 2, nan, 0, nan, 1, 2, nan, nan, 1, 2, 0, 1, 1]
        dense = pd.Series(vals, name='xx')

        sparse = pd.SparseSeries(vals, name='xx')
        tm.assert_series_equal(sparse.value_counts(),
                               dense.value_counts())
        tm.assert_series_equal(sparse.value_counts(dropna=False),
                               dense.value_counts(dropna=False))

        sparse = pd.SparseSeries(vals, name='xx', fill_value=0)
        tm.assert_series_equal(sparse.value_counts(),
                               dense.value_counts())
        tm.assert_series_equal(sparse.value_counts(dropna=False),
                               dense.value_counts(dropna=False))

</source>
<source file="pandas/pandas/tests/sparse/series/test_series.py.pyindent" startline="1314" endline="1330" pcid="8856">
    def test_value_counts_int(self):
        vals = [1, 2, 0, 1, 2, 1, 2, 0, 1, 1]
        dense = pd.Series(vals, name='xx')

        # fill_value is np.nan, but should not be included in the result
        sparse = pd.SparseSeries(vals, name='xx')
        tm.assert_series_equal(sparse.value_counts(),
                               dense.value_counts())
        tm.assert_series_equal(sparse.value_counts(dropna=False),
                               dense.value_counts(dropna=False))

        sparse = pd.SparseSeries(vals, name='xx', fill_value=0)
        tm.assert_series_equal(sparse.value_counts(),
                               dense.value_counts())
        tm.assert_series_equal(sparse.value_counts(dropna=False),
                               dense.value_counts(dropna=False))

</source>
</class>

<class classid="200" nclones="2" nlines="16" similarity="81">
<source file="pandas/pandas/tests/sparse/test_arithmetics.py.pyindent" startline="169" endline="185" pcid="8874">
    def test_float_same_index(self):
        # when sp_index are the same
        for kind in ['integer', 'block']:
            values = self._base([np.nan, 1, 2, 0, np.nan, 0, 1, 2, 1, np.nan])
            rvalues = self._base([np.nan, 2, 3, 4, np.nan, 0, 1, 3, 2, np.nan])

            a = self._klass(values, kind=kind)
            b = self._klass(rvalues, kind=kind)
            self._check_numeric_ops(a, b, values, rvalues)

            values = self._base([0., 1., 2., 6., 0., 0., 1., 2., 1., 0.])
            rvalues = self._base([0., 2., 3., 4., 0., 0., 1., 3., 2., 0.])

            a = self._klass(values, kind=kind, fill_value=0)
            b = self._klass(rvalues, kind=kind, fill_value=0)
            self._check_numeric_ops(a, b, values, rvalues)

</source>
<source file="pandas/pandas/tests/sparse/test_arithmetics.py.pyindent" startline="186" endline="202" pcid="8875">
    def test_float_same_index_comparison(self):
        # when sp_index are the same
        for kind in ['integer', 'block']:
            values = self._base([np.nan, 1, 2, 0, np.nan, 0, 1, 2, 1, np.nan])
            rvalues = self._base([np.nan, 2, 3, 4, np.nan, 0, 1, 3, 2, np.nan])

            a = self._klass(values, kind=kind)
            b = self._klass(rvalues, kind=kind)
            self._check_comparison_ops(a, b, values, rvalues)

            values = self._base([0., 1., 2., 6., 0., 0., 1., 2., 1., 0.])
            rvalues = self._base([0., 2., 3., 4., 0., 0., 1., 3., 2., 0.])

            a = self._klass(values, kind=kind, fill_value=0)
            b = self._klass(rvalues, kind=kind, fill_value=0)
            self._check_comparison_ops(a, b, values, rvalues)

</source>
</class>

<class classid="201" nclones="2" nlines="21" similarity="71">
<source file="pandas/pandas/tests/sparse/test_arithmetics.py.pyindent" startline="203" endline="224" pcid="8876">
    def test_float_array(self):
        values = self._base([np.nan, 1, 2, 0, np.nan, 0, 1, 2, 1, np.nan])
        rvalues = self._base([2, np.nan, 2, 3, np.nan, 0, 1, 5, 2, np.nan])

        for kind in ['integer', 'block']:
            a = self._klass(values, kind=kind)
            b = self._klass(rvalues, kind=kind)
            self._check_numeric_ops(a, b, values, rvalues)
            self._check_numeric_ops(a, b * 0, values, rvalues * 0)

            a = self._klass(values, kind=kind, fill_value=0)
            b = self._klass(rvalues, kind=kind)
            self._check_numeric_ops(a, b, values, rvalues)

            a = self._klass(values, kind=kind, fill_value=0)
            b = self._klass(rvalues, kind=kind, fill_value=0)
            self._check_numeric_ops(a, b, values, rvalues)

            a = self._klass(values, kind=kind, fill_value=1)
            b = self._klass(rvalues, kind=kind, fill_value=2)
            self._check_numeric_ops(a, b, values, rvalues)

</source>
<source file="pandas/pandas/tests/sparse/test_arithmetics.py.pyindent" startline="246" endline="267" pcid="8878">
    def test_float_array_comparison(self):
        values = self._base([np.nan, 1, 2, 0, np.nan, 0, 1, 2, 1, np.nan])
        rvalues = self._base([2, np.nan, 2, 3, np.nan, 0, 1, 5, 2, np.nan])

        for kind in ['integer', 'block']:
            a = self._klass(values, kind=kind)
            b = self._klass(rvalues, kind=kind)
            self._check_comparison_ops(a, b, values, rvalues)
            self._check_comparison_ops(a, b * 0, values, rvalues * 0)

            a = self._klass(values, kind=kind, fill_value=0)
            b = self._klass(rvalues, kind=kind)
            self._check_comparison_ops(a, b, values, rvalues)

            a = self._klass(values, kind=kind, fill_value=0)
            b = self._klass(rvalues, kind=kind, fill_value=0)
            self._check_comparison_ops(a, b, values, rvalues)

            a = self._klass(values, kind=kind, fill_value=1)
            b = self._klass(rvalues, kind=kind, fill_value=2)
            self._check_comparison_ops(a, b, values, rvalues)

</source>
</class>

<class classid="202" nclones="2" nlines="17" similarity="72">
<source file="pandas/pandas/tests/sparse/test_arithmetics.py.pyindent" startline="328" endline="341" pcid="8881">
    def test_bool_same_index(self):
        # GH 14000
        # when sp_index are the same
        for kind in ['integer', 'block']:
            values = self._base([True, False, True, True], dtype=np.bool)
            rvalues = self._base([True, False, True, True], dtype=np.bool)

            for fill_value in [True, False, np.nan]:
                a = self._klass(values, kind=kind, dtype=np.bool,
                                fill_value=fill_value)
                b = self._klass(rvalues, kind=kind, dtype=np.bool,
                                fill_value=fill_value)
                self._check_logical_ops(a, b, values, rvalues)

</source>
<source file="pandas/pandas/tests/sparse/test_arithmetics.py.pyindent" startline="342" endline="357" pcid="8882">
    def test_bool_array_logical(self):
        # GH 14000
        # when sp_index are the same
        for kind in ['integer', 'block']:
            values = self._base([True, False, True, False, True, True],
                                dtype=np.bool)
            rvalues = self._base([True, False, False, True, False, True],
                                 dtype=np.bool)

            for fill_value in [True, False, np.nan]:
                a = self._klass(values, kind=kind, dtype=np.bool,
                                fill_value=fill_value)
                b = self._klass(rvalues, kind=kind, dtype=np.bool,
                                fill_value=fill_value)
                self._check_logical_ops(a, b, values, rvalues)

</source>
</class>

<class classid="203" nclones="2" nlines="28" similarity="78">
<source file="pandas/pandas/tests/sparse/test_arithmetics.py.pyindent" startline="358" endline="386" pcid="8883">
    def test_mixed_array_float_int(self):

        for rdtype in ['int64']:
            values = self._base([np.nan, 1, 2, 0, np.nan, 0, 1, 2, 1, np.nan])
            rvalues = self._base([2, 0, 2, 3, 0, 0, 1, 5, 2, 0], dtype=rdtype)

            for kind in ['integer', 'block']:
                a = self._klass(values, kind=kind)
                b = self._klass(rvalues, kind=kind)
                assert b.dtype == rdtype

                self._check_numeric_ops(a, b, values, rvalues)
                self._check_numeric_ops(a, b * 0, values, rvalues * 0)

                a = self._klass(values, kind=kind, fill_value=0)
                b = self._klass(rvalues, kind=kind)
                assert b.dtype == rdtype
                self._check_numeric_ops(a, b, values, rvalues)

                a = self._klass(values, kind=kind, fill_value=0)
                b = self._klass(rvalues, kind=kind, fill_value=0)
                assert b.dtype == rdtype
                self._check_numeric_ops(a, b, values, rvalues)

                a = self._klass(values, kind=kind, fill_value=1)
                b = self._klass(rvalues, kind=kind, fill_value=2)
                assert b.dtype == rdtype
                self._check_numeric_ops(a, b, values, rvalues)

</source>
<source file="pandas/pandas/tests/sparse/test_arithmetics.py.pyindent" startline="387" endline="417" pcid="8884">
    def test_mixed_array_comparison(self):

        # int32 NI ATM
        for rdtype in ['int64']:
            values = self._base([np.nan, 1, 2, 0, np.nan, 0, 1, 2, 1, np.nan])
            rvalues = self._base([2, 0, 2, 3, 0, 0, 1, 5, 2, 0], dtype=rdtype)

            for kind in ['integer', 'block']:
                a = self._klass(values, kind=kind)
                b = self._klass(rvalues, kind=kind)
                assert b.dtype == rdtype

                self._check_comparison_ops(a, b, values, rvalues)
                self._check_comparison_ops(a, b * 0, values, rvalues * 0)

                a = self._klass(values, kind=kind, fill_value=0)
                b = self._klass(rvalues, kind=kind)
                assert b.dtype == rdtype
                self._check_comparison_ops(a, b, values, rvalues)

                a = self._klass(values, kind=kind, fill_value=0)
                b = self._klass(rvalues, kind=kind, fill_value=0)
                assert b.dtype == rdtype
                self._check_comparison_ops(a, b, values, rvalues)

                a = self._klass(values, kind=kind, fill_value=1)
                b = self._klass(rvalues, kind=kind, fill_value=2)
                assert b.dtype == rdtype
                self._check_comparison_ops(a, b, values, rvalues)


</source>
</class>

<class classid="204" nclones="2" nlines="12" similarity="100">
<source file="pandas/pandas/tests/sparse/test_groupby.py.pyindent" startline="9" endline="19" pcid="8909">
    def setup_method(self, method):
        self.dense = pd.DataFrame({'A': ['foo', 'bar', 'foo', 'bar',
                                         'foo', 'bar', 'foo', 'foo'],
                                   'B': ['one', 'one', 'two', 'three',
                                         'two', 'two', 'one', 'three'],
                                   'C': np.random.randn(8),
                                   'D': np.random.randn(8),
                                   'E': [np.nan, np.nan, 1, 2,
                                         np.nan, 1, np.nan, np.nan]})
        self.sparse = self.dense.to_sparse()

</source>
<source file="pandas/pandas/tests/sparse/test_pivot.py.pyindent" startline="8" endline="18" pcid="9002">
    def setup_method(self, method):
        self.dense = pd.DataFrame({'A': ['foo', 'bar', 'foo', 'bar',
                                         'foo', 'bar', 'foo', 'foo'],
                                   'B': ['one', 'one', 'two', 'three',
                                         'two', 'two', 'one', 'three'],
                                   'C': np.random.randn(8),
                                   'D': np.random.randn(8),
                                   'E': [np.nan, np.nan, 1, 2,
                                         np.nan, 1, np.nan, np.nan]})
        self.sparse = self.dense.to_sparse()

</source>
</class>

<class classid="205" nclones="2" nlines="20" similarity="76">
<source file="pandas/pandas/tests/sparse/test_indexing.py.pyindent" startline="15" endline="40" pcid="8913">
    def test_getitem(self):
        orig = self.orig
        sparse = self.sparse

        assert sparse[0] == 1
        assert np.isnan(sparse[1])
        assert sparse[3] == 3

        result = sparse[[1, 3, 4]]
        exp = orig[[1, 3, 4]].to_sparse()
        tm.assert_sp_series_equal(result, exp)

        # dense array
        result = sparse[orig % 2 == 1]
        exp = orig[orig % 2 == 1].to_sparse()
        tm.assert_sp_series_equal(result, exp)

        # sparse array (actuary it coerces to normal Series)
        result = sparse[sparse % 2 == 1]
        exp = orig[orig % 2 == 1].to_sparse()
        tm.assert_sp_series_equal(result, exp)

        # sparse array
        result = sparse[pd.SparseArray(sparse % 2 == 1, dtype=bool)]
        tm.assert_sp_series_equal(result, exp)

</source>
<source file="pandas/pandas/tests/sparse/test_indexing.py.pyindent" startline="461" endline="489" pcid="8942">
    def test_getitem_multi(self):
        orig = self.orig
        sparse = self.sparse

        assert sparse[0] == orig[0]
        assert np.isnan(sparse[1])
        assert sparse[3] == orig[3]

        tm.assert_sp_series_equal(sparse['A'], orig['A'].to_sparse())
        tm.assert_sp_series_equal(sparse['B'], orig['B'].to_sparse())

        result = sparse[[1, 3, 4]]
        exp = orig[[1, 3, 4]].to_sparse()
        tm.assert_sp_series_equal(result, exp)

        # dense array
        result = sparse[orig % 2 == 1]
        exp = orig[orig % 2 == 1].to_sparse()
        tm.assert_sp_series_equal(result, exp)

        # sparse array (actuary it coerces to normal Series)
        result = sparse[sparse % 2 == 1]
        exp = orig[orig % 2 == 1].to_sparse()
        tm.assert_sp_series_equal(result, exp)

        # sparse array
        result = sparse[pd.SparseArray(sparse % 2 == 1, dtype=bool)]
        tm.assert_sp_series_equal(result, exp)

</source>
</class>

<class classid="206" nclones="2" nlines="11" similarity="81">
<source file="pandas/pandas/tests/sparse/test_indexing.py.pyindent" startline="498" endline="509" pcid="8944">
    def test_getitems_slice_multi(self):
        orig = self.orig
        sparse = self.sparse

        tm.assert_sp_series_equal(sparse[2:], orig[2:].to_sparse())
        tm.assert_sp_series_equal(sparse.loc['B':], orig.loc['B':].to_sparse())
        tm.assert_sp_series_equal(sparse.loc['C':], orig.loc['C':].to_sparse())

        tm.assert_sp_series_equal(sparse.loc['A':'B'],
                                  orig.loc['A':'B'].to_sparse())
        tm.assert_sp_series_equal(sparse.loc[:'B'], orig.loc[:'B'].to_sparse())

</source>
<source file="pandas/pandas/tests/sparse/test_indexing.py.pyindent" startline="556" endline="566" pcid="8947">
    def test_loc_slice(self):
        orig = self.orig
        sparse = self.sparse
        tm.assert_sp_series_equal(sparse.loc['A':], orig.loc['A':].to_sparse())
        tm.assert_sp_series_equal(sparse.loc['B':], orig.loc['B':].to_sparse())
        tm.assert_sp_series_equal(sparse.loc['C':], orig.loc['C':].to_sparse())

        tm.assert_sp_series_equal(sparse.loc['A':'B'],
                                  orig.loc['A':'B'].to_sparse())
        tm.assert_sp_series_equal(sparse.loc[:'B'], orig.loc[:'B'].to_sparse())

</source>
</class>

<class classid="207" nclones="2" nlines="13" similarity="84">
<source file="pandas/pandas/tests/sparse/test_indexing.py.pyindent" startline="811" endline="822" pcid="8956">
    def test_at(self):
        orig = pd.DataFrame([[1, np.nan, 0],
                             [2, 3, np.nan],
                             [0, np.nan, 4],
                             [0, np.nan, 5]],
                            index=list('ABCD'), columns=list('xyz'))
        sparse = orig.to_sparse()
        assert sparse.at['A', 'x'] == orig.at['A', 'x']
        assert np.isnan(sparse.at['B', 'z'])
        assert np.isnan(sparse.at['C', 'y'])
        assert sparse.at['D', 'x'] == orig.at['D', 'x']

</source>
<source file="pandas/pandas/tests/sparse/test_indexing.py.pyindent" startline="823" endline="834" pcid="8957">
    def test_at_fill_value(self):
        orig = pd.DataFrame([[1, np.nan, 0],
                             [2, 3, np.nan],
                             [0, np.nan, 4],
                             [0, np.nan, 5]],
                            index=list('ABCD'), columns=list('xyz'))
        sparse = orig.to_sparse(fill_value=0)
        assert sparse.at['A', 'x'] == orig.at['A', 'x']
        assert np.isnan(sparse.at['B', 'z'])
        assert np.isnan(sparse.at['C', 'y'])
        assert sparse.at['D', 'x'] == orig.at['D', 'x']

</source>
</class>

<class classid="208" nclones="2" nlines="15" similarity="86">
<source file="pandas/pandas/tests/sparse/test_indexing.py.pyindent" startline="835" endline="849" pcid="8958">
    def test_iat(self):
        orig = pd.DataFrame([[1, np.nan, 0],
                             [2, 3, np.nan],
                             [0, np.nan, 4],
                             [0, np.nan, 5]],
                            index=list('ABCD'), columns=list('xyz'))
        sparse = orig.to_sparse()
        assert sparse.iat[0, 0] == orig.iat[0, 0]
        assert np.isnan(sparse.iat[1, 2])
        assert np.isnan(sparse.iat[2, 1])
        assert sparse.iat[2, 0] == orig.iat[2, 0]

        assert np.isnan(sparse.iat[-1, -2])
        assert sparse.iat[-1, -1] == orig.iat[-1, -1]

</source>
<source file="pandas/pandas/tests/sparse/test_indexing.py.pyindent" startline="850" endline="864" pcid="8959">
    def test_iat_fill_value(self):
        orig = pd.DataFrame([[1, np.nan, 0],
                             [2, 3, np.nan],
                             [0, np.nan, 4],
                             [0, np.nan, 5]],
                            index=list('ABCD'), columns=list('xyz'))
        sparse = orig.to_sparse(fill_value=0)
        assert sparse.iat[0, 0] == orig.iat[0, 0]
        assert np.isnan(sparse.iat[1, 2])
        assert np.isnan(sparse.iat[2, 1])
        assert sparse.iat[2, 0] == orig.iat[2, 0]

        assert np.isnan(sparse.iat[-1, -2])
        assert sparse.iat[-1, -1] == orig.iat[-1, -1]

</source>
</class>

<class classid="209" nclones="2" nlines="19" similarity="100">
<source file="pandas/pandas/tests/sparse/test_libsparse.py.pyindent" startline="242" endline="261" pcid="8981">
    def test_int_internal(self):
        idx = _make_index(4, np.array([2, 3], dtype=np.int32), kind='integer')
        assert isinstance(idx, IntIndex)
        assert idx.npoints == 2
        tm.assert_numpy_array_equal(idx.indices,
                                    np.array([2, 3], dtype=np.int32))

        idx = _make_index(4, np.array([], dtype=np.int32), kind='integer')
        assert isinstance(idx, IntIndex)
        assert idx.npoints == 0
        tm.assert_numpy_array_equal(idx.indices,
                                    np.array([], dtype=np.int32))

        idx = _make_index(4, np.array([0, 1, 2, 3], dtype=np.int32),
                          kind='integer')
        assert isinstance(idx, IntIndex)
        assert idx.npoints == 4
        tm.assert_numpy_array_equal(idx.indices,
                                    np.array([0, 1, 2, 3], dtype=np.int32))

</source>
<source file="pandas/pandas/tests/sparse/test_libsparse.py.pyindent" startline="513" endline="532" pcid="8994">
    def test_int_internal(self):
        idx = _make_index(4, np.array([2, 3], dtype=np.int32), kind='integer')
        assert isinstance(idx, IntIndex)
        assert idx.npoints == 2
        tm.assert_numpy_array_equal(idx.indices,
                                    np.array([2, 3], dtype=np.int32))

        idx = _make_index(4, np.array([], dtype=np.int32), kind='integer')
        assert isinstance(idx, IntIndex)
        assert idx.npoints == 0
        tm.assert_numpy_array_equal(idx.indices,
                                    np.array([], dtype=np.int32))

        idx = _make_index(4, np.array([0, 1, 2, 3], dtype=np.int32),
                          kind='integer')
        assert isinstance(idx, IntIndex)
        assert idx.npoints == 4
        tm.assert_numpy_array_equal(idx.indices,
                                    np.array([0, 1, 2, 3], dtype=np.int32))

</source>
</class>

<class classid="210" nclones="2" nlines="33" similarity="93">
<source file="pandas/pandas/tests/sparse/test_libsparse.py.pyindent" startline="262" endline="296" pcid="8982">
    def test_block_internal(self):
        idx = _make_index(4, np.array([2, 3], dtype=np.int32), kind='block')
        assert isinstance(idx, BlockIndex)
        assert idx.npoints == 2
        tm.assert_numpy_array_equal(idx.blocs,
                                    np.array([2], dtype=np.int32))
        tm.assert_numpy_array_equal(idx.blengths,
                                    np.array([2], dtype=np.int32))

        idx = _make_index(4, np.array([], dtype=np.int32), kind='block')
        assert isinstance(idx, BlockIndex)
        assert idx.npoints == 0
        tm.assert_numpy_array_equal(idx.blocs,
                                    np.array([], dtype=np.int32))
        tm.assert_numpy_array_equal(idx.blengths,
                                    np.array([], dtype=np.int32))

        idx = _make_index(4, np.array([0, 1, 2, 3], dtype=np.int32),
                          kind='block')
        assert isinstance(idx, BlockIndex)
        assert idx.npoints == 4
        tm.assert_numpy_array_equal(idx.blocs,
                                    np.array([0], dtype=np.int32))
        tm.assert_numpy_array_equal(idx.blengths,
                                    np.array([4], dtype=np.int32))

        idx = _make_index(4, np.array([0, 2, 3], dtype=np.int32),
                          kind='block')
        assert isinstance(idx, BlockIndex)
        assert idx.npoints == 3
        tm.assert_numpy_array_equal(idx.blocs,
                                    np.array([0, 2], dtype=np.int32))
        tm.assert_numpy_array_equal(idx.blengths,
                                    np.array([1, 2], dtype=np.int32))

</source>
<source file="pandas/pandas/tests/sparse/test_libsparse.py.pyindent" startline="390" endline="423" pcid="8987">
    def test_block_internal(self):
        idx = _make_index(4, np.array([2, 3], dtype=np.int32), kind='block')
        assert isinstance(idx, BlockIndex)
        assert idx.npoints == 2
        tm.assert_numpy_array_equal(idx.blocs,
                                    np.array([2], dtype=np.int32))
        tm.assert_numpy_array_equal(idx.blengths,
                                    np.array([2], dtype=np.int32))

        idx = _make_index(4, np.array([], dtype=np.int32), kind='block')
        assert isinstance(idx, BlockIndex)
        assert idx.npoints == 0
        tm.assert_numpy_array_equal(idx.blocs,
                                    np.array([], dtype=np.int32))
        tm.assert_numpy_array_equal(idx.blengths,
                                    np.array([], dtype=np.int32))

        idx = _make_index(4, np.array([0, 1, 2, 3], dtype=np.int32),
                          kind='block')
        assert isinstance(idx, BlockIndex)
        assert idx.npoints == 4
        tm.assert_numpy_array_equal(idx.blocs,
                                    np.array([0], dtype=np.int32))
        tm.assert_numpy_array_equal(idx.blengths,
                                    np.array([4], dtype=np.int32))

        idx = _make_index(4, np.array([0, 2, 3], dtype=np.int32), kind='block')
        assert isinstance(idx, BlockIndex)
        assert idx.npoints == 3
        tm.assert_numpy_array_equal(idx.blocs,
                                    np.array([0, 2], dtype=np.int32))
        tm.assert_numpy_array_equal(idx.blengths,
                                    np.array([1, 2], dtype=np.int32))

</source>
</class>

<class classid="211" nclones="2" nlines="30" similarity="70">
<source file="pandas/pandas/tests/test_arithmetic.py.pyindent" startline="653" endline="673" pcid="9039">
    def test_td64arr_add_sub_numeric_scalar_invalid(self, box, scalar, tdser):

        if box is pd.DataFrame and isinstance(scalar, np.ndarray):
            # raises ValueError
            pytest.xfail(reason="reversed ops return incorrect answers "
                                "instead of raising.")

        tdser = tm.box_expected(tdser, box)
        err = TypeError
        if box is pd.Index and not isinstance(scalar, float):
            err = NullFrequencyError

        with pytest.raises(err):
            tdser + scalar
        with pytest.raises(err):
            scalar + tdser
        with pytest.raises(err):
            tdser - scalar
        with pytest.raises(err):
            scalar - tdser

</source>
<source file="pandas/pandas/tests/test_arithmetic.py.pyindent" startline="691" endline="714" pcid="9040">
    def test_td64arr_add_sub_numeric_arr_invalid(self, box, vec, dtype, tdser):
        if type(vec) is Series and not dtype.startswith('float'):
            pytest.xfail(reason='GH#19123 integer interpreted as nanos')

        tdser = tm.box_expected(tdser, box)
        err = TypeError
        if box is pd.Index and not dtype.startswith('float'):
            err = NullFrequencyError

        vector = vec.astype(dtype)
        # TODO: parametrize over these four ops?
        with pytest.raises(err):
            tdser + vector
        with pytest.raises(err):
            vector + tdser
        with pytest.raises(err):
            tdser - vector
        with pytest.raises(err):
            vector - tdser

    # ------------------------------------------------------------------
    # Operations with timedelta-like others

    # TODO: this was taken from tests.series.test_ops; de-duplicate
</source>
</class>

<class classid="212" nclones="2" nlines="14" similarity="71">
<source file="pandas/pandas/tests/test_arithmetic.py.pyindent" startline="767" endline="782" pcid="9043">
    def test_td64arr_add_td64_array(self, box_df_fail):
        box = box_df_fail  # DataFrame tries to broadcast incorrectly

        dti = pd.date_range('2016-01-01', periods=3)
        tdi = dti - dti.shift(1)
        tdarr = tdi.values

        expected = 2 * tdi
        tdi = tm.box_expected(tdi, box)
        expected = tm.box_expected(expected, box)

        result = tdi + tdarr
        tm.assert_equal(result, expected)
        result = tdarr + tdi
        tm.assert_equal(result, expected)

</source>
<source file="pandas/pandas/tests/test_arithmetic.py.pyindent" startline="783" endline="799" pcid="9044">
    def test_td64arr_sub_td64_array(self, box_df_fail):
        box = box_df_fail  # DataFrame tries to broadcast incorrectly

        dti = pd.date_range('2016-01-01', periods=3)
        tdi = dti - dti.shift(1)
        tdarr = tdi.values

        expected = 0 * tdi
        tdi = tm.box_expected(tdi, box)
        expected = tm.box_expected(expected, box)

        result = tdi - tdarr
        tm.assert_equal(result, expected)
        result = tdarr - tdi
        tm.assert_equal(result, expected)

    # TODO: parametrize over [add, sub, radd, rsub]?
</source>
</class>

<class classid="213" nclones="2" nlines="14" similarity="71">
<source file="pandas/pandas/tests/test_arithmetic.py.pyindent" startline="866" endline="879" pcid="9047">
    def test_td64arr_add_timedeltalike(self, delta, box):
        # only test adding/sub offsets as + is now numeric
        if box is pd.DataFrame and isinstance(delta, pd.DateOffset):
            pytest.xfail(reason="Returns object dtype instead of m8[ns]")

        rng = timedelta_range('1 days', '10 days')
        expected = timedelta_range('1 days 02:00:00', '10 days 02:00:00',
                                   freq='D')
        rng = tm.box_expected(rng, box)
        expected = tm.box_expected(expected, box)

        result = rng + delta
        tm.assert_equal(result, expected)

</source>
<source file="pandas/pandas/tests/test_arithmetic.py.pyindent" startline="880" endline="897" pcid="9048">
    def test_td64arr_sub_timedeltalike(self, delta, box):
        # only test adding/sub offsets as - is now numeric
        if box is pd.DataFrame and isinstance(delta, pd.DateOffset):
            pytest.xfail(reason="Returns object dtype instead of m8[ns]")

        rng = timedelta_range('1 days', '10 days')
        expected = timedelta_range('0 days 22:00:00', '9 days 22:00:00')

        rng = tm.box_expected(rng, box)
        expected = tm.box_expected(expected, box)

        result = rng - delta
        tm.assert_equal(result, expected)

    # ------------------------------------------------------------------
    # __add__/__sub__ with DateOffsets and arrays of DateOffsets

    # TODO: this was taken from tests.series.test_operators; de-duplicate
</source>
</class>

<class classid="214" nclones="2" nlines="21" similarity="71">
<source file="pandas/pandas/tests/test_arithmetic.py.pyindent" startline="945" endline="966" pcid="9050">
    def test_td64arr_add_offset_index(self, names, box):
        # GH#18849, GH#19744
        tdi = TimedeltaIndex(['1 days 00:00:00', '3 days 04:00:00'],
                             name=names[0])
        other = pd.Index([pd.offsets.Hour(n=1), pd.offsets.Minute(n=-2)],
                         name=names[1])

        expected = TimedeltaIndex([tdi[n] + other[n] for n in range(len(tdi))],
                                  freq='infer', name=names[2])
        tdi = tm.box_expected(tdi, box)
        expected = tm.box_expected(expected, box)

        with tm.assert_produces_warning(PerformanceWarning):
            res = tdi + other
        tm.assert_equal(res, expected)

        with tm.assert_produces_warning(PerformanceWarning):
            res2 = other + tdi
        tm.assert_equal(res2, expected)

    # TODO: combine with test_td64arr_add_offset_index by parametrizing
    # over second box?
</source>
<source file="pandas/pandas/tests/test_arithmetic.py.pyindent" startline="967" endline="986" pcid="9051">
    def test_td64arr_add_offset_array(self, box_df_fail):
        # GH#18849
        box = box_df_fail  # tries to broadcast incorrectly
        tdi = TimedeltaIndex(['1 days 00:00:00', '3 days 04:00:00'])
        other = np.array([pd.offsets.Hour(n=1), pd.offsets.Minute(n=-2)])

        expected = TimedeltaIndex([tdi[n] + other[n] for n in range(len(tdi))],
                                  freq='infer')

        tdi = tm.box_expected(tdi, box)
        expected = tm.box_expected(expected, box)

        with tm.assert_produces_warning(PerformanceWarning):
            res = tdi + other
        tm.assert_equal(res, expected)

        with tm.assert_produces_warning(PerformanceWarning):
            res2 = other + tdi
        tm.assert_equal(res2, expected)

</source>
</class>

<class classid="215" nclones="2" nlines="10" similarity="70">
<source file="pandas/pandas/tests/test_arithmetic.py.pyindent" startline="1257" endline="1269" pcid="9068">
    def test_td64arr_floordiv_tdscalar(self, box, scalar_td):
        # GH#18831
        td1 = Series([timedelta(minutes=5, seconds=3)] * 3)
        td1.iloc[2] = np.nan

        expected = Series([0, 0, np.nan])

        td1 = tm.box_expected(td1, box)
        expected = tm.box_expected(expected, box)

        result = td1 // scalar_td
        tm.assert_equal(result, expected)

</source>
<source file="pandas/pandas/tests/test_arithmetic.py.pyindent" startline="1286" endline="1300" pcid="9070">
    def test_td64arr_rfloordiv_tdscalar_explicit(self, box, scalar_td):
        # GH#18831
        td1 = Series([timedelta(minutes=5, seconds=3)] * 3)
        td1.iloc[2] = np.nan

        expected = Series([1, 1, np.nan])

        td1 = tm.box_expected(td1, box)
        expected = tm.box_expected(expected, box)

        # We can test __rfloordiv__ using this syntax,
        # see `test_timedelta_rfloordiv`
        result = td1.__rfloordiv__(scalar_td)
        tm.assert_equal(result, expected)

</source>
</class>

<class classid="216" nclones="2" nlines="15" similarity="80">
<source file="pandas/pandas/tests/test_arithmetic.py.pyindent" startline="1343" endline="1357" pcid="9074">
    def test_td64arr_mul_tdscalar_invalid(self, box, scalar_td):
        td1 = Series([timedelta(minutes=5, seconds=3)] * 3)
        td1.iloc[2] = np.nan

        td1 = tm.box_expected(td1, box)

        # check that we are getting a TypeError
        # with 'operate' (from core/ops.py) for the ops that are not
        # defined
        pattern = 'operate|unsupported|cannot|not supported'
        with tm.assert_raises_regex(TypeError, pattern):
            td1 * scalar_td
        with tm.assert_raises_regex(TypeError, pattern):
            scalar_td * td1

</source>
<source file="pandas/pandas/tests/test_arithmetic.py.pyindent" startline="1542" endline="1556" pcid="9083">
    def test_td64arr_pow_invalid(self, scalar_td, box):
        td1 = Series([timedelta(minutes=5, seconds=3)] * 3)
        td1.iloc[2] = np.nan

        td1 = tm.box_expected(td1, box)

        # check that we are getting a TypeError
        # with 'operate' (from core/ops.py) for the ops that are not
        # defined
        pattern = 'operate|unsupported|cannot|not supported'
        with tm.assert_raises_regex(TypeError, pattern):
            scalar_td ** td1

        with tm.assert_raises_regex(TypeError, pattern):
            td1 ** scalar_td
</source>
</class>

<class classid="217" nclones="2" nlines="17" similarity="72">
<source file="pandas/pandas/tests/test_config.py.pyindent" startline="208" endline="226" pcid="9171">
    def test_reset_option(self):
        self.cf.register_option('a', 1, 'doc', validator=self.cf.is_int)
        self.cf.register_option('b.c', 'hullo', 'doc2',
                                validator=self.cf.is_str)
        assert self.cf.get_option('a') == 1
        assert self.cf.get_option('b.c') == 'hullo'

        self.cf.set_option('a', 2)
        self.cf.set_option('b.c', 'wurld')
        assert self.cf.get_option('a') == 2
        assert self.cf.get_option('b.c') == 'wurld'

        self.cf.reset_option('a')
        assert self.cf.get_option('a') == 1
        assert self.cf.get_option('b.c') == 'wurld'
        self.cf.reset_option('b.c')
        assert self.cf.get_option('a') == 1
        assert self.cf.get_option('b.c') == 'hullo'

</source>
<source file="pandas/pandas/tests/test_config.py.pyindent" startline="227" endline="242" pcid="9172">
    def test_reset_option_all(self):
        self.cf.register_option('a', 1, 'doc', validator=self.cf.is_int)
        self.cf.register_option('b.c', 'hullo', 'doc2',
                                validator=self.cf.is_str)
        assert self.cf.get_option('a') == 1
        assert self.cf.get_option('b.c') == 'hullo'

        self.cf.set_option('a', 2)
        self.cf.set_option('b.c', 'wurld')
        assert self.cf.get_option('a') == 2
        assert self.cf.get_option('b.c') == 'wurld'

        self.cf.reset_option("all")
        assert self.cf.get_option('a') == 1
        assert self.cf.get_option('b.c') == 'hullo'

</source>
</class>

<class classid="218" nclones="2" nlines="12" similarity="83">
<source file="pandas/pandas/tests/test_join.py.pyindent" startline="150" endline="165" pcid="9210">
def test_left_join_indexer2():
    idx = Index([1, 1, 2, 5])
    idx2 = Index([1, 2, 5, 7, 9])

    res, lidx, ridx = _join.left_join_indexer_int64(idx2.values, idx.values)

    exp_res = np.array([1, 1, 2, 5, 7, 9], dtype=np.int64)
    assert_almost_equal(res, exp_res)

    exp_lidx = np.array([0, 0, 1, 2, 3, 4], dtype=np.int64)
    assert_almost_equal(lidx, exp_lidx)

    exp_ridx = np.array([0, 1, 2, 3, -1, -1], dtype=np.int64)
    assert_almost_equal(ridx, exp_ridx)


</source>
<source file="pandas/pandas/tests/test_join.py.pyindent" startline="166" endline="181" pcid="9211">
def test_outer_join_indexer2():
    idx = Index([1, 1, 2, 5])
    idx2 = Index([1, 2, 5, 7, 9])

    res, lidx, ridx = _join.outer_join_indexer_int64(idx2.values, idx.values)

    exp_res = np.array([1, 1, 2, 5, 7, 9], dtype=np.int64)
    assert_almost_equal(res, exp_res)

    exp_lidx = np.array([0, 0, 1, 2, 3, 4], dtype=np.int64)
    assert_almost_equal(lidx, exp_lidx)

    exp_ridx = np.array([0, 1, 2, 3, -1, -1], dtype=np.int64)
    assert_almost_equal(ridx, exp_ridx)


</source>
</class>

<class classid="219" nclones="2" nlines="13" similarity="76">
<source file="pandas/pandas/tests/test_nanops.py.pyindent" startline="530" endline="540" pcid="9253">
    def test_nancorr(self):
        targ0 = np.corrcoef(self.arr_float_2d, self.arr_float1_2d)[0, 1]
        targ1 = np.corrcoef(self.arr_float_2d.flat,
                            self.arr_float1_2d.flat)[0, 1]
        self.check_nancorr_nancov_2d(nanops.nancorr, targ0, targ1)
        targ0 = np.corrcoef(self.arr_float_1d, self.arr_float1_1d)[0, 1]
        targ1 = np.corrcoef(self.arr_float_1d.flat,
                            self.arr_float1_1d.flat)[0, 1]
        self.check_nancorr_nancov_1d(nanops.nancorr, targ0, targ1,
                                     method='pearson')

</source>
<source file="pandas/pandas/tests/test_nanops.py.pyindent" startline="541" endline="552" pcid="9254">
    def test_nancorr_pearson(self):
        targ0 = np.corrcoef(self.arr_float_2d, self.arr_float1_2d)[0, 1]
        targ1 = np.corrcoef(self.arr_float_2d.flat,
                            self.arr_float1_2d.flat)[0, 1]
        self.check_nancorr_nancov_2d(nanops.nancorr, targ0, targ1,
                                     method='pearson')
        targ0 = np.corrcoef(self.arr_float_1d, self.arr_float1_1d)[0, 1]
        targ1 = np.corrcoef(self.arr_float_1d.flat,
                            self.arr_float1_1d.flat)[0, 1]
        self.check_nancorr_nancov_1d(nanops.nancorr, targ0, targ1,
                                     method='pearson')

</source>
</class>

<class classid="220" nclones="2" nlines="42" similarity="76">
<source file="pandas/pandas/tests/test_nanops.py.pyindent" startline="667" endline="696" pcid="9266">
    def test__has_infs(self):
        pairs = [('arr_complex', False), ('arr_int', False),
                 ('arr_bool', False), ('arr_str', False), ('arr_utf', False),
                 ('arr_complex', False), ('arr_complex_nan', False),
                 ('arr_nan_nanj', False), ('arr_nan_infj', True),
                 ('arr_complex_nan_infj', True)]
        pairs_float = [('arr_float', False), ('arr_nan', False),
                       ('arr_float_nan', False), ('arr_nan_nan', False),
                       ('arr_float_inf', True), ('arr_inf', True),
                       ('arr_nan_inf', True), ('arr_float_nan_inf', True),
                       ('arr_nan_nan_inf', True)]

        for arr, correct in pairs:
            val = getattr(self, arr)
            try:
                self.check_bool(nanops._has_infs, val, correct)
            except BaseException as exc:
                exc.args += (arr, )
                raise

        for arr, correct in pairs_float:
            val = getattr(self, arr)
            try:
                self.check_bool(nanops._has_infs, val, correct)
                self.check_bool(nanops._has_infs, val.astype('f4'), correct)
                self.check_bool(nanops._has_infs, val.astype('f2'), correct)
            except BaseException as exc:
                exc.args += (arr, )
                raise

</source>
<source file="pandas/pandas/tests/test_nanops.py.pyindent" startline="697" endline="731" pcid="9267">
    def test__isfinite(self):
        pairs = [('arr_complex', False), ('arr_int', False),
                 ('arr_bool', False), ('arr_str', False), ('arr_utf', False),
                 ('arr_complex', False), ('arr_complex_nan', True),
                 ('arr_nan_nanj', True), ('arr_nan_infj', True),
                 ('arr_complex_nan_infj', True)]
        pairs_float = [('arr_float', False), ('arr_nan', True),
                       ('arr_float_nan', True), ('arr_nan_nan', True),
                       ('arr_float_inf', True), ('arr_inf', True),
                       ('arr_nan_inf', True), ('arr_float_nan_inf', True),
                       ('arr_nan_nan_inf', True)]

        func1 = lambda x: np.any(nanops._isfinite(x).ravel())

        # TODO: unused?
        # func2 = lambda x: np.any(nanops._isfinite(x).values.ravel())

        for arr, correct in pairs:
            val = getattr(self, arr)
            try:
                self.check_bool(func1, val, correct)
            except BaseException as exc:
                exc.args += (arr, )
                raise

        for arr, correct in pairs_float:
            val = getattr(self, arr)
            try:
                self.check_bool(func1, val, correct)
                self.check_bool(func1, val.astype('f4'), correct)
                self.check_bool(func1, val.astype('f2'), correct)
            except BaseException as exc:
                exc.args += (arr, )
                raise

</source>
</class>

<class classid="221" nclones="2" nlines="14" similarity="85">
<source file="pandas/pandas/tests/tseries/offsets/test_offsets.py.pyindent" startline="585" endline="594" pcid="9422">
    def test_repr(self):
        assert repr(self.offset) == '<BusinessDay>'
        assert repr(self.offset2) == '<2 * BusinessDays>'

        if compat.PY37:
            expected = '<BusinessDay: offset=datetime.timedelta(days=1)>'
        else:
            expected = '<BusinessDay: offset=datetime.timedelta(1)>'
        assert repr(self.offset + timedelta(1)) == expected

</source>
<source file="pandas/pandas/tests/tseries/offsets/test_offsets.py.pyindent" startline="1648" endline="1657" pcid="9478">
    def test_repr(self):
        assert repr(self.offset) == '<CustomBusinessDay>'
        assert repr(self.offset2) == '<2 * CustomBusinessDays>'

        if compat.PY37:
            expected = '<BusinessDay: offset=datetime.timedelta(days=1)>'
        else:
            expected = '<BusinessDay: offset=datetime.timedelta(1)>'
        assert repr(self.offset + timedelta(1)) == expected

</source>
</class>

<class classid="222" nclones="4" nlines="14" similarity="78">
<source file="pandas/pandas/tests/tseries/offsets/test_offsets.py.pyindent" startline="626" endline="643" pcid="9432">
    def test_roll_date_object(self):
        offset = BDay()

        dt = date(2012, 9, 15)

        result = offset.rollback(dt)
        assert result == datetime(2012, 9, 14)

        result = offset.rollforward(dt)
        assert result == datetime(2012, 9, 17)

        offset = offsets.Day()
        result = offset.rollback(dt)
        assert result == datetime(2012, 9, 15)

        result = offset.rollforward(dt)
        assert result == datetime(2012, 9, 15)

</source>
<source file="pandas/pandas/tests/tseries/offsets/test_offsets.py.pyindent" startline="1690" endline="1707" pcid="9488">
    def test_roll_date_object(self):
        offset = CDay()

        dt = date(2012, 9, 15)

        result = offset.rollback(dt)
        assert result == datetime(2012, 9, 14)

        result = offset.rollforward(dt)
        assert result == datetime(2012, 9, 17)

        offset = offsets.Day()
        result = offset.rollback(dt)
        assert result == datetime(2012, 9, 15)

        result = offset.rollforward(dt)
        assert result == datetime(2012, 9, 15)

</source>
<source file="pandas/pandas/tests/tseries/offsets/test_offsets.py.pyindent" startline="2019" endline="2036" pcid="9525">
    def test_roll_date_object(self):
        offset = CBMonthBegin()

        dt = date(2012, 9, 15)

        result = offset.rollback(dt)
        assert result == datetime(2012, 9, 3)

        result = offset.rollforward(dt)
        assert result == datetime(2012, 10, 1)

        offset = offsets.Day()
        result = offset.rollback(dt)
        assert result == datetime(2012, 9, 15)

        result = offset.rollforward(dt)
        assert result == datetime(2012, 9, 15)

</source>
<source file="pandas/pandas/tests/tseries/offsets/test_offsets.py.pyindent" startline="1903" endline="1920" pcid="9513">
    def test_roll_date_object(self):
        offset = CBMonthEnd()

        dt = date(2012, 9, 15)

        result = offset.rollback(dt)
        assert result == datetime(2012, 8, 31)

        result = offset.rollforward(dt)
        assert result == datetime(2012, 9, 28)

        offset = offsets.Day()
        result = offset.rollback(dt)
        assert result == datetime(2012, 9, 15)

        result = offset.rollforward(dt)
        assert result == datetime(2012, 9, 15)

</source>
</class>

<class classid="223" nclones="2" nlines="16" similarity="81">
<source file="pandas/pandas/tests/tseries/offsets/test_offsets.py.pyindent" startline="742" endline="750" pcid="9438">
    def test_constructor_errors(self):
        from datetime import time as dt_time
        with pytest.raises(ValueError):
            BusinessHour(start=dt_time(11, 0, 5))
        with pytest.raises(ValueError):
            BusinessHour(start='AAA')
        with pytest.raises(ValueError):
            BusinessHour(start='14:00:05')

</source>
<source file="pandas/pandas/tests/tseries/offsets/test_offsets.py.pyindent" startline="1404" endline="1412" pcid="9459">
    def test_constructor_errors(self):
        from datetime import time as dt_time
        with pytest.raises(ValueError):
            CustomBusinessHour(start=dt_time(11, 0, 5))
        with pytest.raises(ValueError):
            CustomBusinessHour(start='AAA')
        with pytest.raises(ValueError):
            CustomBusinessHour(start='14:00:05')

</source>
</class>

<class classid="224" nclones="2" nlines="11" similarity="72">
<source file="pandas/pandas/tests/tseries/offsets/test_offsets.py.pyindent" startline="1827" endline="1835" pcid="9497">
    def test_roundtrip_pickle(self):
        def _check_roundtrip(obj):
            unpickled = tm.round_trip_pickle(obj)
            assert unpickled == obj

        _check_roundtrip(self.offset)
        _check_roundtrip(self.offset2)
        _check_roundtrip(self.offset * 2)

</source>
<source file="pandas/pandas/tests/tseries/offsets/test_offsets.py.pyindent" startline="1862" endline="1870" pcid="9504">
    def test_roundtrip_pickle(self):
        def _check_roundtrip(obj):
            unpickled = tm.round_trip_pickle(obj)
            assert unpickled == obj

        _check_roundtrip(self._offset())
        _check_roundtrip(self._offset(2))
        _check_roundtrip(self._offset() * 2)

</source>
</class>

<class classid="225" nclones="2" nlines="14" similarity="71">
<source file="pandas/pandas/tests/util/test_testing.py.pyindent" startline="508" endline="520" pcid="9816">
    def test_categorical_index_equality(self):
        expected = """Index are different

Attribute "dtype" are different
\\[left\\]:  CategoricalDtype\\(categories=\\[u?'a', u?'b'\\], ordered=False\\)
\\[right\\]: CategoricalDtype\\(categories=\\[u?'a', u?'b', u?'c'\\], \
ordered=False\\)"""

        with tm.assert_raises_regex(AssertionError, expected):
            assert_index_equal(pd.Index(pd.Categorical(['a', 'b'])),
                               pd.Index(pd.Categorical(['a', 'b'],
                                        categories=['a', 'b', 'c'])))

</source>
<source file="pandas/pandas/tests/util/test_testing.py.pyindent" startline="624" endline="636" pcid="9826">
    def test_categorical_series_equality(self):
        expected = """Attributes are different

Attribute "dtype" are different
\\[left\\]:  CategoricalDtype\\(categories=\\[u?'a', u?'b'\\], ordered=False\\)
\\[right\\]: CategoricalDtype\\(categories=\\[u?'a', u?'b', u?'c'\\], \
ordered=False\\)"""

        with tm.assert_raises_regex(AssertionError, expected):
            assert_series_equal(pd.Series(pd.Categorical(['a', 'b'])),
                                pd.Series(pd.Categorical(['a', 'b'],
                                          categories=['a', 'b', 'c'])))

</source>
</class>

<class classid="226" nclones="2" nlines="10" similarity="90">
<source file="pandas/pandas/tests/util/test_testing.py.pyindent" startline="592" endline="600" pcid="9824">
    def test_multiindex_dtype(self):
        df1 = DataFrame.from_records(
            {'a': [1, 2], 'b': [2.1, 1.5],
             'c': ['l1', 'l2']}, index=['a', 'b'])
        df2 = DataFrame.from_records(
            {'a': [1.0, 2.0], 'b': [2.1, 1.5],
             'c': ['l1', 'l2']}, index=['a', 'b'])
        self._assert_not_equal(df1.c, df2.c, check_index_type=True)

</source>
<source file="pandas/pandas/tests/util/test_testing.py.pyindent" startline="675" endline="683" pcid="9833">
    def test_multiindex_dtype(self):
        df1 = DataFrame.from_records(
            {'a': [1, 2], 'b': [2.1, 1.5],
             'c': ['l1', 'l2']}, index=['a', 'b'])
        df2 = DataFrame.from_records(
            {'a': [1.0, 2.0], 'b': [2.1, 1.5],
             'c': ['l1', 'l2']}, index=['a', 'b'])
        self._assert_not_equal(df1, df2, check_index_type=True)

</source>
</class>

<class classid="227" nclones="4" nlines="18" similarity="73">
<source file="pandas/pandas/tests/util/test_util.py.pyindent" startline="113" endline="129" pcid="9856">
    def test_bad_arg_length_max_value_single(self):
        args = (None, None)
        compat_args = ('foo',)

        min_fname_arg_count = 0
        max_length = len(compat_args) + min_fname_arg_count
        actual_length = len(args) + min_fname_arg_count
        msg = (r"{fname}\(\) takes at most {max_length} "
               r"argument \({actual_length} given\)"
               .format(fname=self.fname, max_length=max_length,
                       actual_length=actual_length))

        with tm.assert_raises_regex(TypeError, msg):
            validate_args(self.fname, args,
                          min_fname_arg_count,
                          compat_args)

</source>
<source file="pandas/pandas/tests/util/test_util.py.pyindent" startline="244" endline="261" pcid="9864">
    def test_invalid_total_length_max_length_one(self):
        compat_args = ('foo',)
        kwargs = {'foo': 'FOO'}
        args = ('FoO', 'BaZ')

        min_fname_arg_count = 0
        max_length = len(compat_args) + min_fname_arg_count
        actual_length = len(kwargs) + len(args) + min_fname_arg_count
        msg = (r"{fname}\(\) takes at most {max_length} "
               r"argument \({actual_length} given\)"
               .format(fname=self.fname, max_length=max_length,
                       actual_length=actual_length))

        with tm.assert_raises_regex(TypeError, msg):
            validate_args_and_kwargs(self.fname, args, kwargs,
                                     min_fname_arg_count,
                                     compat_args)

</source>
<source file="pandas/pandas/tests/util/test_util.py.pyindent" startline="130" endline="146" pcid="9857">
    def test_bad_arg_length_max_value_multiple(self):
        args = (None, None)
        compat_args = dict(foo=None)

        min_fname_arg_count = 2
        max_length = len(compat_args) + min_fname_arg_count
        actual_length = len(args) + min_fname_arg_count
        msg = (r"{fname}\(\) takes at most {max_length} "
               r"arguments \({actual_length} given\)"
               .format(fname=self.fname, max_length=max_length,
                       actual_length=actual_length))

        with tm.assert_raises_regex(TypeError, msg):
            validate_args(self.fname, args,
                          min_fname_arg_count,
                          compat_args)

</source>
<source file="pandas/pandas/tests/util/test_util.py.pyindent" startline="262" endline="279" pcid="9865">
    def test_invalid_total_length_max_length_multiple(self):
        compat_args = ('foo', 'bar', 'baz')
        kwargs = {'foo': 'FOO', 'bar': 'BAR'}
        args = ('FoO', 'BaZ')

        min_fname_arg_count = 2
        max_length = len(compat_args) + min_fname_arg_count
        actual_length = len(kwargs) + len(args) + min_fname_arg_count
        msg = (r"{fname}\(\) takes at most {max_length} "
               r"arguments \({actual_length} given\)"
               .format(fname=self.fname, max_length=max_length,
                       actual_length=actual_length))

        with tm.assert_raises_regex(TypeError, msg):
            validate_args_and_kwargs(self.fname, args, kwargs,
                                     min_fname_arg_count,
                                     compat_args)

</source>
</class>

<class classid="228" nclones="2" nlines="16" similarity="87">
<source file="pandas/pandas/util/_test_decorators.py.pyindent" startline="81" endline="91" pcid="9955">
def _skip_if_mpl_1_5():
    mod = safe_import("matplotlib")

    if mod:
        v = mod.__version__
        if LooseVersion(v) > LooseVersion('1.4.3') or str(v)[0] == '0':
            return True
        else:
            mod.use("Agg", warn=False)


</source>
<source file="pandas/pandas/util/_test_decorators.py.pyindent" startline="92" endline="102" pcid="9956">
def _skip_if_mpl_2_2():
    mod = safe_import("matplotlib")

    if mod:
        v = mod.__version__
        if LooseVersion(v) > LooseVersion('2.1.2'):
            return True
        else:
            mod.use("Agg", warn=False)


</source>
</class>

<class classid="229" nclones="2" nlines="15" similarity="86">
<source file="pandas/scripts/validate_docstrings.py.pyindent" startline="134" endline="141" pcid="10000">
    def start_blank_lines(self):
        i = None
        if self.raw_doc:
            for i, row in enumerate(self.raw_doc.split('\n')):
                if row.strip():
                    break
        return i

</source>
<source file="pandas/scripts/validate_docstrings.py.pyindent" startline="143" endline="150" pcid="10001">
    def end_blank_lines(self):
        i = None
        if self.raw_doc:
            for i, row in enumerate(reversed(self.raw_doc.split('\n'))):
                if row.strip():
                    break
        return i

</source>
</class>

</clones>
