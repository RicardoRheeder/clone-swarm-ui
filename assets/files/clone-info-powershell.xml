<clones>
<systeminfo processor="nicad3" system="PowerShell" granularity="functions" threshold="30%" minlines="10" maxlines="2500"/>
<cloneinfo npcs="5755" npairs="2018"/>
<runinfo ncompares="924004" cputime="468"/>
<classinfo nclasses="124"/>

<class classid="1" nclones="3" nlines="14" similarity="92">
<source file="PowerShell/docs/host-powershell/sample-dotnet1.1/Logic/UseRunspace.cs.ifdefed" startline="15" endline="33" pcid="1">
        public static int Start(string[] args)
        {
            using (PowerShell ps = PowerShell.Create())
            {
                Console.WriteLine("\nEvaluating 'Get-Command Write-Output' in PS Core Runspace\n");
                var results = ps.AddScript("Get-Command Write-Output").Invoke();
                Console.WriteLine(results[0].ToString());

                ps.Commands.Clear();

                Console.WriteLine("\nEvaluating '([S.M.A.ActionPreference], [S.M.A.AliasAttribute]).FullName' in PS Core Runspace\n");
                results = ps.AddScript("([System.Management.Automation.ActionPreference], [System.Management.Automation.AliasAttribute]).FullName").Invoke();
                foreach (dynamic result in results)
                {
                    Console.WriteLine(result.ToString());
                }
            }
            return 0;
        }
</source>
<source file="PowerShell/docs/host-powershell/sample-dotnet2.0-powershell.beta.3/MyApp/Program.cs.ifdefed" startline="14" endline="32" pcid="6">
        public static int Main(string[] args)
        {
            using (PowerShell ps = PowerShell.Create())
            {
                Console.WriteLine("\nEvaluating 'Get-Command Write-Output' in PS Core Runspace\n");
                var results = ps.AddScript("Get-Command Write-Output").Invoke();
                Console.WriteLine(results[0].ToString());

                ps.Commands.Clear();

                Console.WriteLine("\nEvaluating '([S.M.A.ActionPreference], [S.M.A.AliasAttribute]).FullName' in PS Core Runspace\n");
                results = ps.AddScript("([System.Management.Automation.ActionPreference], [System.Management.Automation.AliasAttribute]).FullName").Invoke();
                foreach (dynamic result in results)
                {
                    Console.WriteLine(result.ToString());
                }
            }
            return 0;
        }
</source>
<source file="PowerShell/docs/host-powershell/sample-dotnet2.0-powershell.beta.1/Logic/UseRunspace.cs.ifdefed" startline="15" endline="33" pcid="4">
        public static int Start(string[] args)
        {
            using (PowerShell ps = PowerShell.Create())
            {
                Console.WriteLine("\nEvaluating 'Get-Command Write-Output' in PS Core Runspace\n");
                var results = ps.AddScript("Get-Command Write-Output").Invoke();
                Console.WriteLine(results[0].ToString());

                ps.Commands.Clear();

                Console.WriteLine("\nEvaluating '([S.M.A.ActionPreference], [S.M.A.AliasAttribute]).FullName' in PS Core Runspace\n");
                results = ps.AddScript("([System.Management.Automation.ActionPreference], [System.Management.Automation.AliasAttribute]).FullName").Invoke();
                foreach (dynamic result in results)
                {
                    Console.WriteLine(result.ToString());
                }
            }
            return 0;
        }
</source>
</class>

<class classid="2" nclones="2" nlines="18" similarity="72">
<source file="PowerShell/src/Microsoft.Management.Infrastructure.CimCmdlets/CimSessionOperations.cs.ifdefed" startline="577" endline="601" pcid="129">
        internal IEnumerable<PSObject> QuerySession(IEnumerable<Guid> instanceIds,
            out IEnumerable<ErrorRecord> errorRecords)
        {
            HashSet<PSObject> sessions = new HashSet<PSObject>();
            HashSet<uint> sessionIds = new HashSet<uint>();
            List<ErrorRecord> errRecords = new List<ErrorRecord>();
            errorRecords = errRecords;
            foreach (Guid instanceid in instanceIds)
            {
                if (this.curCimSessionsByInstanceId.ContainsKey(instanceid))
                {
                    CimSessionWrapper wrapper = this.curCimSessionsByInstanceId[instanceid];
                    if (!sessionIds.Contains(wrapper.SessionId))
                    {
                        sessionIds.Add(wrapper.SessionId);
                        sessions.Add(wrapper.GetPSObject());
                    }
                }
                else
                {
                    AddErrorRecord(ref errRecords, instanceidPropName, instanceid);
                }
            }
            return sessions;
        }
</source>
<source file="PowerShell/src/Microsoft.Management.Infrastructure.CimCmdlets/CimSessionOperations.cs.ifdefed" startline="685" endline="709" pcid="132">
        internal IEnumerable<PSObject> QuerySession(IEnumerable<CimSession> cimsessions,
            out IEnumerable<ErrorRecord> errorRecords)
        {
            HashSet<PSObject> sessions = new HashSet<PSObject>();
            HashSet<uint> sessionIds = new HashSet<uint>();
            List<ErrorRecord> errRecords = new List<ErrorRecord>();
            errorRecords = errRecords;
            foreach (CimSession cimsession in cimsessions)
            {
                if (this.curCimSessionWrapper.ContainsKey(cimsession))
                {
                    CimSessionWrapper wrapper = this.curCimSessionWrapper[cimsession];
                    if (!sessionIds.Contains(wrapper.SessionId))
                    {
                        sessionIds.Add(wrapper.SessionId);
                        sessions.Add(wrapper.GetPSObject());
                    }
                }
                else
                {
                    AddErrorRecord(ref errRecords, CimSessionClassName, CimSessionObject);
                }
            }
            return sessions;
        }
</source>
</class>

<class classid="3" nclones="3" nlines="13" similarity="100">
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Diagnostics/ExportCounterCommand.cs.ifdefed" startline="348" endline="365" pcid="261">
        private void ReportPdhError(uint res, bool bTerminate)
        {
            string msg;
            uint formatRes = CommonUtilities.FormatMessageFromModule(res, "pdh.dll", out msg);
            if (formatRes != 0)
            {
                msg = string.Format(CultureInfo.InvariantCulture, _resourceMgr.GetString("CounterApiError"), res);
            }
            Exception exc = new Exception(msg);
            if (bTerminate)
            {
                ThrowTerminatingError(new ErrorRecord(exc, "CounterApiError", ErrorCategory.InvalidResult, null));
            }
            else
            {
                WriteError(new ErrorRecord(exc, "CounterApiError", ErrorCategory.InvalidResult, null));
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Diagnostics/ImportCounterCommand.cs.ifdefed" startline="615" endline="632" pcid="323">
        private void ReportPdhError(uint res, bool bTerminate)
        {
            string msg;
            uint formatRes = CommonUtilities.FormatMessageFromModule(res, "pdh.dll", out msg);
            if (formatRes != 0)
            {
                msg = string.Format(CultureInfo.InvariantCulture, _resourceMgr.GetString("CounterApiError"), res);
            }
            Exception exc = new Exception(msg);
            if (bTerminate)
            {
                ThrowTerminatingError(new ErrorRecord(exc, "CounterApiError", ErrorCategory.InvalidResult, null));
            }
            else
            {
                WriteError(new ErrorRecord(exc, "CounterApiError", ErrorCategory.InvalidResult, null));
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Diagnostics/GetCounterCommand.cs.ifdefed" startline="570" endline="587" pcid="270">
        private void ReportPdhError(uint res, bool bTerminate)
        {
            string msg;
            uint formatRes = CommonUtilities.FormatMessageFromModule(res, "pdh.dll", out msg);
            if (formatRes != 0)
            {
                msg = string.Format(CultureInfo.InvariantCulture, _resourceMgr.GetString("CounterApiError"), res);
            }
            Exception exc = new Exception(msg);
            if (bTerminate)
            {
                ThrowTerminatingError(new ErrorRecord(exc, "CounterApiError", ErrorCategory.InvalidResult, null));
            }
            else
            {
                WriteError(new ErrorRecord(exc, "CounterApiError", ErrorCategory.InvalidResult, null));
            }
        }
</source>
</class>

<class classid="4" nclones="2" nlines="12" similarity="76">
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Diagnostics/GetCounterCommand.cs.ifdefed" startline="634" endline="647" pcid="272">
        private void WriteSampleSetObject(PerformanceCounterSampleSet set)
        {
            foreach (PerformanceCounterSample sample in set.CounterSamples)
            {
                if (sample.Status != 0)
                {
                    string msg = string.Format(CultureInfo.InvariantCulture, _resourceMgr.GetString("CounterSampleDataInvalid"));
                    Exception exc = new Exception(msg);
                    WriteError(new ErrorRecord(exc, "CounterApiError", ErrorCategory.InvalidResult, null));
                    break;
                }
            }
            WriteObject(set);
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Diagnostics/ImportCounterCommand.cs.ifdefed" startline="641" endline="658" pcid="324">
        private void WriteSampleSetObject(PerformanceCounterSampleSet set, bool firstSet)
        {
            if (!firstSet)
            {
                foreach (PerformanceCounterSample sample in set.CounterSamples)
                {
                    if (sample.Status != 0)
                    {
                        string msg = string.Format(CultureInfo.InvariantCulture, _resourceMgr.GetString("CounterSampleDataInvalid"));
                        Exception exc = new Exception(msg);
                        WriteError(new ErrorRecord(exc, "CounterApiError", ErrorCategory.InvalidResult, null));
                        break;
                    }
                }
            }

            WriteObject(set);
        }
</source>
</class>

<class classid="5" nclones="2" nlines="17" similarity="82">
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Diagnostics/GetEventCommand.cs.ifdefed" startline="1518" endline="1541" pcid="298">
        private string HandleDataHashValue(Object value)
        {
            StringBuilder ret = new StringBuilder();
            Array dataArray = value as Array;
            if (dataArray != null)
            {
                ret.Append("(");
                for (int i = 0; i < dataArray.Length; i++)
                {
                    ret.AppendFormat(CultureInfo.InvariantCulture, DataTemplate, dataArray.GetValue(i).ToString());
                    if (i < (dataArray.Length - 1))
                    {
                        ret.Append(" or ");
                    }
                }
                ret.Append(")");
            }
            else
            {
                ret.AppendFormat(CultureInfo.InvariantCulture, DataTemplate, value);
            }

            return ret.ToString();
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Diagnostics/GetEventCommand.cs.ifdefed" startline="1548" endline="1575" pcid="299">
        private string HandleNamedDataHashValue(String key, Object value)
        {
            StringBuilder ret = new StringBuilder();
            Array dataArray = value as Array;
            if (dataArray != null)
            {
                ret.Append("(");
                for (int i = 0; i < dataArray.Length; i++)
                {
                    ret.AppendFormat(CultureInfo.InvariantCulture,
                                         NamedDataTemplate,
                                         key, dataArray.GetValue(i).ToString());
                    if (i < (dataArray.Length - 1))
                    {
                        ret.Append(" or ");
                    }
                }
                ret.Append(")");
            }
            else
            {
                ret.AppendFormat(CultureInfo.InvariantCulture,
                                         NamedDataTemplate,
                                         key, value);
            }

            return ret.ToString();
        }
</source>
</class>

<class classid="6" nclones="2" nlines="63" similarity="70">
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Diagnostics/PdhHelper.cs.ifdefed" startline="1364" endline="1506" pcid="357">
        public uint ReadNextSetPreVista(out PerformanceCounterSampleSet nextSet, bool bSkipReading)
        {
            uint res = 0;
            nextSet = null;

            res = PdhCollectQueryData(_hQuery);
            if (bSkipReading)
            {
                return res;
            }
            if (res != 0 && res != PdhResults.PDH_NO_DATA)
            {
                return res;
            }

            PerformanceCounterSample[] samplesArr = new PerformanceCounterSample[_consumerPathToHandleAndInstanceMap.Count];
            uint sampleIndex = 0;
            uint numInvalidDataSamples = 0;
            uint lastErr = 0;

            DateTime sampleTimeStamp = DateTime.Now;

            foreach (string path in _consumerPathToHandleAndInstanceMap.Keys)
            {
                IntPtr counterTypePtr = new IntPtr(0);
                UInt32 counterType = (UInt32)PerformanceCounterType.RawBase;
                UInt32 defaultScale = 0;
                UInt64 timeBase = 0;

                IntPtr hCounter = _consumerPathToHandleAndInstanceMap[path].hCounter;
                Debug.Assert(hCounter != null);

                res = GetCounterInfoPlus(hCounter, out counterType, out defaultScale, out timeBase);
                if (res != 0)
                {
                    //Console.WriteLine ("GetCounterInfoPlus for " + path + " failed with " + res);
                }

                PDH_RAW_COUNTER rawValue;
                res = PdhGetRawCounterValue(hCounter, out counterTypePtr, out rawValue);
                if (res == PdhResults.PDH_INVALID_DATA || res == PdhResults.PDH_NO_DATA)
                {
                    //Console.WriteLine ("PdhGetRawCounterValue returned " + res);
                    samplesArr[sampleIndex++] = new PerformanceCounterSample(path,
                                           _consumerPathToHandleAndInstanceMap[path].InstanceName,
                                           0,
                                           (ulong)0,
                                           (ulong)0,
                                           0,
                                           PerformanceCounterType.RawBase,
                                           defaultScale,
                                           timeBase,
                                           DateTime.Now,
                                           (UInt64)DateTime.Now.ToFileTime(),
                                           rawValue.CStatus);

                    numInvalidDataSamples++;
                    lastErr = res;
                    continue;
                }
                else if (res != 0)
                {
                    return res;
                }

                long dtFT = (((long)rawValue.TimeStamp.dwHighDateTime) << 32) +
                                     (uint)rawValue.TimeStamp.dwLowDateTime;

                //
                // NOTE: PDH returns the filetime as local time, therefore
                // we need to call FromFileTimUtc() to avoid .NET applying the timezone adjustment.
                // However, that would result in the DateTime object having Kind.Utc.
                // We have to copy it once more to correct that (Kind is a read-only property).
                //
                sampleTimeStamp = new DateTime(DateTime.FromFileTimeUtc(dtFT).Ticks, DateTimeKind.Local);

                PDH_FMT_COUNTERVALUE_DOUBLE fmtValueDouble;
                res = PdhGetFormattedCounterValue(hCounter,
                                                  PdhFormat.PDH_FMT_DOUBLE | PdhFormat.PDH_FMT_NOCAP100,
                                                  out counterTypePtr,
                                                  out fmtValueDouble);
                if (res == PdhResults.PDH_INVALID_DATA || res == PdhResults.PDH_NO_DATA)
                {
                    //Console.WriteLine ("PdhGetFormattedCounterValue returned " + res);
                    samplesArr[sampleIndex++] = new PerformanceCounterSample(path,
                                           _consumerPathToHandleAndInstanceMap[path].InstanceName,
                                           0,
                                           (ulong)rawValue.FirstValue,
                                           (ulong)rawValue.SecondValue,
                                           rawValue.MultiCount,
                                           (PerformanceCounterType)counterType,
                                           defaultScale,
                                           timeBase,
                                           sampleTimeStamp,
                                           (UInt64)dtFT,
                                           fmtValueDouble.CStatus);

                    numInvalidDataSamples++;
                    lastErr = res;
                    continue;
                }
                else if (res != 0)
                {
                    //Console.WriteLine ("PdhGetFormattedCounterValue returned " + res);
                    return res;
                }

                samplesArr[sampleIndex++] = new PerformanceCounterSample(path,
                                                           _consumerPathToHandleAndInstanceMap[path].InstanceName,
                                                           fmtValueDouble.doubleValue,
                                                           (ulong)rawValue.FirstValue,
                                                           (ulong)rawValue.SecondValue,
                                                           rawValue.MultiCount,
                                                           (PerformanceCounterType)counterTypePtr.ToInt32(),
                                                           defaultScale,
                                                           timeBase,
                                                           sampleTimeStamp,
                                                           (UInt64)dtFT,
                                                           fmtValueDouble.CStatus);
            }

            //
            // Prior to Vista, PdhCollectQueryDataWithTime() was not available,
            // so we could not collect a timestamp for the entire sample set.
            // We will use the last sample's timestamp instead.
            //
            nextSet = new PerformanceCounterSampleSet(sampleTimeStamp, samplesArr, _firstReading);
            _firstReading = false;

            if (numInvalidDataSamples == samplesArr.Length)
            {
                res = lastErr;
            }
            else
            {
                //
                // Reset the error - any errors are saved per sample in PerformanceCounterSample.Status for kvetching later
                //
                res = 0;
            }

            return res;
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Diagnostics/PdhHelper.cs.ifdefed" startline="1508" endline="1647" pcid="358">
        public uint ReadNextSet(out PerformanceCounterSampleSet nextSet, bool bSkipReading)
        {
            Debug.Assert(_hQuery != null && !_hQuery.IsInvalid);

            if (_isPreVista)
            {
                return ReadNextSetPreVista(out nextSet, bSkipReading);
            }

            uint res = 0;
            nextSet = null;

            Int64 batchTimeStampFT = 0;

            res = PdhCollectQueryDataWithTime(_hQuery, ref batchTimeStampFT);
            if (bSkipReading)
            {
                return res;
            }
            if (res != 0 && res != PdhResults.PDH_NO_DATA)
            {
                return res;
            }

            //
            // NOTE: PDH returns the filetime as local time, therefore
            // we need to call FromFileTimUtc() to avoid .NET applying the timezone adjustment.
            // However, that would result in the DateTime object having Kind.Utc.
            // We have to copy it once more to correct that (Kind is a read-only property).
            //
            DateTime batchStamp = DateTime.Now;
            if (res != PdhResults.PDH_NO_DATA)
            {
                batchStamp = new DateTime(DateTime.FromFileTimeUtc(batchTimeStampFT).Ticks, DateTimeKind.Local);
            }

            PerformanceCounterSample[] samplesArr = new PerformanceCounterSample[_consumerPathToHandleAndInstanceMap.Count];
            uint sampleIndex = 0;
            uint numInvalidDataSamples = 0;
            uint lastErr = 0;

            foreach (string path in _consumerPathToHandleAndInstanceMap.Keys)
            {
                IntPtr counterTypePtr = new IntPtr(0);
                UInt32 counterType = (UInt32)PerformanceCounterType.RawBase;
                UInt32 defaultScale = 0;
                UInt64 timeBase = 0;

                IntPtr hCounter = _consumerPathToHandleAndInstanceMap[path].hCounter;
                Debug.Assert(hCounter != null);

                res = GetCounterInfoPlus(hCounter, out counterType, out defaultScale, out timeBase);
                if (res != 0)
                {
                    //Console.WriteLine ("GetCounterInfoPlus for " + path + " failed with " + res);
                }

                PDH_RAW_COUNTER rawValue;
                res = PdhGetRawCounterValue(hCounter, out counterTypePtr, out rawValue);
                if (res != 0)
                {
                    samplesArr[sampleIndex++] = new PerformanceCounterSample(path,
                                           _consumerPathToHandleAndInstanceMap[path].InstanceName,
                                           0,
                                           (ulong)0,
                                           (ulong)0,
                                           0,
                                           PerformanceCounterType.RawBase,
                                           defaultScale,
                                           timeBase,
                                           batchStamp,
                                           (UInt64)batchStamp.ToFileTime(),
                                           (rawValue.CStatus == 0) ? res : rawValue.CStatus);

                    numInvalidDataSamples++;
                    lastErr = res;
                    continue;
                }

                long dtFT = (((long)rawValue.TimeStamp.dwHighDateTime) << 32) +
                                     (uint)rawValue.TimeStamp.dwLowDateTime;

                DateTime dt = new DateTime(DateTime.FromFileTimeUtc(dtFT).Ticks, DateTimeKind.Local);

                PDH_FMT_COUNTERVALUE_DOUBLE fmtValueDouble;
                res = PdhGetFormattedCounterValue(hCounter,
                                                  PdhFormat.PDH_FMT_DOUBLE | PdhFormat.PDH_FMT_NOCAP100,
                                                  out counterTypePtr,
                                                  out fmtValueDouble);
                if (res != 0)
                {
                    samplesArr[sampleIndex++] = new PerformanceCounterSample(path,
                                           _consumerPathToHandleAndInstanceMap[path].InstanceName,
                                           0,
                                           (ulong)rawValue.FirstValue,
                                           (ulong)rawValue.SecondValue,
                                           rawValue.MultiCount,
                                           (PerformanceCounterType)counterType,
                                           defaultScale,
                                           timeBase,
                                           dt,
                                           (UInt64)dtFT,
                                           (fmtValueDouble.CStatus == 0) ? res : rawValue.CStatus);

                    numInvalidDataSamples++;
                    lastErr = res;
                    continue;
                }

                samplesArr[sampleIndex++] = new PerformanceCounterSample(path,
                                                           _consumerPathToHandleAndInstanceMap[path].InstanceName,
                                                           fmtValueDouble.doubleValue,
                                                           (ulong)rawValue.FirstValue,
                                                           (ulong)rawValue.SecondValue,
                                                           rawValue.MultiCount,
                                                           (PerformanceCounterType)counterTypePtr.ToInt32(),
                                                           defaultScale,
                                                           timeBase,
                                                           dt,
                                                           (UInt64)dtFT,
                                                           fmtValueDouble.CStatus);
            }

            nextSet = new PerformanceCounterSampleSet(batchStamp, samplesArr, _firstReading);
            _firstReading = false;

            if (numInvalidDataSamples == samplesArr.Length)
            {
                res = lastErr;
            }
            else
            {
                //
                // Reset the error - any errors are saved per sample in PerformanceCounterSample.Status for kvetching later
                //
                res = 0;
            }

            return res;
        }
</source>
</class>

<class classid="7" nclones="2" nlines="11" similarity="72">
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Management/cimSupport/cmdletization/cim/clientSideQuery.cs.ifdefed" startline="108" endline="123" pcid="410">
            public virtual bool ShouldReportErrorOnNoMatches_IfMultipleFilters()
            {
                switch (this.BehaviorOnNoMatch)
                {
                    case BehaviorOnNoMatch.ReportErrors:
                        return true;

                    case BehaviorOnNoMatch.SilentlyContinue:
                        return false;

                    case BehaviorOnNoMatch.Default:
                    default:
                        Dbg.Assert(false, "BehaviorOnNoMatch.Default should be handled by derived classes");
                        return false;
                }
            }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Management/cimSupport/cmdletization/cim/clientSideQuery.cs.ifdefed" startline="206" endline="221" pcid="414">
            public override bool ShouldReportErrorOnNoMatches_IfMultipleFilters()
            {
                switch (this.BehaviorOnNoMatch)
                {
                    case BehaviorOnNoMatch.ReportErrors:
                        return true;

                    case BehaviorOnNoMatch.SilentlyContinue:
                        return false;

                    case BehaviorOnNoMatch.Default:
                    default:
                        return this.PropertyValueFilters
                                   .Where(f => !f.HadMatch).Any(f => f.BehaviorOnNoMatch == BehaviorOnNoMatch.ReportErrors);
                }
            }
</source>
</class>

<class classid="8" nclones="2" nlines="10" similarity="90">
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Management/cimSupport/cmdletization/cim/InstanceMethodInvocationJob.cs.ifdefed" startline="29" endline="48" pcid="460">
        internal override IObservable<CimMethodResultBase> GetCimOperation()
        {
            if (!this.ShouldProcess())
            {
                return null;
            }

            CimMethodParametersCollection methodParameters = this.GetCimMethodParametersCollection();

            CimOperationOptions operationOptions = this.CreateOperationOptions();
            operationOptions.EnableMethodResultStreaming = true;

            IObservable<CimMethodResultBase> observable = this.JobContext.Session.InvokeMethodAsync(
                this.JobContext.Namespace,
                _targetInstance,
                this.MethodName,
                methodParameters,
                operationOptions);
            return observable;
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Management/cimSupport/cmdletization/cim/StaticMethodInvocationJob.cs.ifdefed" startline="20" endline="39" pcid="480">
        internal override IObservable<CimMethodResultBase> GetCimOperation()
        {
            if (!this.ShouldProcess())
            {
                return null;
            }

            CimMethodParametersCollection methodParameters = this.GetCimMethodParametersCollection();

            CimOperationOptions operationOptions = this.CreateOperationOptions();
            operationOptions.EnableMethodResultStreaming = true;

            IObservable<CimMethodResultBase> observable = this.JobContext.Session.InvokeMethodAsync(
                this.JobContext.Namespace,
                this.JobContext.ClassNameOrNullIfResourceUriIsUsed,
                this.MethodName,
                methodParameters,
                operationOptions);
            return observable;
        }
</source>
</class>

<class classid="9" nclones="9" nlines="22" similarity="72">
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Management/commands/management/ClearContentCommand.cs.ifdefed" startline="21" endline="64" pcid="498">
        protected override void ProcessRecord()
        {
            // Default to the CmdletProviderContext that will direct output to
            // the pipeline.

            CmdletProviderContext currentCommandContext = CmdletProviderContext;
            currentCommandContext.PassThru = false;

            foreach (string path in Path)
            {
                try
                {
                    InvokeProvider.Content.Clear(path, currentCommandContext);
                }
                catch (PSNotSupportedException notSupported)
                {
                    WriteError(
                        new ErrorRecord(
                            notSupported.ErrorRecord,
                            notSupported));
                }
                catch (DriveNotFoundException driveNotFound)
                {
                    WriteError(
                        new ErrorRecord(
                            driveNotFound.ErrorRecord,
                            driveNotFound));
                }
                catch (ProviderNotFoundException providerNotFound)
                {
                    WriteError(
                        new ErrorRecord(
                            providerNotFound.ErrorRecord,
                            providerNotFound));
                }
                catch (ItemNotFoundException pathNotFound)
                {
                    WriteError(
                        new ErrorRecord(
                            pathNotFound.ErrorRecord,
                            pathNotFound));
                }
            }
        } // ProcessRecord
</source>
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Management/commands/management/MovePropertyCommand.cs.ifdefed" startline="118" endline="162" pcid="547">
        protected override void ProcessRecord()
        {
            foreach (string path in Path)
            {
                foreach (string propertyName in Name)
                {
                    try
                    {
                        InvokeProvider.Property.Move(path, propertyName, Destination, propertyName, GetCurrentContext());
                    }
                    catch (PSNotSupportedException notSupported)
                    {
                        WriteError(
                            new ErrorRecord(
                                notSupported.ErrorRecord,
                                notSupported));
                        continue;
                    }
                    catch (DriveNotFoundException driveNotFound)
                    {
                        WriteError(
                            new ErrorRecord(
                                driveNotFound.ErrorRecord,
                                driveNotFound));
                        continue;
                    }
                    catch (ProviderNotFoundException providerNotFound)
                    {
                        WriteError(
                            new ErrorRecord(
                                providerNotFound.ErrorRecord,
                                providerNotFound));
                        continue;
                    }
                    catch (ItemNotFoundException pathNotFound)
                    {
                        WriteError(
                            new ErrorRecord(
                                pathNotFound.ErrorRecord,
                                pathNotFound));
                        continue;
                    }
                }
            }
        } // ProcessRecord
</source>
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Management/commands/management/GetPropertyCommand.cs.ifdefed" startline="116" endline="160" pcid="540">
        protected override void ProcessRecord()
        {
            foreach (string path in Path)
            {
                try
                {
                    InvokeProvider.Property.Get(
                        path,
                        SessionStateUtilities.ConvertArrayToCollection<string>(_property),
                        CmdletProviderContext);
                }
                catch (PSNotSupportedException notSupported)
                {
                    WriteError(
                        new ErrorRecord(
                            notSupported.ErrorRecord,
                            notSupported));
                    continue;
                }
                catch (DriveNotFoundException driveNotFound)
                {
                    WriteError(
                        new ErrorRecord(
                            driveNotFound.ErrorRecord,
                            driveNotFound));
                    continue;
                }
                catch (ProviderNotFoundException providerNotFound)
                {
                    WriteError(
                        new ErrorRecord(
                            providerNotFound.ErrorRecord,
                            providerNotFound));
                    continue;
                }
                catch (ItemNotFoundException pathNotFound)
                {
                    WriteError(
                        new ErrorRecord(
                            pathNotFound.ErrorRecord,
                            pathNotFound));
                    continue;
                }
            }
        } // ProcessRecord
</source>
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Management/commands/management/ClearPropertyCommand.cs.ifdefed" startline="122" endline="168" pcid="501">
        protected override void ProcessRecord()
        {
            CmdletProviderContext currentContext = CmdletProviderContext;
            currentContext.PassThru = PassThru;

            Collection<string> propertyCollection = new Collection<string>();
            propertyCollection.Add(_property);

            foreach (string path in Path)
            {
                try
                {
                    InvokeProvider.Property.Clear(
                        path,
                        propertyCollection,
                        currentContext);
                }
                catch (PSNotSupportedException notSupported)
                {
                    WriteError(
                        new ErrorRecord(
                            notSupported.ErrorRecord,
                            notSupported));
                }
                catch (DriveNotFoundException driveNotFound)
                {
                    WriteError(
                        new ErrorRecord(
                            driveNotFound.ErrorRecord,
                            driveNotFound));
                }
                catch (ProviderNotFoundException providerNotFound)
                {
                    WriteError(
                        new ErrorRecord(
                            providerNotFound.ErrorRecord,
                            providerNotFound));
                }
                catch (ItemNotFoundException pathNotFound)
                {
                    WriteError(
                        new ErrorRecord(
                            pathNotFound.ErrorRecord,
                            pathNotFound));
                }
            }
        } // ProcessRecord
</source>
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Management/commands/management/RenamePropertyCommand.cs.ifdefed" startline="106" endline="143" pcid="599">
        protected override void ProcessRecord()
        {
            try
            {
                CmdletProviderContext currentContext = CmdletProviderContext;
                currentContext.PassThru = PassThru;

                InvokeProvider.Property.Rename(_path, Name, NewName, currentContext);
            }
            catch (PSNotSupportedException notSupported)
            {
                WriteError(
                    new ErrorRecord(
                        notSupported.ErrorRecord,
                        notSupported));
            }
            catch (DriveNotFoundException driveNotFound)
            {
                WriteError(
                    new ErrorRecord(
                        driveNotFound.ErrorRecord,
                        driveNotFound));
            }
            catch (ProviderNotFoundException providerNotFound)
            {
                WriteError(
                    new ErrorRecord(
                        providerNotFound.ErrorRecord,
                        providerNotFound));
            }
            catch (ItemNotFoundException pathNotFound)
            {
                WriteError(
                    new ErrorRecord(
                        pathNotFound.ErrorRecord,
                        pathNotFound));
            }
        } // ProcessRecord
</source>
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Management/commands/management/RemovePropertyCommand.cs.ifdefed" startline="129" endline="173" pcid="596">
        protected override void ProcessRecord()
        {
            foreach (string path in Path)
            {
                foreach (string prop in Name)
                {
                    try
                    {
                        InvokeProvider.Property.Remove(path, prop, CmdletProviderContext);
                    }
                    catch (PSNotSupportedException notSupported)
                    {
                        WriteError(
                            new ErrorRecord(
                                notSupported.ErrorRecord,
                                notSupported));
                        continue;
                    }
                    catch (DriveNotFoundException driveNotFound)
                    {
                        WriteError(
                            new ErrorRecord(
                                driveNotFound.ErrorRecord,
                                driveNotFound));
                        continue;
                    }
                    catch (ProviderNotFoundException providerNotFound)
                    {
                        WriteError(
                            new ErrorRecord(
                                providerNotFound.ErrorRecord,
                                providerNotFound));
                        continue;
                    }
                    catch (ItemNotFoundException pathNotFound)
                    {
                        WriteError(
                            new ErrorRecord(
                                pathNotFound.ErrorRecord,
                                pathNotFound));
                        continue;
                    }
                }
            }
        } // ProcessRecord
</source>
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Management/commands/management/NewPropertyCommand.cs.ifdefed" startline="132" endline="173" pcid="549">
        protected override void ProcessRecord()
        {
            foreach (string path in Path)
            {
                try
                {
                    InvokeProvider.Property.New(path, Name, PropertyType, Value, CmdletProviderContext);
                }
                catch (PSNotSupportedException notSupported)
                {
                    WriteError(
                        new ErrorRecord(
                            notSupported.ErrorRecord,
                            notSupported));
                    continue;
                }
                catch (DriveNotFoundException driveNotFound)
                {
                    WriteError(
                        new ErrorRecord(
                            driveNotFound.ErrorRecord,
                            driveNotFound));
                    continue;
                }
                catch (ProviderNotFoundException providerNotFound)
                {
                    WriteError(
                        new ErrorRecord(
                            providerNotFound.ErrorRecord,
                            providerNotFound));
                    continue;
                }
                catch (ItemNotFoundException pathNotFound)
                {
                    WriteError(
                        new ErrorRecord(
                            pathNotFound.ErrorRecord,
                            pathNotFound));
                    continue;
                }
            }
        } // ProcessRecord
</source>
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Management/commands/management/CopyPropertyCommand.cs.ifdefed" startline="100" endline="146" pcid="532">
        protected override void ProcessRecord()
        {
            foreach (string path in Path)
            {
                try
                {
                    InvokeProvider.Property.Copy(
                        path,
                        Name,
                        Destination,
                        Name,
                        GetCurrentContext());
                }
                catch (PSNotSupportedException notSupported)
                {
                    WriteError(
                        new ErrorRecord(
                            notSupported.ErrorRecord,
                            notSupported));
                    continue;
                }
                catch (DriveNotFoundException driveNotFound)
                {
                    WriteError(
                        new ErrorRecord(
                            driveNotFound.ErrorRecord,
                            driveNotFound));
                    continue;
                }
                catch (ProviderNotFoundException providerNotFound)
                {
                    WriteError(
                        new ErrorRecord(
                            providerNotFound.ErrorRecord,
                            providerNotFound));
                    continue;
                }
                catch (ItemNotFoundException pathNotFound)
                {
                    WriteError(
                        new ErrorRecord(
                            pathNotFound.ErrorRecord,
                            pathNotFound));
                    continue;
                }
            }
        } // ProcessRecord
</source>
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Management/commands/management/ConvertPathCommand.cs.ifdefed" startline="76" endline="125" pcid="530">
        protected override void ProcessRecord()
        {
            ProviderInfo provider = null;

            foreach (string path in Path)
            {
                try
                {
                    Collection<string> results =
                        SessionState.Path.GetResolvedProviderPathFromPSPath(
                                path,
                                CmdletProviderContext,
                                out provider);

                    WriteObject(results, true);
                }
                catch (PSNotSupportedException notSupported)
                {
                    WriteError(
                        new ErrorRecord(
                            notSupported.ErrorRecord,
                            notSupported));
                    continue;
                }
                catch (DriveNotFoundException driveNotFound)
                {
                    WriteError(
                        new ErrorRecord(
                            driveNotFound.ErrorRecord,
                            driveNotFound));
                    continue;
                }
                catch (ProviderNotFoundException providerNotFound)
                {
                    WriteError(
                        new ErrorRecord(
                            providerNotFound.ErrorRecord,
                            providerNotFound));
                    continue;
                }
                catch (ItemNotFoundException pathNotFound)
                {
                    WriteError(
                        new ErrorRecord(
                            pathNotFound.ErrorRecord,
                            pathNotFound));
                    continue;
                }
            }
        } // ProcessRecord
</source>
</class>

<class classid="10" nclones="2" nlines="35" similarity="70">
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Management/commands/management/ContentCommandBase.cs.ifdefed" startline="469" endline="545" pcid="513">
        internal List<ContentHolder> GetContentReaders(
            string[] readerPaths,
            CmdletProviderContext currentCommandContext)
        {
            // Resolve all the paths into PathInfo objects

            Collection<PathInfo> pathInfos = ResolvePaths(readerPaths, false, true, currentCommandContext);

            // Create the results array

            List<ContentHolder> results = new List<ContentHolder>();

            foreach (PathInfo pathInfo in pathInfos)
            {
                // For each path, get the content writer

                Collection<IContentReader> readers = null;

                try
                {
                    string pathToProcess = WildcardPattern.Escape(pathInfo.Path);

                    if (currentCommandContext.SuppressWildcardExpansion)
                    {
                        pathToProcess = pathInfo.Path;
                    }

                    readers =
                        InvokeProvider.Content.GetReader(pathToProcess, currentCommandContext);
                }
                catch (PSNotSupportedException notSupported)
                {
                    WriteError(
                        new ErrorRecord(
                            notSupported.ErrorRecord,
                            notSupported));
                    continue;
                }
                catch (DriveNotFoundException driveNotFound)
                {
                    WriteError(
                        new ErrorRecord(
                            driveNotFound.ErrorRecord,
                            driveNotFound));
                    continue;
                }
                catch (ProviderNotFoundException providerNotFound)
                {
                    WriteError(
                        new ErrorRecord(
                            providerNotFound.ErrorRecord,
                            providerNotFound));
                    continue;
                }
                catch (ItemNotFoundException pathNotFound)
                {
                    WriteError(
                        new ErrorRecord(
                            pathNotFound.ErrorRecord,
                            pathNotFound));
                    continue;
                }

                if (readers != null && readers.Count > 0)
                {
                    if (readers.Count == 1 && readers[0] != null)
                    {
                        ContentHolder holder =
                            new ContentHolder(pathInfo, readers[0], null);

                        results.Add(holder);
                    }
                }
            } // foreach pathInfo in pathInfos

            return results;
        } // GetContentReaders
</source>
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Management/commands/management/WriteContentCommandBase.cs.ifdefed" startline="251" endline="322" pcid="617">
        internal List<ContentHolder> GetContentWriters(
            string[] writerPaths,
            CmdletProviderContext currentCommandContext)
        {
            // Resolve all the paths into PathInfo objects

            Collection<PathInfo> pathInfos = ResolvePaths(writerPaths, true, false, currentCommandContext);

            // Create the results array

            List<ContentHolder> results = new List<ContentHolder>();

            foreach (PathInfo pathInfo in pathInfos)
            {
                // For each path, get the content writer

                Collection<IContentWriter> writers = null;

                try
                {
                    writers =
                        InvokeProvider.Content.GetWriter(
                            pathInfo.Path,
                            currentCommandContext);
                }
                catch (PSNotSupportedException notSupported)
                {
                    WriteError(
                        new ErrorRecord(
                            notSupported.ErrorRecord,
                            notSupported));
                    continue;
                }
                catch (DriveNotFoundException driveNotFound)
                {
                    WriteError(
                        new ErrorRecord(
                            driveNotFound.ErrorRecord,
                            driveNotFound));
                    continue;
                }
                catch (ProviderNotFoundException providerNotFound)
                {
                    WriteError(
                        new ErrorRecord(
                            providerNotFound.ErrorRecord,
                            providerNotFound));
                    continue;
                }
                catch (ItemNotFoundException pathNotFound)
                {
                    WriteError(
                        new ErrorRecord(
                            pathNotFound.ErrorRecord,
                            pathNotFound));
                    continue;
                }

                if (writers != null && writers.Count > 0)
                {
                    if (writers.Count == 1 && writers[0] != null)
                    {
                        ContentHolder holder =
                            new ContentHolder(pathInfo, null, writers[0]);

                        results.Add(holder);
                    }
                }
            } // foreach pathInfo in pathInfos

            return results;
        } // GetContentWriters
</source>
</class>

<class classid="11" nclones="2" nlines="10" similarity="70">
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Management/commands/management/MovePropertyCommand.cs.ifdefed" startline="82" endline="100" pcid="546">
        internal override object GetDynamicParameters(CmdletProviderContext context)
        {
            string propertyName = String.Empty;
            if (Name != null && Name.Length > 0)
            {
                propertyName = Name[0];
            }

            if (Path != null && Path.Length > 0)
            {
                return InvokeProvider.Property.MovePropertyDynamicParameters(Path[0], propertyName, Destination, propertyName, context);
            }
            return InvokeProvider.Property.MovePropertyDynamicParameters(
                ".",
                propertyName,
                Destination,
                propertyName,
                context);
        } // GetDynamicParameters
</source>
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Management/commands/management/RemovePropertyCommand.cs.ifdefed" startline="98" endline="111" pcid="595">
        internal override object GetDynamicParameters(CmdletProviderContext context)
        {
            string propertyName = null;
            if (Name != null && Name.Length > 0)
            {
                propertyName = Name[0];
            }

            if (Path != null && Path.Length > 0)
            {
                return InvokeProvider.Property.RemovePropertyDynamicParameters(Path[0], propertyName, context);
            }
            return InvokeProvider.Property.RemovePropertyDynamicParameters(".", propertyName, context);
        } // GetDynamicParameters
</source>
</class>

<class classid="12" nclones="2" nlines="11" similarity="81">
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/OutGridView/OutWindowProxy.cs.ifdefed" startline="174" endline="192" pcid="727">
        internal void AddItem(PSObject livePSObject)
        {
            if (livePSObject == null)
            {
                throw new ArgumentNullException("livePSObject");
            }

            if (_headerInfo == null)
            {
                throw new InvalidOperationException();
            }

            PSObject stalePSObject = _headerInfo.CreateStalePSObject(livePSObject);

            // Add 3 extra properties, so that the stale PSObject has meaningful info in the Hetero-type header view.
            AddExtraProperties(stalePSObject, livePSObject);

            _graphicalHostReflectionWrapper.CallMethod("AddItem", stalePSObject);
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/OutGridView/OutWindowProxy.cs.ifdefed" startline="200" endline="214" pcid="728">
        internal void AddHeteroViewItem(PSObject livePSObject)
        {
            if (livePSObject == null)
            {
                throw new ArgumentNullException("livePSObject");
            }

            if (_headerInfo == null)
            {
                throw new InvalidOperationException();
            }

            PSObject stalePSObject = _headerInfo.CreateStalePSObject(livePSObject);
            _graphicalHostReflectionWrapper.CallMethod("AddItem", stalePSObject);
        }
</source>
</class>

<class classid="13" nclones="2" nlines="48" similarity="87">
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/OutGridView/TableView.cs.ifdefed" startline="206" endline="281" pcid="745">
        private List<TableRowItemDefinition> GetActiveTableRowDefinition(TableControlBody tableBody, PSObject so)
        {
            if (tableBody.optionalDefinitionList.Count == 0)
            {
                // we do not have any override, use default
                return tableBody.defaultDefinition.rowItemDefinitionList;
            }

            // see if we have an override that matches
            TableRowDefinition matchingRowDefinition = null;

            var typeNames = so.InternalTypeNames;
            TypeMatch match = new TypeMatch(_expressionFactory, _typeInfoDatabase, typeNames);

            foreach (TableRowDefinition x in tableBody.optionalDefinitionList)
            {
                if (match.PerfectMatch(new TypeMatchItem(x, x.appliesTo)))
                {
                    matchingRowDefinition = x;
                    break;
                }
            }
            if (matchingRowDefinition == null)
            {
                matchingRowDefinition = match.BestMatch as TableRowDefinition;
            }

            if (matchingRowDefinition == null)
            {
                Collection<string> typesWithoutPrefix = Deserializer.MaskDeserializationPrefix(typeNames);
                if (typesWithoutPrefix != null)
                {
                    match = new TypeMatch(_expressionFactory, _typeInfoDatabase, typesWithoutPrefix);

                    foreach (TableRowDefinition x in tableBody.optionalDefinitionList)
                    {
                        if (match.PerfectMatch(new TypeMatchItem(x, x.appliesTo)))
                        {
                            matchingRowDefinition = x;
                            break;
                        }
                    }
                    if (matchingRowDefinition == null)
                    {
                        matchingRowDefinition = match.BestMatch as TableRowDefinition;
                    }
                }
            }

            if (matchingRowDefinition == null)
            {
                // no matching override, use default
                return tableBody.defaultDefinition.rowItemDefinitionList;
            }

            // we have an override, we need to compute the merge of the active cells
            List<TableRowItemDefinition> activeRowItemDefinitionList = new List<TableRowItemDefinition>();
            int col = 0;
            foreach (TableRowItemDefinition rowItem in matchingRowDefinition.rowItemDefinitionList)
            {
                // Check if the row is an override or not
                if (rowItem.formatTokenList.Count == 0)
                {
                    // It's a place holder, use the default
                    activeRowItemDefinitionList.Add(tableBody.defaultDefinition.rowItemDefinitionList[col]);
                }
                else
                {
                    // Use the override
                    activeRowItemDefinitionList.Add(rowItem);
                }
                col++;
            }

            return activeRowItemDefinitionList;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/FormatAndOutput/common/FormatViewGenerator_Table.cs.ifdefed" startline="348" endline="429" pcid="4809">
        private List<TableRowItemDefinition> GetActiveTableRowDefinition(TableControlBody tableBody, PSObject so,
                                                out bool multiLine)
        {
            multiLine = tableBody.defaultDefinition.multiLine;
            if (tableBody.optionalDefinitionList.Count == 0)
            {
                // we do not have any override, use default
                return tableBody.defaultDefinition.rowItemDefinitionList;
            }

            // see if we have an override that matches
            TableRowDefinition matchingRowDefinition = null;

            var typeNames = so.InternalTypeNames;
            TypeMatch match = new TypeMatch(expressionFactory, this.dataBaseInfo.db, typeNames);

            foreach (TableRowDefinition x in tableBody.optionalDefinitionList)
            {
                if (match.PerfectMatch(new TypeMatchItem(x, x.appliesTo)))
                {
                    matchingRowDefinition = x;
                    break;
                }
            }
            if (matchingRowDefinition == null)
            {
                matchingRowDefinition = match.BestMatch as TableRowDefinition;
            }

            if (matchingRowDefinition == null)
            {
                Collection<string> typesWithoutPrefix = Deserializer.MaskDeserializationPrefix(typeNames);
                if (typesWithoutPrefix != null)
                {
                    match = new TypeMatch(expressionFactory, this.dataBaseInfo.db, typesWithoutPrefix);

                    foreach (TableRowDefinition x in tableBody.optionalDefinitionList)
                    {
                        if (match.PerfectMatch(new TypeMatchItem(x, x.appliesTo)))
                        {
                            matchingRowDefinition = x;
                            break;
                        }
                    }
                    if (matchingRowDefinition == null)
                    {
                        matchingRowDefinition = match.BestMatch as TableRowDefinition;
                    }
                }
            }

            if (matchingRowDefinition == null)
            {
                // no matching override, use default
                return tableBody.defaultDefinition.rowItemDefinitionList;
            }

            // the overriding row definition takes the precedence
            if (matchingRowDefinition.multiLine)
                multiLine = matchingRowDefinition.multiLine;

            // we have an override, we need to compute the merge of the active cells
            List<TableRowItemDefinition> activeRowItemDefinitionList = new List<TableRowItemDefinition>();
            int col = 0;
            foreach (TableRowItemDefinition rowItem in matchingRowDefinition.rowItemDefinitionList)
            {
                // check if the row is an override or not
                if (rowItem.formatTokenList.Count == 0)
                {
                    // it's a place holder, use the default
                    activeRowItemDefinitionList.Add(tableBody.defaultDefinition.rowItemDefinitionList[col]);
                }
                else
                {
                    // use the override
                    activeRowItemDefinitionList.Add(rowItem);
                }
                col++;
            }

            return activeRowItemDefinitionList;
        }
</source>
</class>

<class classid="14" nclones="2" nlines="24" similarity="87">
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Utility/commands/utility/WebCmdlet/JsonObject.cs.ifdefed" startline="207" endline="245" pcid="897">
        private static ICollection<object> PopulateFromJArray(JArray list, out ErrorRecord error)
        {
            error = null;
            List<object> result = new List<object>();

            foreach (var element in list)
            {
                // Array
                if (element is JArray)
                {
                    JArray subList = element as JArray;
                    ICollection<object> listResult = PopulateFromJArray(subList, out error);
                    if (error != null)
                    {
                        return null;
                    }
                    result.Add(listResult);
                }

                // Dictionary
                else if (element is JObject)
                {
                    JObject dic = element as JObject;
                    PSObject dicResult = PopulateFromJDictionary(dic, out error);
                    if (error != null)
                    {
                        return null;
                    }
                    result.Add(dicResult);
                }

                // Value
                else // (element is JValue)
                {
                    result.Add(((JValue)element).Value);
                }
            }
            return result.ToArray();
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.Commands.Utility/commands/utility/WebCmdlet/JsonObject.cs.ifdefed" startline="303" endline="341" pcid="899">
        private static ICollection<object> PopulateHashTableFromJArray(JArray list, out ErrorRecord error)
        {
            error = null;
            List<object> result = new List<object>();

            foreach (var element in list)
            {
                // Array
                if (element is JArray)
                {
                    JArray subList = element as JArray;
                    ICollection<object> listResult = PopulateHashTableFromJArray(subList, out error);
                    if (error != null)
                    {
                        return null;
                    }
                    result.Add(listResult);
                }

                // Dictionary
                else if (element is JObject)
                {
                    JObject dic = element as JObject;
                    Hashtable dicResult = PopulateHashTableFromJDictionary(dic, out error);
                    if (error != null)
                    {
                        return null;
                    }
                    result.Add(dicResult);
                }

                // Value
                else // (element is JValue)
                {
                    result.Add(((JValue)element).Value);
                }
            }
            return result.ToArray();
        }
</source>
</class>

<class classid="15" nclones="2" nlines="11" similarity="72">
<source file="PowerShell/src/Microsoft.PowerShell.ConsoleHost/host/msh/ConsoleHostUserInterfaceProgress.cs.ifdefed" startline="130" endline="147" pcid="926">
        private
        void
        PostWrite(string value)
        {
            PostWrite();

            if (_parent.IsTranscribing)
            {
                try
                {
                    _parent.WriteToTranscript(value);
                }
                catch (Exception)
                {
                    _parent.IsTranscribing = false;
                }
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.ConsoleHost/host/msh/ConsoleHostUserInterfaceProgress.cs.ifdefed" startline="169" endline="187" pcid="929">
        private
        void
        PostRead(string value)
        {
            PostRead();

            if (_parent.IsTranscribing)
            {
                try
                {
                    // Reads always terminate with the enter key, so add that.
                    _parent.WriteToTranscript(value + Crlf);
                }
                catch (Exception)
                {
                    _parent.IsTranscribing = false;
                }
            }
        }
</source>
</class>

<class classid="16" nclones="2" nlines="19" similarity="73">
<source file="PowerShell/src/Microsoft.PowerShell.CoreCLR.Eventing/DotNetCode/Eventing/Reader/EventKeyword.cs.ifdefed" startline="49" endline="73" pcid="998">
        internal void PrepareData()
        {
            if (_dataReady == true) return;

            lock (_syncObject)
            {
                if (_dataReady == true) return;

                IEnumerable<EventKeyword> result = _pmReference.Keywords;

                _name = null;
                _displayName = null;
                _dataReady = true;

                foreach (EventKeyword key in result)
                {
                    if (key.Value == _value)
                    {
                        _name = key.Name;
                        _displayName = key.DisplayName;
                        break;
                    }
                }
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.CoreCLR.Eventing/DotNetCode/Eventing/Reader/EventLevel.cs.ifdefed" startline="49" endline="71" pcid="999">
        internal void PrepareData()
        {
            if (_dataReady == true) return;

            lock (_syncObject)
            {
                if (_dataReady == true) return;

                IEnumerable<EventLevel> result = _pmReference.Levels;
                _name = null;
                _displayName = null;
                _dataReady = true;
                foreach (EventLevel lev in result)
                {
                    if (lev.Value == _value)
                    {
                        _name = lev.Name;
                        _displayName = lev.DisplayName;
                        break;
                    }
                }
            }
        }
</source>
</class>

<class classid="17" nclones="2" nlines="13" similarity="76">
<source file="PowerShell/src/Microsoft.PowerShell.CoreCLR.Eventing/DotNetCode/Eventing/Reader/EventLogSession.cs.ifdefed" startline="190" endline="208" pcid="1031">
        [System.Security.SecurityCritical]
        public IEnumerable<string> GetProviderNames()
        {
            List<string> namesList = new List<string>(100);

            using (EventLogHandle ProviderEnum = NativeWrapper.EvtOpenProviderEnum(this.Handle, 0))
            {
                bool finish = false;

                do
                {
                    string s = NativeWrapper.EvtNextPublisherId(ProviderEnum, ref finish);
                    if (finish == false) namesList.Add(s);
                }
                while (finish == false);

                return namesList;
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.CoreCLR.Eventing/DotNetCode/Eventing/Reader/EventLogSession.cs.ifdefed" startline="210" endline="228" pcid="1032">
        [System.Security.SecurityCritical]
        public IEnumerable<string> GetLogNames()
        {
            List<string> namesList = new List<string>(100);

            using (EventLogHandle channelEnum = NativeWrapper.EvtOpenChannelEnum(this.Handle, 0))
            {
                bool finish = false;

                do
                {
                    string s = NativeWrapper.EvtNextChannelPath(channelEnum, ref finish);
                    if (finish == false) namesList.Add(s);
                }
                while (finish == false);

                return namesList;
            }
        }
</source>
</class>

<class classid="18" nclones="6" nlines="24" similarity="70">
<source file="PowerShell/src/Microsoft.PowerShell.CoreCLR.Eventing/DotNetCode/Eventing/Reader/NativeWrapper.cs.ifdefed" startline="340" endline="371" pcid="1068">
        [System.Security.SecuritySafeCritical]
        public static object EvtGetEventInfo(EventLogHandle handle, UnsafeNativeMethods.EvtEventPropertyId enumType)
        {
            IntPtr buffer = IntPtr.Zero;
            int bufferNeeded;

            try
            {
                bool status = UnsafeNativeMethods.EvtGetEventInfo(handle, enumType, 0, IntPtr.Zero, out bufferNeeded);
                int error = Marshal.GetLastWin32Error();
                if (!status)
                {
                    if (error == UnsafeNativeMethods.ERROR_SUCCESS) { }
                    else
                        if (error != UnsafeNativeMethods.ERROR_INSUFFICIENT_BUFFER)
                        EventLogException.Throw(error);
                }
                buffer = Marshal.AllocHGlobal((int)bufferNeeded);
                status = UnsafeNativeMethods.EvtGetEventInfo(handle, enumType, bufferNeeded, buffer, out bufferNeeded);
                error = Marshal.GetLastWin32Error();
                if (!status)
                    EventLogException.Throw(error);

                UnsafeNativeMethods.EvtVariant varVal = Marshal.PtrToStructure<UnsafeNativeMethods.EvtVariant>(buffer);
                return ConvertToObject(varVal);
            }
            finally
            {
                if (buffer != IntPtr.Zero)
                    Marshal.FreeHGlobal(buffer);
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.CoreCLR.Eventing/DotNetCode/Eventing/Reader/NativeWrapper.cs.ifdefed" startline="1054" endline="1085" pcid="1084">
        [System.Security.SecurityCritical]
        public static string EvtRenderBookmark(EventLogHandle eventHandle)
        {
            IntPtr buffer = IntPtr.Zero;
            int bufferNeeded;
            int propCount;
            UnsafeNativeMethods.EvtRenderFlags flag = UnsafeNativeMethods.EvtRenderFlags.EvtRenderBookmark;

            try
            {
                bool status = UnsafeNativeMethods.EvtRender(EventLogHandle.Zero, eventHandle, flag, 0, IntPtr.Zero, out bufferNeeded, out propCount);
                int error = Marshal.GetLastWin32Error();
                if (!status)
                {
                    if (error != UnsafeNativeMethods.ERROR_INSUFFICIENT_BUFFER)
                        EventLogException.Throw(error);
                }

                buffer = Marshal.AllocHGlobal((int)bufferNeeded);
                status = UnsafeNativeMethods.EvtRender(EventLogHandle.Zero, eventHandle, flag, bufferNeeded, buffer, out bufferNeeded, out propCount);
                error = Marshal.GetLastWin32Error();
                if (!status)
                    EventLogException.Throw(error);

                return Marshal.PtrToStringUni(buffer);
            }
            finally
            {
                if (buffer != IntPtr.Zero)
                    Marshal.FreeHGlobal(buffer);
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.CoreCLR.Eventing/DotNetCode/Eventing/Reader/NativeWrapper.cs.ifdefed" startline="402" endline="430" pcid="1070">
        [System.Security.SecuritySafeCritical]
        public static object EvtGetPublisherMetadataProperty(EventLogHandle pmHandle, UnsafeNativeMethods.EvtPublisherMetadataPropertyId thePropertyId)
        {
            IntPtr buffer = IntPtr.Zero;
            int bufferNeeded;

            try
            {
                bool status = UnsafeNativeMethods.EvtGetPublisherMetadataProperty(pmHandle, thePropertyId, 0, 0, IntPtr.Zero, out bufferNeeded);
                int error = Marshal.GetLastWin32Error();
                if (!status)
                {
                    if (error != UnsafeNativeMethods.ERROR_INSUFFICIENT_BUFFER)
                        EventLogException.Throw(error);
                }
                buffer = Marshal.AllocHGlobal((int)bufferNeeded);
                status = UnsafeNativeMethods.EvtGetPublisherMetadataProperty(pmHandle, thePropertyId, 0, bufferNeeded, buffer, out bufferNeeded);
                error = Marshal.GetLastWin32Error();
                if (!status)
                    EventLogException.Throw(error);

                UnsafeNativeMethods.EvtVariant varVal = Marshal.PtrToStructure<UnsafeNativeMethods.EvtVariant>(buffer);
                return ConvertToObject(varVal);
            }
            finally
            {
                if (buffer != IntPtr.Zero) Marshal.FreeHGlobal(buffer);
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.CoreCLR.Eventing/DotNetCode/Eventing/Reader/NativeWrapper.cs.ifdefed" startline="373" endline="400" pcid="1069">
        [System.Security.SecurityCritical]
        public static object EvtGetQueryInfo(EventLogHandle handle, UnsafeNativeMethods.EvtQueryPropertyId enumType)
        {
            IntPtr buffer = IntPtr.Zero;
            int bufferNeeded = 0;
            try
            {
                bool status = UnsafeNativeMethods.EvtGetQueryInfo(handle, enumType, 0, IntPtr.Zero, ref bufferNeeded);
                int error = Marshal.GetLastWin32Error();
                if (!status)
                {
                    if (error != UnsafeNativeMethods.ERROR_INSUFFICIENT_BUFFER)
                        EventLogException.Throw(error);
                }
                buffer = Marshal.AllocHGlobal((int)bufferNeeded);
                status = UnsafeNativeMethods.EvtGetQueryInfo(handle, enumType, bufferNeeded, buffer, ref bufferNeeded);
                error = Marshal.GetLastWin32Error();
                if (!status)
                    EventLogException.Throw(error);

                UnsafeNativeMethods.EvtVariant varVal = Marshal.PtrToStructure<UnsafeNativeMethods.EvtVariant>(buffer);
                return ConvertToObject(varVal);
            }
            finally
            {
                if (buffer != IntPtr.Zero) Marshal.FreeHGlobal(buffer);
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.CoreCLR.Eventing/DotNetCode/Eventing/Reader/NativeWrapper.cs.ifdefed" startline="522" endline="551" pcid="1073">
        [System.Security.SecurityCritical]
        public static object EvtGetObjectArrayProperty(EventLogHandle objArrayHandle, int index, int thePropertyId)
        {
            IntPtr buffer = IntPtr.Zero;
            int bufferNeeded;

            try
            {
                bool status = UnsafeNativeMethods.EvtGetObjectArrayProperty(objArrayHandle, thePropertyId, index, 0, 0, IntPtr.Zero, out bufferNeeded);
                int error = Marshal.GetLastWin32Error();

                if (!status)
                {
                    if (error != UnsafeNativeMethods.ERROR_INSUFFICIENT_BUFFER)
                        EventLogException.Throw(error);
                }
                buffer = Marshal.AllocHGlobal((int)bufferNeeded);
                status = UnsafeNativeMethods.EvtGetObjectArrayProperty(objArrayHandle, thePropertyId, index, 0, bufferNeeded, buffer, out bufferNeeded);
                error = Marshal.GetLastWin32Error();
                if (!status)
                    EventLogException.Throw(error);

                UnsafeNativeMethods.EvtVariant varVal = Marshal.PtrToStructure<UnsafeNativeMethods.EvtVariant>(buffer);
                return ConvertToObject(varVal);
            }
            finally
            {
                if (buffer != IntPtr.Zero) Marshal.FreeHGlobal(buffer);
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.CoreCLR.Eventing/DotNetCode/Eventing/Reader/NativeWrapper.cs.ifdefed" startline="432" endline="466" pcid="1071">
        [System.Security.SecurityCritical]
        internal static EventLogHandle EvtGetPublisherMetadataPropertyHandle(EventLogHandle pmHandle, UnsafeNativeMethods.EvtPublisherMetadataPropertyId thePropertyId)
        {
            IntPtr buffer = IntPtr.Zero;
            try
            {
                int bufferNeeded;
                bool status = UnsafeNativeMethods.EvtGetPublisherMetadataProperty(pmHandle, thePropertyId, 0, 0, IntPtr.Zero, out bufferNeeded);
                int error = Marshal.GetLastWin32Error();
                if (!status)
                {
                    if (error != UnsafeNativeMethods.ERROR_INSUFFICIENT_BUFFER)
                        EventLogException.Throw(error);
                }
                buffer = Marshal.AllocHGlobal((int)bufferNeeded);
                status = UnsafeNativeMethods.EvtGetPublisherMetadataProperty(pmHandle, thePropertyId, 0, bufferNeeded, buffer, out bufferNeeded);
                error = Marshal.GetLastWin32Error();
                if (!status)
                    EventLogException.Throw(error);

                //
                // note: there is a case where returned variant does have allocated native resources
                // associated with (e.g. ConfigArrayHandle).  If PtrToStructure throws, then we would
                // leak that resource - fortunately PtrToStructure only throws InvalidArgument which
                // is a logic error - not a possible runtime condition here.  Other System exceptions
                // shouldn't be handled anyhow and the application will terminate.
                //
                UnsafeNativeMethods.EvtVariant varVal = Marshal.PtrToStructure<UnsafeNativeMethods.EvtVariant>(buffer);
                return ConvertToSafeHandle(varVal);
            }
            finally
            {
                if (buffer != IntPtr.Zero) Marshal.FreeHGlobal(buffer);
            }
        }
</source>
</class>

<class classid="19" nclones="3" nlines="29" similarity="70">
<source file="PowerShell/src/Microsoft.PowerShell.CoreCLR.Eventing/DotNetCode/Eventing/Reader/NativeWrapper.cs.ifdefed" startline="469" endline="520" pcid="1072">
        [System.Security.SecurityCritical]
        public static string EvtFormatMessage(EventLogHandle handle, uint msgId)
        {
            int bufferNeeded;

            StringBuilder sb = new StringBuilder(null);
            bool status = UnsafeNativeMethods.EvtFormatMessage(handle, EventLogHandle.Zero, msgId, 0, null, UnsafeNativeMethods.EvtFormatMessageFlags.EvtFormatMessageId, 0, sb, out bufferNeeded);
            int error = Marshal.GetLastWin32Error();

            // ERROR_EVT_UNRESOLVED_VALUE_INSERT and its cousins are commonly returned for raw message text.
            if (!status && error != UnsafeNativeMethods.ERROR_EVT_UNRESOLVED_VALUE_INSERT
                        && error != UnsafeNativeMethods.ERROR_EVT_UNRESOLVED_PARAMETER_INSERT
                        && error != UnsafeNativeMethods.ERROR_EVT_MAX_INSERTS_REACHED)
            {
                switch (error)
                {
                    case UnsafeNativeMethods.ERROR_EVT_MESSAGE_NOT_FOUND:
                    case UnsafeNativeMethods.ERROR_EVT_MESSAGE_ID_NOT_FOUND:
                    case UnsafeNativeMethods.ERROR_EVT_MESSAGE_LOCALE_NOT_FOUND:
                    case UnsafeNativeMethods.ERROR_RESOURCE_LANG_NOT_FOUND:
                    case UnsafeNativeMethods.ERROR_MUI_FILE_NOT_FOUND:
                        return null;
                }
                if (error != UnsafeNativeMethods.ERROR_INSUFFICIENT_BUFFER)
                    EventLogException.Throw(error);
            }

            sb.EnsureCapacity(bufferNeeded);
            status = UnsafeNativeMethods.EvtFormatMessage(handle, EventLogHandle.Zero, msgId, 0, null, UnsafeNativeMethods.EvtFormatMessageFlags.EvtFormatMessageId, bufferNeeded, sb, out bufferNeeded);
            error = Marshal.GetLastWin32Error();

            if (!status && error != UnsafeNativeMethods.ERROR_EVT_UNRESOLVED_VALUE_INSERT
                        && error != UnsafeNativeMethods.ERROR_EVT_UNRESOLVED_PARAMETER_INSERT
                        && error != UnsafeNativeMethods.ERROR_EVT_MAX_INSERTS_REACHED)
            {
                switch (error)
                {
                    case UnsafeNativeMethods.ERROR_EVT_MESSAGE_NOT_FOUND:
                    case UnsafeNativeMethods.ERROR_EVT_MESSAGE_ID_NOT_FOUND:
                    case UnsafeNativeMethods.ERROR_EVT_MESSAGE_LOCALE_NOT_FOUND:
                    case UnsafeNativeMethods.ERROR_RESOURCE_LANG_NOT_FOUND:
                    case UnsafeNativeMethods.ERROR_MUI_FILE_NOT_FOUND:
                        return null;
                }
                if (error == UnsafeNativeMethods.ERROR_EVT_UNRESOLVED_VALUE_INSERT)
                {
                    return null;
                }
                EventLogException.Throw(error);
            }
            return sb.ToString();
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.CoreCLR.Eventing/DotNetCode/Eventing/Reader/NativeWrapper.cs.ifdefed" startline="938" endline="986" pcid="1082">
        [System.Security.SecuritySafeCritical]
        public static string EvtFormatMessageRenderName(EventLogHandle pmHandle, EventLogHandle eventHandle, UnsafeNativeMethods.EvtFormatMessageFlags flag)
        {
            int bufferNeeded;
            StringBuilder sb = new StringBuilder(null);

            bool status = UnsafeNativeMethods.EvtFormatMessage(pmHandle, eventHandle, 0, 0, null, flag, 0, sb, out bufferNeeded);
            int error = Marshal.GetLastWin32Error();

            if (!status && error != UnsafeNativeMethods.ERROR_EVT_UNRESOLVED_VALUE_INSERT)
            {
                //
                // ERROR_EVT_UNRESOLVED_VALUE_INSERT can be returned.  It means
                // message may have one or more unsubstituted strings.  This is
                // not an exception, but we have no way to convey the partial
                // success out to enduser.
                //
                switch (error)
                {
                    case UnsafeNativeMethods.ERROR_EVT_MESSAGE_NOT_FOUND:
                    case UnsafeNativeMethods.ERROR_EVT_MESSAGE_ID_NOT_FOUND:
                    case UnsafeNativeMethods.ERROR_EVT_MESSAGE_LOCALE_NOT_FOUND:
                    case UnsafeNativeMethods.ERROR_RESOURCE_LANG_NOT_FOUND:
                    case UnsafeNativeMethods.ERROR_MUI_FILE_NOT_FOUND:
                        return null;
                }
                if (error != (int)UnsafeNativeMethods.ERROR_INSUFFICIENT_BUFFER)
                    EventLogException.Throw(error);
            }

            sb.EnsureCapacity(bufferNeeded);
            status = UnsafeNativeMethods.EvtFormatMessage(pmHandle, eventHandle, 0, 0, null, flag, bufferNeeded, sb, out bufferNeeded);
            error = Marshal.GetLastWin32Error();

            if (!status && error != UnsafeNativeMethods.ERROR_EVT_UNRESOLVED_VALUE_INSERT)
            {
                switch (error)
                {
                    case UnsafeNativeMethods.ERROR_EVT_MESSAGE_NOT_FOUND:
                    case UnsafeNativeMethods.ERROR_EVT_MESSAGE_ID_NOT_FOUND:
                    case UnsafeNativeMethods.ERROR_EVT_MESSAGE_LOCALE_NOT_FOUND:
                    case UnsafeNativeMethods.ERROR_RESOURCE_LANG_NOT_FOUND:
                    case UnsafeNativeMethods.ERROR_MUI_FILE_NOT_FOUND:
                        return null;
                }
                EventLogException.Throw(error);
            }
            return sb.ToString();
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.CoreCLR.Eventing/DotNetCode/Eventing/Reader/NativeWrapper.cs.ifdefed" startline="1088" endline="1143" pcid="1085">
        [System.Security.SecuritySafeCritical]
        public static string EvtFormatMessageFormatDescription(EventLogHandle handle, EventLogHandle eventHandle, string[] values)
        {
            int bufferNeeded;

            UnsafeNativeMethods.EvtStringVariant[] stringVariants = new UnsafeNativeMethods.EvtStringVariant[values.Length];
            for (int i = 0; i < values.Length; i++)
            {
                stringVariants[i].Type = (uint)UnsafeNativeMethods.EvtVariantType.EvtVarTypeString;
                stringVariants[i].StringVal = values[i];
            }

            StringBuilder sb = new StringBuilder(null);
            bool status = UnsafeNativeMethods.EvtFormatMessage(handle, eventHandle, 0xffffffff, values.Length, stringVariants, UnsafeNativeMethods.EvtFormatMessageFlags.EvtFormatMessageEvent, 0, sb, out bufferNeeded);
            int error = Marshal.GetLastWin32Error();

            if (!status && error != UnsafeNativeMethods.ERROR_EVT_UNRESOLVED_VALUE_INSERT)
            {
                //
                // ERROR_EVT_UNRESOLVED_VALUE_INSERT can be returned.  It means
                // message may have one or more unsubstituted strings.  This is
                // not an exception, but we have no way to convey the partial
                // success out to enduser.
                //
                switch (error)
                {
                    case UnsafeNativeMethods.ERROR_EVT_MESSAGE_NOT_FOUND:
                    case UnsafeNativeMethods.ERROR_EVT_MESSAGE_ID_NOT_FOUND:
                    case UnsafeNativeMethods.ERROR_EVT_MESSAGE_LOCALE_NOT_FOUND:
                    case UnsafeNativeMethods.ERROR_RESOURCE_LANG_NOT_FOUND:
                    case UnsafeNativeMethods.ERROR_MUI_FILE_NOT_FOUND:
                        return null;
                }
                if (error != UnsafeNativeMethods.ERROR_INSUFFICIENT_BUFFER)
                    EventLogException.Throw(error);
            }

            sb.EnsureCapacity(bufferNeeded);
            status = UnsafeNativeMethods.EvtFormatMessage(handle, eventHandle, 0xffffffff, values.Length, stringVariants, UnsafeNativeMethods.EvtFormatMessageFlags.EvtFormatMessageEvent, bufferNeeded, sb, out bufferNeeded);
            error = Marshal.GetLastWin32Error();

            if (!status && error != UnsafeNativeMethods.ERROR_EVT_UNRESOLVED_VALUE_INSERT)
            {
                switch (error)
                {
                    case UnsafeNativeMethods.ERROR_EVT_MESSAGE_NOT_FOUND:
                    case UnsafeNativeMethods.ERROR_EVT_MESSAGE_ID_NOT_FOUND:
                    case UnsafeNativeMethods.ERROR_EVT_MESSAGE_LOCALE_NOT_FOUND:
                    case UnsafeNativeMethods.ERROR_RESOURCE_LANG_NOT_FOUND:
                    case UnsafeNativeMethods.ERROR_MUI_FILE_NOT_FOUND:
                        return null;
                }
                EventLogException.Throw(error);
            }
            return sb.ToString();
        }
</source>
</class>

<class classid="20" nclones="3" nlines="23" similarity="86">
<source file="PowerShell/src/Microsoft.PowerShell.CoreCLR.Eventing/DotNetCode/Eventing/Reader/NativeWrapper.cs.ifdefed" startline="553" endline="582" pcid="1074">
        [System.Security.SecurityCritical]
        public static object EvtGetEventMetadataProperty(EventLogHandle handle, UnsafeNativeMethods.EvtEventMetadataPropertyId enumType)
        {
            IntPtr buffer = IntPtr.Zero;
            int bufferNeeded;

            try
            {
                bool status = UnsafeNativeMethods.EvtGetEventMetadataProperty(handle, enumType, 0, 0, IntPtr.Zero, out bufferNeeded);
                int win32Error = Marshal.GetLastWin32Error();
                if (!status)
                {
                    if (win32Error != UnsafeNativeMethods.ERROR_INSUFFICIENT_BUFFER)
                        EventLogException.Throw(win32Error);
                }
                buffer = Marshal.AllocHGlobal((int)bufferNeeded);
                status = UnsafeNativeMethods.EvtGetEventMetadataProperty(handle, enumType, 0, bufferNeeded, buffer, out bufferNeeded);
                win32Error = Marshal.GetLastWin32Error();
                if (!status)
                    EventLogException.Throw(win32Error);

                UnsafeNativeMethods.EvtVariant varVal = Marshal.PtrToStructure<UnsafeNativeMethods.EvtVariant>(buffer);
                return ConvertToObject(varVal);
            }
            finally
            {
                if (buffer != IntPtr.Zero)
                    Marshal.FreeHGlobal(buffer);
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.CoreCLR.Eventing/DotNetCode/Eventing/Reader/NativeWrapper.cs.ifdefed" startline="761" endline="790" pcid="1079">
        [System.Security.SecurityCritical]
        public static object EvtGetLogInfo(EventLogHandle handle, UnsafeNativeMethods.EvtLogPropertyId enumType)
        {
            IntPtr buffer = IntPtr.Zero;
            int bufferNeeded;

            try
            {
                bool status = UnsafeNativeMethods.EvtGetLogInfo(handle, enumType, 0, IntPtr.Zero, out bufferNeeded);
                int win32Error = Marshal.GetLastWin32Error();
                if (!status)
                {
                    if (win32Error != UnsafeNativeMethods.ERROR_INSUFFICIENT_BUFFER)
                        EventLogException.Throw(win32Error);
                }
                buffer = Marshal.AllocHGlobal((int)bufferNeeded);
                status = UnsafeNativeMethods.EvtGetLogInfo(handle, enumType, bufferNeeded, buffer, out bufferNeeded);
                win32Error = Marshal.GetLastWin32Error();
                if (!status)
                    EventLogException.Throw(win32Error);

                UnsafeNativeMethods.EvtVariant varVal = Marshal.PtrToStructure<UnsafeNativeMethods.EvtVariant>(buffer);
                return ConvertToObject(varVal);
            }
            finally
            {
                if (buffer != IntPtr.Zero)
                    Marshal.FreeHGlobal(buffer);
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.CoreCLR.Eventing/DotNetCode/Eventing/Reader/NativeWrapper.cs.ifdefed" startline="584" endline="620" pcid="1075">
        [System.Security.SecuritySafeCritical]
        public static object EvtGetChannelConfigProperty(EventLogHandle handle, UnsafeNativeMethods.EvtChannelConfigPropertyId enumType)
        {
            IntPtr buffer = IntPtr.Zero;
            int bufferNeeded;

            try
            {
                bool status = UnsafeNativeMethods.EvtGetChannelConfigProperty(handle, enumType, 0, 0, IntPtr.Zero, out bufferNeeded);
                int win32Error = Marshal.GetLastWin32Error();
                if (!status)
                {
                    if (win32Error != UnsafeNativeMethods.ERROR_INSUFFICIENT_BUFFER)
                        EventLogException.Throw(win32Error);
                }
                buffer = Marshal.AllocHGlobal((int)bufferNeeded);
                status = UnsafeNativeMethods.EvtGetChannelConfigProperty(handle, enumType, 0, bufferNeeded, buffer, out bufferNeeded);
                win32Error = Marshal.GetLastWin32Error();
                if (!status)
                    EventLogException.Throw(win32Error);

                //
                // note: there is a case where returned variant does have allocated native resources
                // associated with (e.g. ConfigArrayHandle).  If PtrToStructure throws, then we would
                // leak that resource - fortunately PtrToStructure only throws InvalidArgument which
                // is a logic error - not a possible runtime condition here.  Other System exceptions
                // shouldn't be handled anyhow and the application will terminate.
                //
                UnsafeNativeMethods.EvtVariant varVal = Marshal.PtrToStructure<UnsafeNativeMethods.EvtVariant>(buffer);
                return ConvertToObject(varVal);
            }
            finally
            {
                if (buffer != IntPtr.Zero)
                    Marshal.FreeHGlobal(buffer);
            }
        }
</source>
</class>

<class classid="21" nclones="2" nlines="20" similarity="75">
<source file="PowerShell/src/Microsoft.PowerShell.CoreCLR.Eventing/DotNetCode/Eventing/Reader/NativeWrapper.cs.ifdefed" startline="703" endline="730" pcid="1077">
        [System.Security.SecurityCritical]
        public static string EvtNextChannelPath(EventLogHandle handle, ref bool finish)
        {
            StringBuilder sb = new StringBuilder(null);
            int channelNameNeeded;

            bool status = UnsafeNativeMethods.EvtNextChannelPath(handle, 0, sb, out channelNameNeeded);
            int win32Error = Marshal.GetLastWin32Error();
            if (!status)
            {
                if (win32Error == UnsafeNativeMethods.ERROR_NO_MORE_ITEMS)
                {
                    finish = true;
                    return null;
                }

                if (win32Error != UnsafeNativeMethods.ERROR_INSUFFICIENT_BUFFER)
                    EventLogException.Throw(win32Error);
            }

            sb.EnsureCapacity(channelNameNeeded);
            status = UnsafeNativeMethods.EvtNextChannelPath(handle, channelNameNeeded, sb, out channelNameNeeded);
            win32Error = Marshal.GetLastWin32Error();
            if (!status)
                EventLogException.Throw(win32Error);

            return sb.ToString();
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.CoreCLR.Eventing/DotNetCode/Eventing/Reader/NativeWrapper.cs.ifdefed" startline="732" endline="759" pcid="1078">
        [System.Security.SecurityCritical]
        public static string EvtNextPublisherId(EventLogHandle handle, ref bool finish)
        {
            StringBuilder sb = new StringBuilder(null);
            int ProviderIdNeeded;

            bool status = UnsafeNativeMethods.EvtNextPublisherId(handle, 0, sb, out ProviderIdNeeded);
            int win32Error = Marshal.GetLastWin32Error();
            if (!status)
            {
                if (win32Error == UnsafeNativeMethods.ERROR_NO_MORE_ITEMS)
                {
                    finish = true;
                    return null;
                }

                if (win32Error != UnsafeNativeMethods.ERROR_INSUFFICIENT_BUFFER)
                    EventLogException.Throw(win32Error);
            }

            sb.EnsureCapacity(ProviderIdNeeded);
            status = UnsafeNativeMethods.EvtNextPublisherId(handle, ProviderIdNeeded, sb, out ProviderIdNeeded);
            win32Error = Marshal.GetLastWin32Error();
            if (!status)
                EventLogException.Throw(win32Error);

            return sb.ToString();
        }
</source>
</class>

<class classid="22" nclones="2" nlines="14" similarity="71">
<source file="PowerShell/src/Microsoft.PowerShell.CoreCLR.Eventing/DotNetCode/Eventing/Reader/NativeWrapper.cs.ifdefed" startline="1336" endline="1354" pcid="1093">
        [System.Security.SecurityCritical]
        public static Array ConvertToFileTimeArray(UnsafeNativeMethods.EvtVariant val)
        {
            IntPtr ptr = val.Reference;
            if (ptr == IntPtr.Zero)
            {
                return new DateTime[0];
            }
            else
            {
                DateTime[] array = new DateTime[val.Count];
                for (int i = 0; i < val.Count; i++)
                {
                    array[i] = DateTime.FromFileTime(Marshal.ReadInt64(ptr));
                    ptr = new IntPtr((Int64)ptr + 8 * sizeof(byte)); // FILETIME values are 8 bytes
                }
                return array;
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.CoreCLR.Eventing/DotNetCode/Eventing/Reader/NativeWrapper.cs.ifdefed" startline="1356" endline="1375" pcid="1094">
        [System.Security.SecurityCritical]
        public static Array ConvertToSysTimeArray(UnsafeNativeMethods.EvtVariant val)
        {
            IntPtr ptr = val.Reference;
            if (ptr == IntPtr.Zero)
            {
                return new DateTime[0];
            }
            else
            {
                DateTime[] array = new DateTime[val.Count];
                for (int i = 0; i < val.Count; i++)
                {
                    UnsafeNativeMethods.SystemTime sysTime = Marshal.PtrToStructure<UnsafeNativeMethods.SystemTime>(ptr);
                    array[i] = new DateTime(sysTime.Year, sysTime.Month, sysTime.Day, sysTime.Hour, sysTime.Minute, sysTime.Second, sysTime.Milliseconds);
                    ptr = new IntPtr((Int64)ptr + 16 * sizeof(byte)); // SystemTime values are 16 bytes
                }
                return array;
            }
        }
</source>
</class>

<class classid="23" nclones="2" nlines="12" similarity="75">
<source file="PowerShell/src/Microsoft.PowerShell.CoreCLR.Eventing/DotNetCode/Eventing/Reader/ProviderMetadataCachedInformation.cs.ifdefed" startline="224" endline="241" pcid="1113">
        [System.Security.SecuritySafeCritical]
        public string GetFormatDescription(string ProviderName, EventLogHandle eventHandle)
        {
            lock (this)
            {
                ProviderMetadataId key = new ProviderMetadataId(ProviderName, CultureInfo.CurrentCulture);

                try
                {
                    ProviderMetadata pm = GetProviderMetadata(key);
                    return NativeWrapper.EvtFormatMessageRenderName(pm.Handle, eventHandle, UnsafeNativeMethods.EvtFormatMessageFlags.EvtFormatMessageEvent);
                }
                catch (EventLogNotFoundException)
                {
                    return null;
                }
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.CoreCLR.Eventing/DotNetCode/Eventing/Reader/ProviderMetadataCachedInformation.cs.ifdefed" startline="243" endline="258" pcid="1114">
        public string GetFormatDescription(string ProviderName, EventLogHandle eventHandle, string[] values)
        {
            lock (this)
            {
                ProviderMetadataId key = new ProviderMetadataId(ProviderName, CultureInfo.CurrentCulture);
                ProviderMetadata pm = GetProviderMetadata(key);
                try
                {
                    return NativeWrapper.EvtFormatMessageFormatDescription(pm.Handle, eventHandle, values);
                }
                catch (EventLogNotFoundException)
                {
                    return null;
                }
            }
        }
</source>
</class>

<class classid="24" nclones="2" nlines="13" similarity="100">
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/AddLocalGroupMemberCommand.cs.ifdefed" startline="111" endline="126" pcid="1121">
        protected override void ProcessRecord()
        {
            try
            {
                if (Group != null)
                    ProcessGroup(Group);
                else if (Name != null)
                    ProcessName(Name);
                else if (SID != null)
                    ProcessSid(SID);
            }
            catch (GroupNotFoundException ex)
            {
                WriteError(ex.MakeErrorRecord());
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/RemoveLocalGroupMemberCommand.cs.ifdefed" startline="111" endline="126" pcid="1175">
        protected override void ProcessRecord()
        {
            try
            {
                if (Group != null)
                    ProcessGroup(Group);
                else if (Name != null)
                    ProcessName(Name);
                else if (SID != null)
                    ProcessSid(SID);
            }
            catch (GroupNotFoundException ex)
            {
                WriteError(ex.MakeErrorRecord());
            }
        }
</source>
</class>

<class classid="25" nclones="2" nlines="22" similarity="100">
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/AddLocalGroupMemberCommand.cs.ifdefed" startline="176" endline="209" pcid="1123">
        private LocalPrincipal MakePrincipal(string groupId, LocalPrincipal member)
        {
            LocalPrincipal principal = null;
            // if the member has a SID, we can use it directly
            if (member.SID != null)
            {
                principal = member;
            }
            else    // otherwise it must have been constructed by name
            {
                SecurityIdentifier sid = this.TrySid(member.Name);

                if (sid != null)
                {
                    member.SID = sid;
                    principal = member;
                }
                else
                {
                    try
                    {
                        principal = sam.LookupAccount(member.Name);
                    }
                    catch (Exception ex)
                    {
                        WriteError(ex.MakeErrorRecord());
                    }
                }
            }
            if (CheckShouldProcess(principal, groupId))
                return principal;

            return null;
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/RemoveLocalGroupMemberCommand.cs.ifdefed" startline="174" endline="209" pcid="1177">
        private LocalPrincipal MakePrincipal(string groupId, LocalPrincipal member)
        {
               LocalPrincipal principal = null;

                // if the member has a SID, we can use it directly
                if (member.SID != null)
                {
                    principal = member;
                }
                else    // otherwise it must have been constructed by name
                {
                    SecurityIdentifier sid = this.TrySid(member.Name);

                    if (sid != null)
                    {
                        member.SID = sid;
                        principal = member;
                    }
                    else
                    {
                        try
                        {
                            principal = sam.LookupAccount(member.Name);
                        }
                        catch (Exception ex)
                        {
                            WriteError(ex.MakeErrorRecord());
                        }
                    }
                }

            if (CheckShouldProcess(principal, groupId))
                return principal;

            return null;
        }
</source>
</class>

<class classid="26" nclones="2" nlines="12" similarity="91">
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/AddLocalGroupMemberCommand.cs.ifdefed" startline="240" endline="255" pcid="1125">
        private void ProcessGroup(LocalGroup group)
        {
            string groupId = group.Name ?? group.SID.ToString();
            foreach (var member in this.Member)
            {
                LocalPrincipal principal = MakePrincipal(groupId, member);
                if (principal != null)
                {
                    var ex = sam.AddLocalGroupMember(group, principal);
                    if (ex != null)
                    {
                        WriteError(ex.MakeErrorRecord());
                    }
                }
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/RemoveLocalGroupMemberCommand.cs.ifdefed" startline="240" endline="255" pcid="1179">
        private void ProcessGroup(LocalGroup group)
        {
            string groupId = group.Name ?? group.SID.ToString();
            foreach (var member in this.Member)
            {
                LocalPrincipal principal = MakePrincipal(groupId, member);
                if (principal != null)
                {
                    var ex = sam.RemoveLocalGroupMember(group, principal);
                    if (ex != null)
                    {
                        WriteError(ex.MakeErrorRecord());
                    }
                }
            }
        }
</source>
</class>

<class classid="27" nclones="2" nlines="11" similarity="90">
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/AddLocalGroupMemberCommand.cs.ifdefed" startline="275" endline="289" pcid="1127">
        private void ProcessSid(SecurityIdentifier groupSid)
        {
            foreach (var member in this.Member)
            {
                LocalPrincipal principal = MakePrincipal(groupSid.ToString(), member);
                if (principal != null)
                {
                    var ex = sam.AddLocalGroupMember(groupSid, principal);
                    if (ex != null)
                    {
                        WriteError(ex.MakeErrorRecord());
                    }
                }
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/RemoveLocalGroupMemberCommand.cs.ifdefed" startline="275" endline="289" pcid="1181">
        private void ProcessSid(SecurityIdentifier groupSid)
        {
            foreach (var member in this.Member)
            {
                LocalPrincipal principal = MakePrincipal(groupSid.ToString(), member);
                if (principal != null)
                {
                    var ex = sam.RemoveLocalGroupMember(groupSid, principal);
                    if (ex != null)
                    {
                        WriteError(ex.MakeErrorRecord());
                    }
                }
            }
        }
</source>
</class>

<class classid="28" nclones="6" nlines="10" similarity="70">
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/DisableLocalUserCommand.cs.ifdefed" startline="108" endline="120" pcid="1129">
        protected override void ProcessRecord()
        {
            try
            {
                ProcessUsers();
                ProcessNames();
                ProcessSids();
            }
            catch (Exception ex)
            {
                WriteError(ex.MakeErrorRecord());
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/EnableLocalUserCommand.cs.ifdefed" startline="108" endline="120" pcid="1136">
        protected override void ProcessRecord()
        {
            try
            {
                ProcessUsers();
                ProcessNames();
                ProcessSids();
            }
            catch (Exception ex)
            {
                WriteError(ex.MakeErrorRecord());
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/RemoveLocalUserCommand.cs.ifdefed" startline="102" endline="114" pcid="1183">
        protected override void ProcessRecord()
        {
            try
            {
                ProcessUsers();
                ProcessNames();
                ProcessSids();
            }
            catch (Exception ex)
            {
                WriteError(ex.MakeErrorRecord());
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/RemoveLocalGroupCommand.cs.ifdefed" startline="101" endline="113" pcid="1168">
        protected override void ProcessRecord()
        {
            try
            {
                ProcessGroups();
                ProcessNames();
                ProcessSids();
            }
            catch (Exception ex)
            {
                WriteError(ex.MakeErrorRecord());
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/RenameLocalGroupCommand.cs.ifdefed" startline="112" endline="124" pcid="1190">
        protected override void ProcessRecord()
        {
            try
            {
                ProcessGroup();
                ProcessName();
                ProcessSid();
            }
            catch (Exception ex)
            {
                WriteError(ex.MakeErrorRecord());
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/RenameLocalUserCommand.cs.ifdefed" startline="112" endline="124" pcid="1197">
        protected override void ProcessRecord()
        {
            try
            {
                ProcessUser();
                ProcessName();
                ProcessSid();
            }
            catch (Exception ex)
            {
                WriteError(ex.MakeErrorRecord());
            }
        }
</source>
</class>

<class classid="29" nclones="4" nlines="13" similarity="92">
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/DisableLocalUserCommand.cs.ifdefed" startline="143" endline="160" pcid="1131">
        private void ProcessNames()
        {
            if (Name != null)
            {
                foreach (var name in Name)
                {
                    try
                    {
                        if (CheckShouldProcess(name))
                            sam.EnableLocalUser(sam.GetLocalUser(name), enabling);
                    }
                    catch (Exception ex)
                    {
                        WriteError(ex.MakeErrorRecord());
                    }
                }
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/EnableLocalUserCommand.cs.ifdefed" startline="143" endline="160" pcid="1138">
        private void ProcessNames()
        {
            if (Name != null)
            {
                foreach (var name in Name)
                {
                    try
                    {
                        if (CheckShouldProcess(name))
                            sam.EnableLocalUser(sam.GetLocalUser(name), enabling);
                    }
                    catch (Exception ex)
                    {
                        WriteError(ex.MakeErrorRecord());
                    }
                }
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/RemoveLocalUserCommand.cs.ifdefed" startline="137" endline="154" pcid="1185">
        private void ProcessNames()
        {
            if (Name != null)
            {
                foreach (var name in Name)
                {
                    try
                    {
                        if (CheckShouldProcess(name))
                            sam.RemoveLocalUser(sam.GetLocalUser(name));
                    }
                    catch (Exception ex)
                    {
                        WriteError(ex.MakeErrorRecord());
                    }
                }
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/RemoveLocalGroupCommand.cs.ifdefed" startline="136" endline="153" pcid="1170">
        private void ProcessNames()
        {
            if (Name != null)
            {
                foreach (var name in Name)
                {
                    try
                    {
                        if (CheckShouldProcess(name))
                            sam.RemoveLocalGroup(sam.GetLocalGroup(name));
                    }
                    catch (Exception ex)
                    {
                        WriteError(ex.MakeErrorRecord());
                    }
                }
            }
        }
</source>
</class>

<class classid="30" nclones="6" nlines="13" similarity="76">
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/DisableLocalUserCommand.cs.ifdefed" startline="165" endline="182" pcid="1132">
        private void ProcessSids()
        {
            if (SID != null)
            {
                foreach (var sid in SID)
                {
                    try
                    {
                        if (CheckShouldProcess(sid.ToString()))
                            sam.EnableLocalUser(sid, enabling);
                    }
                    catch (Exception ex)
                    {
                        WriteError(ex.MakeErrorRecord());
                    }
                }
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/RemoveLocalUserCommand.cs.ifdefed" startline="159" endline="176" pcid="1186">
        private void ProcessSids()
        {
            if (SID != null)
            {
                foreach (var sid in SID)
                {
                    try
                    {
                        if (CheckShouldProcess(sid.ToString()))
                            sam.RemoveLocalUser(sid);
                    }
                    catch (Exception ex)
                    {
                        WriteError(ex.MakeErrorRecord());
                    }
                }
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/GetLocalGroupCommand.cs.ifdefed" startline="146" endline="162" pcid="1146">
        private void ProcessSids()
        {
            if (SID != null)
            {
                foreach (var sid in SID)
                {
                    try
                    {
                        WriteObject(sam.GetLocalGroup(sid));
                    }
                    catch (Exception ex)
                    {
                        WriteError(ex.MakeErrorRecord());
                    }
                }
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/GetLocalUserCommand.cs.ifdefed" startline="149" endline="165" pcid="1158">
        private void ProcessSids()
        {
            if (SID != null)
            {
                foreach (var s in SID)
                {
                    try
                    {
                        WriteObject(sam.GetLocalUser(s));
                    }
                    catch (Exception ex)
                    {
                        WriteError(ex.MakeErrorRecord());
                    }
                }
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/RemoveLocalGroupCommand.cs.ifdefed" startline="158" endline="175" pcid="1171">
        private void ProcessSids()
        {
            if (SID != null)
            {
                foreach (var sid in SID)
                {
                    try
                    {
                        if (CheckShouldProcess(sid.ToString()))
                            sam.RemoveLocalGroup(sid);
                    }
                    catch (Exception ex)
                    {
                        WriteError(ex.MakeErrorRecord());
                    }
                }
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/EnableLocalUserCommand.cs.ifdefed" startline="165" endline="182" pcid="1139">
        private void ProcessSids()
        {
            if (SID != null)
            {
                foreach (var sid in SID)
                {
                    try
                    {
                        if (CheckShouldProcess(sid.ToString()))
                            sam.EnableLocalUser(sid, enabling);
                    }
                    catch (Exception ex)
                    {
                        WriteError(ex.MakeErrorRecord());
                    }
                }
            }
        }
</source>
</class>

<class classid="31" nclones="3" nlines="13" similarity="92">
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/DisableLocalUserCommand.cs.ifdefed" startline="187" endline="204" pcid="1133">
        private void ProcessUsers()
        {
            if (InputObject != null)
            {
                foreach (var user in InputObject)
                {
                    try
                    {
                        if (CheckShouldProcess(user.Name))
                            sam.EnableLocalUser(user, enabling);
                    }
                    catch (Exception ex)
                    {
                        WriteError(ex.MakeErrorRecord());
                    }
                }
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/EnableLocalUserCommand.cs.ifdefed" startline="187" endline="204" pcid="1140">
        private void ProcessUsers()
        {
            if (InputObject != null)
            {
                foreach (var user in InputObject)
                {
                    try
                    {
                        if (CheckShouldProcess(user.Name))
                            sam.EnableLocalUser(user, enabling);
                    }
                    catch (Exception ex)
                    {
                        WriteError(ex.MakeErrorRecord());
                    }
                }
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/RemoveLocalUserCommand.cs.ifdefed" startline="181" endline="198" pcid="1187">
        private void ProcessUsers()
        {
            if (InputObject != null)
            {
                foreach (var user in InputObject)
                {
                    try
                    {
                        if (CheckShouldProcess(user.Name))
                            sam.RemoveLocalUser(user);
                    }
                    catch (Exception ex)
                    {
                        WriteError(ex.MakeErrorRecord());
                    }
                }
            }
        }
</source>
</class>

<class classid="32" nclones="2" nlines="11" similarity="90">
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/RenameLocalGroupCommand.cs.ifdefed" startline="147" endline="161" pcid="1192">
        private void ProcessName()
        {
            if (Name != null)
            {
                try
                {
                    if (CheckShouldProcess(Name, NewName))
                        sam.RenameLocalGroup(sam.GetLocalGroup(Name), NewName);
                }
                catch (Exception ex)
                {
                    WriteError(ex.MakeErrorRecord());
                }
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/RenameLocalUserCommand.cs.ifdefed" startline="147" endline="161" pcid="1199">
        private void ProcessName()
        {
            if (Name != null)
            {
                try
                {
                    if (CheckShouldProcess(Name, NewName))
                        sam.RenameLocalUser(sam.GetLocalUser(Name), NewName);
                }
                catch (Exception ex)
                {
                    WriteError(ex.MakeErrorRecord());
                }
            }
        }
</source>
</class>

<class classid="33" nclones="2" nlines="11" similarity="90">
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/RenameLocalGroupCommand.cs.ifdefed" startline="166" endline="180" pcid="1193">
        private void ProcessSid()
        {
            if (SID != null)
            {
                try
                {
                    if (CheckShouldProcess(SID.ToString(), NewName))
                        sam.RenameLocalGroup(SID, NewName);
                }
                catch (Exception ex)
                {
                    WriteError(ex.MakeErrorRecord());
                }
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/RenameLocalUserCommand.cs.ifdefed" startline="166" endline="180" pcid="1200">
        private void ProcessSid()
        {
            if (SID != null)
            {
                try
                {
                    if (CheckShouldProcess(SID.ToString(), NewName))
                        sam.RenameLocalUser(SID, NewName);
                }
                catch (Exception ex)
                {
                    WriteError(ex.MakeErrorRecord());
                }
            }
        }
</source>
</class>

<class classid="34" nclones="2" nlines="11" similarity="81">
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/RenameLocalGroupCommand.cs.ifdefed" startline="185" endline="199" pcid="1194">
        private void ProcessGroup()
        {
            if (InputObject != null)
            {
                try
                {
                    if (CheckShouldProcess(InputObject.Name, NewName))
                        sam.RenameLocalGroup(InputObject, NewName);
                }
                catch (Exception ex)
                {
                    WriteError(ex.MakeErrorRecord());
                }
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.LocalAccounts/LocalAccounts/Commands/RenameLocalUserCommand.cs.ifdefed" startline="185" endline="199" pcid="1201">
        private void ProcessUser()
        {
            if (InputObject != null)
            {
                try
                {
                    if (CheckShouldProcess(InputObject.Name, NewName))
                        sam.RenameLocalUser(InputObject, NewName);
                }
                catch (Exception ex)
                {
                    WriteError(ex.MakeErrorRecord());
                }
            }
        }
</source>
</class>

<class classid="35" nclones="3" nlines="13" similarity="76">
<source file="PowerShell/src/Microsoft.PowerShell.ScheduledJob/commands/AddJobTrigger.cs.ifdefed" startline="96" endline="112" pcid="1239">
        protected override void ProcessRecord()
        {
            switch (ParameterSetName)
            {
                case JobDefinitionParameterSet:
                    AddToJobDefinition(_definitions);
                    break;

                case JobDefinitionIdParameterSet:
                    AddToJobDefinition(GetJobDefinitionsById(_ids));
                    break;

                case JobDefinitionNameParameterSet:
                    AddToJobDefinition(GetJobDefinitionsByName(_names));
                    break;
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.ScheduledJob/commands/RemoveJobTrigger.cs.ifdefed" startline="93" endline="109" pcid="1259">
        protected override void ProcessRecord()
        {
            switch (ParameterSetName)
            {
                case JobDefinitionParameterSet:
                    RemoveFromJobDefinition(_definitions);
                    break;

                case JobDefinitionIdParameterSet:
                    RemoveFromJobDefinition(GetJobDefinitionsById(_definitionIds));
                    break;

                case JobDefinitionNameParameterSet:
                    RemoveFromJobDefinition(GetJobDefinitionsByName(_names));
                    break;
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.ScheduledJob/commands/GetJobTrigger.cs.ifdefed" startline="92" endline="108" pcid="1244">
        protected override void ProcessRecord()
        {
            switch (ParameterSetName)
            {
                case JobDefinitionParameterSet:
                    WriteTriggers(_definition);
                    break;

                case JobDefinitionIdParameterSet:
                    WriteTriggers(GetJobDefinitionById(_definitionId));
                    break;

                case JobDefinitionNameParameterSet:
                    WriteTriggers(GetJobDefinitionByName(_name));
                    break;
            }
        }
</source>
</class>

<class classid="36" nclones="2" nlines="18" similarity="83">
<source file="PowerShell/src/Microsoft.PowerShell.ScheduledJob/ScheduledJob.cs.ifdefed" startline="228" endline="254" pcid="1271">
        public override void StopJob()
        {
            Job job;
            JobState state;
            lock (SyncRoot)
            {
                job = _job;
                state = Status.State;
                _asyncJobStop = false;
            }

            if (IsFinishedState(state))
            {
                return;
            }

            if (job == null)
            {
                // Set job state to failed so that it can be removed from the
                // cache using Remove-Job.
                SetJobState(JobState.Failed);
            }
            else
            {
                job.StopJob();
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.ScheduledJob/ScheduledJob.cs.ifdefed" startline="259" endline="288" pcid="1272">
        public override void StopJobAsync()
        {
            Job job;
            JobState state;
            lock (SyncRoot)
            {
                job = _job;
                state = Status.State;
                _asyncJobStop = true;
            }

            if (IsFinishedState(state))
            {
                return;
            }

            if (job == null)
            {
                // Set job state to failed so that it can be removed from the
                // cache using Remove-Job.
                SetJobState(JobState.Failed);
                HandleJobStateChanged(this,
                    new JobStateEventArgs(
                        new JobStateInfo(JobState.Failed)));
            }
            else
            {
                job.StopJob();
            }
        }
</source>
</class>

<class classid="37" nclones="2" nlines="12" similarity="75">
<source file="PowerShell/src/Microsoft.PowerShell.ScheduledJob/ScheduledJobSourceAdapter.cs.ifdefed" startline="920" endline="936" pcid="1335">
            public void Add(Job2 job)
            {
                if (job == null)
                {
                    throw new PSArgumentNullException("job");
                }

                lock (_syncObject)
                {
                    if (_jobs.ContainsKey(job.InstanceId))
                    {
                        string msg = StringUtil.Format(ScheduledJobErrorStrings.ScheduledJobAlreadyExistsInLocal, job.Name, job.InstanceId);
                        throw new ScheduledJobException(msg);
                    }
                    _jobs.Add(job.InstanceId, job);
                }
            }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.ScheduledJob/ScheduledJobSourceAdapter.cs.ifdefed" startline="942" endline="957" pcid="1336">
            public void AddOrReplace(Job2 job)
            {
                if (job == null)
                {
                    throw new PSArgumentNullException("job");
                }

                lock (_syncObject)
                {
                    if (_jobs.ContainsKey(job.InstanceId))
                    {
                        _jobs.Remove(job.InstanceId);
                    }
                    _jobs.Add(job.InstanceId, job);
                }
            }
</source>
</class>

<class classid="38" nclones="2" nlines="16" similarity="81">
<source file="PowerShell/src/Microsoft.PowerShell.Security/security/AclCommands.cs.ifdefed" startline="204" endline="233" pcid="1397">
        public static string GetOwner(PSObject instance)
        {
            if (instance == null)
            {
                throw PSTraceSource.NewArgumentNullException("instance");
            }

            ObjectSecurity sd = instance.BaseObject as ObjectSecurity;
            if (sd == null)
            {
                throw PSTraceSource.NewArgumentNullException("instance");
            }

            //Get owner
            try
            {
                IdentityReference ir = sd.GetOwner(typeof(NTAccount));
                return ir.ToString();
            }
            catch (IdentityNotMappedException)
            {
                // All Acl cmdlets returning SIDs will return a string
                // representation of the SID in all cases where the SID
                // cannot be mapped to a proper user or group name.
            }

            // We are here since we cannot get IdentityReference from sd..
            // So return sddl..
            return sd.GetSecurityDescriptorSddlForm(AccessControlSections.Owner);
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.Security/security/AclCommands.cs.ifdefed" startline="244" endline="273" pcid="1398">
        public static string GetGroup(PSObject instance)
        {
            if (instance == null)
            {
                throw PSTraceSource.NewArgumentNullException("instance");
            }

            ObjectSecurity sd = instance.BaseObject as ObjectSecurity;
            if (sd == null)
            {
                throw PSTraceSource.NewArgumentNullException("instance");
            }

            //Get Group
            try
            {
                IdentityReference ir = sd.GetGroup(typeof(NTAccount));
                return ir.ToString();
            }
            catch (IdentityNotMappedException)
            {
                // All Acl cmdlets returning SIDs will return a string
                // representation of the SID in all cases where the SID
                // cannot be mapped to a proper user or group name.
            }

            // We are here since we cannot get IdentityReference from sd..
            // So return sddl..
            return sd.GetSecurityDescriptorSddlForm(AccessControlSections.Group);
        }
</source>
</class>

<class classid="39" nclones="2" nlines="19" similarity="73">
<source file="PowerShell/src/Microsoft.PowerShell.Security/security/AclCommands.cs.ifdefed" startline="283" endline="310" pcid="1399">
        public static AuthorizationRuleCollection GetAccess(PSObject instance)
        {
            if (instance == null)
            {
                throw PSTraceSource.NewArgumentNullException("instance");
            }

            ObjectSecurity sd = instance.BaseObject as ObjectSecurity;
            if (sd == null)
            {
                PSTraceSource.NewArgumentException("instance");
            }

            //Get DACL
            AuthorizationRuleCollection dacl;
            CommonObjectSecurity cos = sd as CommonObjectSecurity;
            if (cos != null)
            {
                dacl = cos.GetAccessRules(true, true, typeof(NTAccount));
            }
            else
            {
                DirectoryObjectSecurity dos = sd as DirectoryObjectSecurity;
                Dbg.Diagnostics.Assert(dos != null, "Acl should be of type CommonObjectSecurity or DirectoryObjectSecurity");
                dacl = dos.GetAccessRules(true, true, typeof(NTAccount));
            }
            return dacl;
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.Security/security/AclCommands.cs.ifdefed" startline="321" endline="347" pcid="1400">
        public static AuthorizationRuleCollection GetAudit(PSObject instance)
        {
            if (instance == null)
            {
                throw PSTraceSource.NewArgumentNullException("instance");
            }

            ObjectSecurity sd = instance.BaseObject as ObjectSecurity;
            if (sd == null)
            {
                PSTraceSource.NewArgumentException("instance");
            }

            AuthorizationRuleCollection sacl;
            CommonObjectSecurity cos = sd as CommonObjectSecurity;
            if (cos != null)
            {
                sacl = cos.GetAuditRules(true, true, typeof(NTAccount));
            }
            else
            {
                DirectoryObjectSecurity dos = sd as DirectoryObjectSecurity;
                Dbg.Diagnostics.Assert(dos != null, "Acl should be of type CommonObjectSecurity or DirectoryObjectSecurity");
                sacl = dos.GetAuditRules(true, true, typeof(NTAccount));
            }
            return sacl;
        }
</source>
</class>

<class classid="40" nclones="3" nlines="17" similarity="83">
<source file="PowerShell/src/Microsoft.PowerShell.Security/security/CmsCommands.cs.ifdefed" startline="84" endline="119" pcid="1405">
        protected override void BeginProcessing()
        {
            // Validate Path
            if (!String.IsNullOrEmpty(Path))
            {
                ProviderInfo provider = null;
                Collection<string> resolvedPaths = GetResolvedProviderPathFromPSPath(Path, out provider);

                // Ensure the path is a single path from the file system provider
                if ((resolvedPaths.Count > 1) ||
                    (!String.Equals(provider.Name, "FileSystem", StringComparison.OrdinalIgnoreCase)))
                {
                    ErrorRecord error = new ErrorRecord(
                        new ArgumentException(
                            String.Format(CultureInfo.InvariantCulture,
                                CmsCommands.FilePathMustBeFileSystemPath, Path)),
                        "FilePathMustBeFileSystemPath", ErrorCategory.ObjectNotFound, provider);
                    ThrowTerminatingError(error);
                }

                _resolvedPath = resolvedPaths[0];
            }

            if (!String.IsNullOrEmpty(LiteralPath))
            {
                // Validate that the path exists
                SessionState.InvokeProvider.Item.Get(new string[] { LiteralPath }, false, true);
                _resolvedPath = LiteralPath;
            }

            // Validate OutFile
            if (!String.IsNullOrEmpty(OutFile))
            {
                _resolvedOutFile = GetUnresolvedProviderPathFromPSPath(OutFile);
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.Security/security/CmsCommands.cs.ifdefed" startline="233" endline="262" pcid="1408">
        protected override void BeginProcessing()
        {
            // Validate Path
            if (!String.IsNullOrEmpty(Path))
            {
                ProviderInfo provider = null;
                Collection<string> resolvedPaths = GetResolvedProviderPathFromPSPath(Path, out provider);

                // Ensure the path is a single path from the file system provider
                if ((resolvedPaths.Count > 1) ||
                    (!String.Equals(provider.Name, "FileSystem", StringComparison.OrdinalIgnoreCase)))
                {
                    ErrorRecord error = new ErrorRecord(
                        new ArgumentException(
                            String.Format(CultureInfo.InvariantCulture,
                                CmsCommands.FilePathMustBeFileSystemPath, Path)),
                        "FilePathMustBeFileSystemPath", ErrorCategory.ObjectNotFound, provider);
                    ThrowTerminatingError(error);
                }

                _resolvedPath = resolvedPaths[0];
            }

            if (!String.IsNullOrEmpty(LiteralPath))
            {
                // Validate that the path exists
                SessionState.InvokeProvider.Item.Get(new string[] { LiteralPath }, false, true);
                _resolvedPath = LiteralPath;
            }
        }
</source>
<source file="PowerShell/src/Microsoft.PowerShell.Security/security/CmsCommands.cs.ifdefed" startline="408" endline="437" pcid="1411">
        protected override void BeginProcessing()
        {
            // Validate Path
            if (!String.IsNullOrEmpty(Path))
            {
                ProviderInfo provider = null;
                Collection<string> resolvedPaths = GetResolvedProviderPathFromPSPath(Path, out provider);

                // Ensure the path is a single path from the file system provider
                if ((resolvedPaths.Count > 1) ||
                    (!String.Equals(provider.Name, "FileSystem", StringComparison.OrdinalIgnoreCase)))
                {
                    ErrorRecord error = new ErrorRecord(
                        new ArgumentException(
                            String.Format(CultureInfo.InvariantCulture,
                                CmsCommands.FilePathMustBeFileSystemPath, Path)),
                        "FilePathMustBeFileSystemPath", ErrorCategory.ObjectNotFound, provider);
                    ThrowTerminatingError(error);
                }

                _resolvedPath = resolvedPaths[0];
            }

            if (!String.IsNullOrEmpty(LiteralPath))
            {
                // Validate that the path exists
                SessionState.InvokeProvider.Item.Get(new string[] { LiteralPath }, false, true);
                _resolvedPath = LiteralPath;
            }
        }
</source>
</class>

<class classid="41" nclones="2" nlines="16" similarity="81">
<source file="PowerShell/src/Microsoft.WSMan.Management/CredSSP.cs.ifdefed" startline="229" endline="247" pcid="1440">
        private void DeleteUserDelegateSettings()
        {
            System.IntPtr KeyHandle = System.IntPtr.Zero;
            IGroupPolicyObject GPO = (IGroupPolicyObject)new GPClass();
            GPO.OpenLocalMachineGPO(1);
            KeyHandle = GPO.GetRegistryKey(2);
            RegistryKey rootKey = Registry.CurrentUser;
            string GPOpath = @"SOFTWARE\Microsoft\Windows\CurrentVersion\Group Policy Objects";
            RegistryKey GPOKey = rootKey.OpenSubKey(GPOpath, true);
            foreach (string keyname in GPOKey.GetSubKeyNames())
            {
                if (keyname.EndsWith("Machine", StringComparison.OrdinalIgnoreCase))
                {
                    string key = GPOpath + "\\" + keyname + "\\" + @"Software\Policies\Microsoft\Windows";
                    DeleteDelegateSettings(applicationname, Registry.CurrentUser, key, GPO);
                }
            }
            KeyHandle = System.IntPtr.Zero;
        }
</source>
<source file="PowerShell/src/Microsoft.WSMan.Management/CredSSP.cs.ifdefed" startline="683" endline="703" pcid="1448">
        private void UpdateCurrentUserRegistrySettings()
        {
            System.IntPtr KeyHandle = System.IntPtr.Zero;
            IGroupPolicyObject GPO = (IGroupPolicyObject)new GPClass();
            GPO.OpenLocalMachineGPO(1);
            KeyHandle = GPO.GetRegistryKey(2);
            RegistryKey rootKey = Registry.CurrentUser;
            string GPOpath = @"SOFTWARE\Microsoft\Windows\CurrentVersion\Group Policy Objects";
            RegistryKey GPOKey = rootKey.OpenSubKey(GPOpath, true);
            foreach (string keyname in GPOKey.GetSubKeyNames())
            {
                if (keyname.EndsWith("Machine", StringComparison.OrdinalIgnoreCase))
                {
                    string key = GPOpath + "\\" + keyname + "\\" + @"Software\Policies\Microsoft\Windows";
                    UpdateGPORegistrySettings(applicationname, this.delegatecomputer, Registry.CurrentUser, key);

                }
            }
            //saving gpo settings
            GPO.Save(true, true, new Guid("35378EAC-683F-11D2-A89A-00C04FBBCFA2"), new Guid("7A9206BD-33AF-47af-B832-D4128730E990"));
        }
</source>
</class>

<class classid="42" nclones="23" nlines="20" similarity="71">
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="475" endline="498" pcid="1593">
        private void Write49_EnumMetadataEnumValue(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(@"EnumMetadataEnumValue", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            WriteAttribute(@"Name", @"", ((global::System.String)o.@Name));
            WriteAttribute(@"Value", @"", ((global::System.String)o.@Value));
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="2355" endline="2379" pcid="1632">
        private void Write31_InstanceCmdletMetadata(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.InstanceCmdletMetadata o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.InstanceCmdletMetadata))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(@"InstanceCmdletMetadata", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            Write21_CommonCmdletMetadata(@"CmdletMetadata", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CommonCmdletMetadata)o.@CmdletMetadata), false, false);
            Write30_InstanceMethodMetadata(@"Method", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.InstanceMethodMetadata)o.@Method), false, false);
            Write19_GetCmdletParameters(@"GetCmdletParameters", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.GetCmdletParameters)o.@GetCmdletParameters), false, false);
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="766" endline="789" pcid="1601">
        private void Write6_Item(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateRange o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateRange))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(null, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            WriteAttribute(@"Min", @"", ((global::System.String)o.@Min));
            WriteAttribute(@"Max", @"", ((global::System.String)o.@Max));
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="1852" endline="1875" pcid="1621">
        private void Write16_AssociationAssociatedInstance(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.AssociationAssociatedInstance o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.AssociationAssociatedInstance))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(null, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            Write2_TypeMetadata(@"Type", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.TypeMetadata)o.@Type), false, false);
            Write12_Item(@"CmdletParameterMetadata", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForGetCmdletFilteringParameter)o.@CmdletParameterMetadata), false, false);
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="1509" endline="1532" pcid="1613">
        private void Write24_Item(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.CommonMethodMetadataReturnValue o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.CommonMethodMetadataReturnValue))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(null, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            Write2_TypeMetadata(@"Type", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.TypeMetadata)o.@Type), false, false);
            Write23_CmdletOutputMetadata(@"CmdletOutputMetadata", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CmdletOutputMetadata)o.@CmdletOutputMetadata), false, false);
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="2604" endline="2627" pcid="1640">
        private void Write46_Item(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.CommonMethodMetadataReturnValue o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.CommonMethodMetadataReturnValue))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(@"CommonMethodMetadataReturnValue", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            Write2_TypeMetadata(@"Type", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.TypeMetadata)o.@Type), false, false);
            Write23_CmdletOutputMetadata(@"CmdletOutputMetadata", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CmdletOutputMetadata)o.@CmdletOutputMetadata), false, false);
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="2504" endline="2527" pcid="1636">
        private void Write41_AssociationAssociatedInstance(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.AssociationAssociatedInstance o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.AssociationAssociatedInstance))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(@"AssociationAssociatedInstance", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            Write2_TypeMetadata(@"Type", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.TypeMetadata)o.@Type), false, false);
            Write12_Item(@"CmdletParameterMetadata", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForGetCmdletFilteringParameter)o.@CmdletParameterMetadata), false, false);
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="816" endline="839" pcid="1603">
        private void Write4_Item(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateCount o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateCount))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(null, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            WriteAttribute(@"Min", @"", ((global::System.String)o.@Min));
            WriteAttribute(@"Max", @"", ((global::System.String)o.@Max));
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="1484" endline="1507" pcid="1612">
        private void Write2_TypeMetadata(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.TypeMetadata o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.TypeMetadata))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(@"TypeMetadata", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            WriteAttribute(@"PSType", @"", ((global::System.String)o.@PSType));
            WriteAttribute(@"ETSType", @"", ((global::System.String)o.@ETSType));
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="1378" endline="1401" pcid="1610">
        private void Write23_CmdletOutputMetadata(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.CmdletOutputMetadata o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.CmdletOutputMetadata))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(@"CmdletOutputMetadata", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            WriteAttribute(@"PSName", @"", ((global::System.String)o.@PSName));
            Write1_Object(@"ErrorCode", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.Object)o.@ErrorCode), false, false);
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="2222" endline="2245" pcid="1628">
        private void Write22_GetCmdletMetadata(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.GetCmdletMetadata o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.GetCmdletMetadata))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(@"GetCmdletMetadata", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            Write21_CommonCmdletMetadata(@"CmdletMetadata", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CommonCmdletMetadata)o.@CmdletMetadata), false, false);
            Write19_GetCmdletParameters(@"GetCmdletParameters", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.GetCmdletParameters)o.@GetCmdletParameters), false, false);
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="1250" endline="1276" pcid="1606">
        private void Write35_ClassMetadataData(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.ClassMetadataData o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.ClassMetadataData))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(null, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            WriteAttribute(@"Name", @"", ((global::System.String)o.@Name));
            if ((object)(o.@Value) != null)
            {
                WriteValue(((global::System.String)o.@Value));
            }
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="791" endline="814" pcid="1602">
        private void Write5_Item(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateLength o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateLength))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(null, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            WriteAttribute(@"Min", @"", ((global::System.String)o.@Min));
            WriteAttribute(@"Max", @"", ((global::System.String)o.@Max));
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="2529" endline="2552" pcid="1637">
        private void Write42_Item(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateCount o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateCount))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(@"CmdletParameterMetadataValidateCount", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            WriteAttribute(@"Min", @"", ((global::System.String)o.@Min));
            WriteAttribute(@"Max", @"", ((global::System.String)o.@Max));
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="2579" endline="2602" pcid="1639">
        private void Write44_Item(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateRange o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateRange))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(@"CmdletParameterMetadataValidateRange", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            WriteAttribute(@"Min", @"", ((global::System.String)o.@Min));
            WriteAttribute(@"Max", @"", ((global::System.String)o.@Max));
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="542" endline="565" pcid="1595">
        private void Write37_EnumMetadataEnumValue(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(null, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            WriteAttribute(@"Name", @"", ((global::System.String)o.@Name));
            WriteAttribute(@"Value", @"", ((global::System.String)o.@Value));
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="1699" endline="1723" pcid="1618">
        private void Write18_QueryOption(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.QueryOption o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.QueryOption))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(@"QueryOption", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            WriteAttribute(@"OptionName", @"", ((global::System.String)o.@OptionName));
            Write2_TypeMetadata(@"Type", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.TypeMetadata)o.@Type), false, false);
            Write11_Item(@"CmdletParameterMetadata", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForGetCmdletParameter)o.@CmdletParameterMetadata), false, false);
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="2554" endline="2577" pcid="1638">
        private void Write43_Item(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateLength o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateLength))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(@"CmdletParameterMetadataValidateLength", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            WriteAttribute(@"Min", @"", ((global::System.String)o.@Min));
            WriteAttribute(@"Max", @"", ((global::System.String)o.@Max));
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="567" endline="593" pcid="1596">
        private void Write47_ClassMetadataData(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.ClassMetadataData o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.ClassMetadataData))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(@"ClassMetadataData", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            WriteAttribute(@"Name", @"", ((global::System.String)o.@Name));
            if ((object)(o.@Value) != null)
            {
                WriteValue(((global::System.String)o.@Value));
            }
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="742" endline="764" pcid="1600">
        private void Write7_ObsoleteAttributeMetadata(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.ObsoleteAttributeMetadata o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.ObsoleteAttributeMetadata))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(@"ObsoleteAttributeMetadata", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            WriteAttribute(@"Message", @"", ((global::System.String)o.@Message));
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="1944" endline="1971" pcid="1623">
        private void Write14_PropertyQuery(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.PropertyQuery o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.PropertyQuery))
                {
                }
                else if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.WildcardablePropertyQuery))
                {
                    Write13_WildcardablePropertyQuery(n, ns, (global::Microsoft.PowerShell.Cmdletization.Xml.WildcardablePropertyQuery)o, isNullable, true);
                    return;
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(@"PropertyQuery", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            Write12_Item(@"CmdletParameterMetadata", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForGetCmdletFilteringParameter)o.@CmdletParameterMetadata), false, false);
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="1350" endline="1376" pcid="1609">
        private void Write27_StaticMethodParameterMetadata(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.StaticMethodParameterMetadata o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.StaticMethodParameterMetadata))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(@"StaticMethodParameterMetadata", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            WriteAttribute(@"ParameterName", @"", ((global::System.String)o.@ParameterName));
            WriteAttribute(@"DefaultValue", @"", ((global::System.String)o.@DefaultValue));
            Write2_TypeMetadata(@"Type", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.TypeMetadata)o.@Type), false, false);
            Write8_Item(@"CmdletParameterMetadata", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForStaticMethodParameter)o.@CmdletParameterMetadata), false, false);
            Write23_CmdletOutputMetadata(@"CmdletOutputMetadata", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CmdletOutputMetadata)o.@CmdletOutputMetadata), false, false);
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="1597" endline="1623" pcid="1616">
        private void Write25_Item(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.InstanceMethodParameterMetadata o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.InstanceMethodParameterMetadata))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(@"InstanceMethodParameterMetadata", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            WriteAttribute(@"ParameterName", @"", ((global::System.String)o.@ParameterName));
            WriteAttribute(@"DefaultValue", @"", ((global::System.String)o.@DefaultValue));
            Write2_TypeMetadata(@"Type", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.TypeMetadata)o.@Type), false, false);
            Write9_Item(@"CmdletParameterMetadata", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForInstanceMethodParameter)o.@CmdletParameterMetadata), false, false);
            Write23_CmdletOutputMetadata(@"CmdletOutputMetadata", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CmdletOutputMetadata)o.@CmdletOutputMetadata), false, false);
            WriteEndElement(o);
        }
</source>
</class>

<class classid="43" nclones="2" nlines="32" similarity="93">
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="500" endline="540" pcid="1594">
        private void Write48_EnumMetadataEnum(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnum o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnum))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(@"EnumMetadataEnum", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            WriteAttribute(@"EnumName", @"", ((global::System.String)o.@EnumName));
            WriteAttribute(@"UnderlyingType", @"", ((global::System.String)o.@UnderlyingType));
            if (o.@BitwiseFlagsSpecified)
            {
                WriteAttribute(@"BitwiseFlags", @"", System.Xml.XmlConvert.ToString((global::System.Boolean)((global::System.Boolean)o.@BitwiseFlags)));
            }
            {
                global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue[] a = (global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue[])o.@Value;
                if (a != null)
                {
                    for (int ia = 0; ia < a.Length; ia++)
                    {
                        Write37_EnumMetadataEnumValue(@"Value", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue)a[ia]), false, false);
                    }
                }
            }
            if (o.@BitwiseFlagsSpecified)
            {
            }
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="1208" endline="1248" pcid="1605">
        private void Write38_EnumMetadataEnum(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnum o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnum))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(null, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            WriteAttribute(@"EnumName", @"", ((global::System.String)o.@EnumName));
            WriteAttribute(@"UnderlyingType", @"", ((global::System.String)o.@UnderlyingType));
            if (o.@BitwiseFlagsSpecified)
            {
                WriteAttribute(@"BitwiseFlags", @"", System.Xml.XmlConvert.ToString((global::System.Boolean)((global::System.Boolean)o.@BitwiseFlags)));
            }
            {
                global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue[] a = (global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue[])o.@Value;
                if (a != null)
                {
                    for (int ia = 0; ia < a.Length; ia++)
                    {
                        Write37_EnumMetadataEnumValue(@"Value", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue)a[ia]), false, false);
                    }
                }
            }
            if (o.@BitwiseFlagsSpecified)
            {
            }
            WriteEndElement(o);
        }
</source>
</class>

<class classid="44" nclones="5" nlines="71" similarity="75">
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="640" endline="740" pcid="1599">
        private void Write12_Item(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForGetCmdletFilteringParameter o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForGetCmdletFilteringParameter))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(@"CmdletParameterMetadataForGetCmdletFilteringParameter", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            if (o.@IsMandatorySpecified)
            {
                WriteAttribute(@"IsMandatory", @"", System.Xml.XmlConvert.ToString((global::System.Boolean)((global::System.Boolean)o.@IsMandatory)));
            }
            {
                global::System.String[] a = (global::System.String[])o.@Aliases;
                if (a != null)
                {
                    Writer.WriteStartAttribute(null, @"Aliases", string.Empty);
                    for (int i = 0; i < a.Length; i++)
                    {
                        global::System.String ai = (global::System.String)a[i];
                        if (i != 0) Writer.WriteString(" ");
                        WriteValue(ai);
                    }
                    Writer.WriteEndAttribute();
                }
            }
            WriteAttribute(@"PSName", @"", ((global::System.String)o.@PSName));
            WriteAttribute(@"Position", @"", ((global::System.String)o.@Position));
            if (o.@ValueFromPipelineSpecified)
            {
                WriteAttribute(@"ValueFromPipeline", @"", System.Xml.XmlConvert.ToString((global::System.Boolean)((global::System.Boolean)o.@ValueFromPipeline)));
            }
            if (o.@ValueFromPipelineByPropertyNameSpecified)
            {
                WriteAttribute(@"ValueFromPipelineByPropertyName", @"", System.Xml.XmlConvert.ToString((global::System.Boolean)((global::System.Boolean)o.@ValueFromPipelineByPropertyName)));
            }
            {
                global::System.String[] a = (global::System.String[])o.@CmdletParameterSets;
                if (a != null)
                {
                    Writer.WriteStartAttribute(null, @"CmdletParameterSets", string.Empty);
                    for (int i = 0; i < a.Length; i++)
                    {
                        global::System.String ai = (global::System.String)a[i];
                        if (i != 0) Writer.WriteString(" ");
                        WriteValue(ai);
                    }
                    Writer.WriteEndAttribute();
                }
            }
            if (o.@ErrorOnNoMatchSpecified)
            {
                WriteAttribute(@"ErrorOnNoMatch", @"", System.Xml.XmlConvert.ToString((global::System.Boolean)((global::System.Boolean)o.@ErrorOnNoMatch)));
            }
            Write1_Object(@"AllowEmptyCollection", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.Object)o.@AllowEmptyCollection), false, false);
            Write1_Object(@"AllowEmptyString", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.Object)o.@AllowEmptyString), false, false);
            Write1_Object(@"AllowNull", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.Object)o.@AllowNull), false, false);
            Write1_Object(@"ValidateNotNull", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.Object)o.@ValidateNotNull), false, false);
            Write1_Object(@"ValidateNotNullOrEmpty", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.Object)o.@ValidateNotNullOrEmpty), false, false);
            Write4_Item(@"ValidateCount", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateCount)o.@ValidateCount), false, false);
            Write5_Item(@"ValidateLength", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateLength)o.@ValidateLength), false, false);
            Write6_Item(@"ValidateRange", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateRange)o.@ValidateRange), false, false);
            {
                global::System.String[] a = (global::System.String[])((global::System.String[])o.@ValidateSet);
                if (a != null)
                {
                    WriteStartElement(@"ValidateSet", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", null, false);
                    for (int ia = 0; ia < a.Length; ia++)
                    {
                        WriteElementString(@"AllowedValue", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.String)a[ia]));
                    }
                    WriteEndElement();
                }
            }
            Write7_ObsoleteAttributeMetadata(@"Obsolete", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.ObsoleteAttributeMetadata)o.@Obsolete), false, false);
            if (o.@IsMandatorySpecified)
            {
            }
            if (o.@ValueFromPipelineSpecified)
            {
            }
            if (o.@ValueFromPipelineByPropertyNameSpecified)
            {
            }
            if (o.@ErrorOnNoMatchSpecified)
            {
            }
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="1403" endline="1482" pcid="1611">
        private void Write8_Item(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForStaticMethodParameter o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForStaticMethodParameter))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(@"CmdletParameterMetadataForStaticMethodParameter", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            if (o.@IsMandatorySpecified)
            {
                WriteAttribute(@"IsMandatory", @"", System.Xml.XmlConvert.ToString((global::System.Boolean)((global::System.Boolean)o.@IsMandatory)));
            }
            {
                global::System.String[] a = (global::System.String[])o.@Aliases;
                if (a != null)
                {
                    Writer.WriteStartAttribute(null, @"Aliases", string.Empty);
                    for (int i = 0; i < a.Length; i++)
                    {
                        global::System.String ai = (global::System.String)a[i];
                        if (i != 0) Writer.WriteString(" ");
                        WriteValue(ai);
                    }
                    Writer.WriteEndAttribute();
                }
            }
            WriteAttribute(@"PSName", @"", ((global::System.String)o.@PSName));
            WriteAttribute(@"Position", @"", ((global::System.String)o.@Position));
            if (o.@ValueFromPipelineSpecified)
            {
                WriteAttribute(@"ValueFromPipeline", @"", System.Xml.XmlConvert.ToString((global::System.Boolean)((global::System.Boolean)o.@ValueFromPipeline)));
            }
            if (o.@ValueFromPipelineByPropertyNameSpecified)
            {
                WriteAttribute(@"ValueFromPipelineByPropertyName", @"", System.Xml.XmlConvert.ToString((global::System.Boolean)((global::System.Boolean)o.@ValueFromPipelineByPropertyName)));
            }
            Write1_Object(@"AllowEmptyCollection", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.Object)o.@AllowEmptyCollection), false, false);
            Write1_Object(@"AllowEmptyString", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.Object)o.@AllowEmptyString), false, false);
            Write1_Object(@"AllowNull", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.Object)o.@AllowNull), false, false);
            Write1_Object(@"ValidateNotNull", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.Object)o.@ValidateNotNull), false, false);
            Write1_Object(@"ValidateNotNullOrEmpty", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.Object)o.@ValidateNotNullOrEmpty), false, false);
            Write4_Item(@"ValidateCount", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateCount)o.@ValidateCount), false, false);
            Write5_Item(@"ValidateLength", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateLength)o.@ValidateLength), false, false);
            Write6_Item(@"ValidateRange", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateRange)o.@ValidateRange), false, false);
            {
                global::System.String[] a = (global::System.String[])((global::System.String[])o.@ValidateSet);
                if (a != null)
                {
                    WriteStartElement(@"ValidateSet", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", null, false);
                    for (int ia = 0; ia < a.Length; ia++)
                    {
                        WriteElementString(@"AllowedValue", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.String)a[ia]));
                    }
                    WriteEndElement();
                }
            }
            Write7_ObsoleteAttributeMetadata(@"Obsolete", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.ObsoleteAttributeMetadata)o.@Obsolete), false, false);
            if (o.@IsMandatorySpecified)
            {
            }
            if (o.@ValueFromPipelineSpecified)
            {
            }
            if (o.@ValueFromPipelineByPropertyNameSpecified)
            {
            }
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="1725" endline="1823" pcid="1619">
        private void Write11_Item(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForGetCmdletParameter o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForGetCmdletParameter))
                {
                }
                else if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForGetCmdletFilteringParameter))
                {
                    Write12_Item(n, ns, (global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForGetCmdletFilteringParameter)o, isNullable, true);
                    return;
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(@"CmdletParameterMetadataForGetCmdletParameter", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            if (o.@IsMandatorySpecified)
            {
                WriteAttribute(@"IsMandatory", @"", System.Xml.XmlConvert.ToString((global::System.Boolean)((global::System.Boolean)o.@IsMandatory)));
            }
            {
                global::System.String[] a = (global::System.String[])o.@Aliases;
                if (a != null)
                {
                    Writer.WriteStartAttribute(null, @"Aliases", string.Empty);
                    for (int i = 0; i < a.Length; i++)
                    {
                        global::System.String ai = (global::System.String)a[i];
                        if (i != 0) Writer.WriteString(" ");
                        WriteValue(ai);
                    }
                    Writer.WriteEndAttribute();
                }
            }
            WriteAttribute(@"PSName", @"", ((global::System.String)o.@PSName));
            WriteAttribute(@"Position", @"", ((global::System.String)o.@Position));
            if (o.@ValueFromPipelineSpecified)
            {
                WriteAttribute(@"ValueFromPipeline", @"", System.Xml.XmlConvert.ToString((global::System.Boolean)((global::System.Boolean)o.@ValueFromPipeline)));
            }
            if (o.@ValueFromPipelineByPropertyNameSpecified)
            {
                WriteAttribute(@"ValueFromPipelineByPropertyName", @"", System.Xml.XmlConvert.ToString((global::System.Boolean)((global::System.Boolean)o.@ValueFromPipelineByPropertyName)));
            }
            {
                global::System.String[] a = (global::System.String[])o.@CmdletParameterSets;
                if (a != null)
                {
                    Writer.WriteStartAttribute(null, @"CmdletParameterSets", string.Empty);
                    for (int i = 0; i < a.Length; i++)
                    {
                        global::System.String ai = (global::System.String)a[i];
                        if (i != 0) Writer.WriteString(" ");
                        WriteValue(ai);
                    }
                    Writer.WriteEndAttribute();
                }
            }
            Write1_Object(@"AllowEmptyCollection", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.Object)o.@AllowEmptyCollection), false, false);
            Write1_Object(@"AllowEmptyString", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.Object)o.@AllowEmptyString), false, false);
            Write1_Object(@"AllowNull", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.Object)o.@AllowNull), false, false);
            Write1_Object(@"ValidateNotNull", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.Object)o.@ValidateNotNull), false, false);
            Write1_Object(@"ValidateNotNullOrEmpty", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.Object)o.@ValidateNotNullOrEmpty), false, false);
            Write4_Item(@"ValidateCount", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateCount)o.@ValidateCount), false, false);
            Write5_Item(@"ValidateLength", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateLength)o.@ValidateLength), false, false);
            Write6_Item(@"ValidateRange", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateRange)o.@ValidateRange), false, false);
            {
                global::System.String[] a = (global::System.String[])((global::System.String[])o.@ValidateSet);
                if (a != null)
                {
                    WriteStartElement(@"ValidateSet", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", null, false);
                    for (int ia = 0; ia < a.Length; ia++)
                    {
                        WriteElementString(@"AllowedValue", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.String)a[ia]));
                    }
                    WriteEndElement();
                }
            }
            Write7_ObsoleteAttributeMetadata(@"Obsolete", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.ObsoleteAttributeMetadata)o.@Obsolete), false, false);
            if (o.@IsMandatorySpecified)
            {
            }
            if (o.@ValueFromPipelineSpecified)
            {
            }
            if (o.@ValueFromPipelineByPropertyNameSpecified)
            {
            }
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="1625" endline="1697" pcid="1617">
        private void Write9_Item(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForInstanceMethodParameter o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForInstanceMethodParameter))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(@"CmdletParameterMetadataForInstanceMethodParameter", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            if (o.@IsMandatorySpecified)
            {
                WriteAttribute(@"IsMandatory", @"", System.Xml.XmlConvert.ToString((global::System.Boolean)((global::System.Boolean)o.@IsMandatory)));
            }
            {
                global::System.String[] a = (global::System.String[])o.@Aliases;
                if (a != null)
                {
                    Writer.WriteStartAttribute(null, @"Aliases", string.Empty);
                    for (int i = 0; i < a.Length; i++)
                    {
                        global::System.String ai = (global::System.String)a[i];
                        if (i != 0) Writer.WriteString(" ");
                        WriteValue(ai);
                    }
                    Writer.WriteEndAttribute();
                }
            }
            WriteAttribute(@"PSName", @"", ((global::System.String)o.@PSName));
            WriteAttribute(@"Position", @"", ((global::System.String)o.@Position));
            if (o.@ValueFromPipelineByPropertyNameSpecified)
            {
                WriteAttribute(@"ValueFromPipelineByPropertyName", @"", System.Xml.XmlConvert.ToString((global::System.Boolean)((global::System.Boolean)o.@ValueFromPipelineByPropertyName)));
            }
            Write1_Object(@"AllowEmptyCollection", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.Object)o.@AllowEmptyCollection), false, false);
            Write1_Object(@"AllowEmptyString", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.Object)o.@AllowEmptyString), false, false);
            Write1_Object(@"AllowNull", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.Object)o.@AllowNull), false, false);
            Write1_Object(@"ValidateNotNull", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.Object)o.@ValidateNotNull), false, false);
            Write1_Object(@"ValidateNotNullOrEmpty", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.Object)o.@ValidateNotNullOrEmpty), false, false);
            Write4_Item(@"ValidateCount", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateCount)o.@ValidateCount), false, false);
            Write5_Item(@"ValidateLength", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateLength)o.@ValidateLength), false, false);
            Write6_Item(@"ValidateRange", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateRange)o.@ValidateRange), false, false);
            {
                global::System.String[] a = (global::System.String[])((global::System.String[])o.@ValidateSet);
                if (a != null)
                {
                    WriteStartElement(@"ValidateSet", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", null, false);
                    for (int ia = 0; ia < a.Length; ia++)
                    {
                        WriteElementString(@"AllowedValue", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.String)a[ia]));
                    }
                    WriteEndElement();
                }
            }
            Write7_ObsoleteAttributeMetadata(@"Obsolete", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.ObsoleteAttributeMetadata)o.@Obsolete), false, false);
            if (o.@IsMandatorySpecified)
            {
            }
            if (o.@ValueFromPipelineByPropertyNameSpecified)
            {
            }
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="1973" endline="2058" pcid="1624">
        private void Write10_CmdletParameterMetadata(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadata o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadata))
                {
                }
                else if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForGetCmdletParameter))
                {
                    Write11_Item(n, ns, (global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForGetCmdletParameter)o, isNullable, true);
                    return;
                }
                else if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForGetCmdletFilteringParameter))
                {
                    Write12_Item(n, ns, (global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForGetCmdletFilteringParameter)o, isNullable, true);
                    return;
                }
                else if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForInstanceMethodParameter))
                {
                    Write9_Item(n, ns, (global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForInstanceMethodParameter)o, isNullable, true);
                    return;
                }
                else if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForStaticMethodParameter))
                {
                    Write8_Item(n, ns, (global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForStaticMethodParameter)o, isNullable, true);
                    return;
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(@"CmdletParameterMetadata", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            if (o.@IsMandatorySpecified)
            {
                WriteAttribute(@"IsMandatory", @"", System.Xml.XmlConvert.ToString((global::System.Boolean)((global::System.Boolean)o.@IsMandatory)));
            }
            {
                global::System.String[] a = (global::System.String[])o.@Aliases;
                if (a != null)
                {
                    Writer.WriteStartAttribute(null, @"Aliases", string.Empty);
                    for (int i = 0; i < a.Length; i++)
                    {
                        global::System.String ai = (global::System.String)a[i];
                        if (i != 0) Writer.WriteString(" ");
                        WriteValue(ai);
                    }
                    Writer.WriteEndAttribute();
                }
            }
            WriteAttribute(@"PSName", @"", ((global::System.String)o.@PSName));
            WriteAttribute(@"Position", @"", ((global::System.String)o.@Position));
            Write1_Object(@"AllowEmptyCollection", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.Object)o.@AllowEmptyCollection), false, false);
            Write1_Object(@"AllowEmptyString", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.Object)o.@AllowEmptyString), false, false);
            Write1_Object(@"AllowNull", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.Object)o.@AllowNull), false, false);
            Write1_Object(@"ValidateNotNull", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.Object)o.@ValidateNotNull), false, false);
            Write1_Object(@"ValidateNotNullOrEmpty", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.Object)o.@ValidateNotNullOrEmpty), false, false);
            Write4_Item(@"ValidateCount", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateCount)o.@ValidateCount), false, false);
            Write5_Item(@"ValidateLength", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateLength)o.@ValidateLength), false, false);
            Write6_Item(@"ValidateRange", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateRange)o.@ValidateRange), false, false);
            {
                global::System.String[] a = (global::System.String[])((global::System.String[])o.@ValidateSet);
                if (a != null)
                {
                    WriteStartElement(@"ValidateSet", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", null, false);
                    for (int ia = 0; ia < a.Length; ia++)
                    {
                        WriteElementString(@"AllowedValue", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::System.String)a[ia]));
                    }
                    WriteEndElement();
                }
            }
            Write7_ObsoleteAttributeMetadata(@"Obsolete", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.ObsoleteAttributeMetadata)o.@Obsolete), false, false);
            if (o.@IsMandatorySpecified)
            {
            }
            WriteEndElement(o);
        }
</source>
</class>

<class classid="45" nclones="6" nlines="28" similarity="70">
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="1278" endline="1310" pcid="1607">
        private void Write34_StaticCmdletMetadata(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.StaticCmdletMetadata o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.StaticCmdletMetadata))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(@"StaticCmdletMetadata", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            Write33_Item(@"CmdletMetadata", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.StaticCmdletMetadataCmdletMetadata)o.@CmdletMetadata), false, false);
            {
                global::Microsoft.PowerShell.Cmdletization.Xml.StaticMethodMetadata[] a = (global::Microsoft.PowerShell.Cmdletization.Xml.StaticMethodMetadata[])o.@Method;
                if (a != null)
                {
                    for (int ia = 0; ia < a.Length; ia++)
                    {
                        Write28_StaticMethodMetadata(@"Method", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.StaticMethodMetadata)a[ia]), false, false);
                    }
                }
            }
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="2469" endline="2502" pcid="1635">
        private void Write40_ClassMetadataInstanceCmdlets(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.ClassMetadataInstanceCmdlets o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.ClassMetadataInstanceCmdlets))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(@"ClassMetadataInstanceCmdlets", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            Write19_GetCmdletParameters(@"GetCmdletParameters", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.GetCmdletParameters)o.@GetCmdletParameters), false, false);
            Write22_GetCmdletMetadata(@"GetCmdlet", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.GetCmdletMetadata)o.@GetCmdlet), false, false);
            {
                global::Microsoft.PowerShell.Cmdletization.Xml.InstanceCmdletMetadata[] a = (global::Microsoft.PowerShell.Cmdletization.Xml.InstanceCmdletMetadata[])o.@Cmdlet;
                if (a != null)
                {
                    for (int ia = 0; ia < a.Length; ia++)
                    {
                        Write31_InstanceCmdletMetadata(@"Cmdlet", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.InstanceCmdletMetadata)a[ia]), false, false);
                    }
                }
            }
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="2434" endline="2467" pcid="1634">
        private void Write32_ClassMetadataInstanceCmdlets(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.ClassMetadataInstanceCmdlets o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.ClassMetadataInstanceCmdlets))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(null, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            Write19_GetCmdletParameters(@"GetCmdletParameters", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.GetCmdletParameters)o.@GetCmdletParameters), false, false);
            Write22_GetCmdletMetadata(@"GetCmdlet", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.GetCmdletMetadata)o.@GetCmdlet), false, false);
            {
                global::Microsoft.PowerShell.Cmdletization.Xml.InstanceCmdletMetadata[] a = (global::Microsoft.PowerShell.Cmdletization.Xml.InstanceCmdletMetadata[])o.@Cmdlet;
                if (a != null)
                {
                    for (int ia = 0; ia < a.Length; ia++)
                    {
                        Write31_InstanceCmdletMetadata(@"Cmdlet", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.InstanceCmdletMetadata)a[ia]), false, false);
                    }
                }
            }
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="2629" endline="2663" pcid="1641">
        private void Write39_PowerShellMetadata(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.PowerShellMetadata o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.PowerShellMetadata))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(null, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            Write36_ClassMetadata(@"Class", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.ClassMetadata)o.@Class), false, false);
            {
                global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnum[] a = (global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnum[])((global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnum[])o.@Enums);
                if (a != null)
                {
                    WriteStartElement(@"Enums", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", null, false);
                    for (int ia = 0; ia < a.Length; ia++)
                    {
                        Write38_EnumMetadataEnum(@"Enum", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnum)a[ia]), false, false);
                    }
                    WriteEndElement();
                }
            }
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="2247" endline="2282" pcid="1629">
        private void Write30_InstanceMethodMetadata(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.InstanceMethodMetadata o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.InstanceMethodMetadata))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(@"InstanceMethodMetadata", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            WriteAttribute(@"MethodName", @"", ((global::System.String)o.@MethodName));
            Write24_Item(@"ReturnValue", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CommonMethodMetadataReturnValue)o.@ReturnValue), false, false);
            {
                global::Microsoft.PowerShell.Cmdletization.Xml.InstanceMethodParameterMetadata[] a = (global::Microsoft.PowerShell.Cmdletization.Xml.InstanceMethodParameterMetadata[])((global::Microsoft.PowerShell.Cmdletization.Xml.InstanceMethodParameterMetadata[])o.@Parameters);
                if (a != null)
                {
                    WriteStartElement(@"Parameters", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", null, false);
                    for (int ia = 0; ia < a.Length; ia++)
                    {
                        Write25_Item(@"Parameter", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.InstanceMethodParameterMetadata)a[ia]), false, false);
                    }
                    WriteEndElement();
                }
            }
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="1312" endline="1348" pcid="1608">
        private void Write28_StaticMethodMetadata(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.StaticMethodMetadata o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.StaticMethodMetadata))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(@"StaticMethodMetadata", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            WriteAttribute(@"MethodName", @"", ((global::System.String)o.@MethodName));
            WriteAttribute(@"CmdletParameterSet", @"", ((global::System.String)o.@CmdletParameterSet));
            Write24_Item(@"ReturnValue", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.CommonMethodMetadataReturnValue)o.@ReturnValue), false, false);
            {
                global::Microsoft.PowerShell.Cmdletization.Xml.StaticMethodParameterMetadata[] a = (global::Microsoft.PowerShell.Cmdletization.Xml.StaticMethodParameterMetadata[])((global::Microsoft.PowerShell.Cmdletization.Xml.StaticMethodParameterMetadata[])o.@Parameters);
                if (a != null)
                {
                    WriteStartElement(@"Parameters", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", null, false);
                    for (int ia = 0; ia < a.Length; ia++)
                    {
                        Write27_StaticMethodParameterMetadata(@"Parameter", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.StaticMethodParameterMetadata)a[ia]), false, false);
                    }
                    WriteEndElement();
                }
            }
            WriteEndElement(o);
        }
</source>
</class>

<class classid="46" nclones="3" nlines="40" similarity="85">
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="1534" endline="1581" pcid="1614">
        private void Write33_Item(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.StaticCmdletMetadataCmdletMetadata o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.StaticCmdletMetadataCmdletMetadata))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(null, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            WriteAttribute(@"Verb", @"", ((global::System.String)o.@Verb));
            WriteAttribute(@"Noun", @"", ((global::System.String)o.@Noun));
            {
                global::System.String[] a = (global::System.String[])o.@Aliases;
                if (a != null)
                {
                    Writer.WriteStartAttribute(null, @"Aliases", string.Empty);
                    for (int i = 0; i < a.Length; i++)
                    {
                        global::System.String ai = (global::System.String)a[i];
                        if (i != 0) Writer.WriteString(" ");
                        WriteValue(ai);
                    }
                    Writer.WriteEndAttribute();
                }
            }
            if (o.@ConfirmImpactSpecified)
            {
                WriteAttribute(@"ConfirmImpact", @"", Write20_ConfirmImpact(((global::Microsoft.PowerShell.Cmdletization.Xml.ConfirmImpact)o.@ConfirmImpact)));
            }
            WriteAttribute(@"HelpUri", @"", ((global::System.String)o.@HelpUri));
            WriteAttribute(@"DefaultCmdletParameterSet", @"", ((global::System.String)o.@DefaultCmdletParameterSet));
            Write7_ObsoleteAttributeMetadata(@"Obsolete", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.ObsoleteAttributeMetadata)o.@Obsolete), false, false);
            if (o.@ConfirmImpactSpecified)
            {
            }
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="2169" endline="2220" pcid="1627">
        private void Write21_CommonCmdletMetadata(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.CommonCmdletMetadata o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.CommonCmdletMetadata))
                {
                }
                else if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.StaticCmdletMetadataCmdletMetadata))
                {
                    Write45_Item(n, ns, (global::Microsoft.PowerShell.Cmdletization.Xml.StaticCmdletMetadataCmdletMetadata)o, isNullable, true);
                    return;
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(@"CommonCmdletMetadata", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            WriteAttribute(@"Verb", @"", ((global::System.String)o.@Verb));
            WriteAttribute(@"Noun", @"", ((global::System.String)o.@Noun));
            {
                global::System.String[] a = (global::System.String[])o.@Aliases;
                if (a != null)
                {
                    Writer.WriteStartAttribute(null, @"Aliases", string.Empty);
                    for (int i = 0; i < a.Length; i++)
                    {
                        global::System.String ai = (global::System.String)a[i];
                        if (i != 0) Writer.WriteString(" ");
                        WriteValue(ai);
                    }
                    Writer.WriteEndAttribute();
                }
            }
            if (o.@ConfirmImpactSpecified)
            {
                WriteAttribute(@"ConfirmImpact", @"", Write20_ConfirmImpact(((global::Microsoft.PowerShell.Cmdletization.Xml.ConfirmImpact)o.@ConfirmImpact)));
            }
            WriteAttribute(@"HelpUri", @"", ((global::System.String)o.@HelpUri));
            Write7_ObsoleteAttributeMetadata(@"Obsolete", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.ObsoleteAttributeMetadata)o.@Obsolete), false, false);
            if (o.@ConfirmImpactSpecified)
            {
            }
            WriteEndElement(o);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="2120" endline="2167" pcid="1626">
        private void Write45_Item(string n, string ns, global::Microsoft.PowerShell.Cmdletization.Xml.StaticCmdletMetadataCmdletMetadata o, bool isNullable, bool needType)
        {
            if ((object)o == null)
            {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType)
            {
                System.Type t = o.GetType();
                if (t == typeof(global::Microsoft.PowerShell.Cmdletization.Xml.StaticCmdletMetadataCmdletMetadata))
                {
                }
                else
                {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o, false, null);
            if (needType) WriteXsiType(@"StaticCmdletMetadataCmdletMetadata", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11");
            WriteAttribute(@"Verb", @"", ((global::System.String)o.@Verb));
            WriteAttribute(@"Noun", @"", ((global::System.String)o.@Noun));
            {
                global::System.String[] a = (global::System.String[])o.@Aliases;
                if (a != null)
                {
                    Writer.WriteStartAttribute(null, @"Aliases", string.Empty);
                    for (int i = 0; i < a.Length; i++)
                    {
                        global::System.String ai = (global::System.String)a[i];
                        if (i != 0) Writer.WriteString(" ");
                        WriteValue(ai);
                    }
                    Writer.WriteEndAttribute();
                }
            }
            if (o.@ConfirmImpactSpecified)
            {
                WriteAttribute(@"ConfirmImpact", @"", Write20_ConfirmImpact(((global::Microsoft.PowerShell.Cmdletization.Xml.ConfirmImpact)o.@ConfirmImpact)));
            }
            WriteAttribute(@"HelpUri", @"", ((global::System.String)o.@HelpUri));
            WriteAttribute(@"DefaultCmdletParameterSet", @"", ((global::System.String)o.@DefaultCmdletParameterSet));
            Write7_ObsoleteAttributeMetadata(@"Obsolete", @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11", ((global::Microsoft.PowerShell.Cmdletization.Xml.ObsoleteAttributeMetadata)o.@Obsolete), false, false);
            if (o.@ConfirmImpactSpecified)
            {
            }
            WriteEndElement(o);
        }
</source>
</class>

<class classid="47" nclones="36" nlines="14" similarity="71">
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="2673" endline="2693" pcid="1643">
        public object Read50_PowerShellMetadata()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id1_PowerShellMetadata && (object)Reader.NamespaceURI == (object)_id2_Item))
                {
                    o = Read39_PowerShellMetadata(false, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:PowerShellMetadata");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="2761" endline="2781" pcid="1647">
        public object Read54_PropertyMetadata()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id7_PropertyMetadata && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read15_PropertyMetadata(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":PropertyMetadata");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3159" endline="3179" pcid="1665">
        public object Read72_Item()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id25_Item && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read45_Item(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":StaticCmdletMetadataCmdletMetadata");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3069" endline="3089" pcid="1661">
        public object Read68_GetCmdletMetadata()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id21_GetCmdletMetadata && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read22_GetCmdletMetadata(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":GetCmdletMetadata");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="2717" endline="2737" pcid="1645">
        public object Read52_ClassMetadataInstanceCmdlets()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id5_ClassMetadataInstanceCmdlets && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read40_ClassMetadataInstanceCmdlets(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":ClassMetadataInstanceCmdlets");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="2739" endline="2759" pcid="1646">
        public object Read53_GetCmdletParameters()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id6_GetCmdletParameters && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read19_GetCmdletParameters(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":GetCmdletParameters");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3091" endline="3111" pcid="1662">
        public object Read69_CommonCmdletMetadata()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id22_CommonCmdletMetadata && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read21_CommonCmdletMetadata(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":CommonCmdletMetadata");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="2695" endline="2715" pcid="1644">
        public object Read51_ClassMetadata()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id3_ClassMetadata && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read36_ClassMetadata(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":ClassMetadata");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="2805" endline="2825" pcid="1649">
        public object Read56_Association()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id9_Association && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read17_Association(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":Association");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3137" endline="3157" pcid="1664">
        public object Read71_StaticCmdletMetadata()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id24_StaticCmdletMetadata && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read34_StaticCmdletMetadata(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":StaticCmdletMetadata");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="2783" endline="2803" pcid="1648">
        public object Read55_TypeMetadata()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id8_TypeMetadata && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read2_TypeMetadata(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":TypeMetadata");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3025" endline="3045" pcid="1659">
        public object Read66_Item()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id19_Item && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read8_Item(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":CmdletParameterMetadataForStaticMethodParameter");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3357" endline="3377" pcid="1674">
        public object Read81_InstanceCmdletMetadata()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id34_InstanceCmdletMetadata && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read31_InstanceCmdletMetadata(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":InstanceCmdletMetadata");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3047" endline="3067" pcid="1660">
        public object Read67_QueryOption()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id20_QueryOption && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read18_QueryOption(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":QueryOption");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3379" endline="3399" pcid="1675">
        public object Read82_PropertyQuery()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id35_PropertyQuery && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read14_PropertyQuery(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":PropertyQuery");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3247" endline="3267" pcid="1669">
        public object Read76_StaticMethodParameterMetadata()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id29_StaticMethodParameterMetadata && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read27_StaticMethodParameterMetadata(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":StaticMethodParameterMetadata");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3491" endline="3511" pcid="1680">
        public object Read87_EnumMetadataEnumValue()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id40_EnumMetadataEnumValue && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read49_EnumMetadataEnumValue(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":EnumMetadataEnumValue");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3203" endline="3223" pcid="1667">
        public object Read74_StaticMethodMetadata()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id27_StaticMethodMetadata && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read28_StaticMethodMetadata(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":StaticMethodMetadata");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3269" endline="3289" pcid="1670">
        public object Read77_CmdletOutputMetadata()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id30_CmdletOutputMetadata && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read23_CmdletOutputMetadata(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":CmdletOutputMetadata");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="2871" endline="2891" pcid="1652">
        public object Read59_Item()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id12_Item && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read11_Item(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":CmdletParameterMetadataForGetCmdletParameter");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="2915" endline="2935" pcid="1654">
        public object Read61_Item()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id14_Item && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read42_Item(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":CmdletParameterMetadataValidateCount");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3291" endline="3311" pcid="1671">
        public object Read78_Item()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id31_Item && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read25_Item(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":InstanceMethodParameterMetadata");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="2937" endline="2957" pcid="1655">
        public object Read62_Item()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id15_Item && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read43_Item(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":CmdletParameterMetadataValidateLength");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3225" endline="3245" pcid="1668">
        public object Read75_CommonMethodParameterMetadata()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id28_CommonMethodParameterMetadata && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read26_CommonMethodParameterMetadata(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":CommonMethodParameterMetadata");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3313" endline="3333" pcid="1672">
        public object Read79_Item()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id32_Item && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read46_Item(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":CommonMethodMetadataReturnValue");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3401" endline="3421" pcid="1676">
        public object Read83_WildcardablePropertyQuery()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id36_WildcardablePropertyQuery && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read13_WildcardablePropertyQuery(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":WildcardablePropertyQuery");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3447" endline="3467" pcid="1678">
        public object Read85_ClassMetadataData()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id38_ClassMetadataData && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read47_ClassMetadataData(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":ClassMetadataData");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3335" endline="3355" pcid="1673">
        public object Read80_InstanceMethodMetadata()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id33_InstanceMethodMetadata && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read30_InstanceMethodMetadata(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":InstanceMethodMetadata");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3003" endline="3023" pcid="1658">
        public object Read65_Item()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id18_Item && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read9_Item(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":CmdletParameterMetadataForInstanceMethodParameter");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="2959" endline="2979" pcid="1656">
        public object Read63_Item()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id16_Item && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read44_Item(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":CmdletParameterMetadataValidateRange");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3469" endline="3489" pcid="1679">
        public object Read86_EnumMetadataEnum()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id39_EnumMetadataEnum && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read48_EnumMetadataEnum(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":EnumMetadataEnum");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="2827" endline="2847" pcid="1650">
        public object Read57_AssociationAssociatedInstance()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id10_AssociationAssociatedInstance && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read41_AssociationAssociatedInstance(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":AssociationAssociatedInstance");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="2849" endline="2869" pcid="1651">
        public object Read58_CmdletParameterMetadata()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id11_CmdletParameterMetadata && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read10_CmdletParameterMetadata(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":CmdletParameterMetadata");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3181" endline="3201" pcid="1666">
        public object Read73_CommonMethodMetadata()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id26_CommonMethodMetadata && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read29_CommonMethodMetadata(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":CommonMethodMetadata");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="2981" endline="3001" pcid="1657">
        public object Read64_ObsoleteAttributeMetadata()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id17_ObsoleteAttributeMetadata && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read7_ObsoleteAttributeMetadata(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":ObsoleteAttributeMetadata");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="2893" endline="2913" pcid="1653">
        public object Read60_Item()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id13_Item && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o = Read12_Item(true, true);
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":CmdletParameterMetadataForGetCmdletFilteringParameter");
            }
            return (object)o;
        }
</source>
</class>

<class classid="48" nclones="2" nlines="15" similarity="73">
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3113" endline="3135" pcid="1663">
        public object Read70_ConfirmImpact()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id23_ConfirmImpact && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    {
                        o = Read20_ConfirmImpact(Reader.ReadElementString());
                    }
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":ConfirmImpact");
            }
            return (object)o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3423" endline="3445" pcid="1677">
        public object Read84_ItemsChoiceType()
        {
            object o = null;
            Reader.MoveToContent();
            if (Reader.NodeType == System.Xml.XmlNodeType.Element)
            {
                if (((object)Reader.LocalName == (object)_id37_ItemsChoiceType && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    {
                        o = Read3_ItemsChoiceType(Reader.ReadElementString());
                    }
                }
                else
                {
                    throw CreateUnknownNodeException();
                }
            }
            else
            {
                UnknownNode(null, @":ItemsChoiceType");
            }
            return (object)o;
        }
</source>
</class>

<class classid="49" nclones="12" nlines="47" similarity="70">
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3513" endline="3572" pcid="1681">
        private global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue Read49_EnumMetadataEnumValue(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id40_EnumMetadataEnumValue && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue();
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id41_Name && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Name = Reader.Value;
                    paramsRead[0] = true;
                }
                else if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id42_Value && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Value = CollapseWhitespace(Reader.Value);
                    paramsRead[1] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":Name, :Value");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations0 = 0;
            int readerCount0 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    UnknownNode((object)o, string.Empty);
                }
                else
                {
                    UnknownNode((object)o, string.Empty);
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations0, ref readerCount0);
            }
            ReadEndElement();
            return o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3652" endline="3711" pcid="1683">
        private global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue Read37_EnumMetadataEnumValue(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id4_Item && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue();
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id41_Name && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Name = Reader.Value;
                    paramsRead[0] = true;
                }
                else if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id42_Value && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Value = CollapseWhitespace(Reader.Value);
                    paramsRead[1] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":Name, :Value");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations2 = 0;
            int readerCount2 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    UnknownNode((object)o, string.Empty);
                }
                else
                {
                    UnknownNode((object)o, string.Empty);
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations2, ref readerCount2);
            }
            ReadEndElement();
            return o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="7978" endline="8037" pcid="1727">
        private global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateRange Read44_Item(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id16_Item && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateRange o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateRange();
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id67_Min && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Min = CollapseWhitespace(Reader.Value);
                    paramsRead[0] = true;
                }
                else if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id68_Max && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Max = CollapseWhitespace(Reader.Value);
                    paramsRead[1] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":Min, :Max");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations65 = 0;
            int readerCount65 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    UnknownNode((object)o, string.Empty);
                }
                else
                {
                    UnknownNode((object)o, string.Empty);
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations65, ref readerCount65);
            }
            ReadEndElement();
            return o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="4059" endline="4113" pcid="1688">
        private global::Microsoft.PowerShell.Cmdletization.Xml.ObsoleteAttributeMetadata Read7_ObsoleteAttributeMetadata(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id17_ObsoleteAttributeMetadata && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.ObsoleteAttributeMetadata o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.ObsoleteAttributeMetadata();
            bool[] paramsRead = new bool[1];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id66_Message && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Message = Reader.Value;
                    paramsRead[0] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":Message");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations7 = 0;
            int readerCount7 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    UnknownNode((object)o, string.Empty);
                }
                else
                {
                    UnknownNode((object)o, string.Empty);
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations7, ref readerCount7);
            }
            ReadEndElement();
            return o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="4237" endline="4296" pcid="1691">
        private global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateCount Read4_Item(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id4_Item && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateCount o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateCount();
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id67_Min && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Min = CollapseWhitespace(Reader.Value);
                    paramsRead[0] = true;
                }
                else if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id68_Max && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Max = CollapseWhitespace(Reader.Value);
                    paramsRead[1] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":Min, :Max");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations10 = 0;
            int readerCount10 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    UnknownNode((object)o, string.Empty);
                }
                else
                {
                    UnknownNode((object)o, string.Empty);
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations10, ref readerCount10);
            }
            ReadEndElement();
            return o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="5478" endline="5537" pcid="1700">
        private global::Microsoft.PowerShell.Cmdletization.Xml.TypeMetadata Read2_TypeMetadata(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id8_TypeMetadata && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.TypeMetadata o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.TypeMetadata();
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id94_PSType && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@PSType = Reader.Value;
                    paramsRead[0] = true;
                }
                else if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id95_ETSType && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@ETSType = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":PSType, :ETSType");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations30 = 0;
            int readerCount30 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    UnknownNode((object)o, string.Empty);
                }
                else
                {
                    UnknownNode((object)o, string.Empty);
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations30, ref readerCount30);
            }
            ReadEndElement();
            return o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="4115" endline="4174" pcid="1689">
        private global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateRange Read6_Item(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id4_Item && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateRange o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateRange();
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id67_Min && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Min = CollapseWhitespace(Reader.Value);
                    paramsRead[0] = true;
                }
                else if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id68_Max && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Max = CollapseWhitespace(Reader.Value);
                    paramsRead[1] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":Min, :Max");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations8 = 0;
            int readerCount8 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    UnknownNode((object)o, string.Empty);
                }
                else
                {
                    UnknownNode((object)o, string.Empty);
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations8, ref readerCount8);
            }
            ReadEndElement();
            return o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="4906" endline="4969" pcid="1694">
        private global::Microsoft.PowerShell.Cmdletization.Xml.ClassMetadataData Read35_ClassMetadataData(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id4_Item && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.ClassMetadataData o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.ClassMetadataData();
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id41_Name && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Name = Reader.Value;
                    paramsRead[0] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":Name");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations22 = 0;
            int readerCount22 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                string tmp = null;
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    UnknownNode((object)o, string.Empty);
                }
                else if (Reader.NodeType == System.Xml.XmlNodeType.Text ||
                Reader.NodeType == System.Xml.XmlNodeType.CDATA ||
                Reader.NodeType == System.Xml.XmlNodeType.Whitespace ||
                Reader.NodeType == System.Xml.XmlNodeType.SignificantWhitespace)
                {
                    tmp = ReadString(tmp, false);
                    o.@Value = tmp;
                }
                else
                {
                    UnknownNode((object)o, string.Empty);
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations22, ref readerCount22);
            }
            ReadEndElement();
            return o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="7856" endline="7915" pcid="1725">
        private global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateCount Read42_Item(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id14_Item && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateCount o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateCount();
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id67_Min && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Min = CollapseWhitespace(Reader.Value);
                    paramsRead[0] = true;
                }
                else if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id68_Max && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Max = CollapseWhitespace(Reader.Value);
                    paramsRead[1] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":Min, :Max");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations63 = 0;
            int readerCount63 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    UnknownNode((object)o, string.Empty);
                }
                else
                {
                    UnknownNode((object)o, string.Empty);
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations63, ref readerCount63);
            }
            ReadEndElement();
            return o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="7917" endline="7976" pcid="1726">
        private global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateLength Read43_Item(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id15_Item && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateLength o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateLength();
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id67_Min && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Min = CollapseWhitespace(Reader.Value);
                    paramsRead[0] = true;
                }
                else if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id68_Max && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Max = CollapseWhitespace(Reader.Value);
                    paramsRead[1] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":Min, :Max");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations64 = 0;
            int readerCount64 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    UnknownNode((object)o, string.Empty);
                }
                else
                {
                    UnknownNode((object)o, string.Empty);
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations64, ref readerCount64);
            }
            ReadEndElement();
            return o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="4176" endline="4235" pcid="1690">
        private global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateLength Read5_Item(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id4_Item && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateLength o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateLength();
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id67_Min && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Min = CollapseWhitespace(Reader.Value);
                    paramsRead[0] = true;
                }
                else if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id68_Max && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Max = CollapseWhitespace(Reader.Value);
                    paramsRead[1] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":Min, :Max");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations9 = 0;
            int readerCount9 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    UnknownNode((object)o, string.Empty);
                }
                else
                {
                    UnknownNode((object)o, string.Empty);
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations9, ref readerCount9);
            }
            ReadEndElement();
            return o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3713" endline="3776" pcid="1684">
        private global::Microsoft.PowerShell.Cmdletization.Xml.ClassMetadataData Read47_ClassMetadataData(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id38_ClassMetadataData && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.ClassMetadataData o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.ClassMetadataData();
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id41_Name && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Name = Reader.Value;
                    paramsRead[0] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":Name");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations3 = 0;
            int readerCount3 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                string tmp = null;
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    UnknownNode((object)o, string.Empty);
                }
                else if (Reader.NodeType == System.Xml.XmlNodeType.Text ||
                Reader.NodeType == System.Xml.XmlNodeType.CDATA ||
                Reader.NodeType == System.Xml.XmlNodeType.Whitespace ||
                Reader.NodeType == System.Xml.XmlNodeType.SignificantWhitespace)
                {
                    tmp = ReadString(tmp, false);
                    o.@Value = tmp;
                }
                else
                {
                    UnknownNode((object)o, string.Empty);
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations3, ref readerCount3);
            }
            ReadEndElement();
            return o;
        }
</source>
</class>

<class classid="50" nclones="2" nlines="60" similarity="91">
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3574" endline="3650" pcid="1682">
        private global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnum Read48_EnumMetadataEnum(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id39_EnumMetadataEnum && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnum o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnum();
            global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue[] a_0 = null;
            int ca_0 = 0;
            bool[] paramsRead = new bool[4];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id43_EnumName && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@EnumName = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[2] && ((object)Reader.LocalName == (object)_id44_UnderlyingType && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@UnderlyingType = Reader.Value;
                    paramsRead[2] = true;
                }
                else if (!paramsRead[3] && ((object)Reader.LocalName == (object)_id45_BitwiseFlags && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@BitwiseFlags = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    o.@BitwiseFlagsSpecified = true;
                    paramsRead[3] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":EnumName, :UnderlyingType, :BitwiseFlags");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                o.@Value = (global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue[])ShrinkArray(a_0, ca_0, typeof(global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations1 = 0;
            int readerCount1 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    if (((object)Reader.LocalName == (object)_id42_Value && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        a_0 = (global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue[])EnsureArrayIndex(a_0, ca_0, typeof(global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue)); a_0[ca_0++] = Read37_EnumMetadataEnumValue(false, true);
                    }
                    else
                    {
                        UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Value");
                    }
                }
                else
                {
                    UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Value");
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations1, ref readerCount1);
            }
            o.@Value = (global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue[])ShrinkArray(a_0, ca_0, typeof(global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue), true);
            ReadEndElement();
            return o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="4828" endline="4904" pcid="1693">
        private global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnum Read38_EnumMetadataEnum(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id4_Item && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnum o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnum();
            global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue[] a_0 = null;
            int ca_0 = 0;
            bool[] paramsRead = new bool[4];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id43_EnumName && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@EnumName = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[2] && ((object)Reader.LocalName == (object)_id44_UnderlyingType && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@UnderlyingType = Reader.Value;
                    paramsRead[2] = true;
                }
                else if (!paramsRead[3] && ((object)Reader.LocalName == (object)_id45_BitwiseFlags && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@BitwiseFlags = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    o.@BitwiseFlagsSpecified = true;
                    paramsRead[3] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":EnumName, :UnderlyingType, :BitwiseFlags");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                o.@Value = (global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue[])ShrinkArray(a_0, ca_0, typeof(global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations21 = 0;
            int readerCount21 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    if (((object)Reader.LocalName == (object)_id42_Value && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        a_0 = (global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue[])EnsureArrayIndex(a_0, ca_0, typeof(global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue)); a_0[ca_0++] = Read37_EnumMetadataEnumValue(false, true);
                    }
                    else
                    {
                        UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Value");
                    }
                }
                else
                {
                    UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Value");
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations21, ref readerCount21);
            }
            o.@Value = (global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue[])ShrinkArray(a_0, ca_0, typeof(global::Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue), true);
            ReadEndElement();
            return o;
        }
</source>
</class>

<class classid="51" nclones="3" nlines="49" similarity="70">
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3790" endline="3853" pcid="1686">
        private global::Microsoft.PowerShell.Cmdletization.Xml.WildcardablePropertyQuery Read13_WildcardablePropertyQuery(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id36_WildcardablePropertyQuery && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.WildcardablePropertyQuery o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.WildcardablePropertyQuery();
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id46_AllowGlobbing && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@AllowGlobbing = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    o.@AllowGlobbingSpecified = true;
                    paramsRead[1] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":AllowGlobbing");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations4 = 0;
            int readerCount4 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id11_CmdletParameterMetadata && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@CmdletParameterMetadata = Read12_Item(false, true);
                        paramsRead[0] = true;
                    }
                    else
                    {
                        UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:CmdletParameterMetadata");
                    }
                }
                else
                {
                    UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:CmdletParameterMetadata");
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations4, ref readerCount4);
            }
            ReadEndElement();
            return o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="6470" endline="6529" pcid="1711">
        private global::Microsoft.PowerShell.Cmdletization.Xml.PropertyQuery Read14_PropertyQuery(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id35_PropertyQuery && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else if (((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id36_WildcardablePropertyQuery && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                    return Read13_WildcardablePropertyQuery(isNullable, false);
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.PropertyQuery o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.PropertyQuery();
            bool[] paramsRead = new bool[1];
            while (Reader.MoveToNextAttribute())
            {
                if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations42 = 0;
            int readerCount42 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id11_CmdletParameterMetadata && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@CmdletParameterMetadata = Read12_Item(false, true);
                        paramsRead[0] = true;
                    }
                    else
                    {
                        UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:CmdletParameterMetadata");
                    }
                }
                else
                {
                    UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:CmdletParameterMetadata");
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations42, ref readerCount42);
            }
            ReadEndElement();
            return o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="5229" endline="5291" pcid="1698">
        private global::Microsoft.PowerShell.Cmdletization.Xml.CmdletOutputMetadata Read23_CmdletOutputMetadata(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id30_CmdletOutputMetadata && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.CmdletOutputMetadata o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.CmdletOutputMetadata();
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id49_PSName && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@PSName = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":PSName");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations27 = 0;
            int readerCount27 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id93_ErrorCode && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@ErrorCode = Read1_Object(false, true);
                        paramsRead[0] = true;
                    }
                    else
                    {
                        UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ErrorCode");
                    }
                }
                else
                {
                    UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ErrorCode");
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations27, ref readerCount27);
            }
            ReadEndElement();
            return o;
        }
</source>
</class>

<class classid="52" nclones="5" nlines="145" similarity="76">
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="3855" endline="4057" pcid="1687">
        private global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForGetCmdletFilteringParameter Read12_Item(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id13_Item && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForGetCmdletFilteringParameter o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForGetCmdletFilteringParameter();
            global::System.String[] a_8 = null;
            int ca_8 = 0;
            global::System.String[] a_11 = null;
            int ca_11 = 0;
            global::System.String[] a_16 = null;
            int ca_16 = 0;
            bool[] paramsRead = new bool[18];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[10] && ((object)Reader.LocalName == (object)_id47_IsMandatory && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@IsMandatory = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    o.@IsMandatorySpecified = true;
                    paramsRead[10] = true;
                }
                else if (((object)Reader.LocalName == (object)_id48_Aliases && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    string listValues = Reader.Value;
                    string[] vals = listValues.Split(null);
                    for (int i = 0; i < vals.Length; i++)
                    {
                        a_11 = (global::System.String[])EnsureArrayIndex(a_11, ca_11, typeof(global::System.String)); a_11[ca_11++] = vals[i];
                    }
                }
                else if (!paramsRead[12] && ((object)Reader.LocalName == (object)_id49_PSName && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@PSName = Reader.Value;
                    paramsRead[12] = true;
                }
                else if (!paramsRead[13] && ((object)Reader.LocalName == (object)_id50_Position && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Position = CollapseWhitespace(Reader.Value);
                    paramsRead[13] = true;
                }
                else if (!paramsRead[14] && ((object)Reader.LocalName == (object)_id51_ValueFromPipeline && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@ValueFromPipeline = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    o.@ValueFromPipelineSpecified = true;
                    paramsRead[14] = true;
                }
                else if (!paramsRead[15] && ((object)Reader.LocalName == (object)_id52_Item && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@ValueFromPipelineByPropertyName = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    o.@ValueFromPipelineByPropertyNameSpecified = true;
                    paramsRead[15] = true;
                }
                else if (((object)Reader.LocalName == (object)_id53_CmdletParameterSets && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    string listValues = Reader.Value;
                    string[] vals = listValues.Split(null);
                    for (int i = 0; i < vals.Length; i++)
                    {
                        a_16 = (global::System.String[])EnsureArrayIndex(a_16, ca_16, typeof(global::System.String)); a_16[ca_16++] = vals[i];
                    }
                }
                else if (!paramsRead[17] && ((object)Reader.LocalName == (object)_id54_ErrorOnNoMatch && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@ErrorOnNoMatch = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    o.@ErrorOnNoMatchSpecified = true;
                    paramsRead[17] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":IsMandatory, :Aliases, :PSName, :Position, :ValueFromPipeline, :ValueFromPipelineByPropertyName, :CmdletParameterSets, :ErrorOnNoMatch");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                o.@Aliases = (global::System.String[])ShrinkArray(a_11, ca_11, typeof(global::System.String), true);
                o.@CmdletParameterSets = (global::System.String[])ShrinkArray(a_16, ca_16, typeof(global::System.String), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations5 = 0;
            int readerCount5 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id55_AllowEmptyCollection && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@AllowEmptyCollection = Read1_Object(false, true);
                        paramsRead[0] = true;
                    }
                    else if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id56_AllowEmptyString && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@AllowEmptyString = Read1_Object(false, true);
                        paramsRead[1] = true;
                    }
                    else if (!paramsRead[2] && ((object)Reader.LocalName == (object)_id57_AllowNull && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@AllowNull = Read1_Object(false, true);
                        paramsRead[2] = true;
                    }
                    else if (!paramsRead[3] && ((object)Reader.LocalName == (object)_id58_ValidateNotNull && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@ValidateNotNull = Read1_Object(false, true);
                        paramsRead[3] = true;
                    }
                    else if (!paramsRead[4] && ((object)Reader.LocalName == (object)_id59_ValidateNotNullOrEmpty && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@ValidateNotNullOrEmpty = Read1_Object(false, true);
                        paramsRead[4] = true;
                    }
                    else if (!paramsRead[5] && ((object)Reader.LocalName == (object)_id60_ValidateCount && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@ValidateCount = Read4_Item(false, true);
                        paramsRead[5] = true;
                    }
                    else if (!paramsRead[6] && ((object)Reader.LocalName == (object)_id61_ValidateLength && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@ValidateLength = Read5_Item(false, true);
                        paramsRead[6] = true;
                    }
                    else if (!paramsRead[7] && ((object)Reader.LocalName == (object)_id62_ValidateRange && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@ValidateRange = Read6_Item(false, true);
                        paramsRead[7] = true;
                    }
                    else if (((object)Reader.LocalName == (object)_id63_ValidateSet && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        if (!ReadNull())
                        {
                            global::System.String[] a_8_0 = null;
                            int ca_8_0 = 0;
                            if ((Reader.IsEmptyElement))
                            {
                                Reader.Skip();
                            }
                            else
                            {
                                Reader.ReadStartElement();
                                Reader.MoveToContent();
                                int whileIterations6 = 0;
                                int readerCount6 = ReaderCount;
                                while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
                                {
                                    if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                                    {
                                        if (((object)Reader.LocalName == (object)_id64_AllowedValue && (object)Reader.NamespaceURI == (object)_id2_Item))
                                        {
                                            {
                                                a_8_0 = (global::System.String[])EnsureArrayIndex(a_8_0, ca_8_0, typeof(global::System.String)); a_8_0[ca_8_0++] = Reader.ReadElementString();
                                            }
                                        }
                                        else
                                        {
                                            UnknownNode(null, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowedValue");
                                        }
                                    }
                                    else
                                    {
                                        UnknownNode(null, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowedValue");
                                    }
                                    Reader.MoveToContent();
                                    CheckReaderCount(ref whileIterations6, ref readerCount6);
                                }
                                ReadEndElement();
                            }
                            o.@ValidateSet = (global::System.String[])ShrinkArray(a_8_0, ca_8_0, typeof(global::System.String), false);
                        }
                    }
                    else if (!paramsRead[9] && ((object)Reader.LocalName == (object)_id65_Obsolete && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@Obsolete = Read7_ObsoleteAttributeMetadata(false, true);
                        paramsRead[9] = true;
                    }
                    else
                    {
                        UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowEmptyCollection, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowEmptyString, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowNull, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateNotNull, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateNotNullOrEmpty, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateCount, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateLength, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateRange, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateSet, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Obsolete");
                    }
                }
                else
                {
                    UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowEmptyCollection, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowEmptyString, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowNull, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateNotNull, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateNotNullOrEmpty, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateCount, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateLength, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateRange, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateSet, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Obsolete");
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations5, ref readerCount5);
            }
            o.@Aliases = (global::System.String[])ShrinkArray(a_11, ca_11, typeof(global::System.String), true);
            o.@CmdletParameterSets = (global::System.String[])ShrinkArray(a_16, ca_16, typeof(global::System.String), true);
            ReadEndElement();
            return o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="5792" endline="5969" pcid="1705">
        private global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForInstanceMethodParameter Read9_Item(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id18_Item && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForInstanceMethodParameter o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForInstanceMethodParameter();
            global::System.String[] a_8 = null;
            int ca_8 = 0;
            global::System.String[] a_11 = null;
            int ca_11 = 0;
            bool[] paramsRead = new bool[15];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[10] && ((object)Reader.LocalName == (object)_id47_IsMandatory && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@IsMandatory = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    o.@IsMandatorySpecified = true;
                    paramsRead[10] = true;
                }
                else if (((object)Reader.LocalName == (object)_id48_Aliases && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    string listValues = Reader.Value;
                    string[] vals = listValues.Split(null);
                    for (int i = 0; i < vals.Length; i++)
                    {
                        a_11 = (global::System.String[])EnsureArrayIndex(a_11, ca_11, typeof(global::System.String)); a_11[ca_11++] = vals[i];
                    }
                }
                else if (!paramsRead[12] && ((object)Reader.LocalName == (object)_id49_PSName && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@PSName = Reader.Value;
                    paramsRead[12] = true;
                }
                else if (!paramsRead[13] && ((object)Reader.LocalName == (object)_id50_Position && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Position = CollapseWhitespace(Reader.Value);
                    paramsRead[13] = true;
                }
                else if (!paramsRead[14] && ((object)Reader.LocalName == (object)_id52_Item && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@ValueFromPipelineByPropertyName = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    o.@ValueFromPipelineByPropertyNameSpecified = true;
                    paramsRead[14] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":IsMandatory, :Aliases, :PSName, :Position, :ValueFromPipelineByPropertyName");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                o.@Aliases = (global::System.String[])ShrinkArray(a_11, ca_11, typeof(global::System.String), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations34 = 0;
            int readerCount34 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id55_AllowEmptyCollection && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@AllowEmptyCollection = Read1_Object(false, true);
                        paramsRead[0] = true;
                    }
                    else if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id56_AllowEmptyString && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@AllowEmptyString = Read1_Object(false, true);
                        paramsRead[1] = true;
                    }
                    else if (!paramsRead[2] && ((object)Reader.LocalName == (object)_id57_AllowNull && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@AllowNull = Read1_Object(false, true);
                        paramsRead[2] = true;
                    }
                    else if (!paramsRead[3] && ((object)Reader.LocalName == (object)_id58_ValidateNotNull && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@ValidateNotNull = Read1_Object(false, true);
                        paramsRead[3] = true;
                    }
                    else if (!paramsRead[4] && ((object)Reader.LocalName == (object)_id59_ValidateNotNullOrEmpty && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@ValidateNotNullOrEmpty = Read1_Object(false, true);
                        paramsRead[4] = true;
                    }
                    else if (!paramsRead[5] && ((object)Reader.LocalName == (object)_id60_ValidateCount && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@ValidateCount = Read4_Item(false, true);
                        paramsRead[5] = true;
                    }
                    else if (!paramsRead[6] && ((object)Reader.LocalName == (object)_id61_ValidateLength && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@ValidateLength = Read5_Item(false, true);
                        paramsRead[6] = true;
                    }
                    else if (!paramsRead[7] && ((object)Reader.LocalName == (object)_id62_ValidateRange && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@ValidateRange = Read6_Item(false, true);
                        paramsRead[7] = true;
                    }
                    else if (((object)Reader.LocalName == (object)_id63_ValidateSet && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        if (!ReadNull())
                        {
                            global::System.String[] a_8_0 = null;
                            int ca_8_0 = 0;
                            if ((Reader.IsEmptyElement))
                            {
                                Reader.Skip();
                            }
                            else
                            {
                                Reader.ReadStartElement();
                                Reader.MoveToContent();
                                int whileIterations35 = 0;
                                int readerCount35 = ReaderCount;
                                while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
                                {
                                    if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                                    {
                                        if (((object)Reader.LocalName == (object)_id64_AllowedValue && (object)Reader.NamespaceURI == (object)_id2_Item))
                                        {
                                            {
                                                a_8_0 = (global::System.String[])EnsureArrayIndex(a_8_0, ca_8_0, typeof(global::System.String)); a_8_0[ca_8_0++] = Reader.ReadElementString();
                                            }
                                        }
                                        else
                                        {
                                            UnknownNode(null, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowedValue");
                                        }
                                    }
                                    else
                                    {
                                        UnknownNode(null, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowedValue");
                                    }
                                    Reader.MoveToContent();
                                    CheckReaderCount(ref whileIterations35, ref readerCount35);
                                }
                                ReadEndElement();
                            }
                            o.@ValidateSet = (global::System.String[])ShrinkArray(a_8_0, ca_8_0, typeof(global::System.String), false);
                        }
                    }
                    else if (!paramsRead[9] && ((object)Reader.LocalName == (object)_id65_Obsolete && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@Obsolete = Read7_ObsoleteAttributeMetadata(false, true);
                        paramsRead[9] = true;
                    }
                    else
                    {
                        UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowEmptyCollection, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowEmptyString, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowNull, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateNotNull, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateNotNullOrEmpty, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateCount, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateLength, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateRange, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateSet, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Obsolete");
                    }
                }
                else
                {
                    UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowEmptyCollection, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowEmptyString, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowNull, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateNotNull, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateNotNullOrEmpty, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateCount, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateLength, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateRange, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateSet, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Obsolete");
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations34, ref readerCount34);
            }
            o.@Aliases = (global::System.String[])ShrinkArray(a_11, ca_11, typeof(global::System.String), true);
            ReadEndElement();
            return o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="6531" endline="6710" pcid="1712">
        private global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadata Read10_CmdletParameterMetadata(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id11_CmdletParameterMetadata && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else if (((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id12_Item && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                    return Read11_Item(isNullable, false);
                else if (((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id13_Item && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                    return Read12_Item(isNullable, false);
                else if (((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id18_Item && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                    return Read9_Item(isNullable, false);
                else if (((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id19_Item && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                    return Read8_Item(isNullable, false);
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadata o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadata();
            global::System.String[] a_8 = null;
            int ca_8 = 0;
            global::System.String[] a_11 = null;
            int ca_11 = 0;
            bool[] paramsRead = new bool[14];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[10] && ((object)Reader.LocalName == (object)_id47_IsMandatory && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@IsMandatory = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    o.@IsMandatorySpecified = true;
                    paramsRead[10] = true;
                }
                else if (((object)Reader.LocalName == (object)_id48_Aliases && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    string listValues = Reader.Value;
                    string[] vals = listValues.Split(null);
                    for (int i = 0; i < vals.Length; i++)
                    {
                        a_11 = (global::System.String[])EnsureArrayIndex(a_11, ca_11, typeof(global::System.String)); a_11[ca_11++] = vals[i];
                    }
                }
                else if (!paramsRead[12] && ((object)Reader.LocalName == (object)_id49_PSName && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@PSName = Reader.Value;
                    paramsRead[12] = true;
                }
                else if (!paramsRead[13] && ((object)Reader.LocalName == (object)_id50_Position && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Position = CollapseWhitespace(Reader.Value);
                    paramsRead[13] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":IsMandatory, :Aliases, :PSName, :Position");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                o.@Aliases = (global::System.String[])ShrinkArray(a_11, ca_11, typeof(global::System.String), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations43 = 0;
            int readerCount43 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id55_AllowEmptyCollection && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@AllowEmptyCollection = Read1_Object(false, true);
                        paramsRead[0] = true;
                    }
                    else if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id56_AllowEmptyString && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@AllowEmptyString = Read1_Object(false, true);
                        paramsRead[1] = true;
                    }
                    else if (!paramsRead[2] && ((object)Reader.LocalName == (object)_id57_AllowNull && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@AllowNull = Read1_Object(false, true);
                        paramsRead[2] = true;
                    }
                    else if (!paramsRead[3] && ((object)Reader.LocalName == (object)_id58_ValidateNotNull && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@ValidateNotNull = Read1_Object(false, true);
                        paramsRead[3] = true;
                    }
                    else if (!paramsRead[4] && ((object)Reader.LocalName == (object)_id59_ValidateNotNullOrEmpty && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@ValidateNotNullOrEmpty = Read1_Object(false, true);
                        paramsRead[4] = true;
                    }
                    else if (!paramsRead[5] && ((object)Reader.LocalName == (object)_id60_ValidateCount && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@ValidateCount = Read4_Item(false, true);
                        paramsRead[5] = true;
                    }
                    else if (!paramsRead[6] && ((object)Reader.LocalName == (object)_id61_ValidateLength && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@ValidateLength = Read5_Item(false, true);
                        paramsRead[6] = true;
                    }
                    else if (!paramsRead[7] && ((object)Reader.LocalName == (object)_id62_ValidateRange && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@ValidateRange = Read6_Item(false, true);
                        paramsRead[7] = true;
                    }
                    else if (((object)Reader.LocalName == (object)_id63_ValidateSet && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        if (!ReadNull())
                        {
                            global::System.String[] a_8_0 = null;
                            int ca_8_0 = 0;
                            if ((Reader.IsEmptyElement))
                            {
                                Reader.Skip();
                            }
                            else
                            {
                                Reader.ReadStartElement();
                                Reader.MoveToContent();
                                int whileIterations44 = 0;
                                int readerCount44 = ReaderCount;
                                while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
                                {
                                    if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                                    {
                                        if (((object)Reader.LocalName == (object)_id64_AllowedValue && (object)Reader.NamespaceURI == (object)_id2_Item))
                                        {
                                            {
                                                a_8_0 = (global::System.String[])EnsureArrayIndex(a_8_0, ca_8_0, typeof(global::System.String)); a_8_0[ca_8_0++] = Reader.ReadElementString();
                                            }
                                        }
                                        else
                                        {
                                            UnknownNode(null, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowedValue");
                                        }
                                    }
                                    else
                                    {
                                        UnknownNode(null, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowedValue");
                                    }
                                    Reader.MoveToContent();
                                    CheckReaderCount(ref whileIterations44, ref readerCount44);
                                }
                                ReadEndElement();
                            }
                            o.@ValidateSet = (global::System.String[])ShrinkArray(a_8_0, ca_8_0, typeof(global::System.String), false);
                        }
                    }
                    else if (!paramsRead[9] && ((object)Reader.LocalName == (object)_id65_Obsolete && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@Obsolete = Read7_ObsoleteAttributeMetadata(false, true);
                        paramsRead[9] = true;
                    }
                    else
                    {
                        UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowEmptyCollection, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowEmptyString, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowNull, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateNotNull, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateNotNullOrEmpty, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateCount, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateLength, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateRange, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateSet, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Obsolete");
                    }
                }
                else
                {
                    UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowEmptyCollection, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowEmptyString, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowNull, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateNotNull, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateNotNullOrEmpty, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateCount, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateLength, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateRange, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateSet, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Obsolete");
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations43, ref readerCount43);
            }
            o.@Aliases = (global::System.String[])ShrinkArray(a_11, ca_11, typeof(global::System.String), true);
            ReadEndElement();
            return o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="5293" endline="5476" pcid="1699">
        private global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForStaticMethodParameter Read8_Item(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id19_Item && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForStaticMethodParameter o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForStaticMethodParameter();
            global::System.String[] a_8 = null;
            int ca_8 = 0;
            global::System.String[] a_11 = null;
            int ca_11 = 0;
            bool[] paramsRead = new bool[16];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[10] && ((object)Reader.LocalName == (object)_id47_IsMandatory && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@IsMandatory = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    o.@IsMandatorySpecified = true;
                    paramsRead[10] = true;
                }
                else if (((object)Reader.LocalName == (object)_id48_Aliases && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    string listValues = Reader.Value;
                    string[] vals = listValues.Split(null);
                    for (int i = 0; i < vals.Length; i++)
                    {
                        a_11 = (global::System.String[])EnsureArrayIndex(a_11, ca_11, typeof(global::System.String)); a_11[ca_11++] = vals[i];
                    }
                }
                else if (!paramsRead[12] && ((object)Reader.LocalName == (object)_id49_PSName && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@PSName = Reader.Value;
                    paramsRead[12] = true;
                }
                else if (!paramsRead[13] && ((object)Reader.LocalName == (object)_id50_Position && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Position = CollapseWhitespace(Reader.Value);
                    paramsRead[13] = true;
                }
                else if (!paramsRead[14] && ((object)Reader.LocalName == (object)_id51_ValueFromPipeline && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@ValueFromPipeline = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    o.@ValueFromPipelineSpecified = true;
                    paramsRead[14] = true;
                }
                else if (!paramsRead[15] && ((object)Reader.LocalName == (object)_id52_Item && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@ValueFromPipelineByPropertyName = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    o.@ValueFromPipelineByPropertyNameSpecified = true;
                    paramsRead[15] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":IsMandatory, :Aliases, :PSName, :Position, :ValueFromPipeline, :ValueFromPipelineByPropertyName");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                o.@Aliases = (global::System.String[])ShrinkArray(a_11, ca_11, typeof(global::System.String), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations28 = 0;
            int readerCount28 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id55_AllowEmptyCollection && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@AllowEmptyCollection = Read1_Object(false, true);
                        paramsRead[0] = true;
                    }
                    else if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id56_AllowEmptyString && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@AllowEmptyString = Read1_Object(false, true);
                        paramsRead[1] = true;
                    }
                    else if (!paramsRead[2] && ((object)Reader.LocalName == (object)_id57_AllowNull && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@AllowNull = Read1_Object(false, true);
                        paramsRead[2] = true;
                    }
                    else if (!paramsRead[3] && ((object)Reader.LocalName == (object)_id58_ValidateNotNull && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@ValidateNotNull = Read1_Object(false, true);
                        paramsRead[3] = true;
                    }
                    else if (!paramsRead[4] && ((object)Reader.LocalName == (object)_id59_ValidateNotNullOrEmpty && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@ValidateNotNullOrEmpty = Read1_Object(false, true);
                        paramsRead[4] = true;
                    }
                    else if (!paramsRead[5] && ((object)Reader.LocalName == (object)_id60_ValidateCount && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@ValidateCount = Read4_Item(false, true);
                        paramsRead[5] = true;
                    }
                    else if (!paramsRead[6] && ((object)Reader.LocalName == (object)_id61_ValidateLength && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@ValidateLength = Read5_Item(false, true);
                        paramsRead[6] = true;
                    }
                    else if (!paramsRead[7] && ((object)Reader.LocalName == (object)_id62_ValidateRange && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@ValidateRange = Read6_Item(false, true);
                        paramsRead[7] = true;
                    }
                    else if (((object)Reader.LocalName == (object)_id63_ValidateSet && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        if (!ReadNull())
                        {
                            global::System.String[] a_8_0 = null;
                            int ca_8_0 = 0;
                            if ((Reader.IsEmptyElement))
                            {
                                Reader.Skip();
                            }
                            else
                            {
                                Reader.ReadStartElement();
                                Reader.MoveToContent();
                                int whileIterations29 = 0;
                                int readerCount29 = ReaderCount;
                                while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
                                {
                                    if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                                    {
                                        if (((object)Reader.LocalName == (object)_id64_AllowedValue && (object)Reader.NamespaceURI == (object)_id2_Item))
                                        {
                                            {
                                                a_8_0 = (global::System.String[])EnsureArrayIndex(a_8_0, ca_8_0, typeof(global::System.String)); a_8_0[ca_8_0++] = Reader.ReadElementString();
                                            }
                                        }
                                        else
                                        {
                                            UnknownNode(null, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowedValue");
                                        }
                                    }
                                    else
                                    {
                                        UnknownNode(null, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowedValue");
                                    }
                                    Reader.MoveToContent();
                                    CheckReaderCount(ref whileIterations29, ref readerCount29);
                                }
                                ReadEndElement();
                            }
                            o.@ValidateSet = (global::System.String[])ShrinkArray(a_8_0, ca_8_0, typeof(global::System.String), false);
                        }
                    }
                    else if (!paramsRead[9] && ((object)Reader.LocalName == (object)_id65_Obsolete && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@Obsolete = Read7_ObsoleteAttributeMetadata(false, true);
                        paramsRead[9] = true;
                    }
                    else
                    {
                        UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowEmptyCollection, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowEmptyString, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowNull, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateNotNull, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateNotNullOrEmpty, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateCount, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateLength, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateRange, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateSet, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Obsolete");
                    }
                }
                else
                {
                    UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowEmptyCollection, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowEmptyString, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowNull, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateNotNull, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateNotNullOrEmpty, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateCount, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateLength, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateRange, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateSet, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Obsolete");
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations28, ref readerCount28);
            }
            o.@Aliases = (global::System.String[])ShrinkArray(a_11, ca_11, typeof(global::System.String), true);
            ReadEndElement();
            return o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="6040" endline="6238" pcid="1707">
        private global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForGetCmdletParameter Read11_Item(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id12_Item && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else if (((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id13_Item && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                    return Read12_Item(isNullable, false);
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForGetCmdletParameter o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForGetCmdletParameter();
            global::System.String[] a_8 = null;
            int ca_8 = 0;
            global::System.String[] a_11 = null;
            int ca_11 = 0;
            global::System.String[] a_16 = null;
            int ca_16 = 0;
            bool[] paramsRead = new bool[17];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[10] && ((object)Reader.LocalName == (object)_id47_IsMandatory && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@IsMandatory = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    o.@IsMandatorySpecified = true;
                    paramsRead[10] = true;
                }
                else if (((object)Reader.LocalName == (object)_id48_Aliases && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    string listValues = Reader.Value;
                    string[] vals = listValues.Split(null);
                    for (int i = 0; i < vals.Length; i++)
                    {
                        a_11 = (global::System.String[])EnsureArrayIndex(a_11, ca_11, typeof(global::System.String)); a_11[ca_11++] = vals[i];
                    }
                }
                else if (!paramsRead[12] && ((object)Reader.LocalName == (object)_id49_PSName && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@PSName = Reader.Value;
                    paramsRead[12] = true;
                }
                else if (!paramsRead[13] && ((object)Reader.LocalName == (object)_id50_Position && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Position = CollapseWhitespace(Reader.Value);
                    paramsRead[13] = true;
                }
                else if (!paramsRead[14] && ((object)Reader.LocalName == (object)_id51_ValueFromPipeline && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@ValueFromPipeline = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    o.@ValueFromPipelineSpecified = true;
                    paramsRead[14] = true;
                }
                else if (!paramsRead[15] && ((object)Reader.LocalName == (object)_id52_Item && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@ValueFromPipelineByPropertyName = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    o.@ValueFromPipelineByPropertyNameSpecified = true;
                    paramsRead[15] = true;
                }
                else if (((object)Reader.LocalName == (object)_id53_CmdletParameterSets && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    string listValues = Reader.Value;
                    string[] vals = listValues.Split(null);
                    for (int i = 0; i < vals.Length; i++)
                    {
                        a_16 = (global::System.String[])EnsureArrayIndex(a_16, ca_16, typeof(global::System.String)); a_16[ca_16++] = vals[i];
                    }
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":IsMandatory, :Aliases, :PSName, :Position, :ValueFromPipeline, :ValueFromPipelineByPropertyName, :CmdletParameterSets");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                o.@Aliases = (global::System.String[])ShrinkArray(a_11, ca_11, typeof(global::System.String), true);
                o.@CmdletParameterSets = (global::System.String[])ShrinkArray(a_16, ca_16, typeof(global::System.String), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations37 = 0;
            int readerCount37 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id55_AllowEmptyCollection && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@AllowEmptyCollection = Read1_Object(false, true);
                        paramsRead[0] = true;
                    }
                    else if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id56_AllowEmptyString && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@AllowEmptyString = Read1_Object(false, true);
                        paramsRead[1] = true;
                    }
                    else if (!paramsRead[2] && ((object)Reader.LocalName == (object)_id57_AllowNull && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@AllowNull = Read1_Object(false, true);
                        paramsRead[2] = true;
                    }
                    else if (!paramsRead[3] && ((object)Reader.LocalName == (object)_id58_ValidateNotNull && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@ValidateNotNull = Read1_Object(false, true);
                        paramsRead[3] = true;
                    }
                    else if (!paramsRead[4] && ((object)Reader.LocalName == (object)_id59_ValidateNotNullOrEmpty && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@ValidateNotNullOrEmpty = Read1_Object(false, true);
                        paramsRead[4] = true;
                    }
                    else if (!paramsRead[5] && ((object)Reader.LocalName == (object)_id60_ValidateCount && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@ValidateCount = Read4_Item(false, true);
                        paramsRead[5] = true;
                    }
                    else if (!paramsRead[6] && ((object)Reader.LocalName == (object)_id61_ValidateLength && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@ValidateLength = Read5_Item(false, true);
                        paramsRead[6] = true;
                    }
                    else if (!paramsRead[7] && ((object)Reader.LocalName == (object)_id62_ValidateRange && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@ValidateRange = Read6_Item(false, true);
                        paramsRead[7] = true;
                    }
                    else if (((object)Reader.LocalName == (object)_id63_ValidateSet && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        if (!ReadNull())
                        {
                            global::System.String[] a_8_0 = null;
                            int ca_8_0 = 0;
                            if ((Reader.IsEmptyElement))
                            {
                                Reader.Skip();
                            }
                            else
                            {
                                Reader.ReadStartElement();
                                Reader.MoveToContent();
                                int whileIterations38 = 0;
                                int readerCount38 = ReaderCount;
                                while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
                                {
                                    if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                                    {
                                        if (((object)Reader.LocalName == (object)_id64_AllowedValue && (object)Reader.NamespaceURI == (object)_id2_Item))
                                        {
                                            {
                                                a_8_0 = (global::System.String[])EnsureArrayIndex(a_8_0, ca_8_0, typeof(global::System.String)); a_8_0[ca_8_0++] = Reader.ReadElementString();
                                            }
                                        }
                                        else
                                        {
                                            UnknownNode(null, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowedValue");
                                        }
                                    }
                                    else
                                    {
                                        UnknownNode(null, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowedValue");
                                    }
                                    Reader.MoveToContent();
                                    CheckReaderCount(ref whileIterations38, ref readerCount38);
                                }
                                ReadEndElement();
                            }
                            o.@ValidateSet = (global::System.String[])ShrinkArray(a_8_0, ca_8_0, typeof(global::System.String), false);
                        }
                    }
                    else if (!paramsRead[9] && ((object)Reader.LocalName == (object)_id65_Obsolete && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@Obsolete = Read7_ObsoleteAttributeMetadata(false, true);
                        paramsRead[9] = true;
                    }
                    else
                    {
                        UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowEmptyCollection, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowEmptyString, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowNull, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateNotNull, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateNotNullOrEmpty, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateCount, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateLength, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateRange, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateSet, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Obsolete");
                    }
                }
                else
                {
                    UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowEmptyCollection, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowEmptyString, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:AllowNull, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateNotNull, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateNotNullOrEmpty, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateCount, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateLength, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateRange, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ValidateSet, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Obsolete");
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations37, ref readerCount37);
            }
            o.@Aliases = (global::System.String[])ShrinkArray(a_11, ca_11, typeof(global::System.String), true);
            o.@CmdletParameterSets = (global::System.String[])ShrinkArray(a_16, ca_16, typeof(global::System.String), true);
            ReadEndElement();
            return o;
        }
</source>
</class>

<class classid="53" nclones="2" nlines="82" similarity="75">
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="5038" endline="5148" pcid="1696">
        private global::Microsoft.PowerShell.Cmdletization.Xml.StaticMethodMetadata Read28_StaticMethodMetadata(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id27_StaticMethodMetadata && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.StaticMethodMetadata o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.StaticMethodMetadata();
            global::Microsoft.PowerShell.Cmdletization.Xml.StaticMethodParameterMetadata[] a_2 = null;
            int ca_2 = 0;
            bool[] paramsRead = new bool[4];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id86_MethodName && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@MethodName = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[3] && ((object)Reader.LocalName == (object)_id87_CmdletParameterSet && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@CmdletParameterSet = Reader.Value;
                    paramsRead[3] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":MethodName, :CmdletParameterSet");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations24 = 0;
            int readerCount24 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id88_ReturnValue && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@ReturnValue = Read24_Item(false, true);
                        paramsRead[0] = true;
                    }
                    else if (((object)Reader.LocalName == (object)_id89_Parameters && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        if (!ReadNull())
                        {
                            global::Microsoft.PowerShell.Cmdletization.Xml.StaticMethodParameterMetadata[] a_2_0 = null;
                            int ca_2_0 = 0;
                            if ((Reader.IsEmptyElement))
                            {
                                Reader.Skip();
                            }
                            else
                            {
                                Reader.ReadStartElement();
                                Reader.MoveToContent();
                                int whileIterations25 = 0;
                                int readerCount25 = ReaderCount;
                                while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
                                {
                                    if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                                    {
                                        if (((object)Reader.LocalName == (object)_id76_Parameter && (object)Reader.NamespaceURI == (object)_id2_Item))
                                        {
                                            a_2_0 = (global::Microsoft.PowerShell.Cmdletization.Xml.StaticMethodParameterMetadata[])EnsureArrayIndex(a_2_0, ca_2_0, typeof(global::Microsoft.PowerShell.Cmdletization.Xml.StaticMethodParameterMetadata)); a_2_0[ca_2_0++] = Read27_StaticMethodParameterMetadata(false, true);
                                        }
                                        else
                                        {
                                            UnknownNode(null, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Parameter");
                                        }
                                    }
                                    else
                                    {
                                        UnknownNode(null, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Parameter");
                                    }
                                    Reader.MoveToContent();
                                    CheckReaderCount(ref whileIterations25, ref readerCount25);
                                }
                                ReadEndElement();
                            }
                            o.@Parameters = (global::Microsoft.PowerShell.Cmdletization.Xml.StaticMethodParameterMetadata[])ShrinkArray(a_2_0, ca_2_0, typeof(global::Microsoft.PowerShell.Cmdletization.Xml.StaticMethodParameterMetadata), false);
                        }
                    }
                    else
                    {
                        UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ReturnValue, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Parameters");
                    }
                }
                else
                {
                    UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ReturnValue, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Parameters");
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations24, ref readerCount24);
            }
            ReadEndElement();
            return o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="7157" endline="7262" pcid="1717">
        private global::Microsoft.PowerShell.Cmdletization.Xml.InstanceMethodMetadata Read30_InstanceMethodMetadata(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id33_InstanceMethodMetadata && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.InstanceMethodMetadata o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.InstanceMethodMetadata();
            global::Microsoft.PowerShell.Cmdletization.Xml.InstanceMethodParameterMetadata[] a_2 = null;
            int ca_2 = 0;
            bool[] paramsRead = new bool[3];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id86_MethodName && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@MethodName = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":MethodName");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations52 = 0;
            int readerCount52 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id88_ReturnValue && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@ReturnValue = Read24_Item(false, true);
                        paramsRead[0] = true;
                    }
                    else if (((object)Reader.LocalName == (object)_id89_Parameters && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        if (!ReadNull())
                        {
                            global::Microsoft.PowerShell.Cmdletization.Xml.InstanceMethodParameterMetadata[] a_2_0 = null;
                            int ca_2_0 = 0;
                            if ((Reader.IsEmptyElement))
                            {
                                Reader.Skip();
                            }
                            else
                            {
                                Reader.ReadStartElement();
                                Reader.MoveToContent();
                                int whileIterations53 = 0;
                                int readerCount53 = ReaderCount;
                                while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
                                {
                                    if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                                    {
                                        if (((object)Reader.LocalName == (object)_id76_Parameter && (object)Reader.NamespaceURI == (object)_id2_Item))
                                        {
                                            a_2_0 = (global::Microsoft.PowerShell.Cmdletization.Xml.InstanceMethodParameterMetadata[])EnsureArrayIndex(a_2_0, ca_2_0, typeof(global::Microsoft.PowerShell.Cmdletization.Xml.InstanceMethodParameterMetadata)); a_2_0[ca_2_0++] = Read25_Item(false, true);
                                        }
                                        else
                                        {
                                            UnknownNode(null, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Parameter");
                                        }
                                    }
                                    else
                                    {
                                        UnknownNode(null, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Parameter");
                                    }
                                    Reader.MoveToContent();
                                    CheckReaderCount(ref whileIterations53, ref readerCount53);
                                }
                                ReadEndElement();
                            }
                            o.@Parameters = (global::Microsoft.PowerShell.Cmdletization.Xml.InstanceMethodParameterMetadata[])ShrinkArray(a_2_0, ca_2_0, typeof(global::Microsoft.PowerShell.Cmdletization.Xml.InstanceMethodParameterMetadata), false);
                        }
                    }
                    else
                    {
                        UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ReturnValue, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Parameters");
                    }
                }
                else
                {
                    UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:ReturnValue, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Parameters");
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations52, ref readerCount52);
            }
            ReadEndElement();
            return o;
        }
</source>
</class>

<class classid="54" nclones="2" nlines="60" similarity="86">
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="5150" endline="5227" pcid="1697">
        private global::Microsoft.PowerShell.Cmdletization.Xml.StaticMethodParameterMetadata Read27_StaticMethodParameterMetadata(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id29_StaticMethodParameterMetadata && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.StaticMethodParameterMetadata o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.StaticMethodParameterMetadata();
            bool[] paramsRead = new bool[5];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id90_ParameterName && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@ParameterName = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[2] && ((object)Reader.LocalName == (object)_id91_DefaultValue && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@DefaultValue = Reader.Value;
                    paramsRead[2] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":ParameterName, :DefaultValue");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations26 = 0;
            int readerCount26 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id92_Type && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@Type = Read2_TypeMetadata(false, true);
                        paramsRead[0] = true;
                    }
                    else if (!paramsRead[3] && ((object)Reader.LocalName == (object)_id11_CmdletParameterMetadata && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@CmdletParameterMetadata = Read8_Item(false, true);
                        paramsRead[3] = true;
                    }
                    else if (!paramsRead[4] && ((object)Reader.LocalName == (object)_id30_CmdletOutputMetadata && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@CmdletOutputMetadata = Read23_CmdletOutputMetadata(false, true);
                        paramsRead[4] = true;
                    }
                    else
                    {
                        UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Type, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:CmdletParameterMetadata, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:CmdletOutputMetadata");
                    }
                }
                else
                {
                    UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Type, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:CmdletParameterMetadata, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:CmdletOutputMetadata");
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations26, ref readerCount26);
            }
            ReadEndElement();
            return o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="5713" endline="5790" pcid="1704">
        private global::Microsoft.PowerShell.Cmdletization.Xml.InstanceMethodParameterMetadata Read25_Item(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id31_Item && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.InstanceMethodParameterMetadata o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.InstanceMethodParameterMetadata();
            bool[] paramsRead = new bool[5];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id90_ParameterName && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@ParameterName = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[2] && ((object)Reader.LocalName == (object)_id91_DefaultValue && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@DefaultValue = Reader.Value;
                    paramsRead[2] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":ParameterName, :DefaultValue");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations33 = 0;
            int readerCount33 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id92_Type && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@Type = Read2_TypeMetadata(false, true);
                        paramsRead[0] = true;
                    }
                    else if (!paramsRead[3] && ((object)Reader.LocalName == (object)_id11_CmdletParameterMetadata && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@CmdletParameterMetadata = Read9_Item(false, true);
                        paramsRead[3] = true;
                    }
                    else if (!paramsRead[4] && ((object)Reader.LocalName == (object)_id30_CmdletOutputMetadata && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@CmdletOutputMetadata = Read23_CmdletOutputMetadata(false, true);
                        paramsRead[4] = true;
                    }
                    else
                    {
                        UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Type, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:CmdletParameterMetadata, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:CmdletOutputMetadata");
                    }
                }
                else
                {
                    UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Type, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:CmdletParameterMetadata, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:CmdletOutputMetadata");
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations33, ref readerCount33);
            }
            ReadEndElement();
            return o;
        }
</source>
</class>

<class classid="55" nclones="6" nlines="49" similarity="73">
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="5539" endline="5601" pcid="1701">
        private global::Microsoft.PowerShell.Cmdletization.Xml.CommonMethodMetadataReturnValue Read24_Item(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id4_Item && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.CommonMethodMetadataReturnValue o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.CommonMethodMetadataReturnValue();
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute())
            {
                if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations31 = 0;
            int readerCount31 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id92_Type && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@Type = Read2_TypeMetadata(false, true);
                        paramsRead[0] = true;
                    }
                    else if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id30_CmdletOutputMetadata && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@CmdletOutputMetadata = Read23_CmdletOutputMetadata(false, true);
                        paramsRead[1] = true;
                    }
                    else
                    {
                        UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Type, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:CmdletOutputMetadata");
                    }
                }
                else
                {
                    UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Type, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:CmdletOutputMetadata");
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations31, ref readerCount31);
            }
            ReadEndElement();
            return o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="7792" endline="7854" pcid="1724">
        private global::Microsoft.PowerShell.Cmdletization.Xml.AssociationAssociatedInstance Read41_AssociationAssociatedInstance(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id10_AssociationAssociatedInstance && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.AssociationAssociatedInstance o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.AssociationAssociatedInstance();
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute())
            {
                if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations62 = 0;
            int readerCount62 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id92_Type && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@Type = Read2_TypeMetadata(false, true);
                        paramsRead[0] = true;
                    }
                    else if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id11_CmdletParameterMetadata && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@CmdletParameterMetadata = Read12_Item(false, true);
                        paramsRead[1] = true;
                    }
                    else
                    {
                        UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Type, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:CmdletParameterMetadata");
                    }
                }
                else
                {
                    UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Type, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:CmdletParameterMetadata");
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations62, ref readerCount62);
            }
            ReadEndElement();
            return o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="8039" endline="8101" pcid="1728">
        private global::Microsoft.PowerShell.Cmdletization.Xml.CommonMethodMetadataReturnValue Read46_Item(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id32_Item && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.CommonMethodMetadataReturnValue o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.CommonMethodMetadataReturnValue();
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute())
            {
                if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations66 = 0;
            int readerCount66 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id92_Type && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@Type = Read2_TypeMetadata(false, true);
                        paramsRead[0] = true;
                    }
                    else if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id30_CmdletOutputMetadata && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@CmdletOutputMetadata = Read23_CmdletOutputMetadata(false, true);
                        paramsRead[1] = true;
                    }
                    else
                    {
                        UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Type, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:CmdletOutputMetadata");
                    }
                }
                else
                {
                    UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Type, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:CmdletOutputMetadata");
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations66, ref readerCount66);
            }
            ReadEndElement();
            return o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="7093" endline="7155" pcid="1716">
        private global::Microsoft.PowerShell.Cmdletization.Xml.GetCmdletMetadata Read22_GetCmdletMetadata(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id21_GetCmdletMetadata && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.GetCmdletMetadata o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.GetCmdletMetadata();
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute())
            {
                if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations51 = 0;
            int readerCount51 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id84_CmdletMetadata && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@CmdletMetadata = Read21_CommonCmdletMetadata(false, true);
                        paramsRead[0] = true;
                    }
                    else if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id6_GetCmdletParameters && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@GetCmdletParameters = Read19_GetCmdletParameters(false, true);
                        paramsRead[1] = true;
                    }
                    else
                    {
                        UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:CmdletMetadata, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:GetCmdletParameters");
                    }
                }
                else
                {
                    UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:CmdletMetadata, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:GetCmdletParameters");
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations51, ref readerCount51);
            }
            ReadEndElement();
            return o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="6314" endline="6376" pcid="1709">
        private global::Microsoft.PowerShell.Cmdletization.Xml.AssociationAssociatedInstance Read16_AssociationAssociatedInstance(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id4_Item && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.AssociationAssociatedInstance o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.AssociationAssociatedInstance();
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute())
            {
                if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations40 = 0;
            int readerCount40 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id92_Type && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@Type = Read2_TypeMetadata(false, true);
                        paramsRead[0] = true;
                    }
                    else if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id11_CmdletParameterMetadata && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@CmdletParameterMetadata = Read12_Item(false, true);
                        paramsRead[1] = true;
                    }
                    else
                    {
                        UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Type, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:CmdletParameterMetadata");
                    }
                }
                else
                {
                    UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Type, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:CmdletParameterMetadata");
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations40, ref readerCount40);
            }
            ReadEndElement();
            return o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="5971" endline="6038" pcid="1706">
        private global::Microsoft.PowerShell.Cmdletization.Xml.QueryOption Read18_QueryOption(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id20_QueryOption && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.QueryOption o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.QueryOption();
            bool[] paramsRead = new bool[3];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[2] && ((object)Reader.LocalName == (object)_id100_OptionName && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@OptionName = Reader.Value;
                    paramsRead[2] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":OptionName");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations36 = 0;
            int readerCount36 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id92_Type && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@Type = Read2_TypeMetadata(false, true);
                        paramsRead[0] = true;
                    }
                    else if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id11_CmdletParameterMetadata && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@CmdletParameterMetadata = Read11_Item(false, true);
                        paramsRead[1] = true;
                    }
                    else
                    {
                        UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Type, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:CmdletParameterMetadata");
                    }
                }
                else
                {
                    UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Type, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:CmdletParameterMetadata");
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations36, ref readerCount36);
            }
            ReadEndElement();
            return o;
        }
</source>
</class>

<class classid="56" nclones="3" nlines="73" similarity="82">
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="5603" endline="5699" pcid="1702">
        private global::Microsoft.PowerShell.Cmdletization.Xml.StaticCmdletMetadataCmdletMetadata Read33_Item(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id4_Item && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.StaticCmdletMetadataCmdletMetadata o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.StaticCmdletMetadataCmdletMetadata();
            global::System.String[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[7];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id96_Verb && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Verb = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[2] && ((object)Reader.LocalName == (object)_id97_Noun && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Noun = Reader.Value;
                    paramsRead[2] = true;
                }
                else if (((object)Reader.LocalName == (object)_id48_Aliases && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    string listValues = Reader.Value;
                    string[] vals = listValues.Split(null);
                    for (int i = 0; i < vals.Length; i++)
                    {
                        a_3 = (global::System.String[])EnsureArrayIndex(a_3, ca_3, typeof(global::System.String)); a_3[ca_3++] = vals[i];
                    }
                }
                else if (!paramsRead[4] && ((object)Reader.LocalName == (object)_id23_ConfirmImpact && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@ConfirmImpact = Read20_ConfirmImpact(Reader.Value);
                    o.@ConfirmImpactSpecified = true;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object)Reader.LocalName == (object)_id98_HelpUri && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@HelpUri = CollapseWhitespace(Reader.Value);
                    paramsRead[5] = true;
                }
                else if (!paramsRead[6] && ((object)Reader.LocalName == (object)_id99_DefaultCmdletParameterSet && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@DefaultCmdletParameterSet = Reader.Value;
                    paramsRead[6] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":Verb, :Noun, :Aliases, :ConfirmImpact, :HelpUri, :DefaultCmdletParameterSet");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                o.@Aliases = (global::System.String[])ShrinkArray(a_3, ca_3, typeof(global::System.String), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations32 = 0;
            int readerCount32 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id65_Obsolete && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@Obsolete = Read7_ObsoleteAttributeMetadata(false, true);
                        paramsRead[0] = true;
                    }
                    else
                    {
                        UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Obsolete");
                    }
                }
                else
                {
                    UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Obsolete");
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations32, ref readerCount32);
            }
            o.@Aliases = (global::System.String[])ShrinkArray(a_3, ca_3, typeof(global::System.String), true);
            ReadEndElement();
            return o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="6900" endline="6996" pcid="1714">
        private global::Microsoft.PowerShell.Cmdletization.Xml.StaticCmdletMetadataCmdletMetadata Read45_Item(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id25_Item && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.StaticCmdletMetadataCmdletMetadata o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.StaticCmdletMetadataCmdletMetadata();
            global::System.String[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[7];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id96_Verb && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Verb = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[2] && ((object)Reader.LocalName == (object)_id97_Noun && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Noun = Reader.Value;
                    paramsRead[2] = true;
                }
                else if (((object)Reader.LocalName == (object)_id48_Aliases && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    string listValues = Reader.Value;
                    string[] vals = listValues.Split(null);
                    for (int i = 0; i < vals.Length; i++)
                    {
                        a_3 = (global::System.String[])EnsureArrayIndex(a_3, ca_3, typeof(global::System.String)); a_3[ca_3++] = vals[i];
                    }
                }
                else if (!paramsRead[4] && ((object)Reader.LocalName == (object)_id23_ConfirmImpact && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@ConfirmImpact = Read20_ConfirmImpact(Reader.Value);
                    o.@ConfirmImpactSpecified = true;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object)Reader.LocalName == (object)_id98_HelpUri && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@HelpUri = CollapseWhitespace(Reader.Value);
                    paramsRead[5] = true;
                }
                else if (!paramsRead[6] && ((object)Reader.LocalName == (object)_id99_DefaultCmdletParameterSet && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@DefaultCmdletParameterSet = Reader.Value;
                    paramsRead[6] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":Verb, :Noun, :Aliases, :ConfirmImpact, :HelpUri, :DefaultCmdletParameterSet");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                o.@Aliases = (global::System.String[])ShrinkArray(a_3, ca_3, typeof(global::System.String), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations49 = 0;
            int readerCount49 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id65_Obsolete && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@Obsolete = Read7_ObsoleteAttributeMetadata(false, true);
                        paramsRead[0] = true;
                    }
                    else
                    {
                        UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Obsolete");
                    }
                }
                else
                {
                    UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Obsolete");
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations49, ref readerCount49);
            }
            o.@Aliases = (global::System.String[])ShrinkArray(a_3, ca_3, typeof(global::System.String), true);
            ReadEndElement();
            return o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="6998" endline="7091" pcid="1715">
        private global::Microsoft.PowerShell.Cmdletization.Xml.CommonCmdletMetadata Read21_CommonCmdletMetadata(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id22_CommonCmdletMetadata && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else if (((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id25_Item && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                    return Read45_Item(isNullable, false);
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.CommonCmdletMetadata o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.CommonCmdletMetadata();
            global::System.String[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[6];
            while (Reader.MoveToNextAttribute())
            {
                if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id96_Verb && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Verb = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[2] && ((object)Reader.LocalName == (object)_id97_Noun && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@Noun = Reader.Value;
                    paramsRead[2] = true;
                }
                else if (((object)Reader.LocalName == (object)_id48_Aliases && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    string listValues = Reader.Value;
                    string[] vals = listValues.Split(null);
                    for (int i = 0; i < vals.Length; i++)
                    {
                        a_3 = (global::System.String[])EnsureArrayIndex(a_3, ca_3, typeof(global::System.String)); a_3[ca_3++] = vals[i];
                    }
                }
                else if (!paramsRead[4] && ((object)Reader.LocalName == (object)_id23_ConfirmImpact && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@ConfirmImpact = Read20_ConfirmImpact(Reader.Value);
                    o.@ConfirmImpactSpecified = true;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object)Reader.LocalName == (object)_id98_HelpUri && (object)Reader.NamespaceURI == (object)_id4_Item))
                {
                    o.@HelpUri = CollapseWhitespace(Reader.Value);
                    paramsRead[5] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o, @":Verb, :Noun, :Aliases, :ConfirmImpact, :HelpUri");
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                o.@Aliases = (global::System.String[])ShrinkArray(a_3, ca_3, typeof(global::System.String), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations50 = 0;
            int readerCount50 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id65_Obsolete && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@Obsolete = Read7_ObsoleteAttributeMetadata(false, true);
                        paramsRead[0] = true;
                    }
                    else
                    {
                        UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Obsolete");
                    }
                }
                else
                {
                    UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Obsolete");
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations50, ref readerCount50);
            }
            o.@Aliases = (global::System.String[])ShrinkArray(a_3, ca_3, typeof(global::System.String), true);
            ReadEndElement();
            return o;
        }
</source>
</class>

<class classid="57" nclones="2" nlines="57" similarity="91">
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="7648" endline="7718" pcid="1722">
        private global::Microsoft.PowerShell.Cmdletization.Xml.ClassMetadataInstanceCmdlets Read32_ClassMetadataInstanceCmdlets(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id4_Item && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.ClassMetadataInstanceCmdlets o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.ClassMetadataInstanceCmdlets();
            global::Microsoft.PowerShell.Cmdletization.Xml.InstanceCmdletMetadata[] a_2 = null;
            int ca_2 = 0;
            bool[] paramsRead = new bool[3];
            while (Reader.MoveToNextAttribute())
            {
                if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                o.@Cmdlet = (global::Microsoft.PowerShell.Cmdletization.Xml.InstanceCmdletMetadata[])ShrinkArray(a_2, ca_2, typeof(global::Microsoft.PowerShell.Cmdletization.Xml.InstanceCmdletMetadata), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations60 = 0;
            int readerCount60 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id6_GetCmdletParameters && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@GetCmdletParameters = Read19_GetCmdletParameters(false, true);
                        paramsRead[0] = true;
                    }
                    else if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id120_GetCmdlet && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@GetCmdlet = Read22_GetCmdletMetadata(false, true);
                        paramsRead[1] = true;
                    }
                    else if (((object)Reader.LocalName == (object)_id79_Cmdlet && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        a_2 = (global::Microsoft.PowerShell.Cmdletization.Xml.InstanceCmdletMetadata[])EnsureArrayIndex(a_2, ca_2, typeof(global::Microsoft.PowerShell.Cmdletization.Xml.InstanceCmdletMetadata)); a_2[ca_2++] = Read31_InstanceCmdletMetadata(false, true);
                    }
                    else
                    {
                        UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:GetCmdletParameters, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:GetCmdlet, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Cmdlet");
                    }
                }
                else
                {
                    UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:GetCmdletParameters, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:GetCmdlet, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Cmdlet");
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations60, ref readerCount60);
            }
            o.@Cmdlet = (global::Microsoft.PowerShell.Cmdletization.Xml.InstanceCmdletMetadata[])ShrinkArray(a_2, ca_2, typeof(global::Microsoft.PowerShell.Cmdletization.Xml.InstanceCmdletMetadata), true);
            ReadEndElement();
            return o;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/cmdletization/xml/cmdlets-over-objects.xmlSerializer.autogen.cs.ifdefed" startline="7720" endline="7790" pcid="1723">
        private global::Microsoft.PowerShell.Cmdletization.Xml.ClassMetadataInstanceCmdlets Read40_ClassMetadataInstanceCmdlets(bool isNullable, bool checkType)
        {
            System.Xml.XmlQualifiedName xsiType = checkType ? GetXsiType() : null;
            bool isNull = false;
            if (isNullable) isNull = ReadNull();
            if (checkType)
            {
                if (xsiType == null || ((object)((System.Xml.XmlQualifiedName)xsiType).Name == (object)_id5_ClassMetadataInstanceCmdlets && (object)((System.Xml.XmlQualifiedName)xsiType).Namespace == (object)_id2_Item))
                {
                }
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)xsiType);
            }
            if (isNull) return null;
            global::Microsoft.PowerShell.Cmdletization.Xml.ClassMetadataInstanceCmdlets o;
            o = new global::Microsoft.PowerShell.Cmdletization.Xml.ClassMetadataInstanceCmdlets();
            global::Microsoft.PowerShell.Cmdletization.Xml.InstanceCmdletMetadata[] a_2 = null;
            int ca_2 = 0;
            bool[] paramsRead = new bool[3];
            while (Reader.MoveToNextAttribute())
            {
                if (!IsXmlnsAttribute(Reader.Name))
                {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement)
            {
                Reader.Skip();
                o.@Cmdlet = (global::Microsoft.PowerShell.Cmdletization.Xml.InstanceCmdletMetadata[])ShrinkArray(a_2, ca_2, typeof(global::Microsoft.PowerShell.Cmdletization.Xml.InstanceCmdletMetadata), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            int whileIterations61 = 0;
            int readerCount61 = ReaderCount;
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement && Reader.NodeType != System.Xml.XmlNodeType.None)
            {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element)
                {
                    if (!paramsRead[0] && ((object)Reader.LocalName == (object)_id6_GetCmdletParameters && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@GetCmdletParameters = Read19_GetCmdletParameters(false, true);
                        paramsRead[0] = true;
                    }
                    else if (!paramsRead[1] && ((object)Reader.LocalName == (object)_id120_GetCmdlet && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        o.@GetCmdlet = Read22_GetCmdletMetadata(false, true);
                        paramsRead[1] = true;
                    }
                    else if (((object)Reader.LocalName == (object)_id79_Cmdlet && (object)Reader.NamespaceURI == (object)_id2_Item))
                    {
                        a_2 = (global::Microsoft.PowerShell.Cmdletization.Xml.InstanceCmdletMetadata[])EnsureArrayIndex(a_2, ca_2, typeof(global::Microsoft.PowerShell.Cmdletization.Xml.InstanceCmdletMetadata)); a_2[ca_2++] = Read31_InstanceCmdletMetadata(false, true);
                    }
                    else
                    {
                        UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:GetCmdletParameters, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:GetCmdlet, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Cmdlet");
                    }
                }
                else
                {
                    UnknownNode((object)o, @"http://schemas.microsoft.com/cmdlets-over-objects/2009/11:GetCmdletParameters, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:GetCmdlet, http://schemas.microsoft.com/cmdlets-over-objects/2009/11:Cmdlet");
                }
                Reader.MoveToContent();
                CheckReaderCount(ref whileIterations61, ref readerCount61);
            }
            o.@Cmdlet = (global::Microsoft.PowerShell.Cmdletization.Xml.InstanceCmdletMetadata[])ShrinkArray(a_2, ca_2, typeof(global::Microsoft.PowerShell.Cmdletization.Xml.InstanceCmdletMetadata), true);
            ReadEndElement();
            return o;
        }
</source>
</class>

<class classid="58" nclones="2" nlines="14" similarity="71">
<source file="PowerShell/src/System.Management.Automation/cimSupport/other/ciminstancetypeadapter.cs.ifdefed" startline="158" endline="177" pcid="1856">
        public override string GetPropertyTypeName(PSAdaptedProperty adaptedProperty)
        {
            if (adaptedProperty == null)
            {
                throw new ArgumentNullException("adaptedProperty");
            }

            CimProperty cimProperty = adaptedProperty.Tag as CimProperty;
            if (cimProperty != null)
            {
                return CimTypeToTypeNameDisplayString(cimProperty.CimType);
            }

            if (adaptedProperty.Name.Equals(RemotingConstants.ComputerNameNoteProperty, StringComparison.OrdinalIgnoreCase))
            {
                return ToStringCodeMethods.Type(typeof(string));
            }

            throw new ArgumentNullException("adaptedProperty");
        }
</source>
<source file="PowerShell/src/System.Management.Automation/cimSupport/other/ciminstancetypeadapter.cs.ifdefed" startline="183" endline="203" pcid="1857">
        public override object GetPropertyValue(PSAdaptedProperty adaptedProperty)
        {
            if (adaptedProperty == null)
            {
                throw new ArgumentNullException("adaptedProperty");
            }

            CimProperty cimProperty = adaptedProperty.Tag as CimProperty;
            if (cimProperty != null)
            {
                return cimProperty.Value;
            }

            if (adaptedProperty.Name.Equals(RemotingConstants.ComputerNameNoteProperty, StringComparison.OrdinalIgnoreCase))
            {
                CimInstance cimInstance = (CimInstance)adaptedProperty.Tag;
                return cimInstance.GetCimSessionComputerName();
            }

            throw new ArgumentNullException("adaptedProperty");
        }
</source>
</class>

<class classid="59" nclones="2" nlines="23" similarity="91">
<source file="PowerShell/src/System.Management.Automation/engine/CommandCompletion/CommandCompletion.cs.ifdefed" startline="442" endline="476" pcid="2028">
        private static CommandCompletion CallScriptWithStringParameterSet(string input, int cursorIndex, Hashtable options, PowerShell powershell)
        {
            try
            {
                powershell.Commands.Clear();
                powershell.AddCommand("TabExpansion2")
                    .AddArgument(input)
                    .AddArgument(cursorIndex)
                    .AddArgument(options);
                var results = powershell.Invoke();
                if (results == null)
                {
                    return s_emptyCommandCompletion;
                }

                if (results.Count == 1)
                {
                    var result = PSObject.Base(results[0]);
                    var commandCompletion = result as CommandCompletion;
                    if (commandCompletion != null)
                    {
                        return commandCompletion;
                    }
                }
            }
            catch (Exception)
            {
            }
            finally
            {
                powershell.Commands.Clear();
            }

            return s_emptyCommandCompletion;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/CommandCompletion/CommandCompletion.cs.ifdefed" startline="478" endline="513" pcid="2029">
        private static CommandCompletion CallScriptWithAstParameterSet(Ast ast, Token[] tokens, IScriptPosition cursorPosition, Hashtable options, PowerShell powershell)
        {
            try
            {
                powershell.Commands.Clear();
                powershell.AddCommand("TabExpansion2")
                    .AddArgument(ast)
                    .AddArgument(tokens)
                    .AddArgument(cursorPosition)
                    .AddArgument(options);
                var results = powershell.Invoke();
                if (results == null)
                {
                    return s_emptyCommandCompletion;
                }

                if (results.Count == 1)
                {
                    var result = PSObject.Base(results[0]);
                    var commandCompletion = result as CommandCompletion;
                    if (commandCompletion != null)
                    {
                        return commandCompletion;
                    }
                }
            }
            catch (Exception)
            {
            }
            finally
            {
                powershell.Commands.Clear();
            }

            return s_emptyCommandCompletion;
        }
</source>
</class>

<class classid="60" nclones="2" nlines="21" similarity="80">
<source file="PowerShell/src/System.Management.Automation/engine/ErrorPackage.cs.ifdefed" startline="777" endline="809" pcid="2136">
        private string BuildMessage(
            Cmdlet cmdlet,
            string baseName,
            string resourceId,
            params object[] args)
        {
            if (cmdlet == null)
                throw PSTraceSource.NewArgumentNullException("cmdlet");

            if (String.IsNullOrEmpty(baseName))
                throw PSTraceSource.NewArgumentNullException("baseName");

            if (String.IsNullOrEmpty(resourceId))
                throw PSTraceSource.NewArgumentNullException("resourceId");

            string template = string.Empty;

            try
            {
                template = cmdlet.GetResourceString(baseName, resourceId);
            }
            catch (MissingManifestResourceException e)
            {
                _textLookupError = e;
                return string.Empty; // fallback to Exception.Message
            }
            catch (ArgumentException e)
            {
                _textLookupError = e;
                return string.Empty; // fallback to Exception.Message
            }
            return BuildMessage(template, baseName, resourceId, args);
        } // BuildMessage
</source>
<source file="PowerShell/src/System.Management.Automation/engine/ErrorPackage.cs.ifdefed" startline="810" endline="842" pcid="2137">
        private string BuildMessage(
            IResourceSupplier resourceSupplier,
            string baseName,
            string resourceId,
            params object[] args)
        {
            if (resourceSupplier == null)
                throw PSTraceSource.NewArgumentNullException("resourceSupplier");

            if (String.IsNullOrEmpty(baseName))
                throw PSTraceSource.NewArgumentNullException("baseName");

            if (String.IsNullOrEmpty(resourceId))
                throw PSTraceSource.NewArgumentNullException("resourceId");

            string template = string.Empty;

            try
            {
                template = resourceSupplier.GetResourceString(baseName, resourceId);
            }
            catch (MissingManifestResourceException e)
            {
                _textLookupError = e;
                return string.Empty; // fallback to Exception.Message
            }
            catch (ArgumentException e)
            {
                _textLookupError = e;
                return string.Empty; // fallback to Exception.Message
            }
            return BuildMessage(template, baseName, resourceId, args);
        } // BuildMessage
</source>
</class>

<class classid="61" nclones="5" nlines="17" similarity="70">
<source file="PowerShell/src/System.Management.Automation/engine/hostifaces/InternalHostRawUserInterface.cs.ifdefed" startline="345" endline="371" pcid="2212">
        public override
        KeyInfo
        ReadKey(ReadKeyOptions options)
        {
            if (_externalRawUI == null)
            {
                ThrowNotInteractive();
            }
            KeyInfo result = new KeyInfo();
            try
            {
                result = _externalRawUI.ReadKey(options);
            }
            catch (PipelineStoppedException)
            {
                //PipelineStoppedException is thrown by host when it wants
                //to stop the pipeline.
                LocalPipeline lpl = (LocalPipeline)((RunspaceBase)_parentHost.Context.CurrentRunspace).GetCurrentlyRunningPipeline();
                if (lpl == null)
                {
                    throw;
                }
                lpl.Stopper.Stop();
            }

            return result;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/hostifaces/InternalHostUserInterface.cs.ifdefed" startline="92" endline="119" pcid="2223">
        public override
        string
        ReadLine()
        {
            if (_externalUI == null)
            {
                ThrowNotInteractive();
            }

            string result = null;
            try
            {
                result = _externalUI.ReadLine();
            }
            catch (PipelineStoppedException)
            {
                //PipelineStoppedException is thrown by host when it wants
                //to stop the pipeline.
                LocalPipeline lpl = (LocalPipeline)((RunspaceBase)_parent.Context.CurrentRunspace).GetCurrentlyRunningPipeline();
                if (lpl == null)
                {
                    throw;
                }
                lpl.Stopper.Stop();
            }

            return result;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/hostifaces/InternalHostUserInterface.cs.ifdefed" startline="129" endline="157" pcid="2224">
        public override
        SecureString
        ReadLineAsSecureString()
        {
            if (_externalUI == null)
            {
                ThrowNotInteractive();
            }

            SecureString result = null;

            try
            {
                result = _externalUI.ReadLineAsSecureString();
            }
            catch (PipelineStoppedException)
            {
                //PipelineStoppedException is thrown by host when it wants
                //to stop the pipeline.
                LocalPipeline lpl = (LocalPipeline)((RunspaceBase)_parent.Context.CurrentRunspace).GetCurrentlyRunningPipeline();
                if (lpl == null)
                {
                    throw;
                }
                lpl.Stopper.Stop();
            }

            return result;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/hostifaces/InternalHostUserInterface.cs.ifdefed" startline="777" endline="804" pcid="2251">
        public override
        int
        PromptForChoice(string caption, string message, Collection<ChoiceDescription> choices, int defaultChoice)
        {
            if (_externalUI == null)
            {
                ThrowPromptNotInteractive(message);
            }

            int result = -1;
            try
            {
                result = _externalUI.PromptForChoice(caption, message, choices, defaultChoice);
            }
            catch (PipelineStoppedException)
            {
                //PipelineStoppedException is thrown by host when it wants
                //to stop the pipeline.
                LocalPipeline lpl = (LocalPipeline)((RunspaceBase)_parent.Context.CurrentRunspace).GetCurrentlyRunningPipeline();
                if (lpl == null)
                {
                    throw;
                }
                lpl.Stopper.Stop();
            }

            return result;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/hostifaces/internalHostuserInterfacesecurity.cs.ifdefed" startline="37" endline="72" pcid="2255">
        public override
        PSCredential
        PromptForCredential
        (
            string caption,
            string message,
            string userName,
            string targetName,
            PSCredentialTypes allowedCredentialTypes,
            PSCredentialUIOptions options
        )
        {
            if (_externalUI == null)
            {
                ThrowPromptNotInteractive(message);
            }

            PSCredential result = null;
            try
            {
                result = _externalUI.PromptForCredential(caption, message, userName, targetName, allowedCredentialTypes, options);
            }
            catch (PipelineStoppedException)
            {
                //PipelineStoppedException is thrown by host when it wants
                //to stop the pipeline.
                LocalPipeline lpl = (LocalPipeline)((RunspaceBase)_parent.Context.CurrentRunspace).GetCurrentlyRunningPipeline();
                if (lpl == null)
                {
                    throw;
                }
                lpl.Stopper.Stop();
            }

            return result;
        }
</source>
</class>

<class classid="62" nclones="3" nlines="11" similarity="72">
<source file="PowerShell/src/System.Management.Automation/engine/hostifaces/PSCommand.cs.ifdefed" startline="87" endline="102" pcid="2310">
        public PSCommand AddCommand(string command)
        {
            if (command == null)
            {
                throw PSTraceSource.NewArgumentNullException("cmdlet");
            }
            if (_owner != null)
            {
                _owner.AssertChangesAreAccepted();
            }

            _currentCommand = new Command(command, false);
            _commands.Add(_currentCommand);

            return this;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/hostifaces/PSCommand.cs.ifdefed" startline="252" endline="267" pcid="2314">
        public PSCommand AddCommand(Command command)
        {
            if (command == null)
            {
                throw PSTraceSource.NewArgumentNullException("command");
            }
            if (_owner != null)
            {
                _owner.AssertChangesAreAccepted();
            }

            _currentCommand = command;
            _commands.Add(_currentCommand);

            return this;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/hostifaces/PSCommand.cs.ifdefed" startline="130" endline="145" pcid="2311">
        public PSCommand AddCommand(string cmdlet, bool useLocalScope)
        {
            if (cmdlet == null)
            {
                throw PSTraceSource.NewArgumentNullException("cmdlet");
            }
            if (_owner != null)
            {
                _owner.AssertChangesAreAccepted();
            }

            _currentCommand = new Command(cmdlet, false, useLocalScope);
            _commands.Add(_currentCommand);

            return this;
        }
</source>
</class>

<class classid="63" nclones="2" nlines="11" similarity="81">
<source file="PowerShell/src/System.Management.Automation/engine/hostifaces/PSCommand.cs.ifdefed" startline="171" endline="186" pcid="2312">
        public PSCommand AddScript(string script)
        {
            if (script == null)
            {
                throw PSTraceSource.NewArgumentNullException("script");
            }
            if (_owner != null)
            {
                _owner.AssertChangesAreAccepted();
            }

            _currentCommand = new Command(script, true);
            _commands.Add(_currentCommand);

            return this;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/hostifaces/PSCommand.cs.ifdefed" startline="215" endline="230" pcid="2313">
        public PSCommand AddScript(string script, bool useLocalScope)
        {
            if (script == null)
            {
                throw PSTraceSource.NewArgumentNullException("script");
            }
            if (_owner != null)
            {
                _owner.AssertChangesAreAccepted();
            }

            _currentCommand = new Command(script, true, useLocalScope);
            _commands.Add(_currentCommand);

            return this;
        }
</source>
</class>

<class classid="64" nclones="3" nlines="10" similarity="80">
<source file="PowerShell/src/System.Management.Automation/engine/hostifaces/PSCommand.cs.ifdefed" startline="297" endline="310" pcid="2315">
        public PSCommand AddParameter(string parameterName, object value)
        {
            if (_currentCommand == null)
            {
                throw PSTraceSource.NewInvalidOperationException(PSCommandStrings.ParameterRequiresCommand,
                                                                 new object[] { "PSCommand" });
            }
            if (_owner != null)
            {
                _owner.AssertChangesAreAccepted();
            }
            _currentCommand.Parameters.Add(parameterName, value);
            return this;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/hostifaces/PSCommand.cs.ifdefed" startline="377" endline="390" pcid="2317">
        public PSCommand AddArgument(object value)
        {
            if (_currentCommand == null)
            {
                throw PSTraceSource.NewInvalidOperationException(PSCommandStrings.ParameterRequiresCommand,
                                                                 new object[] { "PSCommand" });
            }
            if (_owner != null)
            {
                _owner.AssertChangesAreAccepted();
            }
            _currentCommand.Parameters.Add(null, value);
            return this;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/hostifaces/PSCommand.cs.ifdefed" startline="337" endline="350" pcid="2316">
        public PSCommand AddParameter(string parameterName)
        {
            if (_currentCommand == null)
            {
                throw PSTraceSource.NewInvalidOperationException(PSCommandStrings.ParameterRequiresCommand,
                                                                 new object[] { "PSCommand" });
            }
            if (_owner != null)
            {
                _owner.AssertChangesAreAccepted();
            }
            _currentCommand.Parameters.Add(parameterName, true);
            return this;
        }
</source>
</class>

<class classid="65" nclones="2" nlines="16" similarity="87">
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/CallInstruction.cs.ifdefed" startline="278" endline="300" pcid="2374">
        public override object InvokeInstance(object instance, params object[] args)
        {
            if (_target.IsStatic)
            {
                try
                {
                    return _target.Invoke(null, args);
                }
                catch (TargetInvocationException e)
                {
                    throw ExceptionHelpers.UpdateForRethrow(e.InnerException);
                }
            }

            try
            {
                return _target.Invoke(instance, args);
            }
            catch (TargetInvocationException e)
            {
                throw ExceptionHelpers.UpdateForRethrow(e.InnerException);
            }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/CallInstruction.cs.ifdefed" startline="302" endline="324" pcid="2375">
        private object InvokeWorker(params object[] args)
        {
            if (_target.IsStatic)
            {
                try
                {
                    return _target.Invoke(null, args);
                }
                catch (TargetInvocationException e)
                {
                    throw ExceptionHelpers.UpdateForRethrow(e.InnerException);
                }
            }

            try
            {
                return _target.Invoke(args[0], GetNonStaticArgs(args));
            }
            catch (TargetInvocationException e)
            {
                throw ExceptionHelpers.UpdateForRethrow(e.InnerException);
            }
        }
</source>
</class>

<class classid="66" nclones="32" nlines="20" similarity="70">
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="28" endline="37" pcid="2713">
        internal TRet Run0<TRet>() {
            if (_compiled != null || TryGetCompiled()) {
                return ((Func<TRet>)_compiled)();
            }

            var frame = MakeFrame();
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
            return (TRet)frame.Pop();
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="56" endline="66" pcid="2717">
        internal TRet Run1<T0,TRet>(T0 arg0) {
            if (_compiled != null || TryGetCompiled()) {
                return ((Func<T0,TRet>)_compiled)(arg0);
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
            return (TRet)frame.Pop();
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="86" endline="97" pcid="2721">
        internal TRet Run2<T0,T1,TRet>(T0 arg0,T1 arg1) {
            if (_compiled != null || TryGetCompiled()) {
                return ((Func<T0,T1,TRet>)_compiled)(arg0, arg1);
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            frame.Data[1] = arg1;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
            return (TRet)frame.Pop();
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="118" endline="130" pcid="2725">
        internal TRet Run3<T0,T1,T2,TRet>(T0 arg0,T1 arg1,T2 arg2) {
            if (_compiled != null || TryGetCompiled()) {
                return ((Func<T0,T1,T2,TRet>)_compiled)(arg0, arg1, arg2);
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            frame.Data[1] = arg1;
            frame.Data[2] = arg2;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
            return (TRet)frame.Pop();
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="68" endline="78" pcid="2718">
        internal void RunVoid1<T0>(T0 arg0) {
            if (_compiled != null || TryGetCompiled()) {
                ((Action<T0>)_compiled)(arg0);
                return;
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="39" endline="48" pcid="2714">
        internal void RunVoid0() {
            if (_compiled != null || TryGetCompiled()) {
                ((Action)_compiled)();
                return;
            }

            var frame = MakeFrame();
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="152" endline="165" pcid="2729">
        internal TRet Run4<T0,T1,T2,T3,TRet>(T0 arg0,T1 arg1,T2 arg2,T3 arg3) {
            if (_compiled != null || TryGetCompiled()) {
                return ((Func<T0,T1,T2,T3,TRet>)_compiled)(arg0, arg1, arg2, arg3);
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            frame.Data[1] = arg1;
            frame.Data[2] = arg2;
            frame.Data[3] = arg3;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
            return (TRet)frame.Pop();
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="132" endline="144" pcid="2726">
        internal void RunVoid3<T0,T1,T2>(T0 arg0,T1 arg1,T2 arg2) {
            if (_compiled != null || TryGetCompiled()) {
                ((Action<T0,T1,T2>)_compiled)(arg0, arg1, arg2);
                return;
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            frame.Data[1] = arg1;
            frame.Data[2] = arg2;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="99" endline="110" pcid="2722">
        internal void RunVoid2<T0,T1>(T0 arg0,T1 arg1) {
            if (_compiled != null || TryGetCompiled()) {
                ((Action<T0,T1>)_compiled)(arg0, arg1);
                return;
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            frame.Data[1] = arg1;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="167" endline="180" pcid="2730">
        internal void RunVoid4<T0,T1,T2,T3>(T0 arg0,T1 arg1,T2 arg2,T3 arg3) {
            if (_compiled != null || TryGetCompiled()) {
                ((Action<T0,T1,T2,T3>)_compiled)(arg0, arg1, arg2, arg3);
                return;
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            frame.Data[1] = arg1;
            frame.Data[2] = arg2;
            frame.Data[3] = arg3;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="188" endline="202" pcid="2733">
        internal TRet Run5<T0,T1,T2,T3,T4,TRet>(T0 arg0,T1 arg1,T2 arg2,T3 arg3,T4 arg4) {
            if (_compiled != null || TryGetCompiled()) {
                return ((Func<T0,T1,T2,T3,T4,TRet>)_compiled)(arg0, arg1, arg2, arg3, arg4);
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            frame.Data[1] = arg1;
            frame.Data[2] = arg2;
            frame.Data[3] = arg3;
            frame.Data[4] = arg4;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
            return (TRet)frame.Pop();
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="226" endline="241" pcid="2737">
        internal TRet Run6<T0,T1,T2,T3,T4,T5,TRet>(T0 arg0,T1 arg1,T2 arg2,T3 arg3,T4 arg4,T5 arg5) {
            if (_compiled != null || TryGetCompiled()) {
                return ((Func<T0,T1,T2,T3,T4,T5,TRet>)_compiled)(arg0, arg1, arg2, arg3, arg4, arg5);
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            frame.Data[1] = arg1;
            frame.Data[2] = arg2;
            frame.Data[3] = arg3;
            frame.Data[4] = arg4;
            frame.Data[5] = arg5;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
            return (TRet)frame.Pop();
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="266" endline="282" pcid="2741">
        internal TRet Run7<T0,T1,T2,T3,T4,T5,T6,TRet>(T0 arg0,T1 arg1,T2 arg2,T3 arg3,T4 arg4,T5 arg5,T6 arg6) {
            if (_compiled != null || TryGetCompiled()) {
                return ((Func<T0,T1,T2,T3,T4,T5,T6,TRet>)_compiled)(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            frame.Data[1] = arg1;
            frame.Data[2] = arg2;
            frame.Data[3] = arg3;
            frame.Data[4] = arg4;
            frame.Data[5] = arg5;
            frame.Data[6] = arg6;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
            return (TRet)frame.Pop();
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="243" endline="258" pcid="2738">
        internal void RunVoid6<T0,T1,T2,T3,T4,T5>(T0 arg0,T1 arg1,T2 arg2,T3 arg3,T4 arg4,T5 arg5) {
            if (_compiled != null || TryGetCompiled()) {
                ((Action<T0,T1,T2,T3,T4,T5>)_compiled)(arg0, arg1, arg2, arg3, arg4, arg5);
                return;
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            frame.Data[1] = arg1;
            frame.Data[2] = arg2;
            frame.Data[3] = arg3;
            frame.Data[4] = arg4;
            frame.Data[5] = arg5;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="204" endline="218" pcid="2734">
        internal void RunVoid5<T0,T1,T2,T3,T4>(T0 arg0,T1 arg1,T2 arg2,T3 arg3,T4 arg4) {
            if (_compiled != null || TryGetCompiled()) {
                ((Action<T0,T1,T2,T3,T4>)_compiled)(arg0, arg1, arg2, arg3, arg4);
                return;
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            frame.Data[1] = arg1;
            frame.Data[2] = arg2;
            frame.Data[3] = arg3;
            frame.Data[4] = arg4;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="308" endline="325" pcid="2745">
        internal TRet Run8<T0,T1,T2,T3,T4,T5,T6,T7,TRet>(T0 arg0,T1 arg1,T2 arg2,T3 arg3,T4 arg4,T5 arg5,T6 arg6,T7 arg7) {
            if (_compiled != null || TryGetCompiled()) {
                return ((Func<T0,T1,T2,T3,T4,T5,T6,T7,TRet>)_compiled)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            frame.Data[1] = arg1;
            frame.Data[2] = arg2;
            frame.Data[3] = arg3;
            frame.Data[4] = arg4;
            frame.Data[5] = arg5;
            frame.Data[6] = arg6;
            frame.Data[7] = arg7;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
            return (TRet)frame.Pop();
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="284" endline="300" pcid="2742">
        internal void RunVoid7<T0,T1,T2,T3,T4,T5,T6>(T0 arg0,T1 arg1,T2 arg2,T3 arg3,T4 arg4,T5 arg5,T6 arg6) {
            if (_compiled != null || TryGetCompiled()) {
                ((Action<T0,T1,T2,T3,T4,T5,T6>)_compiled)(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
                return;
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            frame.Data[1] = arg1;
            frame.Data[2] = arg2;
            frame.Data[3] = arg3;
            frame.Data[4] = arg4;
            frame.Data[5] = arg5;
            frame.Data[6] = arg6;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="327" endline="344" pcid="2746">
        internal void RunVoid8<T0,T1,T2,T3,T4,T5,T6,T7>(T0 arg0,T1 arg1,T2 arg2,T3 arg3,T4 arg4,T5 arg5,T6 arg6,T7 arg7) {
            if (_compiled != null || TryGetCompiled()) {
                ((Action<T0,T1,T2,T3,T4,T5,T6,T7>)_compiled)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                return;
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            frame.Data[1] = arg1;
            frame.Data[2] = arg2;
            frame.Data[3] = arg3;
            frame.Data[4] = arg4;
            frame.Data[5] = arg5;
            frame.Data[6] = arg6;
            frame.Data[7] = arg7;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="352" endline="370" pcid="2749">
        internal TRet Run9<T0,T1,T2,T3,T4,T5,T6,T7,T8,TRet>(T0 arg0,T1 arg1,T2 arg2,T3 arg3,T4 arg4,T5 arg5,T6 arg6,T7 arg7,T8 arg8) {
            if (_compiled != null || TryGetCompiled()) {
                return ((Func<T0,T1,T2,T3,T4,T5,T6,T7,T8,TRet>)_compiled)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            frame.Data[1] = arg1;
            frame.Data[2] = arg2;
            frame.Data[3] = arg3;
            frame.Data[4] = arg4;
            frame.Data[5] = arg5;
            frame.Data[6] = arg6;
            frame.Data[7] = arg7;
            frame.Data[8] = arg8;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
            return (TRet)frame.Pop();
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="398" endline="417" pcid="2753">
        internal TRet Run10<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,TRet>(T0 arg0,T1 arg1,T2 arg2,T3 arg3,T4 arg4,T5 arg5,T6 arg6,T7 arg7,T8 arg8,T9 arg9) {
            if (_compiled != null || TryGetCompiled()) {
                return ((Func<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,TRet>)_compiled)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            frame.Data[1] = arg1;
            frame.Data[2] = arg2;
            frame.Data[3] = arg3;
            frame.Data[4] = arg4;
            frame.Data[5] = arg5;
            frame.Data[6] = arg6;
            frame.Data[7] = arg7;
            frame.Data[8] = arg8;
            frame.Data[9] = arg9;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
            return (TRet)frame.Pop();
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="419" endline="438" pcid="2754">
        internal void RunVoid10<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9>(T0 arg0,T1 arg1,T2 arg2,T3 arg3,T4 arg4,T5 arg5,T6 arg6,T7 arg7,T8 arg8,T9 arg9) {
            if (_compiled != null || TryGetCompiled()) {
                ((Action<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9>)_compiled)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
                return;
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            frame.Data[1] = arg1;
            frame.Data[2] = arg2;
            frame.Data[3] = arg3;
            frame.Data[4] = arg4;
            frame.Data[5] = arg5;
            frame.Data[6] = arg6;
            frame.Data[7] = arg7;
            frame.Data[8] = arg8;
            frame.Data[9] = arg9;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="446" endline="466" pcid="2757">
        internal TRet Run11<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,TRet>(T0 arg0,T1 arg1,T2 arg2,T3 arg3,T4 arg4,T5 arg5,T6 arg6,T7 arg7,T8 arg8,T9 arg9,T10 arg10) {
            if (_compiled != null || TryGetCompiled()) {
                return ((Func<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,TRet>)_compiled)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            frame.Data[1] = arg1;
            frame.Data[2] = arg2;
            frame.Data[3] = arg3;
            frame.Data[4] = arg4;
            frame.Data[5] = arg5;
            frame.Data[6] = arg6;
            frame.Data[7] = arg7;
            frame.Data[8] = arg8;
            frame.Data[9] = arg9;
            frame.Data[10] = arg10;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
            return (TRet)frame.Pop();
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="372" endline="390" pcid="2750">
        internal void RunVoid9<T0,T1,T2,T3,T4,T5,T6,T7,T8>(T0 arg0,T1 arg1,T2 arg2,T3 arg3,T4 arg4,T5 arg5,T6 arg6,T7 arg7,T8 arg8) {
            if (_compiled != null || TryGetCompiled()) {
                ((Action<T0,T1,T2,T3,T4,T5,T6,T7,T8>)_compiled)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                return;
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            frame.Data[1] = arg1;
            frame.Data[2] = arg2;
            frame.Data[3] = arg3;
            frame.Data[4] = arg4;
            frame.Data[5] = arg5;
            frame.Data[6] = arg6;
            frame.Data[7] = arg7;
            frame.Data[8] = arg8;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="548" endline="570" pcid="2765">
        internal TRet Run13<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,TRet>(T0 arg0,T1 arg1,T2 arg2,T3 arg3,T4 arg4,T5 arg5,T6 arg6,T7 arg7,T8 arg8,T9 arg9,T10 arg10,T11 arg11,T12 arg12) {
            if (_compiled != null || TryGetCompiled()) {
                return ((Func<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,TRet>)_compiled)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            frame.Data[1] = arg1;
            frame.Data[2] = arg2;
            frame.Data[3] = arg3;
            frame.Data[4] = arg4;
            frame.Data[5] = arg5;
            frame.Data[6] = arg6;
            frame.Data[7] = arg7;
            frame.Data[8] = arg8;
            frame.Data[9] = arg9;
            frame.Data[10] = arg10;
            frame.Data[11] = arg11;
            frame.Data[12] = arg12;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
            return (TRet)frame.Pop();
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="468" endline="488" pcid="2758">
        internal void RunVoid11<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10>(T0 arg0,T1 arg1,T2 arg2,T3 arg3,T4 arg4,T5 arg5,T6 arg6,T7 arg7,T8 arg8,T9 arg9,T10 arg10) {
            if (_compiled != null || TryGetCompiled()) {
                ((Action<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10>)_compiled)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
                return;
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            frame.Data[1] = arg1;
            frame.Data[2] = arg2;
            frame.Data[3] = arg3;
            frame.Data[4] = arg4;
            frame.Data[5] = arg5;
            frame.Data[6] = arg6;
            frame.Data[7] = arg7;
            frame.Data[8] = arg8;
            frame.Data[9] = arg9;
            frame.Data[10] = arg10;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="496" endline="517" pcid="2761">
        internal TRet Run12<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,TRet>(T0 arg0,T1 arg1,T2 arg2,T3 arg3,T4 arg4,T5 arg5,T6 arg6,T7 arg7,T8 arg8,T9 arg9,T10 arg10,T11 arg11) {
            if (_compiled != null || TryGetCompiled()) {
                return ((Func<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,TRet>)_compiled)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            frame.Data[1] = arg1;
            frame.Data[2] = arg2;
            frame.Data[3] = arg3;
            frame.Data[4] = arg4;
            frame.Data[5] = arg5;
            frame.Data[6] = arg6;
            frame.Data[7] = arg7;
            frame.Data[8] = arg8;
            frame.Data[9] = arg9;
            frame.Data[10] = arg10;
            frame.Data[11] = arg11;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
            return (TRet)frame.Pop();
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="602" endline="625" pcid="2769">
        internal TRet Run14<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,TRet>(T0 arg0,T1 arg1,T2 arg2,T3 arg3,T4 arg4,T5 arg5,T6 arg6,T7 arg7,T8 arg8,T9 arg9,T10 arg10,T11 arg11,T12 arg12,T13 arg13) {
            if (_compiled != null || TryGetCompiled()) {
                return ((Func<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,TRet>)_compiled)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            frame.Data[1] = arg1;
            frame.Data[2] = arg2;
            frame.Data[3] = arg3;
            frame.Data[4] = arg4;
            frame.Data[5] = arg5;
            frame.Data[6] = arg6;
            frame.Data[7] = arg7;
            frame.Data[8] = arg8;
            frame.Data[9] = arg9;
            frame.Data[10] = arg10;
            frame.Data[11] = arg11;
            frame.Data[12] = arg12;
            frame.Data[13] = arg13;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
            return (TRet)frame.Pop();
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="519" endline="540" pcid="2762">
        internal void RunVoid12<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11>(T0 arg0,T1 arg1,T2 arg2,T3 arg3,T4 arg4,T5 arg5,T6 arg6,T7 arg7,T8 arg8,T9 arg9,T10 arg10,T11 arg11) {
            if (_compiled != null || TryGetCompiled()) {
                ((Action<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11>)_compiled)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
                return;
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            frame.Data[1] = arg1;
            frame.Data[2] = arg2;
            frame.Data[3] = arg3;
            frame.Data[4] = arg4;
            frame.Data[5] = arg5;
            frame.Data[6] = arg6;
            frame.Data[7] = arg7;
            frame.Data[8] = arg8;
            frame.Data[9] = arg9;
            frame.Data[10] = arg10;
            frame.Data[11] = arg11;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="572" endline="594" pcid="2766">
        internal void RunVoid13<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12>(T0 arg0,T1 arg1,T2 arg2,T3 arg3,T4 arg4,T5 arg5,T6 arg6,T7 arg7,T8 arg8,T9 arg9,T10 arg10,T11 arg11,T12 arg12) {
            if (_compiled != null || TryGetCompiled()) {
                ((Action<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12>)_compiled)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
                return;
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            frame.Data[1] = arg1;
            frame.Data[2] = arg2;
            frame.Data[3] = arg3;
            frame.Data[4] = arg4;
            frame.Data[5] = arg5;
            frame.Data[6] = arg6;
            frame.Data[7] = arg7;
            frame.Data[8] = arg8;
            frame.Data[9] = arg9;
            frame.Data[10] = arg10;
            frame.Data[11] = arg11;
            frame.Data[12] = arg12;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="627" endline="650" pcid="2770">
        internal void RunVoid14<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13>(T0 arg0,T1 arg1,T2 arg2,T3 arg3,T4 arg4,T5 arg5,T6 arg6,T7 arg7,T8 arg8,T9 arg9,T10 arg10,T11 arg11,T12 arg12,T13 arg13) {
            if (_compiled != null || TryGetCompiled()) {
                ((Action<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13>)_compiled)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
                return;
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            frame.Data[1] = arg1;
            frame.Data[2] = arg2;
            frame.Data[3] = arg3;
            frame.Data[4] = arg4;
            frame.Data[5] = arg5;
            frame.Data[6] = arg6;
            frame.Data[7] = arg7;
            frame.Data[8] = arg8;
            frame.Data[9] = arg9;
            frame.Data[10] = arg10;
            frame.Data[11] = arg11;
            frame.Data[12] = arg12;
            frame.Data[13] = arg13;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="658" endline="682" pcid="2773">
        internal TRet Run15<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,TRet>(T0 arg0,T1 arg1,T2 arg2,T3 arg3,T4 arg4,T5 arg5,T6 arg6,T7 arg7,T8 arg8,T9 arg9,T10 arg10,T11 arg11,T12 arg12,T13 arg13,T14 arg14) {
            if (_compiled != null || TryGetCompiled()) {
                return ((Func<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,TRet>)_compiled)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            frame.Data[1] = arg1;
            frame.Data[2] = arg2;
            frame.Data[3] = arg3;
            frame.Data[4] = arg4;
            frame.Data[5] = arg5;
            frame.Data[6] = arg6;
            frame.Data[7] = arg7;
            frame.Data[8] = arg8;
            frame.Data[9] = arg9;
            frame.Data[10] = arg10;
            frame.Data[11] = arg11;
            frame.Data[12] = arg12;
            frame.Data[13] = arg13;
            frame.Data[14] = arg14;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
            return (TRet)frame.Pop();
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/LightLambda.Generated.cs.ifdefed" startline="684" endline="708" pcid="2774">
        internal void RunVoid15<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14>(T0 arg0,T1 arg1,T2 arg2,T3 arg3,T4 arg4,T5 arg5,T6 arg6,T7 arg7,T8 arg8,T9 arg9,T10 arg10,T11 arg11,T12 arg12,T13 arg13,T14 arg14) {
            if (_compiled != null || TryGetCompiled()) {
                ((Action<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14>)_compiled)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
                return;
            }

            var frame = MakeFrame();
            frame.Data[0] = arg0;
            frame.Data[1] = arg1;
            frame.Data[2] = arg2;
            frame.Data[3] = arg3;
            frame.Data[4] = arg4;
            frame.Data[5] = arg5;
            frame.Data[6] = arg6;
            frame.Data[7] = arg7;
            frame.Data[8] = arg8;
            frame.Data[9] = arg9;
            frame.Data[10] = arg10;
            frame.Data[11] = arg11;
            frame.Data[12] = arg12;
            frame.Data[13] = arg13;
            frame.Data[14] = arg14;
            var current = frame.Enter();
            try { _interpreter.Run(frame); } finally { frame.Leave(current); }
        }
</source>
</class>

<class classid="67" nclones="2" nlines="28" similarity="100">
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/NumericConvertInstruction.cs.ifdefed" startline="52" endline="69" pcid="2864">
            private object Convert(object obj)
            {
                switch (_from)
                {
                    case TypeCode.Byte: return ConvertInt32((Byte)obj);
                    case TypeCode.SByte: return ConvertInt32((SByte)obj);
                    case TypeCode.Int16: return ConvertInt32((Int16)obj);
                    case TypeCode.Char: return ConvertInt32((Char)obj);
                    case TypeCode.Int32: return ConvertInt32((Int32)obj);
                    case TypeCode.Int64: return ConvertInt64((Int64)obj);
                    case TypeCode.UInt16: return ConvertInt32((UInt16)obj);
                    case TypeCode.UInt32: return ConvertInt64((UInt32)obj);
                    case TypeCode.UInt64: return ConvertUInt64((UInt64)obj);
                    case TypeCode.Single: return ConvertDouble((Single)obj);
                    case TypeCode.Double: return ConvertDouble((Double)obj);
                    default: throw Assert.Unreachable;
                }
            }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/NumericConvertInstruction.cs.ifdefed" startline="176" endline="193" pcid="2870">
            private object Convert(object obj)
            {
                switch (_from)
                {
                    case TypeCode.Byte: return ConvertInt32((Byte)obj);
                    case TypeCode.SByte: return ConvertInt32((SByte)obj);
                    case TypeCode.Int16: return ConvertInt32((Int16)obj);
                    case TypeCode.Char: return ConvertInt32((Char)obj);
                    case TypeCode.Int32: return ConvertInt32((Int32)obj);
                    case TypeCode.Int64: return ConvertInt64((Int64)obj);
                    case TypeCode.UInt16: return ConvertInt32((UInt16)obj);
                    case TypeCode.UInt32: return ConvertInt64((UInt32)obj);
                    case TypeCode.UInt64: return ConvertUInt64((UInt64)obj);
                    case TypeCode.Single: return ConvertDouble((Single)obj);
                    case TypeCode.Double: return ConvertDouble((Double)obj);
                    default: throw Assert.Unreachable;
                }
            }
</source>
</class>

<class classid="68" nclones="8" nlines="30" similarity="93">
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/NumericConvertInstruction.cs.ifdefed" startline="71" endline="91" pcid="2865">
            private object ConvertInt32(int obj)
            {
                unchecked
                {
                    switch (_to)
                    {
                        case TypeCode.Byte: return (Byte)obj;
                        case TypeCode.SByte: return (SByte)obj;
                        case TypeCode.Int16: return (Int16)obj;
                        case TypeCode.Char: return (Char)obj;
                        case TypeCode.Int32: return (Int32)obj;
                        case TypeCode.Int64: return (Int64)obj;
                        case TypeCode.UInt16: return (UInt16)obj;
                        case TypeCode.UInt32: return (UInt32)obj;
                        case TypeCode.UInt64: return (UInt64)obj;
                        case TypeCode.Single: return (Single)obj;
                        case TypeCode.Double: return (Double)obj;
                        default: throw Assert.Unreachable;
                    }
                }
            }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/NumericConvertInstruction.cs.ifdefed" startline="261" endline="281" pcid="2874">
            private object ConvertDouble(Double obj)
            {
                checked
                {
                    switch (_to)
                    {
                        case TypeCode.Byte: return (Byte)obj;
                        case TypeCode.SByte: return (SByte)obj;
                        case TypeCode.Int16: return (Int16)obj;
                        case TypeCode.Char: return (Char)obj;
                        case TypeCode.Int32: return (Int32)obj;
                        case TypeCode.Int64: return (Int64)obj;
                        case TypeCode.UInt16: return (UInt16)obj;
                        case TypeCode.UInt32: return (UInt32)obj;
                        case TypeCode.UInt64: return (UInt64)obj;
                        case TypeCode.Single: return (Single)obj;
                        case TypeCode.Double: return (Double)obj;
                        default: throw Assert.Unreachable;
                    }
                }
            }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/NumericConvertInstruction.cs.ifdefed" startline="93" endline="113" pcid="2866">
            private object ConvertInt64(Int64 obj)
            {
                unchecked
                {
                    switch (_to)
                    {
                        case TypeCode.Byte: return (Byte)obj;
                        case TypeCode.SByte: return (SByte)obj;
                        case TypeCode.Int16: return (Int16)obj;
                        case TypeCode.Char: return (Char)obj;
                        case TypeCode.Int32: return (Int32)obj;
                        case TypeCode.Int64: return (Int64)obj;
                        case TypeCode.UInt16: return (UInt16)obj;
                        case TypeCode.UInt32: return (UInt32)obj;
                        case TypeCode.UInt64: return (UInt64)obj;
                        case TypeCode.Single: return (Single)obj;
                        case TypeCode.Double: return (Double)obj;
                        default: throw Assert.Unreachable;
                    }
                }
            }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/NumericConvertInstruction.cs.ifdefed" startline="115" endline="135" pcid="2867">
            private object ConvertUInt64(UInt64 obj)
            {
                unchecked
                {
                    switch (_to)
                    {
                        case TypeCode.Byte: return (Byte)obj;
                        case TypeCode.SByte: return (SByte)obj;
                        case TypeCode.Int16: return (Int16)obj;
                        case TypeCode.Char: return (Char)obj;
                        case TypeCode.Int32: return (Int32)obj;
                        case TypeCode.Int64: return (Int64)obj;
                        case TypeCode.UInt16: return (UInt16)obj;
                        case TypeCode.UInt32: return (UInt32)obj;
                        case TypeCode.UInt64: return (UInt64)obj;
                        case TypeCode.Single: return (Single)obj;
                        case TypeCode.Double: return (Double)obj;
                        default: throw Assert.Unreachable;
                    }
                }
            }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/NumericConvertInstruction.cs.ifdefed" startline="137" endline="157" pcid="2868">
            private object ConvertDouble(Double obj)
            {
                unchecked
                {
                    switch (_to)
                    {
                        case TypeCode.Byte: return (Byte)obj;
                        case TypeCode.SByte: return (SByte)obj;
                        case TypeCode.Int16: return (Int16)obj;
                        case TypeCode.Char: return (Char)obj;
                        case TypeCode.Int32: return (Int32)obj;
                        case TypeCode.Int64: return (Int64)obj;
                        case TypeCode.UInt16: return (UInt16)obj;
                        case TypeCode.UInt32: return (UInt32)obj;
                        case TypeCode.UInt64: return (UInt64)obj;
                        case TypeCode.Single: return (Single)obj;
                        case TypeCode.Double: return (Double)obj;
                        default: throw Assert.Unreachable;
                    }
                }
            }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/NumericConvertInstruction.cs.ifdefed" startline="195" endline="215" pcid="2871">
            private object ConvertInt32(int obj)
            {
                checked
                {
                    switch (_to)
                    {
                        case TypeCode.Byte: return (Byte)obj;
                        case TypeCode.SByte: return (SByte)obj;
                        case TypeCode.Int16: return (Int16)obj;
                        case TypeCode.Char: return (Char)obj;
                        case TypeCode.Int32: return (Int32)obj;
                        case TypeCode.Int64: return (Int64)obj;
                        case TypeCode.UInt16: return (UInt16)obj;
                        case TypeCode.UInt32: return (UInt32)obj;
                        case TypeCode.UInt64: return (UInt64)obj;
                        case TypeCode.Single: return (Single)obj;
                        case TypeCode.Double: return (Double)obj;
                        default: throw Assert.Unreachable;
                    }
                }
            }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/NumericConvertInstruction.cs.ifdefed" startline="217" endline="237" pcid="2872">
            private object ConvertInt64(Int64 obj)
            {
                checked
                {
                    switch (_to)
                    {
                        case TypeCode.Byte: return (Byte)obj;
                        case TypeCode.SByte: return (SByte)obj;
                        case TypeCode.Int16: return (Int16)obj;
                        case TypeCode.Char: return (Char)obj;
                        case TypeCode.Int32: return (Int32)obj;
                        case TypeCode.Int64: return (Int64)obj;
                        case TypeCode.UInt16: return (UInt16)obj;
                        case TypeCode.UInt32: return (UInt32)obj;
                        case TypeCode.UInt64: return (UInt64)obj;
                        case TypeCode.Single: return (Single)obj;
                        case TypeCode.Double: return (Double)obj;
                        default: throw Assert.Unreachable;
                    }
                }
            }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/interpreter/NumericConvertInstruction.cs.ifdefed" startline="239" endline="259" pcid="2873">
            private object ConvertUInt64(UInt64 obj)
            {
                checked
                {
                    switch (_to)
                    {
                        case TypeCode.Byte: return (Byte)obj;
                        case TypeCode.SByte: return (SByte)obj;
                        case TypeCode.Int16: return (Int16)obj;
                        case TypeCode.Char: return (Char)obj;
                        case TypeCode.Int32: return (Int32)obj;
                        case TypeCode.Int64: return (Int64)obj;
                        case TypeCode.UInt16: return (UInt16)obj;
                        case TypeCode.UInt32: return (UInt32)obj;
                        case TypeCode.UInt64: return (UInt64)obj;
                        case TypeCode.Single: return (Single)obj;
                        case TypeCode.Double: return (Double)obj;
                        default: throw Assert.Unreachable;
                    }
                }
            }
</source>
</class>

<class classid="69" nclones="2" nlines="13" similarity="84">
<source file="PowerShell/src/System.Management.Automation/engine/lang/codegen.cs.ifdefed" startline="20" endline="37" pcid="2959">
        public static string EscapeSingleQuotedStringContent(string value)
        {
            if (string.IsNullOrEmpty(value))
            {
                return string.Empty;
            }
            StringBuilder sb = new StringBuilder(value.Length);
            foreach (char c in value)
            {
                sb.Append(c);
                if (SpecialCharacters.IsSingleQuote(c))
                {
                    // double-up quotes to escape them
                    sb.Append(c);
                }
            }
            return sb.ToString();
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/lang/codegen.cs.ifdefed" startline="64" endline="81" pcid="2961">
        public static string EscapeFormatStringContent(string value)
        {
            if (string.IsNullOrEmpty(value))
            {
                return string.Empty;
            }
            StringBuilder sb = new StringBuilder(value.Length);
            foreach (char c in value)
            {
                sb.Append(c);
                if (SpecialCharacters.IsCurlyBracket(c))
                {
                    // double-up curly brackets to escape them
                    sb.Append(c);
                }
            }
            return sb.ToString();
        }
</source>
</class>

<class classid="70" nclones="2" nlines="10" similarity="70">
<source file="PowerShell/src/System.Management.Automation/engine/remoting/client/RemotingProtocol2.cs.ifdefed" startline="662" endline="678" pcid="3403">
        private ClientPowerShellDataStructureHandler GetAssociatedPowerShellDataStructureHandler
            (Guid clientPowerShellId)
        {
            ClientPowerShellDataStructureHandler dsHandler = null;

            lock (_associationSyncObject)
            {
                bool success = _associatedPowerShellDSHandlers.TryGetValue(clientPowerShellId, out dsHandler);

                if (!success)
                {
                    dsHandler = null;
                }
            }

            return dsHandler;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/remoting/server/ServerRemotingProtocol2.cs.ifdefed" startline="358" endline="373" pcid="4120">
        internal ServerPowerShellDataStructureHandler GetAssociatedPowerShellDataStructureHandler
            (Guid clientPowerShellId)
        {
            ServerPowerShellDataStructureHandler dsHandler = null;

            lock (_associationSyncObject)
            {
                bool success = _associatedShells.TryGetValue(clientPowerShellId, out dsHandler);

                if (!success)
                {
                    dsHandler = null;
                }
            }
            return dsHandler;
        }
</source>
</class>

<class classid="71" nclones="2" nlines="29" similarity="74">
<source file="PowerShell/src/System.Management.Automation/engine/remoting/commands/RemoveJob.cs.ifdefed" startline="229" endline="290" pcid="3516">
        private bool FindJobsMatchingByInstanceIdHelper(List<Job> matches, IList<Job> jobsToSearch, Guid instanceId,
                        Hashtable duplicateDetector, bool recurse, bool writeobject, bool checkIfJobCanBeRemoved)
        {
            bool jobFound = false;

            // Most likely users will ask for top level jobs.
            // So in order to be more efficient, first look
            // into the top level jobs and only if a match is
            // not found in the top level jobs, recurse. This
            // will ensure that we get a pretty quick hit when
            // the job tree is more than 2 levels deep

            // check if job is found in top level item
            foreach (Job job in jobsToSearch)
            {
                if (duplicateDetector.ContainsKey(job.Id))
                {
                    continue;
                }

                duplicateDetector.Add(job.Id, job.Id);

                if (job.InstanceId == instanceId)
                {
                    jobFound = true;
                    if (!checkIfJobCanBeRemoved || CheckJobCanBeRemoved(job, InstanceIdParameter, RemotingErrorIdStrings.JobWithSpecifiedInstanceIdNotCompleted, job.Id, job.InstanceId))
                    {
                        // instance id is unique, so once a match is found
                        // you can break
                        if (writeobject)
                        {
                            WriteObject(job);
                        }
                        else
                        {
                            matches.Add(job);
                        }
                        break;
                    }
                }
            }

            // check if a match is found in the child jobs
            if (!jobFound && recurse)
            {
                foreach (Job job in jobsToSearch)
                {
                    if (job.ChildJobs != null && job.ChildJobs.Count > 0)
                    {
                        jobFound = FindJobsMatchingByInstanceIdHelper(matches, job.ChildJobs, instanceId,
                                        duplicateDetector, recurse, writeobject, checkIfJobCanBeRemoved);

                        if (jobFound)
                        {
                            break;
                        }
                    }
                }
            }

            return jobFound;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/remoting/commands/RemoveJob.cs.ifdefed" startline="338" endline="393" pcid="3518">
        private bool FindJobsMatchingBySessionIdHelper(List<Job> matches, IList<Job> jobsToSearch, int sessionId,
                        Hashtable duplicateDetector, bool recurse, bool writeobject, bool checkIfJobCanBeRemoved)
        {
            bool jobFound = false;

            // Most likely users will ask for top level jobs.
            // So in order to be more efficient, first look
            // into the top level jobs and only if a match is
            // not found in the top level jobs, recurse. This
            // will ensure that we get a pretty quick hit when
            // the job tree is more than 2 levels deep

            // check if there is a match in the top level jobs
            foreach (Job job in jobsToSearch)
            {
                if (job.Id == sessionId)
                {
                    jobFound = true;
                    if (!checkIfJobCanBeRemoved || CheckJobCanBeRemoved(job, SessionIdParameter, RemotingErrorIdStrings.JobWithSpecifiedSessionIdNotCompleted, job.Id))
                    {
                        if (writeobject)
                        {
                            WriteObject(job);
                        }
                        else
                        {
                            matches.Add(job);
                        }

                        // session id will be unique for every session, so
                        // can break after the first match
                        break;
                    }
                }
            }

            // check if there is a match found in the child jobs
            if (!jobFound && recurse)
            {
                foreach (Job job in jobsToSearch)
                {
                    if (job.ChildJobs != null && job.ChildJobs.Count > 0)
                    {
                        jobFound = FindJobsMatchingBySessionIdHelper(matches, job.ChildJobs, sessionId,
                                        duplicateDetector, recurse, writeobject, checkIfJobCanBeRemoved);

                        if (jobFound)
                        {
                            break;
                        }
                    }
                }
            }

            return jobFound;
        }
</source>
</class>

<class classid="72" nclones="3" nlines="17" similarity="70">
<source file="PowerShell/src/System.Management.Automation/engine/remoting/commands/ResumeJob.cs.ifdefed" startline="218" endline="235" pcid="3536">
        protected override void EndProcessing()
        {
            bool jobsPending = false;
            lock (_syncObject)
            {
                _needToCheckForWaitingJobs = true;
                if (_pendingJobs.Count > 0)
                    jobsPending = true;
            }

            if (Wait && jobsPending)
                _waitForJobs.WaitOne();

            if (_warnInvalidState) WriteWarning(RemotingErrorIdStrings.ResumeJobInvalidJobState);
            foreach (var e in _errorsToWrite) WriteError(e);
            foreach (var j in _allJobsToResume) WriteObject(j);
            base.EndProcessing();
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/remoting/commands/SuspendJob.cs.ifdefed" startline="308" endline="325" pcid="3558">
        protected override void EndProcessing()
        {
            bool haveToWait = false;
            lock (_syncObject)
            {
                _needToCheckForWaitingJobs = true;
                if (_pendingJobs.Count > 0)
                    haveToWait = true;
            }

            if (haveToWait)
                _waitForJobs.WaitOne();

            if (_warnInvalidState) WriteWarning(RemotingErrorIdStrings.SuspendJobInvalidJobState);
            foreach (var e in _errorsToWrite) WriteError(e);
            foreach (var j in _allJobsToSuspend) WriteObject(j);
            base.EndProcessing();
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/remoting/commands/StopJob.cs.ifdefed" startline="170" endline="188" pcid="3549">
        protected override void EndProcessing()
        {
            bool haveToWait = false;
            lock (_syncObject)
            {
                _needToCheckForWaitingJobs = true;
                if (_pendingJobs.Count > 0)
                    haveToWait = true;
            }

            if (haveToWait)
                _waitForJobs.WaitOne();

            foreach (var e in _errorsToWrite) WriteError(e);
            if (_passThru)
            {
                foreach (var job in _allJobsToStop) WriteObject(job);
            }
        }
</source>
</class>

<class classid="73" nclones="2" nlines="12" similarity="76">
<source file="PowerShell/src/System.Management.Automation/engine/remoting/common/throttlemanager.cs.ifdefed" startline="230" endline="254" pcid="3638">
        internal void SubmitOperations(List<IThrottleOperation> operations)
        {
            lock (_syncObject)
            {
                // operations can be submitted only until submitComplete
                // is not set to true (happens when EndSubmitOperations is called)
                if (!_submitComplete)
                {
                    // add items to the queue
                    foreach (IThrottleOperation operation in operations)
                    {
                        Dbg.Assert(operation != null,
                            "Operation submitComplete to throttle manager cannot be null");
                        _operationsQueue.Add(operation);
                    }
                }
                else
                {
                    throw new InvalidOperationException();
                }
            }

            // schedule operations here if possible
            StartOperationsFromQueue();
        } // SubmitOperations
</source>
<source file="PowerShell/src/System.Management.Automation/engine/remoting/common/throttlemanager.cs.ifdefed" startline="260" endline="282" pcid="3639">
        internal void AddOperation(IThrottleOperation operation)
        {
            // add item to the queue
            lock (_syncObject)
            {
                // operations can be submitted only until submitComplete
                // is not set to true (happens when EndSubmitOperations is called)
                if (!_submitComplete)
                {
                    Dbg.Assert(operation != null,
                        "Operation submitComplete to throttle manager cannot be null");

                    _operationsQueue.Add(operation);
                }
                else
                {
                    throw new InvalidOperationException();
                }
            }

            // start operations from queue if possible
            StartOperationsFromQueue();
        }// AddOperation
</source>
</class>

<class classid="74" nclones="2" nlines="10" similarity="70">
<source file="PowerShell/src/System.Management.Automation/engine/remoting/fanin/OutOfProcTransportManager.cs.ifdefed" startline="764" endline="784" pcid="3822">
        private void SendData(byte[] data, DataPriorityType priorityType)
        {
            PSEtwLog.LogAnalyticInformational(
                       PSEventId.WSManSendShellInputEx, PSOpcode.Send, PSTask.None,
                       PSKeyword.Transport | PSKeyword.UseAlwaysAnalytic,
                       RunspacePoolInstanceId.ToString(),
                       Guid.Empty.ToString(),
                       data.Length.ToString(CultureInfo.InvariantCulture));

            lock (syncObject)
            {
                if (isClosed)
                {
                    return;
                }

                stdInWriter.WriteLine(OutOfProcessUtils.CreateDataPacket(data,
                    priorityType,
                    Guid.Empty));
            }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/remoting/fanin/OutOfProcTransportManager.cs.ifdefed" startline="2235" endline="2255" pcid="3878">
        private void SendData(byte[] data, DataPriorityType priorityType)
        {
            PSEtwLog.LogAnalyticInformational(
                    PSEventId.WSManSendShellInputEx, PSOpcode.Send, PSTask.None,
                    PSKeyword.Transport | PSKeyword.UseAlwaysAnalytic,
                    RunspacePoolInstanceId.ToString(),
                    powershellInstanceId.ToString(),
                    data.Length.ToString(CultureInfo.InvariantCulture));

            lock (syncObject)
            {
                if (isClosed)
                {
                    return;
                }

                _stdInWriter.WriteLine(OutOfProcessUtils.CreateDataPacket(data,
                    priorityType,
                    powershellInstanceId));
            }
        }
</source>
</class>

<class classid="75" nclones="2" nlines="10" similarity="70">
<source file="PowerShell/src/System.Management.Automation/engine/remoting/fanin/OutOfProcTransportManager.cs.ifdefed" startline="833" endline="852" pcid="3825">
        private void OnDataAckPacketReceived(Guid psGuid)
        {
            if (psGuid == Guid.Empty)
            {
                // this data is meant for session.
                OnRemoteSessionSendCompleted();
            }
            else
            {
                // this is for a command
                OutOfProcessClientCommandTransportManager cmdTM = GetCommandTransportManager(psGuid);
                if (cmdTM != null)
                {
                    // not throwing the exception in null case as the command might have already
                    // closed. The RS data structure handler does not wait for the close ack before
                    // it clears the command transport manager..so this might happen.
                    cmdTM.OnRemoteCmdSendCompleted();
                }
            }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/remoting/fanin/OutOfProcTransportManager.cs.ifdefed" startline="883" endline="899" pcid="3829">
        private void OnSignalAckPacketReceived(Guid psGuid)
        {
            if (psGuid == Guid.Empty)
            {
                throw new PSRemotingTransportException(PSRemotingErrorId.IPCNoSignalForSession,
                    RemotingErrorIdStrings.IPCNoSignalForSession,
                    OutOfProcessUtils.PS_OUT_OF_PROC_SIGNAL_ACK_TAG);
            }
            else
            {
                OutOfProcessClientCommandTransportManager cmdTM = GetCommandTransportManager(psGuid);
                if (cmdTM != null)
                {
                    cmdTM.OnRemoteCmdSignalCompleted();
                }
            }
        }
</source>
</class>

<class classid="76" nclones="3" nlines="31" similarity="75">
<source file="PowerShell/src/System.Management.Automation/engine/remoting/fanin/OutOfProcTransportManager.cs.ifdefed" startline="1211" endline="1271" pcid="3842">
        protected void ProcessReaderThread(object state)
        {
            try
            {
                StreamReader reader = state as StreamReader;
                Dbg.Assert(reader != null, "Reader cannot be null.");

                // Send one fragment.
                SendOneItem();

                // Start reader loop.
                while (true)
                {
                    string data = reader.ReadLine();
                    if (data == null)
                    {
                        // End of stream indicates the target process was lost.
                        // Raise transport exception to invalidate the client remote runspace.
                        PSRemotingTransportException psrte = new PSRemotingTransportException(
                            PSRemotingErrorId.IPCServerProcessReportedError,
                            RemotingErrorIdStrings.IPCServerProcessReportedError,
                            RemotingErrorIdStrings.HyperVSocketTransportProcessEnded);
                        RaiseErrorHandler(new TransportErrorOccuredEventArgs(psrte, TransportMethodEnum.ReceiveShellOutputEx));
                        break;
                    }

                    if (data.StartsWith(System.Management.Automation.Remoting.Server.HyperVSocketErrorTextWriter.ErrorPrepend, StringComparison.OrdinalIgnoreCase))
                    {
                        // Error message from the server.
                        string errorData = data.Substring(System.Management.Automation.Remoting.Server.HyperVSocketErrorTextWriter.ErrorPrepend.Length);
                        HandleErrorDataReceived(errorData);
                    }
                    else
                    {
                        // Normal output data.
                        HandleOutputDataReceived(data);
                    }
                }
            }
            catch (ObjectDisposedException)
            {
                // Normal reader thread end.
            }
            catch (Exception e)
            {
                if (e is ArgumentOutOfRangeException)
                {
                    Dbg.Assert(false, "Need to adjust transport fragmentor to accomodate read buffer size.");
                }

                string errorMsg = (e.Message != null) ? e.Message : string.Empty;
                _tracer.WriteMessage("HyperVSocketClientSessionTransportManager", "StartReaderThread", Guid.Empty,
                    "Transport manager reader thread ended with error: {0}", errorMsg);

                PSRemotingTransportException psrte = new PSRemotingTransportException(
                    PSRemotingErrorId.IPCServerProcessReportedError,
                    RemotingErrorIdStrings.IPCServerProcessReportedError,
                    RemotingErrorIdStrings.HyperVSocketTransportProcessEnded);
                RaiseErrorHandler(new TransportErrorOccuredEventArgs(psrte, TransportMethodEnum.ReceiveShellOutputEx));
            }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/remoting/fanin/OutOfProcTransportManager.cs.ifdefed" startline="1652" endline="1705" pcid="3855">
        private void ProcessReaderThread(object state)
        {
            try
            {
                StreamReader reader = state as StreamReader;
                Dbg.Assert(reader != null, "Reader cannot be null.");

                // Send one fragment.
                SendOneItem();

                // Start reader loop.
                while (true)
                {
                    string data = reader.ReadLine();
                    if (data == null)
                    {
                        // End of stream indicates that the SSH transport is broken.
                        // SSH will return the appropriate error in StdErr stream so
                        // let the error reader thread report the error.
                        break;
                    }

                    if (data.StartsWith(System.Management.Automation.Remoting.Server.NamedPipeErrorTextWriter.ErrorPrepend, StringComparison.OrdinalIgnoreCase))
                    {
                        // Error message from the server.
                        string errorData = data.Substring(System.Management.Automation.Remoting.Server.NamedPipeErrorTextWriter.ErrorPrepend.Length);
                        HandleErrorDataReceived(errorData);
                    }
                    else
                    {
                        // The first received PSRP message from the server indicates that the connection is established and that PSRP is running.
                        if (!_connectionEstablished) { _connectionEstablished = true; }

                        // Normal output data.
                        HandleOutputDataReceived(data);
                    }
                }
            }
            catch (ObjectDisposedException)
            {
                // Normal reader thread end.
            }
            catch (Exception e)
            {
                if (e is ArgumentOutOfRangeException)
                {
                    Dbg.Assert(false, "Need to adjust transport fragmentor to accomodate read buffer size.");
                }

                string errorMsg = (e.Message != null) ? e.Message : string.Empty;
                _tracer.WriteMessage("SSHClientSessionTransportManager", "ProcessReaderThread", Guid.Empty,
                    "Transport manager reader thread ended with error: {0}", errorMsg);
            }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/remoting/fanin/OutOfProcTransportManager.cs.ifdefed" startline="1778" endline="1832" pcid="3859">
        private void ProcessReaderThread(object state)
        {
            try
            {
                StreamReader reader = state as StreamReader;
                Dbg.Assert(reader != null, "Reader cannot be null.");

                // Send one fragment.
                SendOneItem();

                // Start reader loop.
                while (true)
                {
                    string data = reader.ReadLine();
                    if (data == null)
                    {
                        // End of stream indicates the target process was lost.
                        // Raise transport exception to invalidate the client remote runspace.
                        PSRemotingTransportException psrte = new PSRemotingTransportException(
                            PSRemotingErrorId.IPCServerProcessReportedError,
                            RemotingErrorIdStrings.IPCServerProcessReportedError,
                            RemotingErrorIdStrings.NamedPipeTransportProcessEnded);
                        RaiseErrorHandler(new TransportErrorOccuredEventArgs(psrte, TransportMethodEnum.ReceiveShellOutputEx));
                        break;
                    }

                    if (data.StartsWith(System.Management.Automation.Remoting.Server.NamedPipeErrorTextWriter.ErrorPrepend, StringComparison.OrdinalIgnoreCase))
                    {
                        // Error message from the server.
                        string errorData = data.Substring(System.Management.Automation.Remoting.Server.NamedPipeErrorTextWriter.ErrorPrepend.Length);
                        HandleErrorDataReceived(errorData);
                    }
                    else
                    {
                        // Normal output data.
                        HandleOutputDataReceived(data);
                    }
                }
            }
            catch (ObjectDisposedException)
            {
                // Normal reader thread end.
            }
            catch (Exception e)
            {
                if (e is ArgumentOutOfRangeException)
                {
                    Dbg.Assert(false, "Need to adjust transport fragmentor to accomodate read buffer size.");
                }

                string errorMsg = (e.Message != null) ? e.Message : string.Empty;
                _tracer.WriteMessage("NamedPipeClientSessionTransportManager", "StartReaderThread", Guid.Empty,
                    "Transport manager reader thread ended with error: {0}", errorMsg);
            }
        }
</source>
</class>

<class classid="77" nclones="6" nlines="11" similarity="72">
<source file="PowerShell/src/System.Management.Automation/engine/remoting/fanin/WSManTransportManager.cs.ifdefed" startline="605" endline="623" pcid="3958">
        internal void SetDefaultTimeOut(int milliseconds)
        {
            Dbg.Assert(_wsManSessionHandle != IntPtr.Zero, "Session handle cannot be null");
            using (tracer.TraceMethod("Setting Default timeout: {0} milliseconds", milliseconds))
            {
                int result = WSManNativeApi.WSManSetSessionOption(_wsManSessionHandle,
                    WSManNativeApi.WSManSessionOption.WSMAN_OPTION_DEFAULT_OPERATION_TIMEOUTMS,
                    new WSManNativeApi.WSManDataDWord(milliseconds));

                if (result != 0)
                {
                    // Get the error message from WSMan
                    string errorMessage = WSManNativeApi.WSManGetErrorMessage(WSManAPIData.WSManAPIHandle, result);

                    PSInvalidOperationException exception = new PSInvalidOperationException(errorMessage);
                    throw exception;
                }
            }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/remoting/fanin/WSManTransportManager.cs.ifdefed" startline="633" endline="651" pcid="3959">
        internal void SetConnectTimeOut(int milliseconds)
        {
            Dbg.Assert(_wsManSessionHandle != IntPtr.Zero, "Session handle cannot be null");
            using (tracer.TraceMethod("Setting CreateShell timeout: {0} milliseconds", milliseconds))
            {
                int result = WSManNativeApi.WSManSetSessionOption(_wsManSessionHandle,
                    WSManNativeApi.WSManSessionOption.WSMAN_OPTION_TIMEOUTMS_CREATE_SHELL,
                    new WSManNativeApi.WSManDataDWord(milliseconds));

                if (result != 0)
                {
                    // Get the error message from WSMan
                    string errorMessage = WSManNativeApi.WSManGetErrorMessage(WSManAPIData.WSManAPIHandle, result);

                    PSInvalidOperationException exception = new PSInvalidOperationException(errorMessage);
                    throw exception;
                }
            }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/remoting/fanin/WSManTransportManager.cs.ifdefed" startline="717" endline="735" pcid="3962">
        internal void SetReceiveTimeOut(int milliseconds)
        {
            Dbg.Assert(_wsManSessionHandle != IntPtr.Zero, "Session handle cannot be null");
            using (tracer.TraceMethod("Setting ReceiveShellOutput timeout: {0} milliseconds", milliseconds))
            {
                int result = WSManNativeApi.WSManSetSessionOption(_wsManSessionHandle,
                    WSManNativeApi.WSManSessionOption.WSMAN_OPTION_TIMEOUTMS_RECEIVE_SHELL_OUTPUT,
                    new WSManNativeApi.WSManDataDWord(milliseconds));

                if (result != 0)
                {
                    // Get the error message from WSMan
                    string errorMessage = WSManNativeApi.WSManGetErrorMessage(WSManAPIData.WSManAPIHandle, result);

                    PSInvalidOperationException exception = new PSInvalidOperationException(errorMessage);
                    throw exception;
                }
            }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/remoting/fanin/WSManTransportManager.cs.ifdefed" startline="689" endline="707" pcid="3961">
        internal void SetSendTimeOut(int milliseconds)
        {
            Dbg.Assert(_wsManSessionHandle != IntPtr.Zero, "Session handle cannot be null");
            using (tracer.TraceMethod("Setting SendShellInput timeout: {0} milliseconds", milliseconds))
            {
                int result = WSManNativeApi.WSManSetSessionOption(_wsManSessionHandle,
                    WSManNativeApi.WSManSessionOption.WSMAN_OPTION_TIMEOUTMS_SEND_SHELL_INPUT,
                    new WSManNativeApi.WSManDataDWord(milliseconds));

                if (result != 0)
                {
                    // Get the error message from WSMan
                    string errorMessage = WSManNativeApi.WSManGetErrorMessage(WSManAPIData.WSManAPIHandle, result);

                    PSInvalidOperationException exception = new PSInvalidOperationException(errorMessage);
                    throw exception;
                }
            }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/remoting/fanin/WSManTransportManager.cs.ifdefed" startline="661" endline="679" pcid="3960">
        internal void SetCloseTimeOut(int milliseconds)
        {
            Dbg.Assert(_wsManSessionHandle != IntPtr.Zero, "Session handle cannot be null");
            using (tracer.TraceMethod("Setting CloseShell timeout: {0} milliseconds", milliseconds))
            {
                int result = WSManNativeApi.WSManSetSessionOption(_wsManSessionHandle,
                    WSManNativeApi.WSManSessionOption.WSMAN_OPTION_TIMEOUTMS_CLOSE_SHELL_OPERATION,
                    new WSManNativeApi.WSManDataDWord(milliseconds));

                if (result != 0)
                {
                    // Get the error message from WSMan
                    string errorMessage = WSManNativeApi.WSManGetErrorMessage(WSManAPIData.WSManAPIHandle, result);

                    PSInvalidOperationException exception = new PSInvalidOperationException(errorMessage);
                    throw exception;
                }
            }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/remoting/fanin/WSManTransportManager.cs.ifdefed" startline="745" endline="763" pcid="3963">
        internal void SetSignalTimeOut(int milliseconds)
        {
            Dbg.Assert(_wsManSessionHandle != IntPtr.Zero, "Session handle cannot be null");
            using (tracer.TraceMethod("Setting SignalShell timeout: {0} milliseconds", milliseconds))
            {
                int result = WSManNativeApi.WSManSetSessionOption(_wsManSessionHandle,
                    WSManNativeApi.WSManSessionOption.WSMAN_OPTION_TIMEOUTMS_SIGNAL_SHELL,
                    new WSManNativeApi.WSManDataDWord(milliseconds));

                if (result != 0)
                {
                    // Get the error message from WSMan
                    string errorMessage = WSManNativeApi.WSManGetErrorMessage(WSManAPIData.WSManAPIHandle, result);

                    PSInvalidOperationException exception = new PSInvalidOperationException(errorMessage);
                    throw exception;
                }
            }
        }
</source>
</class>

<class classid="78" nclones="2" nlines="18" similarity="72">
<source file="PowerShell/src/System.Management.Automation/engine/remoting/fanin/WSManTransportManager.cs.ifdefed" startline="991" endline="1019" pcid="3969">
        internal override void StartReceivingData()
        {
            lock (syncObject)
            {
                // make sure the transport is not closed.
                if (isClosed)
                {
                    tracer.WriteLine("Client Session TM: Transport manager is closed. So returning");
                    return;
                }

                if (receiveDataInitiated)
                {
                    tracer.WriteLine("Client Session TM: ReceiveData has already been called.");
                    return;
                }

                receiveDataInitiated = true;
                tracer.WriteLine("Client Session TM: Placing Receive request using WSManReceiveShellOutputEx");
                PSEtwLog.LogAnalyticInformational(PSEventId.WSManReceiveShellOutputEx,
                    PSOpcode.Receive, PSTask.None, PSKeyword.Transport | PSKeyword.UseAlwaysAnalytic,
                    RunspacePoolInstanceId.ToString(), Guid.Empty.ToString());

                _receivedFromRemote = new WSManNativeApi.WSManShellAsync(new IntPtr(_sessionContextID), s_sessionReceiveCallback);
                WSManNativeApi.WSManReceiveShellOutputEx(_wsManShellOperationHandle,
                    IntPtr.Zero, 0, WSManAPIData.OutputStreamSet, _receivedFromRemote,
                    ref _wsManReceiveOperationHandle);
            }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/remoting/fanin/WSManTransportManager.cs.ifdefed" startline="3926" endline="3956" pcid="4021">
        internal override void StartReceivingData()
        {
            PSEtwLog.LogAnalyticInformational(PSEventId.WSManReceiveShellOutputEx,
                    PSOpcode.Receive, PSTask.None, PSKeyword.Transport | PSKeyword.UseAlwaysAnalytic,
                    RunspacePoolInstanceId.ToString(), powershellInstanceId.ToString());
            // We should call Receive only once.. WSMan will call the callback multiple times.
            _shouldStartReceivingData = false;
            lock (syncObject)
            {
                // make sure the transport is not closed.
                if (isClosed)
                {
                    tracer.WriteLine("Client Session TM: Transport manager is closed. So returning");
                    return;
                }

                if (receiveDataInitiated)
                {
                    tracer.WriteLine("Client Session TM: ReceiveData has already been called.");
                    return;
                }

                receiveDataInitiated = true;
                // receive callback
                _receivedFromRemote = new WSManNativeApi.WSManShellAsync(new IntPtr(_cmdContextId), s_cmdReceiveCallback);
                WSManNativeApi.WSManReceiveShellOutputEx(_wsManShellOperationHandle,
                    _wsManCmdOperationHandle, startInDisconnectedMode ? (int)WSManNativeApi.WSManShellFlag.WSMAN_FLAG_RECEIVE_DELAY_OUTPUT_STREAM : 0,
                   _sessnTm.WSManAPIData.OutputStreamSet,
                   _receivedFromRemote, ref _wsManReceiveOperationHandle);
            }
        }
</source>
</class>

<class classid="79" nclones="2" nlines="15" similarity="73">
<source file="PowerShell/src/System.Management.Automation/engine/remoting/fanin/WSManTransportManager.cs.ifdefed" startline="1615" endline="1651" pcid="3978">
        internal override void RaiseErrorHandler(TransportErrorOccuredEventArgs eventArgs)
        {
            // Look for a valid stack trace.
            string stackTrace;
            if (!string.IsNullOrEmpty(eventArgs.Exception.StackTrace))
            {
                stackTrace = eventArgs.Exception.StackTrace;
            }
            else if (eventArgs.Exception.InnerException != null &&
                     !string.IsNullOrEmpty(eventArgs.Exception.InnerException.StackTrace))
            {
                stackTrace = eventArgs.Exception.InnerException.StackTrace;
            }
            else
            {
                stackTrace = string.Empty;
            }

            // Write errors into both Operational and Analytical channels
            PSEtwLog.LogOperationalError(PSEventId.TransportError, PSOpcode.Open, PSTask.None, PSKeyword.UseAlwaysOperational,
                RunspacePoolInstanceId.ToString(),
                Guid.Empty.ToString(),
                eventArgs.Exception.ErrorCode.ToString(CultureInfo.InvariantCulture),
                eventArgs.Exception.Message,
                stackTrace);

            PSEtwLog.LogAnalyticError(PSEventId.TransportError_Analytic,
                PSOpcode.Open, PSTask.None,
                PSKeyword.Transport | PSKeyword.UseAlwaysAnalytic,
                RunspacePoolInstanceId.ToString(),
                Guid.Empty.ToString(),
                eventArgs.Exception.ErrorCode.ToString(CultureInfo.InvariantCulture),
                eventArgs.Exception.Message,
                stackTrace);

            base.RaiseErrorHandler(eventArgs);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/remoting/fanin/WSManTransportManager.cs.ifdefed" startline="3145" endline="3182" pcid="4006">
        internal override void RaiseErrorHandler(TransportErrorOccuredEventArgs eventArgs)
        {
            // Look for a valid stack trace.
            string stackTrace;
            if (!string.IsNullOrEmpty(eventArgs.Exception.StackTrace))
            {
                stackTrace = eventArgs.Exception.StackTrace;
            }
            else if (eventArgs.Exception.InnerException != null &&
                     !string.IsNullOrEmpty(eventArgs.Exception.InnerException.StackTrace))
            {
                stackTrace = eventArgs.Exception.InnerException.StackTrace;
            }
            else
            {
                stackTrace = string.Empty;
            }

            PSEtwLog.LogOperationalError(
                PSEventId.TransportError, PSOpcode.Open, PSTask.None,
                PSKeyword.UseAlwaysOperational,
                RunspacePoolInstanceId.ToString(),
                powershellInstanceId.ToString(),
                eventArgs.Exception.ErrorCode.ToString(CultureInfo.InvariantCulture),
                eventArgs.Exception.Message,
                stackTrace);

            PSEtwLog.LogAnalyticError(
                PSEventId.TransportError_Analytic, PSOpcode.Open, PSTask.None,
                PSKeyword.Transport | PSKeyword.UseAlwaysAnalytic,
                RunspacePoolInstanceId.ToString(),
                powershellInstanceId.ToString(),
                eventArgs.Exception.ErrorCode.ToString(CultureInfo.InvariantCulture),
                eventArgs.Exception.Message,
                stackTrace);

            base.RaiseErrorHandler(eventArgs);
        }
</source>
</class>

<class classid="80" nclones="2" nlines="23" similarity="100">
<source file="PowerShell/src/System.Management.Automation/engine/remoting/fanin/WSManTransportManager.cs.ifdefed" startline="1661" endline="1696" pcid="3979">
        internal void ClearReceiveOrSendResources(int flags, bool shouldClearSend)
        {
            if (shouldClearSend)
            {
                if (_sendToRemoteCompleted != null)
                {
                    _sendToRemoteCompleted.Dispose();
                    _sendToRemoteCompleted = null;
                }

                // For send..clear always
                if (IntPtr.Zero != _wsManSendOperationHandle)
                {
                    WSManNativeApi.WSManCloseOperation(_wsManSendOperationHandle, 0);
                    _wsManSendOperationHandle = IntPtr.Zero;
                }
            }
            else
            {
                // clearing for receive..Clear only when the end of operation is reached.
                if (flags == (int)WSManNativeApi.WSManCallbackFlags.WSMAN_FLAG_CALLBACK_END_OF_OPERATION)
                {
                    if (IntPtr.Zero != _wsManReceiveOperationHandle)
                    {
                        WSManNativeApi.WSManCloseOperation(_wsManReceiveOperationHandle, 0);
                        _wsManReceiveOperationHandle = IntPtr.Zero;
                    }

                    if (_receivedFromRemote != null)
                    {
                        _receivedFromRemote.Dispose();
                        _receivedFromRemote = null;
                    }
                }
            }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/remoting/fanin/WSManTransportManager.cs.ifdefed" startline="3212" endline="3247" pcid="4008">
        internal void ClearReceiveOrSendResources(int flags, bool shouldClearSend)
        {
            if (shouldClearSend)
            {
                if (_sendToRemoteCompleted != null)
                {
                    _sendToRemoteCompleted.Dispose();
                    _sendToRemoteCompleted = null;
                }

                // For send..clear always
                if (IntPtr.Zero != _wsManSendOperationHandle)
                {
                    WSManNativeApi.WSManCloseOperation(_wsManSendOperationHandle, 0);
                    _wsManSendOperationHandle = IntPtr.Zero;
                }
            }
            else
            {
                // clearing for receive..Clear only when the end of operation is reached.
                if (flags == (int)WSManNativeApi.WSManCallbackFlags.WSMAN_FLAG_CALLBACK_END_OF_OPERATION)
                {
                    if (IntPtr.Zero != _wsManReceiveOperationHandle)
                    {
                        WSManNativeApi.WSManCloseOperation(_wsManReceiveOperationHandle, 0);
                        _wsManReceiveOperationHandle = IntPtr.Zero;
                    }

                    if (_receivedFromRemote != null)
                    {
                        _receivedFromRemote.Dispose();
                        _receivedFromRemote = null;
                    }
                }
            }
        }
</source>
</class>

<class classid="81" nclones="2" nlines="31" similarity="70">
<source file="PowerShell/src/System.Management.Automation/engine/remoting/fanin/WSManTransportManager.cs.ifdefed" startline="1989" endline="2055" pcid="3985">
        private static void OnRemoteSessionDisconnectCompleted(IntPtr operationContext,
            int flags,
            IntPtr error,
            IntPtr shellOperationHandle,
            IntPtr commandOperationHandle,
            IntPtr operationHandle,
            IntPtr data)
        {
            tracer.WriteLine("Client Session TM: CreateShell callback received");

            long sessionTMHandle = 0;
            WSManClientSessionTransportManager sessionTM = null;
            if (!TryGetSessionTransportManager(operationContext, out sessionTM, out sessionTMHandle))
            {
                // We dont have the session TM handle..just return.
                tracer.WriteLine("Unable to find a transport manager for context {0}.", sessionTMHandle);
                return;
            }

            //LOG ETW EVENTS

            // Dispose the OnDisconnect callback as it is not needed anymore
            if (sessionTM._disconnectSessionCompleted != null)
            {
                sessionTM._disconnectSessionCompleted.Dispose();
                sessionTM._disconnectSessionCompleted = null;
            }

            if (IntPtr.Zero != error)
            {
                WSManNativeApi.WSManError errorStruct = WSManNativeApi.WSManError.UnMarshal(error);

                if (errorStruct.errorCode != 0)
                {
                    tracer.WriteLine("Got error with error code {0}. Message {1}", errorStruct.errorCode, errorStruct.errorDetail);

                    TransportErrorOccuredEventArgs eventargs = WSManTransportManagerUtils.ConstructTransportErrorEventArgs(
                        sessionTM.WSManAPIData.WSManAPIHandle,
                        sessionTM,
                        errorStruct,
                        TransportMethodEnum.DisconnectShellEx,
                        RemotingErrorIdStrings.DisconnectShellExFailed,
                        new object[] { sessionTM.ConnectionInfo.ComputerName, WSManTransportManagerUtils.ParseEscapeWSManErrorMessage(errorStruct.errorDetail) });
                    sessionTM.ProcessWSManTransportError(eventargs);

                    return;
                }
            }

            lock (sessionTM.syncObject)
            {
                // make sure the transport is not closed yet.
                if (sessionTM.isClosed)
                {
                    tracer.WriteLine("Client Session TM: Transport manager is closed. So returning");
                    return;
                }

                // successfully made a connection. Now report this by raising the ConnectCompleted event.
                sessionTM.EnqueueAndStartProcessingThread(null, null,
                    new CompletionEventArgs(CompletionNotification.DisconnectCompleted));

                //Log ETW traces
            }

            return;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/remoting/fanin/WSManTransportManager.cs.ifdefed" startline="2057" endline="2118" pcid="3986">
        private static void OnRemoteSessionReconnectCompleted(IntPtr operationContext,
            int flags,
            IntPtr error,
            IntPtr shellOperationHandle,
            IntPtr commandOperationHandle,
            IntPtr operationHandle,
            IntPtr data)
        {
            tracer.WriteLine("Client Session TM: CreateShell callback received");

            long sessionTMHandle = 0;
            WSManClientSessionTransportManager sessionTM = null;
            if (!TryGetSessionTransportManager(operationContext, out sessionTM, out sessionTMHandle))
            {
                // We dont have the session TM handle..just return.
                tracer.WriteLine("Unable to find a transport manager for context {0}.", sessionTMHandle);
                return;
            }

            //Add ETW events

            // Dispose the OnCreate callback as it is not needed anymore
            if (sessionTM._reconnectSessionCompleted != null)
            {
                sessionTM._reconnectSessionCompleted.Dispose();
                sessionTM._reconnectSessionCompleted = null;
            }

            if (IntPtr.Zero != error)
            {
                WSManNativeApi.WSManError errorStruct = WSManNativeApi.WSManError.UnMarshal(error);

                if (errorStruct.errorCode != 0)
                {
                    tracer.WriteLine("Got error with error code {0}. Message {1}", errorStruct.errorCode, errorStruct.errorDetail);

                    TransportErrorOccuredEventArgs eventargs = WSManTransportManagerUtils.ConstructTransportErrorEventArgs(
                        sessionTM.WSManAPIData.WSManAPIHandle,
                        sessionTM,
                        errorStruct,
                        TransportMethodEnum.ReconnectShellEx,
                        RemotingErrorIdStrings.ReconnectShellExCallBackErrr,
                        new object[] { sessionTM.ConnectionInfo.ComputerName, WSManTransportManagerUtils.ParseEscapeWSManErrorMessage(errorStruct.errorDetail) });
                    sessionTM.ProcessWSManTransportError(eventargs);

                    return;
                }
            }

            lock (sessionTM.syncObject)
            {
                // make sure the transport is not closed yet.
                if (sessionTM.isClosed)
                {
                    tracer.WriteLine("Client Session TM: Transport manager is closed. So returning");
                    return;
                }

                // successfully made a connection. Now report this by raising the ConnectCompleted event.
                sessionTM.RaiseReconnectCompleted();
            }
        }
</source>
</class>

<class classid="82" nclones="2" nlines="11" similarity="72">
<source file="PowerShell/src/System.Management.Automation/engine/remoting/server/serverremotesessionstatemachine.cs.ifdefed" startline="721" endline="739" pcid="4100">
        private void DoCloseFailed(object sender, RemoteSessionStateMachineEventArgs fsmEventArg)
        {
            using (s_trace.TraceEventHandlers())
            {
                if (fsmEventArg == null)
                {
                    throw PSTraceSource.NewArgumentNullException("fsmEventArg");
                }

                Dbg.Assert(fsmEventArg.StateEvent == RemoteSessionEvent.CloseFailed, "StateEvent must be CloseFailed");

                RemoteSessionState stateBeforeTransition = _state;

                SetState(RemoteSessionState.Closed, fsmEventArg.Reason);

                // ignore
                CleanAll();
            }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/remoting/server/serverremotesessionstatemachine.cs.ifdefed" startline="751" endline="768" pcid="4101">
        private void DoCloseCompleted(object sender, RemoteSessionStateMachineEventArgs fsmEventArg)
        {
            using (s_trace.TraceEventHandlers())
            {
                if (fsmEventArg == null)
                {
                    throw PSTraceSource.NewArgumentNullException("fsmEventArg");
                }

                Dbg.Assert(fsmEventArg.StateEvent == RemoteSessionEvent.CloseCompleted, "StateEvent must be CloseCompleted");

                SetState(RemoteSessionState.Closed, fsmEventArg.Reason);
                // Close the session only after changing the state..this way
                // state machine will not process anything.
                _session.Close(fsmEventArg);
                CleanAll();
            }
        }
</source>
</class>

<class classid="83" nclones="3" nlines="10" similarity="80">
<source file="PowerShell/src/System.Management.Automation/engine/remoting/server/serverremotesessionstatemachine.cs.ifdefed" startline="781" endline="796" pcid="4102">
        private void DoNegotiationFailed(object sender, RemoteSessionStateMachineEventArgs fsmEventArg)
        {
            using (s_trace.TraceEventHandlers())
            {
                if (fsmEventArg == null)
                {
                    throw PSTraceSource.NewArgumentNullException("fsmEventArg");
                }

                Dbg.Assert(fsmEventArg.StateEvent == RemoteSessionEvent.NegotiationFailed, "StateEvent must be NegotiationFailed");

                RemoteSessionStateMachineEventArgs closeArg = new RemoteSessionStateMachineEventArgs(RemoteSessionEvent.Close);

                RaiseEventPrivate(closeArg);
            }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/remoting/server/serverremotesessionstatemachine.cs.ifdefed" startline="874" endline="889" pcid="4105">
        private void DoReceiveFailed(object sender, RemoteSessionStateMachineEventArgs fsmEventArg)
        {
            using (s_trace.TraceEventHandlers())
            {
                if (fsmEventArg == null)
                {
                    throw PSTraceSource.NewArgumentNullException("fsmEventArg");
                }

                Dbg.Assert(fsmEventArg.StateEvent == RemoteSessionEvent.ReceiveFailed, "StateEvent must be ReceivedFailed");

                RemoteSessionStateMachineEventArgs closeArg = new RemoteSessionStateMachineEventArgs(RemoteSessionEvent.Close);

                RaiseEventPrivate(closeArg);
            }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/remoting/server/serverremotesessionstatemachine.cs.ifdefed" startline="845" endline="860" pcid="4104">
        private void DoSendFailed(object sender, RemoteSessionStateMachineEventArgs fsmEventArg)
        {
            using (s_trace.TraceEventHandlers())
            {
                if (fsmEventArg == null)
                {
                    throw PSTraceSource.NewArgumentNullException("fsmEventArg");
                }

                Dbg.Assert(fsmEventArg.StateEvent == RemoteSessionEvent.SendFailed, "StateEvent must be SendFailed");

                RemoteSessionStateMachineEventArgs closeArg = new RemoteSessionStateMachineEventArgs(RemoteSessionEvent.Close);

                RaiseEventPrivate(closeArg);
            }
        }
</source>
</class>

<class classid="84" nclones="2" nlines="13" similarity="84">
<source file="PowerShell/src/System.Management.Automation/engine/runtime/Operations/NumericOps.cs.ifdefed" startline="47" endline="71" pcid="4163">
        internal static object Divide(int lhs, int rhs)
        {
            // TBD: is it better to cover the special cases explicitly, or
            //      alternatively guard with try/catch?

            if (rhs == 0)
            {
                DivideByZeroException dbze = new DivideByZeroException();
                throw new RuntimeException(dbze.Message, dbze);
            }

            if (lhs == int.MinValue && rhs == -1)
            {
                // The result of this operation can't fit in an int, so promote.
                return (double)lhs / (double)rhs;
            }

            // If the remainder is 0, stay with integer division, otherwise use doubles.
            if ((lhs % rhs) == 0)
            {
                return lhs / rhs;
            }

            return (double)lhs / (double)rhs;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/runtime/Operations/NumericOps.cs.ifdefed" startline="232" endline="257" pcid="4186">
        internal static object Divide(long lhs, long rhs)
        {
            // TBD: is it better to cover the special cases explicitly, or
            //      alternatively guard with try/catch?

            if (rhs == 0)
            {
                DivideByZeroException dbze = new DivideByZeroException();
                throw new RuntimeException(dbze.Message, dbze);
            }

            // Special case.
            // This changes the sign of the min value, causing an integer overflow.
            if (lhs == long.MinValue && rhs == -1)
            {
                return (double)lhs / (double)rhs;
            }

            // If the remainder is 0, stay with integer division, otherwise use doubles.
            if ((lhs % rhs) == 0)
            {
                return lhs / rhs;
            }

            return (double)lhs / (double)rhs;
        }
</source>
</class>

<class classid="85" nclones="2" nlines="10" similarity="70">
<source file="PowerShell/src/System.Management.Automation/engine/runtime/Operations/NumericOps.cs.ifdefed" startline="73" endline="92" pcid="4164">
        internal static object Remainder(int lhs, int rhs)
        {
            // TBD: is it better to cover the special cases explicitly, or
            //      alternatively guard with try/catch?

            if (rhs == 0)
            {
                DivideByZeroException dbze = new DivideByZeroException();
                throw new RuntimeException(dbze.Message, dbze);
            }

            if (lhs == int.MinValue && rhs == -1)
            {
                // The CLR raises an overflow exception for these values.  PowerShell typically
                // promotes whenever things overflow, so we just hard code the result value.
                return 0;
            }

            return lhs % rhs;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/runtime/Operations/NumericOps.cs.ifdefed" startline="259" endline="278" pcid="4187">
        internal static object Remainder(long lhs, long rhs)
        {
            // TBD: is it better to cover the special cases explicitly, or
            //      alternatively guard with try/catch?

            if (rhs == 0)
            {
                DivideByZeroException dbze = new DivideByZeroException();
                throw new RuntimeException(dbze.Message, dbze);
            }

            if (lhs == long.MinValue && rhs == -1)
            {
                // The CLR raises an overflow exception for these values.  PowerShell typically
                // promotes whenever things overflow, so we just hard code the result value.
                return 0L;
            }

            return lhs % rhs;
        }
</source>
</class>

<class classid="86" nclones="2" nlines="10" similarity="90">
<source file="PowerShell/src/System.Management.Automation/engine/runtime/Operations/NumericOps.cs.ifdefed" startline="155" endline="173" pcid="4175">
        internal static object Divide(uint lhs, uint rhs)
        {
            // TBD: is it better to cover the special cases explicitly, or
            //      alternatively guard with try/catch?

            if (rhs == 0)
            {
                DivideByZeroException dbze = new DivideByZeroException();
                throw new RuntimeException(dbze.Message, dbze);
            }

            // If the remainder is 0, stay with integer division, otherwise use doubles.
            if ((lhs % rhs) == 0)
            {
                return lhs / rhs;
            }

            return (double)lhs / (double)rhs;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/runtime/Operations/NumericOps.cs.ifdefed" startline="323" endline="341" pcid="4197">
        internal static object Divide(ulong lhs, ulong rhs)
        {
            // TBD: is it better to cover the special cases explicitly, or
            //      alternatively guard with try/catch?

            if (rhs == 0)
            {
                DivideByZeroException dbze = new DivideByZeroException();
                throw new RuntimeException(dbze.Message, dbze);
            }

            // If the remainder is 0, stay with integer division, otherwise use doubles.
            if ((lhs % rhs) == 0)
            {
                return lhs / rhs;
            }

            return (double)lhs / (double)rhs;
        }
</source>
</class>

<class classid="87" nclones="2" nlines="11" similarity="81">
<source file="PowerShell/src/System.Management.Automation/engine/runtime/Operations/NumericOps.cs.ifdefed" startline="403" endline="417" pcid="4208">
        internal static object Divide(decimal lhs, decimal rhs)
        {
            try
            {
                return checked(lhs / rhs);
            }
            catch (OverflowException oe)
            {
                throw new RuntimeException(oe.Message, oe);
            }
            catch (DivideByZeroException dbze)
            {
                throw new RuntimeException(dbze.Message, dbze);
            }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/runtime/Operations/NumericOps.cs.ifdefed" startline="419" endline="433" pcid="4209">
        internal static object Remainder(decimal lhs, decimal rhs)
        {
            try
            {
                return checked(lhs % rhs);
            }
            catch (OverflowException oe)
            {
                throw new RuntimeException(oe.Message, oe);
            }
            catch (DivideByZeroException dbze)
            {
                throw new RuntimeException(dbze.Message, dbze);
            }
        }
</source>
</class>

<class classid="88" nclones="3" nlines="17" similarity="70">
<source file="PowerShell/src/System.Management.Automation/engine/runtime/Operations/NumericOps.cs.ifdefed" startline="435" endline="460" pcid="4210">
        internal static object BNot(decimal val)
        {
            if (val <= int.MaxValue && val >= int.MinValue)
            {
                return unchecked(~LanguagePrimitives.ConvertTo<int>(val));
            }

            if (val <= uint.MaxValue && val >= uint.MinValue)
            {
                return unchecked(~LanguagePrimitives.ConvertTo<uint>(val));
            }

            if (val <= long.MaxValue && val >= long.MinValue)
            {
                return unchecked(~LanguagePrimitives.ConvertTo<long>(val));
            }

            if (val <= ulong.MaxValue && val >= ulong.MinValue)
            {
                return unchecked(~LanguagePrimitives.ConvertTo<ulong>(val));
            }

            LanguagePrimitives.ThrowInvalidCastException(val, typeof(int));
            Diagnostics.Assert(false, "an exception is raised by LanguagePrimitives.ThrowInvalidCastException.");
            return null;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/runtime/Operations/NumericOps.cs.ifdefed" startline="523" endline="548" pcid="4215">
        internal static object LeftShift(decimal val, int count)
        {
            if (val <= int.MaxValue && val >= int.MinValue)
            {
                return unchecked(LanguagePrimitives.ConvertTo<int>(val) << count);
            }

            if (val <= uint.MaxValue && val >= uint.MinValue)
            {
                return unchecked(LanguagePrimitives.ConvertTo<uint>(val) << count);
            }

            if (val <= long.MaxValue && val >= long.MinValue)
            {
                return unchecked(LanguagePrimitives.ConvertTo<long>(val) << count);
            }

            if (val <= ulong.MaxValue && val >= ulong.MinValue)
            {
                return unchecked(LanguagePrimitives.ConvertTo<ulong>(val) << count);
            }

            LanguagePrimitives.ThrowInvalidCastException(val, typeof(int));
            Diagnostics.Assert(false, "an exception is raised by LanguagePrimitives.ThrowInvalidCastException.");
            return null;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/runtime/Operations/NumericOps.cs.ifdefed" startline="550" endline="575" pcid="4216">
        internal static object RightShift(decimal val, int count)
        {
            if (val <= int.MaxValue && val >= int.MinValue)
            {
                return unchecked(LanguagePrimitives.ConvertTo<int>(val) >> count);
            }

            if (val <= uint.MaxValue && val >= uint.MinValue)
            {
                return unchecked(LanguagePrimitives.ConvertTo<uint>(val) >> count);
            }

            if (val <= long.MaxValue && val >= long.MinValue)
            {
                return unchecked(LanguagePrimitives.ConvertTo<long>(val) >> count);
            }

            if (val <= ulong.MaxValue && val >= ulong.MinValue)
            {
                return unchecked(LanguagePrimitives.ConvertTo<ulong>(val) >> count);
            }

            LanguagePrimitives.ThrowInvalidCastException(val, typeof(int));
            Diagnostics.Assert(false, "an exception is raised by LanguagePrimitives.ThrowInvalidCastException.");
            return null;
        }
</source>
</class>

<class classid="89" nclones="6" nlines="10" similarity="70">
<source file="PowerShell/src/System.Management.Automation/engine/runtime/Operations/NumericOps.cs.ifdefed" startline="462" endline="476" pcid="4211">
        internal static object BOr(decimal lhs, decimal rhs)
        {
            ulong l = ConvertToUlong(lhs);
            ulong r = ConvertToUlong(rhs);

            // If either operand is signed, return signed result
            if (lhs < 0 || rhs < 0)
            {
                unchecked
                {
                    return (long)(l | r);
                }
            }
            return l | r;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/runtime/Operations/NumericOps.cs.ifdefed" startline="728" endline="742" pcid="4245">
        internal static object BAnd(double lhs, double rhs)
        {
            ulong l = ConvertToUlong(lhs);
            ulong r = ConvertToUlong(rhs);

            // If either operand is signed, return signed result
            if (lhs < 0 || rhs < 0)
            {
                unchecked
                {
                    return (long)(l & r);
                }
            }
            return l & r;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/runtime/Operations/NumericOps.cs.ifdefed" startline="494" endline="508" pcid="4213">
        internal static object BAnd(decimal lhs, decimal rhs)
        {
            ulong l = ConvertToUlong(lhs);
            ulong r = ConvertToUlong(rhs);

            // If either operand is signed, return signed result
            if (lhs < 0 || rhs < 0)
            {
                unchecked
                {
                    return (long)(l & r);
                }
            }
            return l & r;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/runtime/Operations/NumericOps.cs.ifdefed" startline="712" endline="726" pcid="4244">
        internal static object BXor(double lhs, double rhs)
        {
            ulong l = ConvertToUlong(lhs);
            ulong r = ConvertToUlong(rhs);

            // If either operand is signed, return signed result
            if (lhs < 0 || rhs < 0)
            {
                unchecked
                {
                    return (long)(l ^ r);
                }
            }
            return l ^ r;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/runtime/Operations/NumericOps.cs.ifdefed" startline="478" endline="492" pcid="4212">
        internal static object BXor(decimal lhs, decimal rhs)
        {
            ulong l = ConvertToUlong(lhs);
            ulong r = ConvertToUlong(rhs);

            // If either operand is signed, return signed result
            if (lhs < 0 || rhs < 0)
            {
                unchecked
                {
                    return (long)(l ^ r);
                }
            }
            return l ^ r;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/runtime/Operations/NumericOps.cs.ifdefed" startline="696" endline="710" pcid="4243">
        internal static object BOr(double lhs, double rhs)
        {
            ulong l = ConvertToUlong(lhs);
            ulong r = ConvertToUlong(rhs);

            // If either operand is signed, return signed result
            if (lhs < 0 || rhs < 0)
            {
                unchecked
                {
                    return (long)(l | r);
                }
            }
            return l | r;
        }
</source>
</class>

<class classid="90" nclones="2" nlines="19" similarity="73">
<source file="PowerShell/src/System.Management.Automation/engine/runtime/Operations/NumericOps.cs.ifdefed" startline="757" endline="785" pcid="4247">
        internal static object LeftShift(double val, int count)
        {
            checked
            {
                if (val <= int.MaxValue && val >= int.MinValue)
                {
                    return LanguagePrimitives.ConvertTo<int>(val) << count;
                }

                if (val <= uint.MaxValue && val >= uint.MinValue)
                {
                    return LanguagePrimitives.ConvertTo<uint>(val) << count;
                }

                if (val <= long.MaxValue && val >= long.MinValue)
                {
                    return LanguagePrimitives.ConvertTo<long>(val) << count;
                }

                if (val <= ulong.MaxValue && val >= ulong.MinValue)
                {
                    return LanguagePrimitives.ConvertTo<ulong>(val) << count;
                }
            }

            LanguagePrimitives.ThrowInvalidCastException(val, typeof(ulong));
            Diagnostics.Assert(false, "an exception is raised by LanguagePrimitives.ThrowInvalidCastException.");
            return null;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/runtime/Operations/NumericOps.cs.ifdefed" startline="787" endline="815" pcid="4248">
        internal static object RightShift(double val, int count)
        {
            checked
            {
                if (val <= int.MaxValue && val >= int.MinValue)
                {
                    return LanguagePrimitives.ConvertTo<int>(val) >> count;
                }

                if (val <= uint.MaxValue && val >= uint.MinValue)
                {
                    return LanguagePrimitives.ConvertTo<uint>(val) >> count;
                }

                if (val <= long.MaxValue && val >= long.MinValue)
                {
                    return LanguagePrimitives.ConvertTo<long>(val) >> count;
                }

                if (val <= ulong.MaxValue && val >= ulong.MinValue)
                {
                    return LanguagePrimitives.ConvertTo<ulong>(val) >> count;
                }
            }

            LanguagePrimitives.ThrowInvalidCastException(val, typeof(ulong));
            Diagnostics.Assert(false, "an exception is raised by LanguagePrimitives.ThrowInvalidCastException.");
            return null;
        }
</source>
</class>

<class classid="91" nclones="2" nlines="17" similarity="88">
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateCmdletAPIs.cs.ifdefed" startline="234" endline="268" pcid="4299">
        internal void RemoveCmdlet(string name, int index, bool force, CommandOrigin origin)
        {
            if (String.IsNullOrEmpty(name))
            {
                throw PSTraceSource.NewArgumentException("name");
            }

            // Use the scope enumerator to find an existing function

            SessionStateScopeEnumerator scopeEnumerator =
                new SessionStateScopeEnumerator(_currentScope);

            foreach (SessionStateScope scope in scopeEnumerator)
            {
                CmdletInfo cmdletInfo =
                    scope.GetCmdlet(name);

                if (cmdletInfo != null)
                {
                    // Make sure the cmdlet isn't private or if it is that the current
                    // scope is the same scope the cmdlet was retrieved from.

                    if ((cmdletInfo.Options & ScopedItemOptions.Private) != 0 &&
                        scope != _currentScope)
                    {
                        cmdletInfo = null;
                    }
                    else
                    {
                        scope.RemoveCmdlet(name, index, force);
                        break;
                    }
                }
            }
        } // RemoveCmdlet
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateCmdletAPIs.cs.ifdefed" startline="285" endline="319" pcid="4300">
        internal void RemoveCmdletEntry(string name, bool force)
        {
            if (String.IsNullOrEmpty(name))
            {
                throw PSTraceSource.NewArgumentException("name");
            }

            // Use the scope enumerator to find an existing function

            SessionStateScopeEnumerator scopeEnumerator =
                new SessionStateScopeEnumerator(_currentScope);

            foreach (SessionStateScope scope in scopeEnumerator)
            {
                CmdletInfo cmdletInfo =
                    scope.GetCmdlet(name);

                if (cmdletInfo != null)
                {
                    // Make sure the cmdlet isn't private or if it is that the current
                    // scope is the same scope the cmdlet was retrieved from.

                    if ((cmdletInfo.Options & ScopedItemOptions.Private) != 0 &&
                        scope != _currentScope)
                    {
                        cmdletInfo = null;
                    }
                    else
                    {
                        scope.RemoveCmdletEntry(name, force);
                        break;
                    }
                }
            }
        } // RemoveCmdlet
</source>
</class>

<class classid="92" nclones="7" nlines="11" similarity="72">
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateContent.cs.ifdefed" startline="53" endline="69" pcid="4301">
        internal Collection<IContentReader> GetContentReader(string[] paths, bool force, bool literalPath)
        {
            if (paths == null)
            {
                throw PSTraceSource.NewArgumentNullException("paths");
            }

            CmdletProviderContext context = new CmdletProviderContext(this.ExecutionContext);
            context.Force = force;
            context.SuppressWildcardExpansion = literalPath;

            Collection<IContentReader> results = GetContentReader(paths, context);

            context.ThrowFirstErrorOrDoNothing();

            return results;
        } // GetContentReader
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateContent.cs.ifdefed" startline="398" endline="414" pcid="4306">
        internal Collection<IContentWriter> GetContentWriter(string[] paths, bool force, bool literalPath)
        {
            if (paths == null)
            {
                throw PSTraceSource.NewArgumentNullException("paths");
            }

            CmdletProviderContext context = new CmdletProviderContext(this.ExecutionContext);
            context.Force = force;
            context.SuppressWildcardExpansion = literalPath;

            Collection<IContentWriter> results = GetContentWriter(paths, context);

            context.ThrowFirstErrorOrDoNothing();

            return results;
        } // GetContentWriter
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateItem.cs.ifdefed" startline="54" endline="74" pcid="4362">
        internal Collection<PSObject> GetItem(string[] paths, bool force, bool literalPath)
        {
            if (paths == null)
            {
                throw PSTraceSource.NewArgumentNullException("paths");
            }

            CmdletProviderContext context = new CmdletProviderContext(this.ExecutionContext);
            context.Force = force;
            context.SuppressWildcardExpansion = literalPath;

            GetItem(paths, context);

            context.ThrowFirstErrorOrDoNothing();

            // Since there was not errors return the accumulated objects

            Collection<PSObject> results = context.GetAccumulatedObjects();

            return results;
        } // GetItem
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateContent.cs.ifdefed" startline="737" endline="751" pcid="4311">
        internal void ClearContent(string[] paths, bool force, bool literalPath)
        {
            if (paths == null)
            {
                throw PSTraceSource.NewArgumentNullException("paths");
            }

            CmdletProviderContext context = new CmdletProviderContext(this.ExecutionContext);
            context.Force = force;
            context.SuppressWildcardExpansion = literalPath;

            ClearContent(paths, context);

            context.ThrowFirstErrorOrDoNothing();
        } // ClearContent
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateItem.cs.ifdefed" startline="391" endline="409" pcid="4367">
        internal Collection<PSObject> SetItem(string[] paths, object value, bool force, bool literalPath)
        {
            if (paths == null)
            {
                throw PSTraceSource.NewArgumentNullException("paths");
            }

            CmdletProviderContext context = new CmdletProviderContext(this.ExecutionContext);
            context.Force = force;
            context.SuppressWildcardExpansion = literalPath;

            SetItem(paths, value, context);

            context.ThrowFirstErrorOrDoNothing();

            // Since there was no errors return the accumulated objects

            return context.GetAccumulatedObjects();
        } // SetItem
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateNavigation.cs.ifdefed" startline="1332" endline="1350" pcid="4411">
        internal Collection<PSObject> MoveItem(string[] paths, string destination, bool force, bool literalPath)
        {
            if (paths == null)
            {
                throw PSTraceSource.NewArgumentNullException("paths");
            }

            CmdletProviderContext context = new CmdletProviderContext(this.ExecutionContext);
            context.Force = force;
            context.SuppressWildcardExpansion = literalPath;

            MoveItem(paths, destination, context);

            context.ThrowFirstErrorOrDoNothing();

            // Since there was no errors return the accumulated objects

            return context.GetAccumulatedObjects();
        } // MoveItem
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateItem.cs.ifdefed" startline="742" endline="758" pcid="4372">
        internal Collection<PSObject> ClearItem(string[] paths, bool force, bool literalPath)
        {
            if (paths == null)
            {
                throw PSTraceSource.NewArgumentNullException("paths");
            }

            CmdletProviderContext context = new CmdletProviderContext(this.ExecutionContext);
            context.Force = force;
            context.SuppressWildcardExpansion = literalPath;

            ClearItem(paths, context);

            context.ThrowFirstErrorOrDoNothing();

            return context.GetAccumulatedObjects();
        } // ClearItem
</source>
</class>

<class classid="93" nclones="34" nlines="24" similarity="70">
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateContent.cs.ifdefed" startline="169" endline="219" pcid="4303">
        private IContentReader GetContentReaderPrivate(
            CmdletProvider providerInstance,
            string path,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            IContentReader result = null;

            try
            {
                result = providerInstance.GetContentReader(path, context);
            }
            catch (NotSupportedException)
            {
                throw;
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "GetContentReaderProviderException",
                    SessionStateStrings.GetContentReaderProviderException,
                    providerInstance.ProviderInfo,
                    path,
                    e);
            }
            return result;
        } // GetContentReaderPrivate
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateNavigation.cs.ifdefed" startline="1229" endline="1283" pcid="4410">
        private string GetChildName(
            CmdletProvider providerInstance,
            string path,
            CmdletProviderContext context,
            bool acceptNonContainerProviders
            )
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            string result = null;

            NavigationCmdletProvider navigationCmdletProvider =
                GetNavigationProviderInstance(providerInstance, acceptNonContainerProviders);

            if (navigationCmdletProvider == null)
                return path;

            try
            {
                result = navigationCmdletProvider.GetChildName(path, context);
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "GetChildNameProviderException",
                    SessionStateStrings.GetChildNameProviderException,
                    navigationCmdletProvider.ProviderInfo,
                    path,
                    e);
            }
            return result;
        } // GetChildName
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateDynamicProperty.cs.ifdefed" startline="580" endline="632" pcid="4344">
        private void RemoveProperty(
            CmdletProvider providerInstance,
            string path,
            string property,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                property != null,
                "Caller should validate property before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            try
            {
                providerInstance.RemoveProperty(path, property, context);
            }
            catch (NotSupportedException)
            {
                throw;
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "RemovePropertyProviderException",
                    SessionStateStrings.RemovePropertyProviderException,
                    providerInstance.ProviderInfo,
                    path,
                    e);
            }
        } // RemoveProperty
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateDynamicProperty.cs.ifdefed" startline="1933" endline="1990" pcid="4359">
        private void RenameProperty(
            CmdletProvider providerInstance,
            string sourcePath,
            string sourceProperty,
            string destinationProperty,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                sourcePath != null,
                "Caller should validate sourcePath before calling this method");

            Dbg.Diagnostics.Assert(
                sourceProperty != null,
                "Caller should validate sourceProperty before calling this method");

            Dbg.Diagnostics.Assert(
                destinationProperty != null,
                "Caller should validate destinationProperty before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            try
            {
                providerInstance.RenameProperty(sourcePath, sourceProperty, destinationProperty, context);
            }
            catch (NotSupportedException)
            {
                throw;
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "RenamePropertyProviderException",
                    SessionStateStrings.RenamePropertyProviderException,
                    providerInstance.ProviderInfo,
                    sourcePath,
                    e);
            }
        } // RenameProperty
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateProperty.cs.ifdefed" startline="900" endline="952" pcid="4428">
        private void ClearPropertyPrivate(
            CmdletProvider providerInstance,
            string path,
            Collection<string> propertyToClear,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                propertyToClear != null,
                "Caller should validate propertyToClear before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            try
            {
                providerInstance.ClearProperty(path, propertyToClear, context);
            }
            catch (NotSupportedException)
            {
                throw;
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "ClearPropertyProviderException",
                    SessionStateStrings.ClearPropertyProviderException,
                    providerInstance.ProviderInfo,
                    path,
                    e);
            }
        } // ClearPropertyPrivate
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateDynamicProperty.cs.ifdefed" startline="206" endline="260" pcid="4339">
        private void NewProperty(
            CmdletProvider providerInstance,
            string path,
            string property,
            string type,
            object value,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                property != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            try
            {
                providerInstance.NewProperty(path, property, type, value, context);
            }
            catch (NotSupportedException)
            {
                throw;
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "NewPropertyProviderException",
                    SessionStateStrings.NewPropertyProviderException,
                    providerInstance.ProviderInfo,
                    path,
                    e);
            }
        } // NewProperty
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateContent.cs.ifdefed" startline="312" endline="361" pcid="4305">
        private object GetContentReaderDynamicParameters(
            CmdletProvider providerInstance,
            string path,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            object result = null;
            try
            {
                result = providerInstance.GetContentReaderDynamicParameters(path, context);
            }
            catch (NotSupportedException)
            {
                throw;
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "GetContentReaderDynamicParametersProviderException",
                    SessionStateStrings.GetContentReaderDynamicParametersProviderException,
                    providerInstance.ProviderInfo,
                    path,
                    e);
            }
            return result;
        } // GetContentReaderDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateDynamicProperty.cs.ifdefed" startline="2102" endline="2157" pcid="4361">
        private object RenamePropertyDynamicParameters(
            CmdletProvider providerInstance,
            string path,
            string sourceProperty,
            string destinationProperty,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            object result = null;
            try
            {
                result = providerInstance.RenamePropertyDynamicParameters(
                    path,
                    sourceProperty,
                    destinationProperty,
                    context);
            }
            catch (NotSupportedException)
            {
                throw;
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "RenamePropertyDynamicParametersProviderException",
                    SessionStateStrings.RenamePropertyDynamicParametersProviderException,
                    providerInstance.ProviderInfo,
                    path,
                    e);
            }
            return result;
        } // RenamePropertyDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateProperty.cs.ifdefed" startline="692" endline="742" pcid="4425">
        private object SetPropertyDynamicParameters(
            CmdletProvider providerInstance,
            string path,
            PSObject propertyValue,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            object result = null;
            try
            {
                result = providerInstance.SetPropertyDynamicParameters(path, propertyValue, context);
            }
            catch (NotSupportedException)
            {
                throw;
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "SetPropertyDynamicParametersProviderException",
                    SessionStateStrings.SetPropertyDynamicParametersProviderException,
                    providerInstance.ProviderInfo,
                    path,
                    e);
            }
            return result;
        } // SetPropertyDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateContent.cs.ifdefed" startline="512" endline="561" pcid="4308">
        private IContentWriter GetContentWriterPrivate(
            CmdletProvider providerInstance,
            string path,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            IContentWriter result = null;
            try
            {
                result = providerInstance.GetContentWriter(path, context);
            }
            catch (NotSupportedException)
            {
                throw;
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "GetContentWriterProviderException",
                    SessionStateStrings.GetContentWriterProviderException,
                    providerInstance.ProviderInfo,
                    path,
                    e);
            }
            return result;
        } // GetContentWriterPrivate
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateProperty.cs.ifdefed" startline="174" endline="222" pcid="4418">
        private void GetPropertyPrivate(
            CmdletProvider providerInstance,
            string path,
            Collection<string> providerSpecificPickList,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            try
            {
                providerInstance.GetProperty(path, providerSpecificPickList, context);
            }
            catch (NotSupportedException)
            {
                throw;
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "GetPropertyProviderException",
                    SessionStateStrings.GetPropertyProviderException,
                    providerInstance.ProviderInfo,
                    path,
                    e);
            }
        } // GetPropertyPrivate
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateProperty.cs.ifdefed" startline="322" endline="372" pcid="4420">
        private object GetPropertyDynamicParameters(
            CmdletProvider providerInstance,
            string path,
            Collection<string> providerSpecificPickList,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            object result = null;
            try
            {
                result = providerInstance.GetPropertyDynamicParameters(path, providerSpecificPickList, context);
            }
            catch (NotSupportedException)
            {
                throw;
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "GetPropertyDynamicParametersProviderException",
                    SessionStateStrings.GetPropertyDynamicParametersProviderException,
                    providerInstance.ProviderInfo,
                    path,
                    e);
            }
            return result;
        } // GetPropertyDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateContent.cs.ifdefed" startline="976" endline="1025" pcid="4315">
        private object ClearContentDynamicParameters(
            CmdletProvider providerInstance,
            string path,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            object result = null;
            try
            {
                result = providerInstance.ClearContentDynamicParameters(path, context);
            }
            catch (NotSupportedException)
            {
                throw;
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "ClearContentDynamicParametersProviderException",
                    SessionStateStrings.ClearContentDynamicParametersProviderException,
                    providerInstance.ProviderInfo,
                    path,
                    e);
            }
            return result;
        } // ClearContentDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateItem.cs.ifdefed" startline="302" endline="350" pcid="4366">
        private object GetItemDynamicParameters(
            CmdletProvider providerInstance,
            string path,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            ItemCmdletProvider itemCmdletProvider =
                GetItemProviderInstance(providerInstance);

            object result = null;
            try
            {
                result = itemCmdletProvider.GetItemDynamicParameters(path, context);
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "GetItemDynamicParametersProviderException",
                    SessionStateStrings.GetItemDynamicParametersProviderException,
                    itemCmdletProvider.ProviderInfo,
                    path,
                    e);
            }
            return result;
        } // GetItemDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateContent.cs.ifdefed" startline="837" endline="884" pcid="4313">
        private void ClearContentPrivate(
            CmdletProvider providerInstance,
            string path,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            try
            {
                providerInstance.ClearContent(path, context);
            }
            catch (NotSupportedException)
            {
                throw;
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "ClearContentProviderException",
                    SessionStateStrings.ClearContentProviderException,
                    providerInstance.ProviderInfo,
                    path,
                    e);
            }
        } // ClearContentPrivate
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateContent.cs.ifdefed" startline="654" endline="703" pcid="4310">
        private object GetContentWriterDynamicParameters(
            CmdletProvider providerInstance,
            string path,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            object result = null;
            try
            {
                result = providerInstance.GetContentWriterDynamicParameters(path, context);
            }
            catch (NotSupportedException)
            {
                throw;
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "GetContentWriterDynamicParametersProviderException",
                    SessionStateStrings.GetContentWriterDynamicParametersProviderException,
                    providerInstance.ProviderInfo,
                    path,
                    e);
            }
            return result;
        } // GetContentWriterDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateNavigation.cs.ifdefed" startline="380" endline="434" pcid="4397">
        internal string GetParentPath(
            CmdletProvider providerInstance,
            string path,
            string root,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                root != null,
                "Caller should validate root before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            NavigationCmdletProvider navigationCmdletProvider =
                GetNavigationProviderInstance(providerInstance, false);

            string result = null;

            try
            {
                result = navigationCmdletProvider.GetParentPath(path, root, context);
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "GetParentPathProviderException",
                    SessionStateStrings.GetParentPathProviderException,
                    navigationCmdletProvider.ProviderInfo,
                    path,
                    e);
            }
            return result;
        } // GetParentPath
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateDynamicProperty.cs.ifdefed" startline="1509" endline="1571" pcid="4354">
        private void MoveProperty(
            CmdletProvider providerInstance,
            string sourcePath,
            string sourceProperty,
            string destinationPath,
            string destinationProperty,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                sourcePath != null,
                "Caller should validate sourcePath before calling this method");

            Dbg.Diagnostics.Assert(
                sourceProperty != null,
                "Caller should validate sourceProperty before calling this method");

            Dbg.Diagnostics.Assert(
                destinationPath != null,
                "Caller should validate destinationPath before calling this method");

            Dbg.Diagnostics.Assert(
                destinationProperty != null,
                "Caller should validate destinationProperty before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            try
            {
                providerInstance.MoveProperty(sourcePath, sourceProperty, destinationPath, destinationProperty, context);
            }
            catch (NotSupportedException)
            {
                throw;
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "MovePropertyProviderException",
                    SessionStateStrings.MovePropertyProviderException,
                    providerInstance.ProviderInfo,
                    sourcePath,
                    e);
            }
        } // MoveProperty
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateDynamicProperty.cs.ifdefed" startline="732" endline="782" pcid="4346">
        private object RemovePropertyDynamicParameters(
            CmdletProvider providerInstance,
            string path,
            string propertyName,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            object result = null;
            try
            {
                result = providerInstance.RemovePropertyDynamicParameters(path, propertyName, context);
            }
            catch (NotSupportedException)
            {
                throw;
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "RemovePropertyDynamicParametersProviderException",
                    SessionStateStrings.RemovePropertyDynamicParametersProviderException,
                    providerInstance.ProviderInfo,
                    path,
                    e);
            }
            return result;
        } // RemovePropertyDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateDynamicProperty.cs.ifdefed" startline="374" endline="426" pcid="4341">
        private object NewPropertyDynamicParameters(
            CmdletProvider providerInstance,
            string path,
            string propertyName,
            string type,
            object value,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            object result = null;
            try
            {
                result = providerInstance.NewPropertyDynamicParameters(path, propertyName, type, value, context);
            }
            catch (NotSupportedException)
            {
                throw;
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "NewPropertyDynamicParametersProviderException",
                    SessionStateStrings.NewPropertyDynamicParametersProviderException,
                    providerInstance.ProviderInfo,
                    path,
                    e);
            }
            return result;
        } // NewPropertyDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateItem.cs.ifdefed" startline="650" endline="699" pcid="4371">
        private object SetItemDynamicParameters(
            CmdletProvider providerInstance,
            string path,
            object value,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            ItemCmdletProvider itemCmdletProvider =
                GetItemProviderInstance(providerInstance);

            object result = null;
            try
            {
                result = itemCmdletProvider.SetItemDynamicParameters(path, value, context);
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "SetItemDynamicParametersProviderException",
                    SessionStateStrings.SetItemDynamicParametersProviderException,
                    itemCmdletProvider.ProviderInfo,
                    path,
                    e);
            }
            return result;
        } // SetItemDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateNavigation.cs.ifdefed" startline="1680" endline="1734" pcid="4415">
        private object MoveItemDynamicParameters(
            CmdletProvider providerInstance,
            string path,
            string destination,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            NavigationCmdletProvider navigationCmdletProvider =
                GetNavigationProviderInstance(providerInstance, false);

            object result = null;

            try
            {
                result = navigationCmdletProvider.MoveItemDynamicParameters(path, destination, context);
            }
            catch (NotSupportedException)
            {
                throw;
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "MoveItemDynamicParametersProviderException",
                    SessionStateStrings.MoveItemDynamicParametersProviderException,
                    navigationCmdletProvider.ProviderInfo,
                    path,
                    e);
            }
            return result;
        } // MoveItemDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateProperty.cs.ifdefed" startline="540" endline="592" pcid="4423">
        private void SetPropertyPrivate(
            CmdletProvider providerInstance,
            string path,
            PSObject property,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                property != null,
                "Caller should validate properties before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            try
            {
                providerInstance.SetProperty(path, property, context);
            }
            catch (NotSupportedException)
            {
                throw;
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "SetPropertyProviderException",
                    SessionStateStrings.SetPropertyProviderException,
                    providerInstance.ProviderInfo,
                    path,
                    e);
            }
        } // SetPropertyPrivate
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateDynamicProperty.cs.ifdefed" startline="1025" endline="1087" pcid="4349">
        private void CopyProperty(
            CmdletProvider providerInstance,
            string sourcePath,
            string sourceProperty,
            string destinationPath,
            string destinationProperty,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                sourcePath != null,
                "Caller should validate sourcePath before calling this method");

            Dbg.Diagnostics.Assert(
                sourceProperty != null,
                "Caller should validate sourceProperty before calling this method");

            Dbg.Diagnostics.Assert(
                destinationPath != null,
                "Caller should validate destinationPath before calling this method");

            Dbg.Diagnostics.Assert(
                destinationProperty != null,
                "Caller should validate destinationProperty before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            try
            {
                providerInstance.CopyProperty(sourcePath, sourceProperty, destinationPath, destinationProperty, context);
            }
            catch (NotSupportedException)
            {
                throw;
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "CopyPropertyProviderException",
                    SessionStateStrings.CopyPropertyProviderException,
                    providerInstance.ProviderInfo,
                    sourcePath,
                    e);
            }
        } // CopyProperty
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateItem.cs.ifdefed" startline="1312" endline="1360" pcid="4381">
        private object InvokeDefaultActionDynamicParameters(
            CmdletProvider providerInstance,
            string path,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            ItemCmdletProvider itemCmdletProvider =
                GetItemProviderInstance(providerInstance);

            object result = null;
            try
            {
                result = itemCmdletProvider.InvokeDefaultActionDynamicParameters(path, context);
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "InvokeDefaultActionDynamicParametersProviderException",
                    SessionStateStrings.InvokeDefaultActionDynamicParametersProviderException,
                    itemCmdletProvider.ProviderInfo,
                    path,
                    e);
            }
            return result;
        } // InvokeDefaultActionDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateDynamicProperty.cs.ifdefed" startline="1207" endline="1264" pcid="4351">
        private object CopyPropertyDynamicParameters(
            CmdletProvider providerInstance,
            string path,
            string sourceProperty,
            string destinationPath,
            string destinationProperty,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            object result = null;
            try
            {
                result = providerInstance.CopyPropertyDynamicParameters(
                    path,
                    sourceProperty,
                    destinationPath,
                    destinationProperty,
                    context);
            }
            catch (NotSupportedException)
            {
                throw;
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "CopyPropertyDynamicParametersProviderException",
                    SessionStateStrings.CopyPropertyDynamicParametersProviderException,
                    providerInstance.ProviderInfo,
                    path,
                    e);
            }
            return result;
        } // CopyPropertyDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateItem.cs.ifdefed" startline="987" endline="1035" pcid="4376">
        private object ClearItemDynamicParameters(
            CmdletProvider providerInstance,
            string path,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            ItemCmdletProvider itemCmdletProvider =
                GetItemProviderInstance(providerInstance);

            object result = null;
            try
            {
                result = itemCmdletProvider.ClearItemDynamicParameters(path, context);
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "ClearItemProviderException",
                    SessionStateStrings.ClearItemProviderException,
                    itemCmdletProvider.ProviderInfo,
                    path,
                    e);
            }
            return result;
        } // ClearItemDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateProperty.cs.ifdefed" startline="1052" endline="1103" pcid="4430">
        private object ClearPropertyDynamicParameters(
            CmdletProvider providerInstance,
            string path,
            Collection<string> propertyToClear,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            object result = null;

            try
            {
                result = providerInstance.ClearPropertyDynamicParameters(path, propertyToClear, context);
            }
            catch (NotSupportedException)
            {
                throw;
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "ClearPropertyDynamicParametersProviderException",
                    SessionStateStrings.ClearPropertyDynamicParametersProviderException,
                    providerInstance.ProviderInfo,
                    path,
                    e);
            }
            return result;
        } // ClearPropertyDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateDynamicProperty.cs.ifdefed" startline="1691" endline="1749" pcid="4356">
        private object MovePropertyDynamicParameters(
            CmdletProvider providerInstance,
            string path,
            string sourceProperty,
            string destinationPath,
            string destinationProperty,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            object result = null;

            try
            {
                result = providerInstance.MovePropertyDynamicParameters(
                    path,
                    sourceProperty,
                    destinationPath,
                    destinationProperty,
                    context);
            }
            catch (NotSupportedException)
            {
                throw;
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "MovePropertyDynamicParametersProviderException",
                    SessionStateStrings.MovePropertyDynamicParametersProviderException,
                    providerInstance.ProviderInfo,
                    path,
                    e);
            }
            return result;
        } // MovePropertyDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateItem.cs.ifdefed" startline="165" endline="211" pcid="4364">
        private void GetItemPrivate(
            CmdletProvider providerInstance,
            string path,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            ItemCmdletProvider itemCmdletProvider =
                GetItemProviderInstance(providerInstance);

            try
            {
                itemCmdletProvider.GetItem(path, context);
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "GetItemProviderException",
                    SessionStateStrings.GetItemProviderException,
                    itemCmdletProvider.ProviderInfo,
                    path,
                    e);
            }
        } // GetItem
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateItem.cs.ifdefed" startline="850" endline="896" pcid="4374">
        private void ClearItemPrivate(
            CmdletProvider providerInstance,
            string path,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            ItemCmdletProvider itemCmdletProvider =
                GetItemProviderInstance(providerInstance);

            try
            {
                itemCmdletProvider.ClearItem(path, context);
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "ClearItemProviderException",
                    SessionStateStrings.ClearItemProviderException,
                    itemCmdletProvider.ProviderInfo,
                    path,
                    e);
            }
        } // ClearItem
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateItem.cs.ifdefed" startline="1175" endline="1221" pcid="4379">
        private void InvokeDefaultActionPrivate(
            CmdletProvider providerInstance,
            string path,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            ItemCmdletProvider itemCmdletProvider =
                GetItemProviderInstance(providerInstance);

            try
            {
                itemCmdletProvider.InvokeDefaultAction(path, context);
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "InvokeDefaultActionProviderException",
                    SessionStateStrings.InvokeDefaultActionProviderException,
                    itemCmdletProvider.ProviderInfo,
                    path,
                    e);
            }
        } // InvokeDefaultAction
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateNavigation.cs.ifdefed" startline="1533" endline="1580" pcid="4413">
        private void MoveItemPrivate(
            CmdletProvider providerInstance,
            string path,
            string destination,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            NavigationCmdletProvider navigationCmdletProvider =
                GetNavigationProviderInstance(providerInstance, false);

            try
            {
                navigationCmdletProvider.MoveItem(path, destination, context);
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "MoveItemProviderException",
                    SessionStateStrings.MoveItemProviderException,
                    navigationCmdletProvider.ProviderInfo,
                    path,
                    e);
            }
        } // MoveItem
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateItem.cs.ifdefed" startline="506" endline="553" pcid="4369">
        private void SetItem(
            CmdletProvider providerInstance,
            string path,
            object value,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            ItemCmdletProvider itemCmdletProvider =
                GetItemProviderInstance(providerInstance);

            try
            {
                itemCmdletProvider.SetItem(path, value, context);
            }
            catch (LoopFlowException)
            {
                throw;
            }
            catch (PipelineStoppedException)
            {
                throw;
            }
            catch (ActionPreferenceStopException)
            {
                throw;
            }
            catch (Exception e) // Catch-all OK, 3rd party callout.
            {
                throw NewProviderInvocationException(
                    "SetItemProviderException",
                    SessionStateStrings.SetItemProviderException,
                    itemCmdletProvider.ProviderInfo,
                    path,
                    e);
            }
        } // SetItem
</source>
</class>

<class classid="94" nclones="16" nlines="14" similarity="85">
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateContent.cs.ifdefed" startline="251" endline="285" pcid="4304">
        internal object GetContentReaderDynamicParameters(
             string path,
            CmdletProviderContext context)
        {
            if (path == null)
            {
                return null;
            }

            ProviderInfo provider = null;
            CmdletProvider providerInstance = null;

            CmdletProviderContext newContext =
                new CmdletProviderContext(context);
            newContext.SetFilters(
                new Collection<string>(),
                new Collection<string>(),
                null);

            Collection<string> providerPaths =
                Globber.GetGlobbedProviderPathsFromMonadPath(
                    path,
                    true,
                    newContext,
                    out provider,
                    out providerInstance);

            if (providerPaths.Count > 0)
            {
                // Get the dynamic parameters for the first resolved path

                return GetContentReaderDynamicParameters(providerInstance, providerPaths[0], newContext);
            }
            return null;
        } // GetContentReaderDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateDynamicProperty.cs.ifdefed" startline="301" endline="338" pcid="4340">
        internal object NewPropertyDynamicParameters(
             string path,
            string propertyName,
            string type,
            object value,
            CmdletProviderContext context)
        {
            if (path == null)
            {
                return null;
            }

            ProviderInfo provider = null;
            CmdletProvider providerInstance = null;

            CmdletProviderContext newContext =
                new CmdletProviderContext(context);
            newContext.SetFilters(
                new Collection<string>(),
                new Collection<string>(),
                null);

            Collection<string> providerPaths =
                Globber.GetGlobbedProviderPathsFromMonadPath(
                    path,
                    true,
                    newContext,
                    out provider,
                    out providerInstance);

            if (providerPaths.Count > 0)
            {
                // Get the dynamic parameters for the first resolved path

                return NewPropertyDynamicParameters(providerInstance, providerPaths[0], propertyName, type, value, newContext);
            }
            return null;
        } // NewPropertyDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateProperty.cs.ifdefed" startline="987" endline="1022" pcid="4429">
        internal object ClearPropertyDynamicParameters(
            string path,
            Collection<string> propertyToClear,
            CmdletProviderContext context)
        {
            if (path == null)
            {
                return null;
            }

            ProviderInfo provider = null;
            CmdletProvider providerInstance = null;

            CmdletProviderContext newContext =
               new CmdletProviderContext(context);
            newContext.SetFilters(
                new Collection<string>(),
                new Collection<string>(),
                null);

            Collection<string> providerPaths =
                 Globber.GetGlobbedProviderPathsFromMonadPath(
                    path,
                    true,
                    newContext,
                    out provider,
                    out providerInstance);

            if (providerPaths.Count > 0)
            {
                // Get the dynamic parameters for the first resolved path

                return ClearPropertyDynamicParameters(providerInstance, providerPaths[0], propertyToClear, newContext);
            }
            return null;
        } // ClearPropertyDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateProperty.cs.ifdefed" startline="257" endline="292" pcid="4419">
        internal object GetPropertyDynamicParameters(
            string path,
            Collection<string> providerSpecificPickList,
            CmdletProviderContext context)
        {
            if (path == null)
            {
                return null;
            }

            ProviderInfo provider = null;
            CmdletProvider providerInstance = null;

            CmdletProviderContext newContext =
               new CmdletProviderContext(context);
            newContext.SetFilters(
                new Collection<string>(),
                new Collection<string>(),
                null);

            Collection<string> providerPaths =
                 Globber.GetGlobbedProviderPathsFromMonadPath(
                    path,
                    true,
                    newContext,
                    out provider,
                    out providerInstance);

            if (providerPaths.Count > 0)
            {
                // Get the dynamic parameters for the first resolved path

                return GetPropertyDynamicParameters(providerInstance, providerPaths[0], providerSpecificPickList, newContext);
            }
            return null;
        } // GetPropertyDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateDynamicProperty.cs.ifdefed" startline="2028" endline="2069" pcid="4360">
        internal object RenamePropertyDynamicParameters(
             string path,
            string sourceProperty,
            string destinationProperty,
            CmdletProviderContext context)
        {
            if (path == null)
            {
                return null;
            }

            ProviderInfo provider = null;
            CmdletProvider providerInstance = null;

            CmdletProviderContext newContext =
                new CmdletProviderContext(context);
            newContext.SetFilters(
                new Collection<string>(),
                new Collection<string>(),
                null);

            Collection<string> providerPaths =
                Globber.GetGlobbedProviderPathsFromMonadPath(
                    path,
                    true,
                    newContext,
                    out provider,
                    out providerInstance);

            if (providerPaths.Count > 0)
            {
                // Get the dynamic parameters for the first resolved path

                return RenamePropertyDynamicParameters(
                    providerInstance,
                    providerPaths[0],
                    sourceProperty,
                    destinationProperty,
                    newContext);
            }
            return null;
        } // RenamePropertyDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateItem.cs.ifdefed" startline="243" endline="275" pcid="4365">
        internal object GetItemDynamicParameters(string path, CmdletProviderContext context)
        {
            if (path == null)
            {
                return null;
            }

            ProviderInfo provider = null;
            CmdletProvider providerInstance = null;

            CmdletProviderContext newContext =
                new CmdletProviderContext(context);
            newContext.SetFilters(
                new Collection<string>(),
                new Collection<string>(),
                null);

            Collection<string> providerPaths =
                Globber.GetGlobbedProviderPathsFromMonadPath(
                    path,
                    true,
                    newContext,
                    out provider,
                    out providerInstance);

            if (providerPaths.Count > 0)
            {
                // Get the dynamic parameters for the first resolved path

                return GetItemDynamicParameters(providerInstance, providerPaths[0], newContext);
            }
            return null;
        } // GetItemDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateItem.cs.ifdefed" startline="928" endline="960" pcid="4375">
        internal object ClearItemDynamicParameters(string path, CmdletProviderContext context)
        {
            if (path == null)
            {
                return null;
            }

            ProviderInfo provider = null;
            CmdletProvider providerInstance = null;

            CmdletProviderContext newContext =
               new CmdletProviderContext(context);
            newContext.SetFilters(
                new Collection<string>(),
                new Collection<string>(),
                null);

            Collection<string> providerPaths =
                 Globber.GetGlobbedProviderPathsFromMonadPath(
                    path,
                    true,
                    newContext,
                    out provider,
                    out providerInstance);

            if (providerPaths.Count > 0)
            {
                // Get the dynamic parameters for the first resolved path

                return ClearItemDynamicParameters(providerInstance, providerPaths[0], newContext);
            }
            return null;
        } // ClearItemDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateDynamicProperty.cs.ifdefed" startline="667" endline="702" pcid="4345">
        internal object RemovePropertyDynamicParameters(
             string path,
            string propertyName,
            CmdletProviderContext context)
        {
            if (path == null)
            {
                return null;
            }

            ProviderInfo provider = null;
            CmdletProvider providerInstance = null;

            CmdletProviderContext newContext =
               new CmdletProviderContext(context);
            newContext.SetFilters(
                new Collection<string>(),
                new Collection<string>(),
                null);

            Collection<string> providerPaths =
                 Globber.GetGlobbedProviderPathsFromMonadPath(
                    path,
                    true,
                    newContext,
                    out provider,
                    out providerInstance);

            if (providerPaths.Count > 0)
            {
                // Get the dynamic parameters for the first resolved path

                return RemovePropertyDynamicParameters(providerInstance, providerPaths[0], propertyName, newContext);
            }
            return null;
        } // RemovePropertyDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateContent.cs.ifdefed" startline="593" endline="627" pcid="4309">
        internal object GetContentWriterDynamicParameters(
             string path,
            CmdletProviderContext context)
        {
            if (path == null)
            {
                return null;
            }

            ProviderInfo provider = null;
            CmdletProvider providerInstance = null;

            CmdletProviderContext newContext =
                new CmdletProviderContext(context);
            newContext.SetFilters(
                new Collection<string>(),
                new Collection<string>(),
                null);

            Collection<string> providerPaths =
                Globber.GetGlobbedProviderPathsFromMonadPath(
                    path,
                    true,
                    newContext,
                    out provider,
                    out providerInstance);

            if (providerPaths.Count > 0)
            {
                // Get the dynamic parameters for the first resolved path

                return GetContentWriterDynamicParameters(providerInstance, providerPaths[0], newContext);
            }
            return null;
        } // GetContentWriterDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateProperty.cs.ifdefed" startline="627" endline="662" pcid="4424">
        internal object SetPropertyDynamicParameters(
            string path,
            PSObject propertyValue,
            CmdletProviderContext context)
        {
            if (path == null)
            {
                return null;
            }

            ProviderInfo provider = null;
            CmdletProvider providerInstance = null;

            CmdletProviderContext newContext =
                new CmdletProviderContext(context);
            newContext.SetFilters(
                new Collection<string>(),
                new Collection<string>(),
                null);

            Collection<string> providerPaths =
                Globber.GetGlobbedProviderPathsFromMonadPath(
                    path,
                    true,
                    newContext,
                    out provider,
                    out providerInstance);

            if (providerPaths.Count > 0)
            {
                // Get the dynamic parameters for the first resolved path

                return SetPropertyDynamicParameters(providerInstance, providerPaths[0], propertyValue, newContext);
            }
            return null;
        } // SetPropertyDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateNavigation.cs.ifdefed" startline="1615" endline="1650" pcid="4414">
        internal object MoveItemDynamicParameters(
            string path,
            string destination,
            CmdletProviderContext context)
        {
            if (path == null)
            {
                return null;
            }

            ProviderInfo provider = null;
            CmdletProvider providerInstance = null;

            CmdletProviderContext newContext =
                new CmdletProviderContext(context);
            newContext.SetFilters(
                new Collection<string>(),
                new Collection<string>(),
                null);

            Collection<string> providerPaths =
                Globber.GetGlobbedProviderPathsFromMonadPath(
                    path,
                    true,
                    newContext,
                    out provider,
                    out providerInstance);

            if (providerPaths.Count > 0)
            {
                // Get the dynamic parameters for the first resolved path

                return MoveItemDynamicParameters(providerInstance, providerPaths[0], destination, newContext);
            }
            return null;
        } // MoveItemDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateDynamicProperty.cs.ifdefed" startline="1612" endline="1655" pcid="4355">
        internal object MovePropertyDynamicParameters(
             string path,
            string sourceProperty,
            string destinationPath,
            string destinationProperty,
            CmdletProviderContext context)
        {
            if (path == null)
            {
                return null;
            }

            ProviderInfo provider = null;
            CmdletProvider providerInstance = null;

            CmdletProviderContext newContext =
                new CmdletProviderContext(context);
            newContext.SetFilters(
                new Collection<string>(),
                new Collection<string>(),
                null);

            Collection<string> providerPaths =
                Globber.GetGlobbedProviderPathsFromMonadPath(
                    path,
                    true,
                    newContext,
                    out provider,
                    out providerInstance);

            if (providerPaths.Count > 0)
            {
                // Get the dynamic parameters for the first resolved path

                return MovePropertyDynamicParameters(
                    providerInstance,
                    providerPaths[0],
                    sourceProperty,
                    destinationPath,
                    destinationProperty,
                    newContext);
            }
            return null;
        } // MovePropertyDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateItem.cs.ifdefed" startline="588" endline="620" pcid="4370">
        internal object SetItemDynamicParameters(string path, object value, CmdletProviderContext context)
        {
            if (path == null)
            {
                return null;
            }

            ProviderInfo provider = null;
            CmdletProvider providerInstance = null;

            CmdletProviderContext newContext =
               new CmdletProviderContext(context);
            newContext.SetFilters(
                new Collection<string>(),
                new Collection<string>(),
                null);

            Collection<string> providerPaths =
                 Globber.GetGlobbedProviderPathsFromMonadPath(
                    path,
                    true,
                    newContext,
                    out provider,
                    out providerInstance);

            if (providerPaths.Count > 0)
            {
                // Get the dynamic parameters for the first resolved path

                return SetItemDynamicParameters(providerInstance, providerPaths[0], value, newContext);
            }
            return null;
        } // SetItemDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateDynamicProperty.cs.ifdefed" startline="1128" endline="1171" pcid="4350">
        internal object CopyPropertyDynamicParameters(
             string path,
            string sourceProperty,
            string destinationPath,
            string destinationProperty,
            CmdletProviderContext context)
        {
            if (path == null)
            {
                return null;
            }

            ProviderInfo provider = null;
            CmdletProvider providerInstance = null;

            CmdletProviderContext newContext =
                new CmdletProviderContext(context);
            newContext.SetFilters(
                new Collection<string>(),
                new Collection<string>(),
                null);

            Collection<string> providerPaths =
                Globber.GetGlobbedProviderPathsFromMonadPath(
                    path,
                    true,
                    newContext,
                    out provider,
                    out providerInstance);

            if (providerPaths.Count > 0)
            {
                // Get the dynamic parameters for the first resolved path

                return CopyPropertyDynamicParameters(
                    providerInstance,
                    providerPaths[0],
                    sourceProperty,
                    destinationPath,
                    destinationProperty,
                    newContext);
            }
            return null;
        } // CopyPropertyDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateContent.cs.ifdefed" startline="916" endline="950" pcid="4314">
        internal object ClearContentDynamicParameters(
             string path,
            CmdletProviderContext context)
        {
            if (path == null)
            {
                return null;
            }

            ProviderInfo provider = null;
            CmdletProvider providerInstance = null;

            CmdletProviderContext newContext =
                new CmdletProviderContext(context);
            newContext.SetFilters(
                new Collection<string>(),
                new Collection<string>(),
                null);

            Collection<string> providerPaths =
                Globber.GetGlobbedProviderPathsFromMonadPath(
                    path,
                    true,
                    newContext,
                    out provider,
                    out providerInstance);

            if (providerPaths.Count > 0)
            {
                // Get the dynamic parameters for the first resolved path

                return ClearContentDynamicParameters(providerInstance, providerPaths[0], newContext);
            }
            return null;
        } // ClearContentDynamicParameters
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateItem.cs.ifdefed" startline="1253" endline="1285" pcid="4380">
        internal object InvokeDefaultActionDynamicParameters(string path, CmdletProviderContext context)
        {
            if (path == null)
            {
                return null;
            }

            ProviderInfo provider = null;
            CmdletProvider providerInstance = null;

            CmdletProviderContext newContext =
               new CmdletProviderContext(context);
            newContext.SetFilters(
                new Collection<string>(),
                new Collection<string>(),
                null);

            Collection<string> providerPaths =
                 Globber.GetGlobbedProviderPathsFromMonadPath(
                    path,
                    true,
                    newContext,
                    out provider,
                    out providerInstance);

            if (providerPaths.Count > 0)
            {
                // Get the dynamic parameters for the first resolved path

                return InvokeDefaultActionDynamicParameters(providerInstance, providerPaths[0], newContext);
            }
            return null;
        } // InvokeDefaultActionDynamicParameters
</source>
</class>

<class classid="95" nclones="10" nlines="17" similarity="71">
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateContent.cs.ifdefed" startline="782" endline="814" pcid="4312">
        internal void ClearContent(
              string[] paths,
              CmdletProviderContext context)
        {
            if (paths == null)
            {
                throw PSTraceSource.NewArgumentNullException("paths");
            }

            ProviderInfo provider = null;
            CmdletProvider providerInstance = null;

            foreach (string path in paths)
            {
                if (path == null)
                {
                    PSTraceSource.NewArgumentNullException("paths");
                }

                Collection<string> providerPaths =
                    Globber.GetGlobbedProviderPathsFromMonadPath(
                        path,
                        false,
                        context,
                        out provider,
                        out providerInstance);

                foreach (string providerPath in providerPaths)
                {
                    ClearContentPrivate(providerInstance, providerPath, context);
                }
            }
        } // ClearContent
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateItem.cs.ifdefed" startline="1117" endline="1152" pcid="4378">
        internal void InvokeDefaultAction(
            string[] paths,
            CmdletProviderContext context)
        {
            if (paths == null)
            {
                throw PSTraceSource.NewArgumentNullException("paths");
            }

            ProviderInfo provider = null;
            CmdletProvider providerInstance = null;

            foreach (string path in paths)
            {
                if (path == null)
                {
                    throw PSTraceSource.NewArgumentNullException("paths");
                }

                Collection<string> providerPaths =
                    Globber.GetGlobbedProviderPathsFromMonadPath(
                        path,
                        false,
                        context,
                        out provider,
                        out providerInstance);

                if (providerPaths != null)
                {
                    foreach (string providerPath in providerPaths)
                    {
                        InvokeDefaultActionPrivate(providerInstance, providerPath, context);
                    }
                }
            }
        } // InvokeDefaultAction
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateItem.cs.ifdefed" startline="110" endline="142" pcid="4363">
        internal void GetItem(
            string[] paths,
            CmdletProviderContext context)
        {
            if (paths == null)
            {
                throw PSTraceSource.NewArgumentNullException("paths");
            }

            ProviderInfo provider = null;
            CmdletProvider providerInstance = null;

            foreach (string path in paths)
            {
                if (path == null)
                {
                    throw PSTraceSource.NewArgumentNullException("paths");
                }

                Collection<string> providerPaths =
                    Globber.GetGlobbedProviderPathsFromMonadPath(
                        path,
                        false,
                        context,
                        out provider,
                        out providerInstance);

                foreach (string providerPath in providerPaths)
                {
                    GetItemPrivate(providerInstance, providerPath, context);
                }
            }
        } // GetItem
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateItem.cs.ifdefed" startline="792" endline="827" pcid="4373">
        internal void ClearItem(
            string[] paths,
            CmdletProviderContext context)
        {
            if (paths == null)
            {
                throw PSTraceSource.NewArgumentNullException("paths");
            }

            ProviderInfo provider = null;
            CmdletProvider providerInstance = null;

            foreach (string path in paths)
            {
                if (path == null)
                {
                    throw PSTraceSource.NewArgumentNullException("paths");
                }

                Collection<string> providerPaths =
                    Globber.GetGlobbedProviderPathsFromMonadPath(
                        path,
                        false,
                        context,
                        out provider,
                        out providerInstance);

                if (providerPaths != null)
                {
                    foreach (string providerPath in providerPaths)
                    {
                        ClearItemPrivate(providerInstance, providerPath, context);
                    }
                }
            }
        } // ClearItem
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateItem.cs.ifdefed" startline="444" endline="480" pcid="4368">
        internal void SetItem(
            string[] paths,
            object value,
            CmdletProviderContext context)
        {
            if (paths == null)
            {
                throw PSTraceSource.NewArgumentNullException("paths");
            }

            foreach (string path in paths)
            {
                if (path == null)
                {
                    throw PSTraceSource.NewArgumentNullException("paths");
                }

                ProviderInfo provider = null;
                CmdletProvider providerInstance = null;

                Collection<string> providerPaths =
                    Globber.GetGlobbedProviderPathsFromMonadPath(
                        path,
                        true,
                        context,
                        out provider,
                        out providerInstance);

                if (providerPaths != null)
                {
                    foreach (string providerPath in providerPaths)
                    {
                        SetItem(providerInstance, providerPath, value, context);
                    }
                }
            }
        } // SetItem
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateDynamicProperty.cs.ifdefed" startline="134" endline="174" pcid="4338">
        internal void NewProperty(
            string[] paths,
            string property,
            string type,
            object value,
            CmdletProviderContext context)
        {
            if (paths == null)
            {
                throw PSTraceSource.NewArgumentNullException("paths");
            }

            if (property == null)
            {
                throw PSTraceSource.NewArgumentNullException("property");
            }

            ProviderInfo provider = null;
            CmdletProvider providerInstance = null;

            foreach (string path in paths)
            {
                if (path == null)
                {
                    throw PSTraceSource.NewArgumentNullException("paths");
                }

                Collection<string> providerPaths =
                    Globber.GetGlobbedProviderPathsFromMonadPath(
                        path,
                        false,
                        context,
                        out provider,
                        out providerInstance);

                foreach (string providerPath in providerPaths)
                {
                    NewProperty(providerInstance, providerPath, property, type, value, context);
                }
            }
        } // NewProperty
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateProperty.cs.ifdefed" startline="111" endline="148" pcid="4417">
        internal void GetProperty(
            string[] paths,
            Collection<string> providerSpecificPickList,
            CmdletProviderContext context)
        {
            if (paths == null)
            {
                throw PSTraceSource.NewArgumentNullException("paths");
            }

            foreach (string path in paths)
            {
                if (path == null)
                {
                    throw PSTraceSource.NewArgumentNullException("paths");
                }

                ProviderInfo provider = null;
                CmdletProvider providerInstance = null;

                Collection<string> providerPaths =
                    Globber.GetGlobbedProviderPathsFromMonadPath(
                        path,
                        false,
                        context,
                        out provider,
                        out providerInstance);

                foreach (string providerPath in providerPaths)
                {
                    GetPropertyPrivate(
                        providerInstance,
                        providerPath,
                        providerSpecificPickList,
                        context);
                }
            }
        } // GetProperty
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateProperty.cs.ifdefed" startline="473" endline="514" pcid="4422">
        internal void SetProperty(
            string[] paths,
            PSObject property,
            CmdletProviderContext context)
        {
            if (paths == null)
            {
                throw PSTraceSource.NewArgumentNullException("paths");
            }

            if (property == null)
            {
                throw PSTraceSource.NewArgumentNullException("property");
            }

            foreach (string path in paths)
            {
                if (path == null)
                {
                    throw PSTraceSource.NewArgumentNullException("paths");
                }

                ProviderInfo provider = null;
                CmdletProvider providerInstance = null;

                Collection<string> providerPaths =
                    Globber.GetGlobbedProviderPathsFromMonadPath(
                        path,
                        false,
                        context,
                        out provider,
                        out providerInstance);

                if (providerPaths != null)
                {
                    foreach (string providerPath in providerPaths)
                    {
                        SetPropertyPrivate(providerInstance, providerPath, property, context);
                    }
                }
            }
        } // SetProperty
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateDynamicProperty.cs.ifdefed" startline="516" endline="554" pcid="4343">
        internal void RemoveProperty(
            string[] paths,
            string property,
            CmdletProviderContext context)
        {
            if (paths == null)
            {
                throw PSTraceSource.NewArgumentNullException("paths");
            }

            if (property == null)
            {
                throw PSTraceSource.NewArgumentNullException("property");
            }

            foreach (string path in paths)
            {
                if (path == null)
                {
                    throw PSTraceSource.NewArgumentNullException("paths");
                }

                ProviderInfo provider = null;
                CmdletProvider providerInstance = null;

                Collection<string> providerPaths =
                    Globber.GetGlobbedProviderPathsFromMonadPath(
                        path,
                        false,
                        context,
                        out provider,
                        out providerInstance);

                foreach (string providerPath in providerPaths)
                {
                    RemoveProperty(providerInstance, providerPath, property, context);
                }
            }
        } // RemoveProperty
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateProperty.cs.ifdefed" startline="836" endline="874" pcid="4427">
        internal void ClearProperty(
            string[] paths,
            Collection<string> propertyToClear,
            CmdletProviderContext context)
        {
            if (paths == null)
            {
                throw PSTraceSource.NewArgumentNullException("paths");
            }

            if (propertyToClear == null)
            {
                throw PSTraceSource.NewArgumentNullException("propertyToClear");
            }

            foreach (string path in paths)
            {
                if (path == null)
                {
                    throw PSTraceSource.NewArgumentNullException("paths");
                }

                ProviderInfo provider = null;
                CmdletProvider providerInstance = null;

                Collection<string> providerPaths =
                    Globber.GetGlobbedProviderPathsFromMonadPath(
                        path,
                        false,
                        context,
                        out provider,
                        out providerInstance);

                foreach (string providerPath in providerPaths)
                {
                    ClearPropertyPrivate(providerInstance, providerPath, propertyToClear, context);
                }
            }
        } // ClearProperty
</source>
</class>

<class classid="96" nclones="3" nlines="14" similarity="73">
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateDynamicProperty.cs.ifdefed" startline="62" endline="91" pcid="4337">
        internal Collection<PSObject> NewProperty(
            string[] paths,
            string property,
            string type,
            object value,
            bool force,
            bool literalPath)
        {
            if (paths == null)
            {
                throw PSTraceSource.NewArgumentNullException("paths");
            }

            if (property == null)
            {
                throw PSTraceSource.NewArgumentNullException("property");
            }

            CmdletProviderContext context = new CmdletProviderContext(this.ExecutionContext);
            context.Force = force;
            context.SuppressWildcardExpansion = literalPath;

            NewProperty(paths, property, type, value, context);

            context.ThrowFirstErrorOrDoNothing();

            Collection<PSObject> results = context.GetAccumulatedObjects();

            return results;
        } // NewProperty
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateDynamicProperty.cs.ifdefed" startline="463" endline="482" pcid="4342">
        internal void RemoveProperty(string[] paths, string property, bool force, bool literalPath)
        {
            if (paths == null)
            {
                throw PSTraceSource.NewArgumentNullException("paths");
            }

            if (property == null)
            {
                throw PSTraceSource.NewArgumentNullException("property");
            }

            CmdletProviderContext context = new CmdletProviderContext(this.ExecutionContext);
            context.Force = force;
            context.SuppressWildcardExpansion = literalPath;

            RemoveProperty(paths, property, context);

            context.ThrowFirstErrorOrDoNothing();
        } // RemoveProperty
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateProperty.cs.ifdefed" startline="412" endline="435" pcid="4421">
        internal Collection<PSObject> SetProperty(string[] paths, PSObject property, bool force, bool literalPath)
        {
            if (paths == null)
            {
                throw PSTraceSource.NewArgumentNullException("paths");
            }

            if (property == null)
            {
                throw PSTraceSource.NewArgumentNullException("properties");
            }

            CmdletProviderContext context = new CmdletProviderContext(this.ExecutionContext);
            context.Force = force;
            context.SuppressWildcardExpansion = literalPath;

            SetProperty(paths, property, context);

            context.ThrowFirstErrorOrDoNothing();

            Collection<PSObject> results = context.GetAccumulatedObjects();

            return results;
        } // SetProperty
</source>
</class>

<class classid="97" nclones="3" nlines="20" similarity="76">
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateDynamicProperty.cs.ifdefed" startline="828" endline="867" pcid="4347">
        internal Collection<PSObject> CopyProperty(
            string[] sourcePaths,
            string sourceProperty,
            string destinationPath,
            string destinationProperty,
            bool force,
            bool literalPath)
        {
            if (sourcePaths == null)
            {
                throw PSTraceSource.NewArgumentNullException("sourcePaths");
            }

            if (sourceProperty == null)
            {
                throw PSTraceSource.NewArgumentNullException("sourceProperty");
            }

            if (destinationPath == null)
            {
                throw PSTraceSource.NewArgumentNullException("destinationPath");
            }

            if (destinationProperty == null)
            {
                throw PSTraceSource.NewArgumentNullException("destinationProperty");
            }

            CmdletProviderContext context = new CmdletProviderContext(this.ExecutionContext);
            context.Force = force;
            context.SuppressWildcardExpansion = literalPath;

            CopyProperty(sourcePaths, sourceProperty, destinationPath, destinationProperty, context);

            context.ThrowFirstErrorOrDoNothing();

            Collection<PSObject> results = context.GetAccumulatedObjects();

            return results;
        } // CopyProperty
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateDynamicProperty.cs.ifdefed" startline="1790" endline="1822" pcid="4357">
        internal Collection<PSObject> RenameProperty(
            string[] sourcePaths,
            string sourceProperty,
            string destinationProperty,
            bool force,
            bool literalPath)
        {
            if (sourcePaths == null)
            {
                throw PSTraceSource.NewArgumentNullException("sourcePaths");
            }

            if (sourceProperty == null)
            {
                throw PSTraceSource.NewArgumentNullException("sourceProperty");
            }

            if (destinationProperty == null)
            {
                throw PSTraceSource.NewArgumentNullException("destinationProperty");
            }

            CmdletProviderContext context = new CmdletProviderContext(this.ExecutionContext);
            context.Force = force;
            context.SuppressWildcardExpansion = literalPath;

            RenameProperty(sourcePaths, sourceProperty, destinationProperty, context);

            context.ThrowFirstErrorOrDoNothing();
            Collection<PSObject> results = context.GetAccumulatedObjects();

            return results;
        } // RenameProperty
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateDynamicProperty.cs.ifdefed" startline="1313" endline="1352" pcid="4352">
        internal Collection<PSObject> MoveProperty(
            string[] sourcePaths,
            string sourceProperty,
            string destinationPath,
            string destinationProperty,
            bool force,
            bool literalPath)
        {
            if (sourcePaths == null)
            {
                throw PSTraceSource.NewArgumentNullException("sourcePaths");
            }

            if (sourceProperty == null)
            {
                throw PSTraceSource.NewArgumentNullException("sourceProperty");
            }

            if (destinationPath == null)
            {
                throw PSTraceSource.NewArgumentNullException("destinationPath");
            }

            if (destinationProperty == null)
            {
                throw PSTraceSource.NewArgumentNullException("destinationProperty");
            }

            CmdletProviderContext context = new CmdletProviderContext(this.ExecutionContext);
            context.Force = force;
            context.SuppressWildcardExpansion = literalPath;

            MoveProperty(sourcePaths, sourceProperty, destinationPath, destinationProperty, context);

            context.ThrowFirstErrorOrDoNothing();

            Collection<PSObject> results = context.GetAccumulatedObjects();

            return results;
        } // MoveProperty
</source>
</class>

<class classid="98" nclones="2" nlines="28" similarity="75">
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateNavigation.cs.ifdefed" startline="674" endline="736" pcid="4401">
        internal string NormalizeRelativePath(
            ProviderInfo provider,
            string path,
            string basePath,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                provider != null,
                "Caller should validate provider before calling this method");

            Dbg.Diagnostics.Assert(
                path != null,
                "Caller should validate path before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            // Get an instance of the provider

            Provider.CmdletProvider providerInstance = GetProviderInstance(provider);

            NavigationCmdletProvider navigationCmdletProvider = providerInstance as NavigationCmdletProvider;
            if (navigationCmdletProvider != null)
            {
                try
                {
                    path = navigationCmdletProvider.NormalizeRelativePath(path, basePath, context);
                }
                catch (LoopFlowException)
                {
                    throw;
                }
                catch (PipelineStoppedException)
                {
                    throw;
                }
                catch (ActionPreferenceStopException)
                {
                    throw;
                }
                catch (Exception e) // Catch-all OK, 3rd party callout.
                {
                    throw NewProviderInvocationException(
                        "NormalizeRelativePathProviderException",
                    SessionStateStrings.NormalizeRelativePathProviderException,
                        navigationCmdletProvider.ProviderInfo,
                        path,
                        e);
                }
            }
            else if (providerInstance is ContainerCmdletProvider)
            {
                // Do nothing and return the path as-is
            }
            else
            {
                throw PSTraceSource.NewNotSupportedException();
            }

            return path;
        } // NormalizeRelativePath
</source>
<source file="PowerShell/src/System.Management.Automation/engine/SessionStateNavigation.cs.ifdefed" startline="949" endline="1008" pcid="4405">
        internal string MakePath(
            CmdletProvider providerInstance,
            string parent,
            string child,
            CmdletProviderContext context)
        {
            // All parameters should have been validated by caller
            Dbg.Diagnostics.Assert(
                providerInstance != null,
                "Caller should validate providerInstance before calling this method");

            Dbg.Diagnostics.Assert(
                context != null,
                "Caller should validate context before calling this method");

            // Get an instance of the provider

            string result = null;

            NavigationCmdletProvider navigationCmdletProvider = providerInstance as NavigationCmdletProvider;

            if (navigationCmdletProvider != null)
            {
                try
                {
                    result = navigationCmdletProvider.MakePath(parent, child, context);
                }
                catch (LoopFlowException)
                {
                    throw;
                }
                catch (PipelineStoppedException)
                {
                    throw;
                }
                catch (ActionPreferenceStopException)
                {
                    throw;
                }
                catch (Exception e) // Catch-all OK, 3rd party callout.
                {
                    throw NewProviderInvocationException(
                        "MakePathProviderException",
                        SessionStateStrings.MakePathProviderException,
                        navigationCmdletProvider.ProviderInfo,
                        parent,
                        e);
                }
            }
            else if (providerInstance is ContainerCmdletProvider)
            {
                result = child;
            }
            else
            {
                throw PSTraceSource.NewNotSupportedException();
            }

            return result;
        } // MakePath
</source>
</class>

<class classid="99" nclones="3" nlines="10" similarity="70">
<source file="PowerShell/src/System.Management.Automation/engine/ThirdPartyAdapter.cs.ifdefed" startline="146" endline="163" pcid="4496">
        protected override bool PropertyIsSettable(PSProperty property)
        {
            PSAdaptedProperty adaptedProperty = property as PSAdaptedProperty;

            Diagnostics.Assert(adaptedProperty != null, "ThirdPartyAdapter should only receive PSAdaptedProperties");

            try
            {
                return _externalAdapter.IsSettable(adaptedProperty);
            }
            catch (Exception exception)
            {
                throw new ExtendedTypeSystemException(
                    "PSPropertyAdapter.PropertyIsSettableError",
                    exception,
                    ExtendedTypeSystem.PropertyIsSettableError, property.Name);
            }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/ThirdPartyAdapter.cs.ifdefed" startline="168" endline="185" pcid="4497">
        protected override bool PropertyIsGettable(PSProperty property)
        {
            PSAdaptedProperty adaptedProperty = property as PSAdaptedProperty;

            Diagnostics.Assert(adaptedProperty != null, "ThirdPartyAdapter should only receive PSAdaptedProperties");

            try
            {
                return _externalAdapter.IsGettable(adaptedProperty);
            }
            catch (Exception exception)
            {
                throw new ExtendedTypeSystemException(
                    "PSPropertyAdapter.PropertyIsGettableError",
                    exception,
                    ExtendedTypeSystem.PropertyIsGettableError, property.Name);
            }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/engine/ThirdPartyAdapter.cs.ifdefed" startline="190" endline="207" pcid="4498">
        protected override object PropertyGet(PSProperty property)
        {
            PSAdaptedProperty adaptedProperty = property as PSAdaptedProperty;

            Diagnostics.Assert(adaptedProperty != null, "ThirdPartyAdapter should only receive PSAdaptedProperties");

            try
            {
                return _externalAdapter.GetPropertyValue(adaptedProperty);
            }
            catch (Exception exception)
            {
                throw new ExtendedTypeSystemException(
                    "PSPropertyAdapter.PropertyGetError",
                    exception,
                    ExtendedTypeSystem.PropertyGetError, property.Name);
            }
        }
</source>
</class>

<class classid="100" nclones="2" nlines="37" similarity="77">
<source file="PowerShell/src/System.Management.Automation/FormatAndOutput/common/DisplayDatabase/typeDataQuery.cs.ifdefed" startline="397" endline="467" pcid="4615">
        private static ViewDefinition GetView(PSPropertyExpressionFactory expressionFactory, TypeInfoDataBase db, System.Type mainControlType, Collection<string> typeNames, string viewName)
        {
            TypeMatch match = new TypeMatch(expressionFactory, db, typeNames);
            foreach (ViewDefinition vd in db.viewDefinitionsSection.viewDefinitionList)
            {
                if (vd == null || mainControlType != vd.mainControl.GetType())
                {
                    ActiveTracer.WriteLine(
                        "NOT MATCH {0}  NAME: {1}",
                        ControlBase.GetControlShapeName(vd.mainControl), (vd != null ? vd.name : string.Empty));
                    continue;
                }
                if (IsOutOfBandView(vd))
                {
                    ActiveTracer.WriteLine(
                        "NOT MATCH OutOfBand {0}  NAME: {1}",
                        ControlBase.GetControlShapeName(vd.mainControl), vd.name);
                    continue;
                }
                if (vd.appliesTo == null)
                {
                    ActiveTracer.WriteLine(
                        "NOT MATCH {0}  NAME: {1}  No applicable types",
                        ControlBase.GetControlShapeName(vd.mainControl), vd.name);
                    continue;
                }
                // first make sure we match on name:
                // if not, we do not try a match at all
                if (viewName != null && !string.Equals(vd.name, viewName, StringComparison.OrdinalIgnoreCase))
                {
                    ActiveTracer.WriteLine(
                        "NOT MATCH {0}  NAME: {1}",
                        ControlBase.GetControlShapeName(vd.mainControl), vd.name);
                    continue;
                }

                // check if we have a perfect match
                // if so, we are done
                try
                {
                    TypeMatch.SetTracer(ActiveTracer);
                    if (match.PerfectMatch(new TypeMatchItem(vd, vd.appliesTo)))
                    {
                        TraceHelper(vd, true);
                        return vd;
                    }
                }
                finally
                {
                    TypeMatch.ResetTracer();
                }
                TraceHelper(vd, false);
            }

            // this is the best match we had
            ViewDefinition result = GetBestMatch(match);

            // we were unable to find a best match so far..try
            // to get rid of Deserialization prefix and see if a
            // match can be found.
            if (result == null)
            {
                Collection<string> typesWithoutPrefix = Deserializer.MaskDeserializationPrefix(typeNames);
                if (typesWithoutPrefix != null)
                {
                    result = GetView(expressionFactory, db, mainControlType, typesWithoutPrefix, viewName);
                }
            }

            return result;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/FormatAndOutput/common/DisplayDatabase/typeDataQuery.cs.ifdefed" startline="504" endline="557" pcid="4618">
        private static ViewDefinition GetDefaultView(PSPropertyExpressionFactory expressionFactory, TypeInfoDataBase db, Collection<string> typeNames)
        {
            TypeMatch match = new TypeMatch(expressionFactory, db, typeNames);

            foreach (ViewDefinition vd in db.viewDefinitionsSection.viewDefinitionList)
            {
                if (vd == null)
                    continue;

                if (IsOutOfBandView(vd))
                {
                    ActiveTracer.WriteLine(
                        "NOT MATCH OutOfBand {0}  NAME: {1}",
                        ControlBase.GetControlShapeName(vd.mainControl), vd.name);
                    continue;
                }
                if (vd.appliesTo == null)
                {
                    ActiveTracer.WriteLine(
                        "NOT MATCH {0}  NAME: {1}  No applicable types",
                        ControlBase.GetControlShapeName(vd.mainControl), vd.name);
                    continue;
                }
                try
                {
                    TypeMatch.SetTracer(ActiveTracer);
                    if (match.PerfectMatch(new TypeMatchItem(vd, vd.appliesTo)))
                    {
                        TraceHelper(vd, true);
                        return vd;
                    }
                }
                finally
                {
                    TypeMatch.ResetTracer();
                }
                TraceHelper(vd, false);
            }
            // this is the best match we had
            ViewDefinition result = GetBestMatch(match);
            // we were unable to find a best match so far..try
            // to get rid of Deserialization prefix and see if a
            // match can be found.
            if (result == null)
            {
                Collection<string> typesWithoutPrefix = Deserializer.MaskDeserializationPrefix(typeNames);
                if (typesWithoutPrefix != null)
                {
                    result = GetDefaultView(expressionFactory, db, typesWithoutPrefix);
                }
            }

            return result;
        }
</source>
</class>

<class classid="101" nclones="2" nlines="11" similarity="81">
<source file="PowerShell/src/System.Management.Automation/FormatAndOutput/common/FormatViewGenerator.cs.ifdefed" startline="379" endline="393" pcid="4764">
        protected bool EvaluateDisplayCondition(PSObject so, ExpressionToken conditionToken)
        {
            if (conditionToken == null)
                return true;

            PSPropertyExpression ex = this.expressionFactory.CreateFromExpressionToken(conditionToken, this.dataBaseInfo.view.loadingInfo);
            PSPropertyExpressionResult expressionResult;
            bool retVal = DisplayCondition.Evaluate(so, ex, out expressionResult);

            if (expressionResult != null && expressionResult.Exception != null)
            {
                _errorManager.LogPSPropertyExpressionFailedResult(expressionResult, so);
            }
            return retVal;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/FormatAndOutput/common/FormatViewGenerator_Complex.cs.ifdefed" startline="359" endline="373" pcid="4777">
        private bool EvaluateDisplayCondition(PSObject so, ExpressionToken conditionToken)
        {
            if (conditionToken == null)
                return true;

            PSPropertyExpression ex = _expressionFactory.CreateFromExpressionToken(conditionToken, _loadingInfo);
            PSPropertyExpressionResult expressionResult;
            bool retVal = DisplayCondition.Evaluate(so, ex, out expressionResult);

            if (expressionResult != null && expressionResult.Exception != null)
            {
                _errorManager.LogPSPropertyExpressionFailedResult(expressionResult, so);
            }
            return retVal;
        }
</source>
</class>

<class classid="102" nclones="2" nlines="26" similarity="73">
<source file="PowerShell/src/System.Management.Automation/FormatAndOutput/common/FormatViewGenerator_List.cs.ifdefed" startline="138" endline="176" pcid="4797">
        private ListControlEntryDefinition GetActiveListControlEntryDefinition(ListControlBody listBody, PSObject so)
        {
            // see if we have an override that matches
            var typeNames = so.InternalTypeNames;
            TypeMatch match = new TypeMatch(expressionFactory, this.dataBaseInfo.db, typeNames);
            foreach (ListControlEntryDefinition x in listBody.optionalEntryList)
            {
                if (match.PerfectMatch(new TypeMatchItem(x, x.appliesTo, so)))
                {
                    return x;
                }
            }
            if (match.BestMatch != null)
            {
                return match.BestMatch as ListControlEntryDefinition;
            }
            else
            {
                Collection<string> typesWithoutPrefix = Deserializer.MaskDeserializationPrefix(typeNames);
                if (typesWithoutPrefix != null)
                {
                    match = new TypeMatch(expressionFactory, this.dataBaseInfo.db, typesWithoutPrefix);
                    foreach (ListControlEntryDefinition x in listBody.optionalEntryList)
                    {
                        if (match.PerfectMatch(new TypeMatchItem(x, x.appliesTo)))
                        {
                            return x;
                        }
                    }
                    if (match.BestMatch != null)
                    {
                        return match.BestMatch as ListControlEntryDefinition;
                    }
                }

                // we do not have any override, use default
                return listBody.defaultEntryDefinition;
            }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/FormatAndOutput/common/FormatViewGenerator_Wide.cs.ifdefed" startline="89" endline="127" pcid="4816">
        private WideControlEntryDefinition GetActiveWideControlEntryDefinition(WideControlBody wideBody, PSObject so)
        {
            // see if we have an override that matches
            var typeNames = so.InternalTypeNames;
            TypeMatch match = new TypeMatch(expressionFactory, this.dataBaseInfo.db, typeNames);
            foreach (WideControlEntryDefinition x in wideBody.optionalEntryList)
            {
                if (match.PerfectMatch(new TypeMatchItem(x, x.appliesTo)))
                {
                    return x;
                }
            }
            if (match.BestMatch != null)
            {
                return match.BestMatch as WideControlEntryDefinition;
            }
            else
            {
                Collection<string> typesWithoutPrefix = Deserializer.MaskDeserializationPrefix(typeNames);
                if (typesWithoutPrefix != null)
                {
                    match = new TypeMatch(expressionFactory, this.dataBaseInfo.db, typesWithoutPrefix);
                    foreach (WideControlEntryDefinition x in wideBody.optionalEntryList)
                    {
                        if (match.PerfectMatch(new TypeMatchItem(x, x.appliesTo)))
                        {
                            return x;
                        }
                    }
                    if (match.BestMatch != null)
                    {
                        return match.BestMatch as WideControlEntryDefinition;
                    }
                }

                // we do not have any override, use default
                return wideBody.defaultEntryDefinition;
            }
        }
</source>
</class>

<class classid="103" nclones="2" nlines="13" similarity="71">
<source file="PowerShell/src/System.Management.Automation/FormatAndOutput/common/Utilities/MshParameterAssociation.cs.ifdefed" startline="74" endline="96" pcid="4904">
        internal static List<MshResolvedExpressionParameterAssociation> ExpandTableParameters(List<MshParameter> parameters, PSObject target)
        {
            List<MshResolvedExpressionParameterAssociation> retVal = new List<MshResolvedExpressionParameterAssociation>();

            foreach (MshParameter par in parameters)
            {
                PSPropertyExpression expression = par.GetEntry(FormatParameterDefinitionKeys.ExpressionEntryKey) as PSPropertyExpression;
                List<PSPropertyExpression> expandedExpressionList = expression.ResolveNames(target);

                if (!expression.HasWildCardCharacters && expandedExpressionList.Count == 0)
                {
                    // we did not find anything, mark as unresolved
                    retVal.Add(new MshResolvedExpressionParameterAssociation(par, expression));
                }

                foreach (PSPropertyExpression ex in expandedExpressionList)
                {
                    retVal.Add(new MshResolvedExpressionParameterAssociation(par, ex));
                }
            }

            return retVal;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/FormatAndOutput/common/Utilities/MshParameterAssociation.cs.ifdefed" startline="98" endline="114" pcid="4905">
        internal static List<MshResolvedExpressionParameterAssociation> ExpandParameters(List<MshParameter> parameters, PSObject target)
        {
            List<MshResolvedExpressionParameterAssociation> retVal = new List<MshResolvedExpressionParameterAssociation>();

            foreach (MshParameter par in parameters)
            {
                PSPropertyExpression expression = par.GetEntry(FormatParameterDefinitionKeys.ExpressionEntryKey) as PSPropertyExpression;
                List<PSPropertyExpression> expandedExpressionList = expression.ResolveNames(target);

                foreach (PSPropertyExpression ex in expandedExpressionList)
                {
                    retVal.Add(new MshResolvedExpressionParameterAssociation(par, ex));
                }
            }

            return retVal;
        }
</source>
</class>

<class classid="104" nclones="2" nlines="22" similarity="78">
<source file="PowerShell/src/System.Management.Automation/FormatAndOutput/out-console/ConsoleLineOutput.cs.ifdefed" startline="289" endline="328" pcid="4916">
        private void OnWriteLine(string s)
        {
//#if TEST_MULTICELL_ON_SINGLE_CELL_LOCALE
//            s = ((DisplayCellsTest)this._displayCellsPSHost).GenerateTestString(s);
//#endif
            // Do any default transcription.
            _console.TranscribeResult(s);

            switch (this.WriteStream)
            {
                case WriteStreamType.Error:
                    _console.WriteErrorLine(s);
                    break;

                case WriteStreamType.Warning:
                    _console.WriteWarningLine(s);
                    break;

                case WriteStreamType.Verbose:
                    _console.WriteVerboseLine(s);
                    break;

                case WriteStreamType.Debug:
                    _console.WriteDebugLine(s);
                    break;

                default:
                    // If the host is in "transcribe only"
                    // mode (due to an implicitly added call to Out-Default -Transcribe),
                    // then don't call the actual host API.
                    if (!_console.TranscribeOnly)
                    {
                        _console.WriteLine(s);
                    }

                    break;
            }

            LineWrittenEvent();
        }
</source>
<source file="PowerShell/src/System.Management.Automation/FormatAndOutput/out-console/ConsoleLineOutput.cs.ifdefed" startline="336" endline="365" pcid="4917">
        private void OnWrite(string s)
        {
//#if TEST_MULTICELL_ON_SINGLE_CELL_LOCALE
//            s = ((DisplayCellsTest)this._displayCellsPSHost).GenerateTestString(s);
//#endif
            switch (this.WriteStream)
            {
                case WriteStreamType.Error:
                    _console.WriteErrorLine(s);
                    break;

                case WriteStreamType.Warning:
                    _console.WriteWarningLine(s);
                    break;

                case WriteStreamType.Verbose:
                    _console.WriteVerboseLine(s);
                    break;

                case WriteStreamType.Debug:
                    _console.WriteDebugLine(s);
                    break;

                default:
                    _console.Write(s);
                    break;
            }

            LineWrittenEvent();
        }
</source>
</class>

<class classid="105" nclones="2" nlines="12" similarity="91">
<source file="PowerShell/src/System.Management.Automation/help/BaseCommandHelpInfo.cs.ifdefed" startline="352" endline="370" pcid="4932">
        internal override bool MatchPatternInContent(WildcardPattern pattern)
        {
            Dbg.Assert(pattern != null, "pattern cannot be null");

            string synopsis = Synopsis;
            string detailedDescription = DetailedDescription;

            if (synopsis == null)
            {
                synopsis = string.Empty;
            }

            if (detailedDescription == null)
            {
                detailedDescription = string.Empty;
            }

            return pattern.IsMatch(synopsis) || pattern.IsMatch(detailedDescription);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/help/ProviderHelpInfo.cs.ifdefed" startline="163" endline="181" pcid="5023">
        internal override bool MatchPatternInContent(WildcardPattern pattern)
        {
            Diagnostics.Assert(pattern != null, "pattern cannot be null");

            string synopsis = Synopsis;
            string detailedDescription = DetailedDescription;

            if (synopsis == null)
            {
                synopsis = string.Empty;
            }

            if (detailedDescription == null)
            {
                detailedDescription = string.Empty;
            }

            return pattern.IsMatch(synopsis) || pattern.IsMatch(detailedDescription);
        }
</source>
</class>

<class classid="106" nclones="2" nlines="18" similarity="88">
<source file="PowerShell/src/System.Management.Automation/help/DscResourceHelpProvider.cs.ifdefed" startline="66" endline="92" pcid="4960">
        internal override IEnumerable<HelpInfo> SearchHelp(HelpRequest helpRequest, bool searchOnlyContent)
        {
            Debug.Assert(helpRequest != null, "helpRequest cannot be null.");

            string target = helpRequest.Target;
            Collection<string> patternList = new Collection<string>();

            bool decoratedSearch = !WildcardPattern.ContainsWildcardCharacters(helpRequest.Target);

            if (decoratedSearch)
            {
                patternList.Add("*" + target + "*");
            }
            else
                patternList.Add(target);

            foreach (string pattern in patternList)
            {
                DscResourceSearcher searcher = new DscResourceSearcher(pattern, _context);

                foreach (var helpInfo in GetHelpInfo(searcher))
                {
                    if (helpInfo != null)
                        yield return helpInfo;
                }
            }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/help/PSClassHelpProvider.cs.ifdefed" startline="66" endline="94" pcid="5031">
        internal override IEnumerable<HelpInfo> SearchHelp(HelpRequest helpRequest, bool searchOnlyContent)
        {
            Debug.Assert(helpRequest != null, "helpRequest cannot be null.");

            string target = helpRequest.Target;
            Collection<string> patternList = new Collection<string>();

            bool decoratedSearch = !WildcardPattern.ContainsWildcardCharacters(helpRequest.Target);

            if (decoratedSearch)
            {
                patternList.Add("*" + target + "*");
            }
            else
                patternList.Add(target);

            bool useWildCards = true;

            foreach (string pattern in patternList)
            {
                PSClassSearcher searcher = new PSClassSearcher(pattern, useWildCards, _context);

                foreach (var helpInfo in GetHelpInfo(searcher))
                {
                    if (helpInfo != null)
                        yield return helpInfo;
                }
            }
        }
</source>
</class>

<class classid="107" nclones="2" nlines="14" similarity="78">
<source file="PowerShell/src/System.Management.Automation/help/DscResourceHelpProvider.cs.ifdefed" startline="99" endline="119" pcid="4961">
        internal override IEnumerable<HelpInfo> ExactMatchHelp(HelpRequest helpRequest)
        {
            Debug.Assert(helpRequest != null, "helpRequest cannot be null.");

            if ((helpRequest.HelpCategory & Automation.HelpCategory.DscResource) == 0)
            {
                yield return null;
            }

            string target = helpRequest.Target;

            DscResourceSearcher searcher = new DscResourceSearcher(target, _context);

            foreach (var helpInfo in GetHelpInfo(searcher))
            {
                if (helpInfo != null)
                {
                    yield return helpInfo;
                }
            }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/help/PSClassHelpProvider.cs.ifdefed" startline="101" endline="122" pcid="5032">
        internal override IEnumerable<HelpInfo> ExactMatchHelp(HelpRequest helpRequest)
        {
            Debug.Assert(helpRequest != null, "helpRequest cannot be null.");

            if ((helpRequest.HelpCategory & Automation.HelpCategory.Class) == 0)
            {
                yield return null;
            }

            string target = helpRequest.Target;
            bool useWildCards = false;

            PSClassSearcher searcher = new PSClassSearcher(target, useWildCards, _context);

            foreach (var helpInfo in GetHelpInfo(searcher))
            {
                if (helpInfo != null)
                {
                    yield return helpInfo;
                }
            }
        }
</source>
</class>

<class classid="108" nclones="2" nlines="13" similarity="100">
<source file="PowerShell/src/System.Management.Automation/help/DscResourceHelpProvider.cs.ifdefed" startline="179" endline="199" pcid="4963">
        internal static bool IsMamlHelp(string helpFile, XmlNode helpItemsNode)
        {
            Debug.Assert(!String.IsNullOrEmpty(helpFile), "helpFile cannot be null.");

            if (helpFile.EndsWith(".maml", StringComparison.CurrentCultureIgnoreCase))
                return true;

            if (helpItemsNode.Attributes == null)
                return false;

            foreach (XmlNode attribute in helpItemsNode.Attributes)
            {
                if (attribute.Name.Equals("schema", StringComparison.OrdinalIgnoreCase)
                    && attribute.Value.Equals("maml", StringComparison.OrdinalIgnoreCase))
                {
                    return true;
                }
            }

            return false;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/help/PSClassHelpProvider.cs.ifdefed" startline="184" endline="204" pcid="5034">
        internal static bool IsMamlHelp(string helpFile, XmlNode helpItemsNode)
        {
            Debug.Assert(!String.IsNullOrEmpty(helpFile), "helpFile cannot be null.");

            if (helpFile.EndsWith(".maml", StringComparison.CurrentCultureIgnoreCase))
                return true;

            if (helpItemsNode.Attributes == null)
                return false;

            foreach (XmlNode attribute in helpItemsNode.Attributes)
            {
                if (attribute.Name.Equals("schema", StringComparison.OrdinalIgnoreCase)
                    && attribute.Value.Equals("maml", StringComparison.OrdinalIgnoreCase))
                {
                    return true;
                }
            }

            return false;
        }
</source>
</class>

<class classid="109" nclones="2" nlines="14" similarity="71">
<source file="PowerShell/src/System.Management.Automation/help/DscResourceHelpProvider.cs.ifdefed" startline="203" endline="225" pcid="4964">
        private HelpInfo GetHelpInfoFromHelpFile(DscResourceInfo resourceInfo, string helpFileToFind, Collection<string> searchPaths, bool reportErrors, out string helpFile)
        {
            Dbg.Assert(resourceInfo != null, "Caller should verify that resourceInfo != null");
            Dbg.Assert(helpFileToFind != null, "Caller should verify that helpFileToFind != null");

            helpFile = MUIFileSearcher.LocateFile(helpFileToFind, searchPaths);

            if (!File.Exists(helpFile))
                return null;

            if (!String.IsNullOrEmpty(helpFile))
            {
                //Load the help file only once. Then use it from the cache.
                if (!_helpFiles.Contains(helpFile))
                {
                    LoadHelpFile(helpFile, helpFile, resourceInfo.Name, reportErrors);
                }

                return GetFromResourceHelpCache(helpFile, Automation.HelpCategory.DscResource);
            }

            return null;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/help/PSClassHelpProvider.cs.ifdefed" startline="208" endline="230" pcid="5035">
        private HelpInfo GetHelpInfoFromHelpFile(PSClassInfo classInfo, string helpFileToFind, Collection<string> searchPaths, bool reportErrors, out string helpFile)
        {
            Dbg.Assert(classInfo != null, "Caller should verify that classInfo != null");
            Dbg.Assert(helpFileToFind != null, "Caller should verify that helpFileToFind != null");

            helpFile = MUIFileSearcher.LocateFile(helpFileToFind, searchPaths);

            if (!File.Exists(helpFile))
                return null;

            if (!String.IsNullOrEmpty(helpFile))
            {
                //Load the help file only once. Then use it from the cache.
                if (!_helpFiles.Contains(helpFile))
                {
                    LoadHelpFile(helpFile, helpFile, classInfo.Name, reportErrors);
                }

                return GetFromPSClassHelpCache(helpFile, Automation.HelpCategory.Class);
            }

            return null;
        }
</source>
</class>

<class classid="110" nclones="2" nlines="29" similarity="96">
<source file="PowerShell/src/System.Management.Automation/help/DscResourceHelpProvider.cs.ifdefed" startline="248" endline="287" pcid="4966">
        private void LoadHelpFile(string helpFile, string helpFileIdentifier, string commandName, bool reportErrors)
        {
            Exception e = null;
            try
            {
                LoadHelpFile(helpFile, helpFileIdentifier);
            }
            catch (IOException ioException)
            {
                e = ioException;
            }
            catch (System.Security.SecurityException securityException)
            {
                e = securityException;
            }
            catch (XmlException xmlException)
            {
                e = xmlException;
            }
            catch (NotSupportedException notSupportedException)
            {
                e = notSupportedException;
            }
            catch (UnauthorizedAccessException unauthorizedAccessException)
            {
                e = unauthorizedAccessException;
            }
            catch (InvalidOperationException invalidOperationException)
            {
                e = invalidOperationException;
            }

            if (e != null)
                s_tracer.WriteLine("Error occured in DscResourceHelpProvider {0}", e.Message);

            if (reportErrors && (e != null))
            {
                ReportHelpFileError(e, commandName, helpFile);
            }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/help/PSClassHelpProvider.cs.ifdefed" startline="253" endline="292" pcid="5037">
        private void LoadHelpFile(string helpFile, string helpFileIdentifier, string commandName, bool reportErrors)
        {
            Exception e = null;
            try
            {
                LoadHelpFile(helpFile, helpFileIdentifier);
            }
            catch (IOException ioException)
            {
                e = ioException;
            }
            catch (System.Security.SecurityException securityException)
            {
                e = securityException;
            }
            catch (XmlException xmlException)
            {
                e = xmlException;
            }
            catch (NotSupportedException notSupportedException)
            {
                e = notSupportedException;
            }
            catch (UnauthorizedAccessException unauthorizedAccessException)
            {
                e = unauthorizedAccessException;
            }
            catch (InvalidOperationException invalidOperationException)
            {
                e = invalidOperationException;
            }

            if (e != null)
                s_tracer.WriteLine("Error occured in PSClassHelpProvider {0}", e.Message);

            if (reportErrors && (e != null))
            {
                ReportHelpFileError(e, commandName, helpFile);
            }
        }
</source>
</class>

<class classid="111" nclones="2" nlines="41" similarity="87">
<source file="PowerShell/src/System.Management.Automation/help/DscResourceHelpProvider.cs.ifdefed" startline="299" endline="366" pcid="4967">
        private void LoadHelpFile(string helpFile, string helpFileIdentifier)
        {
            Dbg.Assert(!String.IsNullOrEmpty(helpFile), "HelpFile cannot be null or empty.");
            Dbg.Assert(!String.IsNullOrEmpty(helpFileIdentifier), "helpFileIdentifier cannot be null or empty.");

            XmlDocument doc = InternalDeserializer.LoadUnsafeXmlDocument(
                new FileInfo(helpFile),
                false, /* ignore whitespace, comments, etc. */
                null); /* default maxCharactersInDocument */

            // Add this file into _helpFiles hashtable to prevent it to be loaded again.
            _helpFiles[helpFile] = 0;

            XmlNode helpItemsNode = null;

            if (doc.HasChildNodes)
            {
                for (int i = 0; i < doc.ChildNodes.Count; i++)
                {
                    XmlNode node = doc.ChildNodes[i];
                    if (node.NodeType == XmlNodeType.Element && String.Compare(node.LocalName, "helpItems", StringComparison.OrdinalIgnoreCase) == 0)
                    {
                        helpItemsNode = node;
                        break;
                    }
                }
            }

            if (helpItemsNode == null)
            {
                s_tracer.WriteLine("Unable to find 'helpItems' element in file {0}", helpFile);
                return;
            }

            bool isMaml = IsMamlHelp(helpFile, helpItemsNode);

            using (this.HelpSystem.Trace(helpFile))
            {
                if (helpItemsNode.HasChildNodes)
                {
                    for (int i = 0; i < helpItemsNode.ChildNodes.Count; i++)
                    {
                        XmlNode node = helpItemsNode.ChildNodes[i];

                        string nodeLocalName = node.LocalName;

                        bool isDscResource = (String.Compare(nodeLocalName, "dscResource", StringComparison.OrdinalIgnoreCase) == 0);

                        if (node.NodeType == XmlNodeType.Element && isDscResource)
                        {
                            MamlCommandHelpInfo helpInfo = null;

                            if (isMaml)
                            {
                                if (isDscResource)
                                    helpInfo = MamlCommandHelpInfo.Load(node, HelpCategory.DscResource);
                            }

                            if (helpInfo != null)
                            {
                                this.HelpSystem.TraceErrors(helpInfo.Errors);
                                AddCache(helpFileIdentifier, helpInfo);
                            }
                        }
                    }
                }
            }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/help/PSClassHelpProvider.cs.ifdefed" startline="304" endline="371" pcid="5038">
        private void LoadHelpFile(string helpFile, string helpFileIdentifier)
        {
            Dbg.Assert(!String.IsNullOrEmpty(helpFile), "HelpFile cannot be null or empty.");
            Dbg.Assert(!String.IsNullOrEmpty(helpFileIdentifier), "helpFileIdentifier cannot be null or empty.");

            XmlDocument doc = InternalDeserializer.LoadUnsafeXmlDocument(
                new FileInfo(helpFile),
                false, /* ignore whitespace, comments, etc. */
                null); /* default maxCharactersInDocument */

            // Add this file into _helpFiles hashtable to prevent it to be loaded again.
            _helpFiles[helpFile] = 0;

            XmlNode helpItemsNode = null;

            if (doc.HasChildNodes)
            {
                for (int i = 0; i < doc.ChildNodes.Count; i++)
                {
                    XmlNode node = doc.ChildNodes[i];
                    if (node.NodeType == XmlNodeType.Element && String.Compare(node.LocalName, "helpItems", StringComparison.OrdinalIgnoreCase) == 0)
                    {
                        helpItemsNode = node;
                        break;
                    }
                }
            }

            if (helpItemsNode == null)
            {
                s_tracer.WriteLine("Unable to find 'helpItems' element in file {0}", helpFile);
                return;
            }

            bool isMaml = IsMamlHelp(helpFile, helpItemsNode);

            using (this.HelpSystem.Trace(helpFile))
            {
                if (helpItemsNode.HasChildNodes)
                {
                    for (int i = 0; i < helpItemsNode.ChildNodes.Count; i++)
                    {
                        XmlNode node = helpItemsNode.ChildNodes[i];

                        string nodeLocalName = node.LocalName;

                        bool isClass = (String.Compare(nodeLocalName, "class", StringComparison.OrdinalIgnoreCase) == 0);

                        if (node.NodeType == XmlNodeType.Element && isClass)
                        {
                            MamlClassHelpInfo helpInfo = null;

                            if (isMaml)
                            {
                                if (isClass)
                                    helpInfo = MamlClassHelpInfo.Load(node, HelpCategory.Class);
                            }

                            if (helpInfo != null)
                            {
                                this.HelpSystem.TraceErrors(helpInfo.Errors);
                                AddCache(helpFileIdentifier, helpInfo);
                            }
                        }
                    }
                }
            }
        }
</source>
</class>

<class classid="112" nclones="3" nlines="25" similarity="76">
<source file="PowerShell/src/System.Management.Automation/logging/eventlog/EventLogLogProvider.cs.ifdefed" startline="97" endline="136" pcid="5069">
        internal override void LogEngineHealthEvent(LogContext logContext, int eventId, Exception exception, Dictionary<String, String> additionalInfo)
        {
            Hashtable mapArgs = new Hashtable();

            IContainsErrorRecord icer = exception as IContainsErrorRecord;
            if (icer != null && icer.ErrorRecord != null)
            {
                mapArgs["ExceptionClass"] = exception.GetType().Name;
                mapArgs["ErrorCategory"] = icer.ErrorRecord.CategoryInfo.Category;
                mapArgs["ErrorId"] = icer.ErrorRecord.FullyQualifiedErrorId;

                if (icer.ErrorRecord.ErrorDetails != null)
                {
                    mapArgs["ErrorMessage"] = icer.ErrorRecord.ErrorDetails.Message;
                }
                else
                {
                    mapArgs["ErrorMessage"] = exception.Message;
                }
            }
            else
            {
                mapArgs["ExceptionClass"] = exception.GetType().Name;
                mapArgs["ErrorCategory"] = string.Empty;
                mapArgs["ErrorId"] = string.Empty;
                mapArgs["ErrorMessage"] = exception.Message;
            }

            FillEventArgs(mapArgs, logContext);

            FillEventArgs(mapArgs, additionalInfo);

            EventInstance entry = new EventInstance(eventId, EngineHealthCategoryId);

            entry.EntryType = GetEventLogEntryType(logContext);

            string detail = GetEventDetail("EngineHealthContext", mapArgs);

            LogEvent(entry, mapArgs["ErrorMessage"], detail);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/logging/eventlog/EventLogLogProvider.cs.ifdefed" startline="215" endline="254" pcid="5073">
        internal override void LogCommandHealthEvent(LogContext logContext, Exception exception)
        {
            int eventId = _commandHealthEventId;

            Hashtable mapArgs = new Hashtable();

            IContainsErrorRecord icer = exception as IContainsErrorRecord;
            if (icer != null && icer.ErrorRecord != null)
            {
                mapArgs["ExceptionClass"] = exception.GetType().Name;
                mapArgs["ErrorCategory"] = icer.ErrorRecord.CategoryInfo.Category;
                mapArgs["ErrorId"] = icer.ErrorRecord.FullyQualifiedErrorId;

                if (icer.ErrorRecord.ErrorDetails != null)
                {
                    mapArgs["ErrorMessage"] = icer.ErrorRecord.ErrorDetails.Message;
                }
                else
                {
                    mapArgs["ErrorMessage"] = exception.Message;
                }
            }
            else
            {
                mapArgs["ExceptionClass"] = exception.GetType().Name;
                mapArgs["ErrorCategory"] = string.Empty;
                mapArgs["ErrorId"] = string.Empty;
                mapArgs["ErrorMessage"] = exception.Message;
            }

            FillEventArgs(mapArgs, logContext);

            EventInstance entry = new EventInstance(eventId, CommandHealthCategoryId);

            entry.EntryType = GetEventLogEntryType(logContext);

            string detail = GetEventDetail("CommandHealthContext", mapArgs);

            LogEvent(entry, mapArgs["ErrorMessage"], detail);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/logging/eventlog/EventLogLogProvider.cs.ifdefed" startline="390" endline="432" pcid="5079">
        internal override void LogProviderHealthEvent(LogContext logContext, string providerName, Exception exception)
        {
            int eventId = _providerHealthEventId;

            Hashtable mapArgs = new Hashtable();

            mapArgs["ProviderName"] = providerName;

            IContainsErrorRecord icer = exception as IContainsErrorRecord;
            if (icer != null && icer.ErrorRecord != null)
            {
                mapArgs["ExceptionClass"] = exception.GetType().Name;
                mapArgs["ErrorCategory"] = icer.ErrorRecord.CategoryInfo.Category;
                mapArgs["ErrorId"] = icer.ErrorRecord.FullyQualifiedErrorId;

                if (icer.ErrorRecord.ErrorDetails != null
                    && !String.IsNullOrEmpty(icer.ErrorRecord.ErrorDetails.Message))
                {
                    mapArgs["ErrorMessage"] = icer.ErrorRecord.ErrorDetails.Message;
                }
                else
                {
                    mapArgs["ErrorMessage"] = exception.Message;
                }
            }
            else
            {
                mapArgs["ExceptionClass"] = exception.GetType().Name;
                mapArgs["ErrorCategory"] = string.Empty;
                mapArgs["ErrorId"] = string.Empty;
                mapArgs["ErrorMessage"] = exception.Message;
            }

            FillEventArgs(mapArgs, logContext);

            EventInstance entry = new EventInstance(eventId, ProviderHealthCategoryId);

            entry.EntryType = GetEventLogEntryType(logContext);

            string detail = GetEventDetail("ProviderHealthContext", mapArgs);

            LogEvent(entry, mapArgs["ErrorMessage"], detail);
        }
</source>
</class>

<class classid="113" nclones="2" nlines="37" similarity="75">
<source file="PowerShell/src/System.Management.Automation/namespaces/LocationGlobber.cs.ifdefed" startline="1458" endline="1531" pcid="5238">
        internal static bool IsAbsolutePath(string path)
        {
            // Verify parameters

            if (path == null)
            {
                throw PSTraceSource.NewArgumentNullException("path");
            }

            bool result = false;

            do
            {
                if (path.Length == 0)
                {
                    // The current working directory is specified

                    result = false;
                    break;
                }

                // compare both to \ and / here
                if (path.StartsWith(@".\", StringComparison.Ordinal) ||
                    path.StartsWith(@"./", StringComparison.Ordinal))
                {
                    // The .\ prefix basically escapes anything that follows
                    // so treat it as a relative path no matter what comes
                    // after it.

                    result = false;
                    break;
                }

                // check if we're on a single root filesystem and it's an absolute path
                if (IsSingleFileSystemAbsolutePath(path))
                {
                    result = true;
                    break;
                }

                int index = path.IndexOf(":", StringComparison.Ordinal);

                if (index == -1)
                {
                    // If there is no : then the path is relative to the
                    // current working drive

                    result = false;
                    break;
                }

                // If the : is the first character in the path then we
                // must assume that it is part of the path, and not
                // delimiting the drive name.

                if (index > 0)
                {
                    // see if there are any path separators before the colon which would mean the
                    // colon is part of a file or folder name and not a drive: ./foo:bar vs foo:bar
                    int separator = path.IndexOf(StringLiterals.DefaultPathSeparator, 0, index-1);
                    if (separator == -1)
                    {
                        separator = path.IndexOf(StringLiterals.AlternatePathSeparator, 0, index-1);
                    }
                    if (separator == -1 || index < separator)
                    {
                        // We must have a drive specified
                        result = true;
                    }
                }
            } while (false);

            return result;
        } // IsAbsolutePath
</source>
<source file="PowerShell/src/System.Management.Automation/namespaces/LocationGlobber.cs.ifdefed" startline="1546" endline="1634" pcid="5239">
        internal bool IsAbsolutePath(string path, out string driveName)
        {
            // Verify parameters

            if (path == null)
            {
                throw PSTraceSource.NewArgumentNullException("path");
            }

            bool result = false;

            if (_sessionState.Drive.Current != null)
            {
                driveName = _sessionState.Drive.Current.Name;
            }
            else
            {
                driveName = null;
            }

            do
            {
                if (path.Length == 0)
                {
                    // The current working directory is specified

                    result = false;
                    break;
                }

                if (path.StartsWith(@".\", StringComparison.Ordinal) ||
                    path.StartsWith(@"./", StringComparison.Ordinal))
                {
                    // The .\ prefix basically escapes anything that follows
                    // so treat it as a relative path no matter what comes
                    // after it.

                    result = false;
                    break;
                }

                // check if we're on a single root filesystem and it's an absolute path
                if (IsSingleFileSystemAbsolutePath(path))
                {
                    driveName = StringLiterals.DefaultPathSeparatorString;
                    result = true;
                    break;
                }

                int index = path.IndexOf(":", StringComparison.CurrentCulture);

                if (index == -1)
                {
                    // If there is no : then the path is relative to the
                    // current working drive

                    result = false;
                    break;
                }

                // If the : is the first character in the path then we
                // must assume that it is part of the path, and not
                // delimiting the drive name.

                if (index > 0)
                {
                    // We must have a drive specified
                    driveName = path.Substring(0, index);

                    result = true;
                }
            } while (false);

//#if DEBUG
//            if (result)
//            {
//                Dbg.Diagnostics.Assert(
//                    driveName != null,
//                    "The drive name should always have a value, " +
//                    "the default is the current working drive");
//
//                s_tracer.WriteLine(
//                    "driveName = {0}",
//                    driveName);
//            }
//#endif

            return result;
        } // IsAbsolutePath
</source>
</class>

<class classid="114" nclones="2" nlines="132" similarity="75">
<source file="PowerShell/src/System.Management.Automation/namespaces/LocationGlobber.cs.ifdefed" startline="2621" endline="2947" pcid="5251">
        private Collection<string> ExpandMshGlobPath(
            string path,
            bool allowNonexistingPaths,
            PSDriveInfo drive,
            ContainerCmdletProvider provider,
            CmdletProviderContext context)
        {
            if (path == null)
            {
                throw PSTraceSource.NewArgumentNullException("path");
            }

            if (provider == null)
            {
                throw PSTraceSource.NewArgumentNullException("provider");
            }

            if (drive == null)
            {
                throw PSTraceSource.NewArgumentNullException("drive");
            }
            s_tracer.WriteLine("path = {0}", path);

            NavigationCmdletProvider navigationProvider = provider as NavigationCmdletProvider;

            Collection<string> result = new Collection<string>();

            using (s_pathResolutionTracer.TraceScope("EXPANDING WILDCARDS"))
            {
                if (ShouldPerformGlobbing(path, context))
                {
                    // This collection contains the directories for which a leaf is being added.
                    // If the directories are being globed over as well, then there will be
                    // many directories in this collection which will have to be iterated over
                    // every time there is a child being added

                    List<string> dirs = new List<string>();

                    // Each leaf element that is pulled off the path is pushed on the stack in
                    // order such that we can generate the path again.

                    Stack<String> leafElements = new Stack<String>();

                    using (s_pathResolutionTracer.TraceScope("Tokenizing path"))
                    {
                        // If the path contains glob characters then iterate through pulling the
                        // leaf elements off and pushing them on to the leafElements stack until
                        // there are no longer any glob characters in the path.

                        while (StringContainsGlobCharacters(path))
                        {
                            // Make sure to obey StopProcessing
                            if (context.Stopping)
                            {
                                throw new PipelineStoppedException();
                            }

                            // Use the provider to get the leaf element string

                            string leafElement = path;

                            if (navigationProvider != null)
                            {
                                leafElement = navigationProvider.GetChildName(path, context);
                            }

                            if (String.IsNullOrEmpty(leafElement))
                            {
                                break;
                            }

                            s_tracer.WriteLine("Pushing leaf element: {0}", leafElement);

                            s_pathResolutionTracer.WriteLine("Leaf element: {0}", leafElement);

                            // Push the leaf element onto the leaf element stack for future use

                            leafElements.Push(leafElement);

                            // Now use the parent path for the next iteration

                            if (navigationProvider != null)
                            {
                                // Now call GetParentPath with the root

                                string newParentPath = navigationProvider.GetParentPath(path, drive.Root, context);

                                if (String.Equals(
                                        newParentPath,
                                        path,
                                        StringComparison.OrdinalIgnoreCase))
                                {
                                    // The provider is implemented in an inconsistent way.
                                    // GetChildName returned a non-empty/non-null result but
                                    // GetParentPath with the same path returns the same path.
                                    // This would cause the globber to go into an infinite loop,
                                    // so instead an exception is thrown.

                                    PSInvalidOperationException invalidOperation =
                                        PSTraceSource.NewInvalidOperationException(
                                            SessionStateStrings.ProviderImplementationInconsistent,
                                            provider.ProviderInfo.Name,
                                            path);
                                    throw invalidOperation;
                                }
                                path = newParentPath;
                            }
                            else
                            {
                                // If the provider doesn't implement NavigationCmdletProvider then at most
                                // it can have only one segment in its path. So after removing
                                // the leaf all we have left is the empty string.

                                path = String.Empty;
                            }

                            s_tracer.WriteLine("New path: {0}", path);

                            s_pathResolutionTracer.WriteLine("Parent path: {0}", path);
                        }

                        s_tracer.WriteLine("Base container path: {0}", path);

                        // If no glob elements were found there must be an include and/or
                        // exclude specified. Use the parent path to iterate over to
                        // resolve the include/exclude filters

                        if (leafElements.Count == 0)
                        {
                            string leafElement = path;

                            if (navigationProvider != null)
                            {
                                leafElement = navigationProvider.GetChildName(path, context);

                                if (!String.IsNullOrEmpty(leafElement))
                                {
                                    path = navigationProvider.GetParentPath(path, null, context);
                                }
                            }
                            else
                            {
                                path = String.Empty;
                            }

                            leafElements.Push(leafElement);

                            s_pathResolutionTracer.WriteLine("Leaf element: {0}", leafElement);
                        }

                        s_pathResolutionTracer.WriteLine("Root path of resolution: {0}", path);
                    }

                    // Once the container path with no glob characters are found store it
                    // so that it's children can be iterated over.

                    dirs.Add(path);

                    // Reconstruct the path one leaf element at a time, expanding wherever
                    // we encounter glob characters

                    while (leafElements.Count > 0)
                    {
                        // Make sure to obey StopProcessing
                        if (context.Stopping)
                        {
                            throw new PipelineStoppedException();
                        }

                        string leafElement = leafElements.Pop();

                        Dbg.Diagnostics.Assert(
                            leafElement != null,
                            "I am only pushing strings onto this stack so I should be able " +
                            "to cast any Pop to a string without failure.");

                        dirs =
                            GenerateNewPSPathsWithGlobLeaf(
                                dirs,
                                drive,
                                leafElement,
                                leafElements.Count == 0,
                                provider,
                                context);

                        // If there are more leaf elements in the stack we need
                        // to make sure that only containers where added to dirs
                        // in GenerateNewPathsWithGlobLeaf

                        if (leafElements.Count > 0)
                        {
                            using (s_pathResolutionTracer.TraceScope("Checking matches to ensure they are containers"))
                            {
                                int index = 0;

                                while (index < dirs.Count)
                                {
                                    // Make sure to obey StopProcessing
                                    if (context.Stopping)
                                    {
                                        throw new PipelineStoppedException();
                                    }

                                    string resolvedPath =
                                        GetMshQualifiedPath(dirs[index], drive);

                                    // Check to see if the matching item is a container

                                    if (navigationProvider != null &&
                                        !_sessionState.Internal.IsItemContainer(
                                            resolvedPath,
                                            context))
                                    {
                                        // If not, remove it from the collection

                                        s_tracer.WriteLine(
                                            "Removing {0} because it is not a container",
                                            dirs[index]);

                                        s_pathResolutionTracer.WriteLine("{0} is not a container", dirs[index]);
                                        dirs.RemoveAt(index);
                                    }
                                    else if (navigationProvider == null)
                                    {
                                        Dbg.Diagnostics.Assert(
                                            navigationProvider != null,
                                            "The path in the dirs should never be a container unless " +
                                            "the provider implements the NavigationCmdletProvider interface. If it " +
                                            "doesn't, there should be no more leafElements in the stack " +
                                            "when this check is done");
                                    }
                                    else
                                    {
                                        s_pathResolutionTracer.WriteLine("{0} is a container", dirs[index]);

                                        // If so, leave it and move on to the next one

                                        ++index;
                                    }
                                }
                            }
                        }
                    } // while (leafElements.Count > 0)

                    Dbg.Diagnostics.Assert(
                        dirs != null,
                        "GenerateNewPathsWithGlobLeaf() should return the base path as an element " +
                        "even if there are no globing characters");

                    foreach (string dir in dirs)
                    {
                        s_pathResolutionTracer.WriteLine("RESOLVED PATH: {0}", dir);
                        result.Add(dir);
                    }

                    Dbg.Diagnostics.Assert(
                        dirs.Count == result.Count,
                        "The result of copying the globed strings should be the same " +
                        "as from the collection");
                }
                else
                {
                    string unescapedPath = context.SuppressWildcardExpansion ? path : RemoveGlobEscaping(path);

                    string formatString = "{0}:" + StringLiterals.DefaultPathSeparator + "{1}";

                    // Check to see if its a hidden provider drive.
                    if (drive.Hidden)
                    {
                        if (IsProviderDirectPath(unescapedPath))
                        {
                            formatString = "{1}";
                        }
                        else
                        {
                            formatString = "{0}::{1}";
                        }
                    }
                    else
                    {
                        if (path.StartsWith(StringLiterals.DefaultPathSeparatorString, StringComparison.Ordinal))
                        {
                            formatString = "{0}:{1}";
                        }
                    }

                    // Porting note: if the volume is not separated by a colon (non-Windows filesystems), don't add it.
                    if (!drive.VolumeSeparatedByColon)
                    {
                        formatString = "{0}{1}";
                    }

                    string resolvedPath =
                        String.Format(
                            System.Globalization.CultureInfo.InvariantCulture,
                            formatString,
                            drive.Name,
                            unescapedPath);

                    // Since we didn't do globbing, be sure the path exists
                    if (allowNonexistingPaths ||
                        provider.ItemExists(GetProviderPath(resolvedPath, context), context))
                    {
                        s_pathResolutionTracer.WriteLine("RESOLVED PATH: {0}", resolvedPath);
                        result.Add(resolvedPath);
                    }
                    else
                    {
                        ItemNotFoundException pathNotFound =
                            new ItemNotFoundException(
                                resolvedPath,
                                "PathNotFound",
                                SessionStateStrings.PathNotFound);

                        s_pathResolutionTracer.TraceError("Item does not exist: {0}", path);

                        throw pathNotFound;
                    }
                }
            }

            Dbg.Diagnostics.Assert(
                result != null,
                "This method should at least return the path or more if it has glob characters");

            return result;
        } // ExpandMshGlobPath
</source>
<source file="PowerShell/src/System.Management.Automation/namespaces/LocationGlobber.cs.ifdefed" startline="3573" endline="3889" pcid="5259">
        internal Collection<string> ExpandGlobPath(
            string path,
            bool allowNonexistingPaths,
            ContainerCmdletProvider provider,
            CmdletProviderContext context)
        {
            if (path == null)
            {
                throw PSTraceSource.NewArgumentNullException("path");
            }

            if (provider == null)
            {
                throw PSTraceSource.NewArgumentNullException("provider");
            }

            // See if the provider wants to convert the path and filter
            string convertedPath = null;
            string convertedFilter = null;
            string originalFilter = context.Filter;
            bool changedPathOrFilter = provider.ConvertPath(path, context.Filter, ref convertedPath, ref convertedFilter, context);

            if (changedPathOrFilter)
            {
                if (s_tracer.IsEnabled)
                {
                    s_tracer.WriteLine("Provider converted path and filter.");
                    s_tracer.WriteLine("Original path: {0}", path);
                    s_tracer.WriteLine("Converted path: {0}", convertedPath);
                    s_tracer.WriteLine("Original filter: {0}", context.Filter);
                    s_tracer.WriteLine("Converted filter: {0}", convertedFilter);
                }

                path = convertedPath;
                originalFilter = context.Filter;
            }

            NavigationCmdletProvider navigationProvider = provider as NavigationCmdletProvider;

            s_tracer.WriteLine("path = {0}", path);

            Collection<string> result = new Collection<string>();

            using (s_pathResolutionTracer.TraceScope("EXPANDING WILDCARDS"))
            {
                if (ShouldPerformGlobbing(path, context))
                {
                    // This collection contains the directories for which a leaf is being added.
                    // If the directories are being globed over as well, then there will be
                    // many directories in this collection which will have to be iterated over
                    // every time there is a child being added

                    List<string> dirs = new List<string>();

                    // Each leaf element that is pulled off the path is pushed on the stack in
                    // order such that we can generate the path again.

                    Stack<String> leafElements = new Stack<String>();

                    using (s_pathResolutionTracer.TraceScope("Tokenizing path"))
                    {
                        // If the path contains glob characters then iterate through pulling the
                        // leaf elements off and pushing them on to the leafElements stack until
                        // there are no longer any glob characters in the path.

                        while (StringContainsGlobCharacters(path))
                        {
                            // Make sure to obey StopProcessing
                            if (context.Stopping)
                            {
                                throw new PipelineStoppedException();
                            }

                            // Use the provider to get the leaf element string

                            string leafElement = path;

                            if (navigationProvider != null)
                            {
                                leafElement = navigationProvider.GetChildName(path, context);
                            }

                            if (String.IsNullOrEmpty(leafElement))
                            {
                                break;
                            }

                            s_tracer.WriteLine("Pushing leaf element: {0}", leafElement);

                            s_pathResolutionTracer.WriteLine("Leaf element: {0}", leafElement);

                            // Push the leaf element onto the leaf element stack for future use

                            leafElements.Push(leafElement);

                            // Now use the parent path for the next iteration

                            if (navigationProvider != null)
                            {
                                // See if we can get the root from the context

                                string root = String.Empty;

                                if (context != null)
                                {
                                    PSDriveInfo drive = context.Drive;

                                    if (drive != null)
                                    {
                                        root = drive.Root;
                                    }
                                }

                                // Now call GetParentPath with the root

                                string newParentPath = navigationProvider.GetParentPath(path, root, context);

                                if (String.Equals(
                                        newParentPath,
                                        path,
                                        StringComparison.OrdinalIgnoreCase))
                                {
                                    // The provider is implemented in an inconsistent way.
                                    // GetChildName returned a non-empty/non-null result but
                                    // GetParentPath with the same path returns the same path.
                                    // This would cause the globber to go into an infinite loop,
                                    // so instead an exception is thrown.

                                    PSInvalidOperationException invalidOperation =
                                        PSTraceSource.NewInvalidOperationException(
                                            SessionStateStrings.ProviderImplementationInconsistent,
                                            provider.ProviderInfo.Name,
                                            path);
                                    throw invalidOperation;
                                }
                                path = newParentPath;
                            }
                            else
                            {
                                // If the provider doesn't implement NavigationCmdletProvider then at most
                                // it can have only one segment in its path. So after removing
                                // the leaf all we have left is the empty string.

                                path = String.Empty;
                            }

                            s_tracer.WriteLine("New path: {0}", path);
                            s_pathResolutionTracer.WriteLine("Parent path: {0}", path);
                        }

                        s_tracer.WriteLine("Base container path: {0}", path);

                        // If no glob elements were found there must be an include and/or
                        // exclude specified. Use the parent path to iterate over to
                        // resolve the include/exclude filters

                        if (leafElements.Count == 0)
                        {
                            string leafElement = path;

                            if (navigationProvider != null)
                            {
                                leafElement = navigationProvider.GetChildName(path, context);

                                if (!String.IsNullOrEmpty(leafElement))
                                {
                                    path = navigationProvider.GetParentPath(path, null, context);
                                }
                            }
                            else
                            {
                                path = String.Empty;
                            }
                            leafElements.Push(leafElement);
                            s_pathResolutionTracer.WriteLine("Leaf element: {0}", leafElement);
                        }

                        s_pathResolutionTracer.WriteLine("Root path of resolution: {0}", path);
                    }
                    // Once the container path with no glob characters are found store it
                    // so that it's children can be iterated over.

                    dirs.Add(path);

                    // Reconstruct the path one leaf element at a time, expanding where-ever
                    // we encounter glob characters

                    while (leafElements.Count > 0)
                    {
                        // Make sure to obey StopProcessing
                        if (context.Stopping)
                        {
                            throw new PipelineStoppedException();
                        }

                        string leafElement = leafElements.Pop();

                        Dbg.Diagnostics.Assert(
                            leafElement != null,
                            "I am only pushing strings onto this stack so I should be able " +
                            "to cast any Pop to a string without failure.");

                        dirs =
                            GenerateNewPathsWithGlobLeaf(
                                dirs,
                                leafElement,
                                leafElements.Count == 0,
                                provider,
                                context);

                        // If there are more leaf elements in the stack we need
                        // to make sure that only containers where added to dirs
                        // in GenerateNewPathsWithGlobLeaf

                        if (leafElements.Count > 0)
                        {
                            using (s_pathResolutionTracer.TraceScope("Checking matches to ensure they are containers"))
                            {
                                int index = 0;

                                while (index < dirs.Count)
                                {
                                    // Make sure to obey StopProcessing
                                    if (context.Stopping)
                                    {
                                        throw new PipelineStoppedException();
                                    }

                                    // Check to see if the matching item is a container

                                    if (navigationProvider != null &&
                                        !navigationProvider.IsItemContainer(
                                            dirs[index],
                                            context))
                                    {
                                        // If not, remove it from the collection

                                        s_tracer.WriteLine(
                                            "Removing {0} because it is not a container",
                                            dirs[index]);

                                        s_pathResolutionTracer.WriteLine("{0} is not a container", dirs[index]);
                                        dirs.RemoveAt(index);
                                    }
                                    else if (navigationProvider == null)
                                    {
                                        Dbg.Diagnostics.Assert(
                                            navigationProvider != null,
                                            "The path in the dirs should never be a container unless " +
                                            "the provider implements the NavigationCmdletProvider interface. If it " +
                                            "doesn't, there should be no more leafElements in the stack " +
                                            "when this check is done");
                                    }
                                    else
                                    {
                                        s_pathResolutionTracer.WriteLine("{0} is a container", dirs[index]);

                                        // If so, leave it and move on to the next one

                                        ++index;
                                    }
                                }
                            }
                        }
                    } // while (leafElements.Count > 0)

                    Dbg.Diagnostics.Assert(
                        dirs != null,
                        "GenerateNewPathsWithGlobLeaf() should return the base path as an element " +
                        "even if there are no globing characters");

                    foreach (string dir in dirs)
                    {
                        s_pathResolutionTracer.WriteLine("RESOLVED PATH: {0}", dir);
                        result.Add(dir);
                    }

                    Dbg.Diagnostics.Assert(
                        dirs.Count == result.Count,
                        "The result of copying the globed strings should be the same " +
                        "as from the collection");
                }
                else
                {
                    string unescapedPath = context.SuppressWildcardExpansion ? path : RemoveGlobEscaping(path);

                    if (allowNonexistingPaths ||
                        provider.ItemExists(unescapedPath, context))
                    {
                        s_pathResolutionTracer.WriteLine("RESOLVED PATH: {0}", unescapedPath);
                        result.Add(unescapedPath);
                    }
                    else
                    {
                        ItemNotFoundException pathNotFound =
                            new ItemNotFoundException(
                                path,
                                "PathNotFound",
                                SessionStateStrings.PathNotFound);

                        s_pathResolutionTracer.TraceError("Item does not exist: {0}", path);

                        throw pathNotFound;
                    }
                }
            }
            Dbg.Diagnostics.Assert(
                result != null,
                "This method should at least return the path or more if it has glob characters");

            if (changedPathOrFilter)
            {
                context.Filter = originalFilter;
            }

            return result;
        } // ExpandGlobPath
</source>
</class>

<class classid="115" nclones="2" nlines="68" similarity="80">
<source file="PowerShell/src/System.Management.Automation/namespaces/LocationGlobber.cs.ifdefed" startline="3326" endline="3509" pcid="5258">
        private List<string> GenerateNewPSPathsWithGlobLeaf(
            List<string> currentDirs,
            PSDriveInfo drive,
            string leafElement,
            bool isLastLeaf,
            ContainerCmdletProvider provider,
            CmdletProviderContext context)
        {
            if (currentDirs == null)
            {
                throw PSTraceSource.NewArgumentNullException("currentDirs");
            }

            if (provider == null)
            {
                throw PSTraceSource.NewArgumentNullException("provider");
            }

            NavigationCmdletProvider navigationProvider = provider as NavigationCmdletProvider;

            List<string> newDirs = new List<string>();

            // Only loop through the child names if the leafElement contains a glob character

            if (!string.IsNullOrEmpty(leafElement) &&
                StringContainsGlobCharacters(leafElement) ||
                isLastLeaf)
            {
                string regexEscapedLeafElement = ConvertMshEscapeToRegexEscape(leafElement);

                // Construct the glob filter

                WildcardPattern stringMatcher =
                    WildcardPattern.Get(
                        regexEscapedLeafElement,
                        WildcardOptions.IgnoreCase);

                // Construct the include filter

                Collection<WildcardPattern> includeMatcher =
                    SessionStateUtilities.CreateWildcardsFromStrings(
                        context.Include,
                        WildcardOptions.IgnoreCase);

                // Construct the exclude filter

                Collection<WildcardPattern> excludeMatcher =
                    SessionStateUtilities.CreateWildcardsFromStrings(
                        context.Exclude,
                        WildcardOptions.IgnoreCase);

                // Loop through the current dirs and add the appropriate children

                foreach (string dir in currentDirs)
                {
                    using (s_pathResolutionTracer.TraceScope("Expanding wildcards for items under '{0}'", dir))
                    {
                        // Make sure to obey StopProcessing
                        if (context.Stopping)
                        {
                            throw new PipelineStoppedException();
                        }

                        // Now continue on with the names that were returned

                        string mshQualifiedParentPath = String.Empty;
                        Collection<PSObject> childNamesObjectArray =
                            GetChildNamesInDir(
                                dir,
                                leafElement,
                                !isLastLeaf,
                                context,
                                false,
                                drive,
                                provider,
                                out mshQualifiedParentPath);

                        if (childNamesObjectArray == null)
                        {
                            s_tracer.TraceError("GetChildNames returned a null array");
                            s_pathResolutionTracer.WriteLine("No child names returned for '{0}'", dir);
                            continue;
                        }

                        // Loop through each child to see if they match the glob expression

                        foreach (PSObject childObject in childNamesObjectArray)
                        {
                            // Make sure to obey StopProcessing
                            if (context.Stopping)
                            {
                                throw new PipelineStoppedException();
                            }

                            string child = String.Empty;

                            if (IsChildNameAMatch(
                                    childObject,
                                    stringMatcher,
                                    includeMatcher,
                                    excludeMatcher,
                                    out child))
                            {
                                string childPath = child;

                                if (navigationProvider != null)
                                {
                                    string parentPath = RemoveMshQualifier(mshQualifiedParentPath, drive);

                                    childPath =
                                        _sessionState.Internal.
                                            MakePath(
                                                parentPath,
                                                child,
                                                context);

                                    childPath = GetMshQualifiedPath(childPath, drive);
                                }

                                s_tracer.WriteLine("Adding child path to dirs {0}", childPath);

                                // -- If there are more leafElements, the current childPath will be treated as a container path later,
                                //    we should escape the childPath in case the actual childPath contains wildcard characters such as '[' or ']'.
                                // -- If there is no more leafElement, the childPath will not be further processed, and we don't need to
                                //    escape it.
                                childPath = isLastLeaf ? childPath : WildcardPattern.Escape(childPath);
                                newDirs.Add(childPath);
                            }
                        } // foreach (child in childNames)
                    }
                } // foreach (dir in currentDirs)
            } // if (StringContainsGlobCharacters(leafElement))
            else
            {
                s_tracer.WriteLine(
                    "LeafElement does not contain any glob characters so do a MakePath");

                // Loop through the current dirs and add the leafElement to each of
                // the dirs

                foreach (string dir in currentDirs)
                {
                    using (s_pathResolutionTracer.TraceScope("Expanding intermediate containers under '{0}'", dir))
                    {
                        // Make sure to obey StopProcessing
                        if (context.Stopping)
                        {
                            throw new PipelineStoppedException();
                        }

                        string backslashEscapedLeafElement = ConvertMshEscapeToRegexEscape(leafElement);

                        string unescapedDir = context.SuppressWildcardExpansion ? dir : RemoveGlobEscaping(dir);
                        string resolvedPath = GetMshQualifiedPath(unescapedDir, drive);

                        string childPath = backslashEscapedLeafElement;

                        if (navigationProvider != null)
                        {
                            string parentPath = RemoveMshQualifier(resolvedPath, drive);

                            childPath =
                                _sessionState.Internal.
                                    MakePath(
                                        parentPath,
                                        backslashEscapedLeafElement,
                                        context);

                            childPath = GetMshQualifiedPath(childPath, drive);
                        }

                        if (_sessionState.Internal.ItemExists(childPath, context))
                        {
                            s_tracer.WriteLine("Adding child path to dirs {0}", childPath);
                            s_pathResolutionTracer.WriteLine("Valid intermediate container: {0}", childPath);

                            newDirs.Add(childPath);
                        }
                    }
                } // foreach (dir in currentDirs)
            } // if (StringContainsGlobCharacters(leafElement))

            return newDirs;
        } // GenerateNewPSPathsWithGlobLeaf
</source>
<source file="PowerShell/src/System.Management.Automation/namespaces/LocationGlobber.cs.ifdefed" startline="3941" endline="4096" pcid="5260">
        internal List<string> GenerateNewPathsWithGlobLeaf(
            List<string> currentDirs,
            string leafElement,
            bool isLastLeaf,
            ContainerCmdletProvider provider,
            CmdletProviderContext context)
        {
            if (currentDirs == null)
            {
                throw PSTraceSource.NewArgumentNullException("currentDirs");
            }

            if (provider == null)
            {
                throw PSTraceSource.NewArgumentNullException("provider");
            }

            NavigationCmdletProvider navigationProvider = provider as NavigationCmdletProvider;

            List<string> newDirs = new List<string>();

            // Only loop through the child names if the leafElement contains a glob character

            if (!string.IsNullOrEmpty(leafElement) &&
                (StringContainsGlobCharacters(leafElement) ||
                 isLastLeaf))
            {
                string regexEscapedLeafElement = ConvertMshEscapeToRegexEscape(leafElement);

                // Construct the glob filter

                WildcardPattern stringMatcher =
                    WildcardPattern.Get(
                        regexEscapedLeafElement,
                        WildcardOptions.IgnoreCase);

                // Construct the include filter

                Collection<WildcardPattern> includeMatcher =
                    SessionStateUtilities.CreateWildcardsFromStrings(
                        context.Include,
                        WildcardOptions.IgnoreCase);

                // Construct the exclude filter

                Collection<WildcardPattern> excludeMatcher =
                    SessionStateUtilities.CreateWildcardsFromStrings(
                        context.Exclude,
                        WildcardOptions.IgnoreCase);

                // Loop through the current dirs and add the appropriate children

                foreach (string dir in currentDirs)
                {
                    using (s_pathResolutionTracer.TraceScope("Expanding wildcards for items under '{0}'", dir))
                    {
                        // Make sure to obey StopProcessing
                        if (context.Stopping)
                        {
                            throw new PipelineStoppedException();
                        }

                        string unescapedDir = null;

                        Collection<PSObject> childNamesObjectArray =
                            GetChildNamesInDir(dir, leafElement, !isLastLeaf, context, true, null, provider, out unescapedDir);

                        if (childNamesObjectArray == null)
                        {
                            s_tracer.TraceError("GetChildNames returned a null array");

                            s_pathResolutionTracer.WriteLine("No child names returned for '{0}'", dir);
                            continue;
                        }

                        // Loop through each child to see if they match the glob expression

                        foreach (PSObject childObject in childNamesObjectArray)
                        {
                            // Make sure to obey StopProcessing
                            if (context.Stopping)
                            {
                                throw new PipelineStoppedException();
                            }

                            string child = String.Empty;
                            if (IsChildNameAMatch(childObject, stringMatcher, includeMatcher, excludeMatcher, out child))
                            {
                                string childPath = child;

                                if (navigationProvider != null)
                                {
                                    childPath =
                                        navigationProvider.
                                        MakePath(
                                            unescapedDir,
                                            child,
                                            context);
                                }

                                s_tracer.WriteLine("Adding child path to dirs {0}", childPath);

                                newDirs.Add(childPath);
                            }
                        } // foreach (child in childNames)
                    }
                } // foreach (dir in currentDirs)
            } // if (StringContainsGlobCharacters(leafElement))
            else
            {
                s_tracer.WriteLine(
                    "LeafElement does not contain any glob characters so do a MakePath");

                // Loop through the current dirs and add the leafElement to each of
                // the dirs

                foreach (string dir in currentDirs)
                {
                    using (s_pathResolutionTracer.TraceScope("Expanding intermediate containers under '{0}'", dir))
                    {
                        // Make sure to obey StopProcessing
                        if (context.Stopping)
                        {
                            throw new PipelineStoppedException();
                        }

                        string backslashEscapedLeafElement = ConvertMshEscapeToRegexEscape(leafElement);

                        string unescapedDir = context.SuppressWildcardExpansion ? dir : RemoveGlobEscaping(dir);

                        string childPath = backslashEscapedLeafElement;

                        if (navigationProvider != null)
                        {
                            childPath =
                                navigationProvider.
                                    MakePath(
                                        unescapedDir,
                                        backslashEscapedLeafElement,
                                        context);
                        }

                        if (provider.ItemExists(childPath, context))
                        {
                            s_tracer.WriteLine("Adding child path to dirs {0}", childPath);

                            newDirs.Add(childPath);

                            s_pathResolutionTracer.WriteLine("Valid intermediate container: {0}", childPath);
                        }
                    }
                } // foreach (dir in currentDirs)
            } // if (StringContainsGlobCharacters(leafElement))

            return newDirs;
        } // GenerateNewPathsWithGlobLeaf
</source>
</class>

<class classid="116" nclones="2" nlines="11" similarity="81">
<source file="PowerShell/src/System.Management.Automation/namespaces/RegistryWrapper.cs.ifdefed" startline="331" endline="348" pcid="5350">
        public object GetValue(string name)
        {
            using (_provider.CurrentPSTransaction)
            {
                object value = _txRegKey.GetValue(name);

                try
                {
                    value = RegistryWrapperUtils.ConvertValueToUIntFromRegistryIfNeeded(name, value, GetValueKind(name));
                }
                catch (System.IO.IOException)
                {
                    // This is expected if the value does not exist.
                }

                return value;
            }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/namespaces/RegistryWrapper.cs.ifdefed" startline="350" endline="367" pcid="5351">
        public object GetValue(string name, object defaultValue, RegistryValueOptions options)
        {
            using (_provider.CurrentPSTransaction)
            {
                object value = _txRegKey.GetValue(name, defaultValue, options);

                try
                {
                    value = RegistryWrapperUtils.ConvertValueToUIntFromRegistryIfNeeded(name, value, GetValueKind(name));
                }
                catch (System.IO.IOException)
                {
                    // This is expected if the value does not exist.
                }

                return value;
            }
        }
</source>
</class>

<class classid="117" nclones="2" nlines="12" similarity="75">
<source file="PowerShell/src/System.Management.Automation/security/SecurityManager.cs.ifdefed" startline="422" endline="439" pcid="5428">
        private bool IsTrustedPublisher(Signature signature, string file)
        {
            // Get the thumbprint of the current signature
            X509Certificate2 signerCertificate = signature.SignerCertificate;
            string thumbprint = signerCertificate.Thumbprint;

            // See if it matches any in the list of trusted publishers
            X509Store trustedPublishers = new X509Store(StoreName.TrustedPublisher, StoreLocation.CurrentUser);
            trustedPublishers.Open(OpenFlags.ReadOnly);

            foreach (X509Certificate2 trustedCertificate in trustedPublishers.Certificates)
            {
                if (String.Equals(trustedCertificate.Thumbprint, thumbprint, StringComparison.OrdinalIgnoreCase))
                    if (!IsUntrustedPublisher(signature, file)) return true;
            }

            return false;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/security/SecurityManager.cs.ifdefed" startline="441" endline="458" pcid="5429">
        private bool IsUntrustedPublisher(Signature signature, string file)
        {
            // Get the thumbprint of the current signature
            X509Certificate2 signerCertificate = signature.SignerCertificate;
            string thumbprint = signerCertificate.Thumbprint;

            // See if it matches any in the list of trusted publishers
            X509Store trustedPublishers = new X509Store(StoreName.Disallowed, StoreLocation.CurrentUser);
            trustedPublishers.Open(OpenFlags.ReadOnly);

            foreach (X509Certificate2 trustedCertificate in trustedPublishers.Certificates)
            {
                if (String.Equals(trustedCertificate.Thumbprint, thumbprint, StringComparison.OrdinalIgnoreCase))
                    return true;
            }

            return false;
        }
</source>
</class>

<class classid="118" nclones="2" nlines="12" similarity="75">
<source file="PowerShell/src/System.Management.Automation/utils/CommandDiscoveryExceptions.cs.ifdefed" startline="155" endline="174" pcid="5488">
        private static string BuildMessage(
            string commandName,
            string resourceStr,
            params object[] messageArgs
            )
        {
            object[] a;
            if (messageArgs != null && 0 < messageArgs.Length)
            {
                a = new object[messageArgs.Length + 1];
                a[0] = commandName;
                messageArgs.CopyTo(a, 1);
            }
            else
            {
                a = new object[1];
                a[0] = commandName;
            }
            return StringUtil.Format(resourceStr, a);
        }
</source>
<source file="PowerShell/src/System.Management.Automation/utils/SessionStateExceptions.cs.ifdefed" startline="530" endline="548" pcid="5668">
        private static string BuildMessage(
            string itemName,
            string resourceStr,
            params object[] messageArgs)
        {
            object[] a;
            if (messageArgs != null && 0 < messageArgs.Length)
            {
                a = new object[messageArgs.Length + 1];
                a[0] = itemName;
                messageArgs.CopyTo(a, 1);
            }
            else
            {
                a = new object[1];
                a[0] = itemName;
            }
            return StringUtil.Format(resourceStr, a);
        }
</source>
</class>

<class classid="119" nclones="3" nlines="11" similarity="81">
<source file="PowerShell/src/System.Management.Automation/utils/MshTraceSource.cs.ifdefed" startline="256" endline="274" pcid="5543">
        internal static PSArgumentNullException NewArgumentNullException(
            string paramName, string resourceString, params object[] args)
        {
            if (String.IsNullOrEmpty(paramName))
            {
                throw NewArgumentNullException("paramName");
            }
            if (String.IsNullOrEmpty(resourceString))
            {
                throw NewArgumentNullException("resourceString");
            }

            string message = StringUtil.Format(resourceString, args);

            // Note that the paramName param comes first
            var e = new PSArgumentNullException(paramName, message);

            return e;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/utils/MshTraceSource.cs.ifdefed" startline="504" endline="520" pcid="5553">
        internal static PSArgumentOutOfRangeException NewArgumentOutOfRangeException(
            string paramName, object actualValue, string resourceString, params object[] args)
        {
            if (String.IsNullOrEmpty(paramName))
            {
                throw NewArgumentNullException("paramName");
            }
            if (String.IsNullOrEmpty(resourceString))
            {
                throw NewArgumentNullException("resourceString");
            }

            string message = StringUtil.Format(resourceString, args);
            var e = new PSArgumentOutOfRangeException(paramName, actualValue, message);

            return e;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/utils/MshTraceSource.cs.ifdefed" startline="314" endline="332" pcid="5545">
        internal static PSArgumentException NewArgumentException(
            string paramName, string resourceString, params object[] args)
        {
            if (String.IsNullOrEmpty(paramName))
            {
                throw NewArgumentNullException("paramName");
            }
            if (String.IsNullOrEmpty(resourceString))
            {
                throw NewArgumentNullException("resourceString");
            }

            string message = StringUtil.Format(resourceString, args);

            // Note that the message param comes first
            var e = new PSArgumentException(message, paramName);

            return e;
        }
</source>
</class>

<class classid="120" nclones="2" nlines="19" similarity="84">
<source file="PowerShell/src/System.Management.Automation/utils/ObjectReader.cs.ifdefed" startline="570" endline="596" pcid="5578">
        public override Collection<ReturnType> NonBlockingRead(int maxRequested)
        {
            if (maxRequested < 0)
            {
                throw PSTraceSource.NewArgumentOutOfRangeException("maxRequested", maxRequested);
            }

            if (maxRequested == 0)
            {
                return new Collection<ReturnType>();
            }
            Collection<ReturnType> results = new Collection<ReturnType>();
            int readCount = maxRequested;

            while (readCount > 0)
            {
                if (_enumerator.MoveNext(false))
                {
                    results.Add(ConvertToReturnType(_enumerator.Current));
                    continue;
                }

                break;
            }

            return results;
        }
</source>
<source file="PowerShell/src/System.Management.Automation/utils/ObjectReader.cs.ifdefed" startline="751" endline="778" pcid="5586">
        public override Collection<ReturnType> NonBlockingRead(int maxRequested)
        {
            if (maxRequested < 0)
            {
                throw PSTraceSource.NewArgumentOutOfRangeException("maxRequested", maxRequested);
            }

            if (maxRequested == 0)
            {
                return new Collection<ReturnType>();
            }
            Collection<ReturnType> results = new Collection<ReturnType>();
            int readCount = maxRequested;

            while (readCount > 0)
            {
                if (_datastore.Count > 0)
                {
                    results.Add(ConvertToReturnType((_datastore.ReadAndRemove(1))[0]));
                    readCount--;
                    continue;
                }

                break;
            }

            return results;
        }
</source>
</class>

<class classid="121" nclones="2" nlines="10" similarity="100">
<source file="PowerShell/src/System.Management.Automation/utils/ObjectReader.cs.ifdefed" startline="619" endline="632" pcid="5581">
        private ReturnType ConvertToReturnType(object inputObject)
        {
            Type resultType = typeof(ReturnType);
            if (typeof(PSObject) == resultType || typeof(object) == resultType)
            {
                ReturnType result;
                LanguagePrimitives.TryConvertTo(inputObject, out result);
                return result;
            }

            System.Management.Automation.Diagnostics.Assert(false,
                "ReturnType should be either object or PSObject only");
            throw PSTraceSource.NewNotSupportedException();
        }
</source>
<source file="PowerShell/src/System.Management.Automation/utils/ObjectReader.cs.ifdefed" startline="794" endline="807" pcid="5588">
        private ReturnType ConvertToReturnType(object inputObject)
        {
            Type resultType = typeof(ReturnType);
            if (typeof(PSObject) == resultType || typeof(object) == resultType)
            {
                ReturnType result;
                LanguagePrimitives.TryConvertTo(inputObject, out result);
                return result;
            }

            System.Management.Automation.Diagnostics.Assert(false,
                "ReturnType should be either object or PSObject only");
            throw PSTraceSource.NewNotSupportedException();
        }
</source>
</class>

<class classid="122" nclones="3" nlines="21" similarity="86">
<source file="PowerShell/src/System.Management.Automation/utils/perfCounters/CounterSetInstanceBase.cs.ifdefed" startline="347" endline="382" pcid="5646">
        public override bool UpdateCounterByValue(int counterId, long stepAmount, bool isNumerator)
        {
            if (_Disposed)
            {
                ObjectDisposedException objectDisposedException =
                    new ObjectDisposedException("PSCounterSetInstance");
                _tracer.TraceException(objectDisposedException);
                return false;
            }

            int targetCounterId;
            if (base.RetrieveTargetCounterIdIfValid(counterId, isNumerator, out targetCounterId))
            {
                CounterData targetCounterData = _CounterSetInstance.Counters[targetCounterId];
                if (targetCounterData != null)
                {
                    this.UpdateCounterByValue(targetCounterData, stepAmount);
                    return true;
                }
                else
                {
                    InvalidOperationException invalidOperationException =
                    new InvalidOperationException(
                        String.Format(
                        CultureInfo.InvariantCulture,
                        "Lookup for counter corresponding to counter id {0} failed",
                        counterId));
                    _tracer.TraceException(invalidOperationException);
                    return false;
                }
            }
            else
            {
                return false;
            }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/utils/perfCounters/CounterSetInstanceBase.cs.ifdefed" startline="428" endline="464" pcid="5648">
        public override bool SetCounterValue(int counterId, long counterValue, bool isNumerator)
        {
            if (_Disposed)
            {
                ObjectDisposedException objectDisposedException =
                    new ObjectDisposedException("PSCounterSetInstance");
                _tracer.TraceException(objectDisposedException);
                return false;
            }

            int targetCounterId;
            if (base.RetrieveTargetCounterIdIfValid(counterId, isNumerator, out targetCounterId))
            {
                CounterData targetCounterData = _CounterSetInstance.Counters[targetCounterId];

                if (targetCounterData != null)
                {
                    targetCounterData.Value = counterValue;
                    return true;
                }
                else
                {
                    InvalidOperationException invalidOperationException =
                        new InvalidOperationException(
                            String.Format(
                            CultureInfo.InvariantCulture,
                            "Lookup for counter corresponding to counter id {0} failed",
                            counterId));
                    _tracer.TraceException(invalidOperationException);
                    return false;
                }
            }
            else
            {
                return false;
            }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/utils/perfCounters/CounterSetInstanceBase.cs.ifdefed" startline="510" endline="546" pcid="5650">
        public override bool GetCounterValue(int counterId, bool isNumerator, out long counterValue)
        {
            counterValue = -1;
            if (_Disposed)
            {
                ObjectDisposedException objectDisposedException =
                    new ObjectDisposedException("PSCounterSetInstance");
                _tracer.TraceException(objectDisposedException);
                return false;
            }
            int targetCounterId;
            if (base.RetrieveTargetCounterIdIfValid(counterId, isNumerator, out targetCounterId))
            {
                CounterData targetCounterData = _CounterSetInstance.Counters[targetCounterId];

                if (targetCounterData != null)
                {
                    counterValue = targetCounterData.Value;
                    return true;
                }
                else
                {
                    InvalidOperationException invalidOperationException =
                        new InvalidOperationException(
                            String.Format(
                            CultureInfo.InvariantCulture,
                            "Lookup for counter corresponding to counter id {0} failed",
                            counterId));
                    _tracer.TraceException(invalidOperationException);
                    return false;
                }
            }
            else
            {
                return false;
            }
        }
</source>
</class>

<class classid="123" nclones="3" nlines="21" similarity="86">
<source file="PowerShell/src/System.Management.Automation/utils/perfCounters/CounterSetInstanceBase.cs.ifdefed" startline="388" endline="421" pcid="5647">
        public override bool UpdateCounterByValue(string counterName, long stepAmount, bool isNumerator)
        {
            if (_Disposed)
            {
                ObjectDisposedException objectDisposedException =
                    new ObjectDisposedException("PSCounterSetInstance");
                _tracer.TraceException(objectDisposedException);
                return false;
            }
            // retrieve counter id associated with the counter name
            if (counterName == null)
            {
                ArgumentNullException argNullException = new ArgumentNullException("counterName");
                _tracer.TraceException(argNullException);
                return false;
            }

            try
            {
                int targetCounterId = this._counterNameToIdMapping[counterName];
                return this.UpdateCounterByValue(targetCounterId, stepAmount, isNumerator);
            }
            catch (KeyNotFoundException)
            {
                InvalidOperationException invalidOperationException =
                    new InvalidOperationException(
                    String.Format(
                    CultureInfo.InvariantCulture,
                    "Lookup for counter corresponding to counter name {0} failed",
                    counterName));
                _tracer.TraceException(invalidOperationException);
                return false;
            }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/utils/perfCounters/CounterSetInstanceBase.cs.ifdefed" startline="471" endline="504" pcid="5649">
        public override bool SetCounterValue(string counterName, long counterValue, bool isNumerator)
        {
            if (_Disposed)
            {
                ObjectDisposedException objectDisposedException =
                    new ObjectDisposedException("PSCounterSetInstance");
                _tracer.TraceException(objectDisposedException);
                return false;
            }

            // retrieve counter id associated with the counter name
            if (counterName == null)
            {
                ArgumentNullException argNullException = new ArgumentNullException("counterName");
                _tracer.TraceException(argNullException);
                return false;
            }
            try
            {
                int targetCounterId = this._counterNameToIdMapping[counterName];
                return this.SetCounterValue(targetCounterId, counterValue, isNumerator);
            }
            catch (KeyNotFoundException)
            {
                InvalidOperationException invalidOperationException =
                    new InvalidOperationException(
                    String.Format(
                    CultureInfo.InvariantCulture,
                    "Lookup for counter corresponding to counter name {0} failed",
                    counterName));
                _tracer.TraceException(invalidOperationException);
                return false;
            }
        }
</source>
<source file="PowerShell/src/System.Management.Automation/utils/perfCounters/CounterSetInstanceBase.cs.ifdefed" startline="552" endline="586" pcid="5651">
        public override bool GetCounterValue(string counterName, bool isNumerator, out long counterValue)
        {
            counterValue = -1;
            if (_Disposed)
            {
                ObjectDisposedException objectDisposedException =
                    new ObjectDisposedException("PSCounterSetInstance");
                _tracer.TraceException(objectDisposedException);
                return false;
            }

            // retrieve counter id associated with the counter name
            if (counterName == null)
            {
                ArgumentNullException argNullException = new ArgumentNullException("counterName");
                _tracer.TraceException(argNullException);
                return false;
            }
            try
            {
                int targetCounterId = this._counterNameToIdMapping[counterName];
                return this.GetCounterValue(targetCounterId, isNumerator, out counterValue);
            }
            catch (KeyNotFoundException)
            {
                InvalidOperationException invalidOperationException =
                    new InvalidOperationException(
                        String.Format(
                        CultureInfo.InvariantCulture,
                        "Lookup for counter corresponding to counter name {0} failed",
                        counterName));
                _tracer.TraceException(invalidOperationException);
                return false;
            }
        }
</source>
</class>

<class classid="124" nclones="5" nlines="66" similarity="71">
<source file="PowerShell/test/csharp/test_PSConfiguration.cs.ifdefed" startline="409" endline="505" pcid="5739">
        [Fact]
        public void Utils_GetPolicySetting_BothConfigFilesNotEmpty()
        {
            fixture.SetupConfigFile1();

            ScriptExecution scriptExecution;
            scriptExecution = Utils.GetPolicySetting<ScriptExecution>(Utils.SystemWideOnlyConfig);
            fixture.CompareScriptExecution(scriptExecution, fixture.SystemWidePolicies.ScriptExecution);

            scriptExecution = Utils.GetPolicySetting<ScriptExecution>(Utils.CurrentUserOnlyConfig);
            fixture.CompareScriptExecution(scriptExecution, fixture.CurrentUserPolicies.ScriptExecution);

            scriptExecution = Utils.GetPolicySetting<ScriptExecution>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareScriptExecution(scriptExecution, fixture.SystemWidePolicies.ScriptExecution);

            scriptExecution = Utils.GetPolicySetting<ScriptExecution>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareScriptExecution(scriptExecution, fixture.CurrentUserPolicies.ScriptExecution);

            ScriptBlockLogging scriptBlockLogging;
            scriptBlockLogging = Utils.GetPolicySetting<ScriptBlockLogging>(Utils.SystemWideOnlyConfig);
            fixture.CompareScriptBlockLogging(scriptBlockLogging, fixture.SystemWidePolicies.ScriptBlockLogging);

            scriptBlockLogging = Utils.GetPolicySetting<ScriptBlockLogging>(Utils.CurrentUserOnlyConfig);
            fixture.CompareScriptBlockLogging(scriptBlockLogging, fixture.CurrentUserPolicies.ScriptBlockLogging);

            scriptBlockLogging = Utils.GetPolicySetting<ScriptBlockLogging>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareScriptBlockLogging(scriptBlockLogging, fixture.SystemWidePolicies.ScriptBlockLogging);

            scriptBlockLogging = Utils.GetPolicySetting<ScriptBlockLogging>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareScriptBlockLogging(scriptBlockLogging, fixture.CurrentUserPolicies.ScriptBlockLogging);

            ModuleLogging moduleLogging;
            moduleLogging = Utils.GetPolicySetting<ModuleLogging>(Utils.SystemWideOnlyConfig);
            fixture.CompareModuleLogging(moduleLogging, fixture.SystemWidePolicies.ModuleLogging);

            moduleLogging = Utils.GetPolicySetting<ModuleLogging>(Utils.CurrentUserOnlyConfig);
            fixture.CompareModuleLogging(moduleLogging, fixture.CurrentUserPolicies.ModuleLogging);

            moduleLogging = Utils.GetPolicySetting<ModuleLogging>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareModuleLogging(moduleLogging, fixture.SystemWidePolicies.ModuleLogging);

            moduleLogging = Utils.GetPolicySetting<ModuleLogging>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareModuleLogging(moduleLogging, fixture.CurrentUserPolicies.ModuleLogging);

            ProtectedEventLogging protectedEventLogging;
            protectedEventLogging = Utils.GetPolicySetting<ProtectedEventLogging>(Utils.SystemWideOnlyConfig);
            fixture.CompareProtectedEventLogging(protectedEventLogging, fixture.SystemWidePolicies.ProtectedEventLogging);

            protectedEventLogging = Utils.GetPolicySetting<ProtectedEventLogging>(Utils.CurrentUserOnlyConfig);
            fixture.CompareProtectedEventLogging(protectedEventLogging, fixture.CurrentUserPolicies.ProtectedEventLogging);

            protectedEventLogging = Utils.GetPolicySetting<ProtectedEventLogging>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareProtectedEventLogging(protectedEventLogging, fixture.SystemWidePolicies.ProtectedEventLogging);

            protectedEventLogging = Utils.GetPolicySetting<ProtectedEventLogging>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareProtectedEventLogging(protectedEventLogging, fixture.CurrentUserPolicies.ProtectedEventLogging);

            // The CurrentUser config doesn't contain any settings for 'Transcription', 'UpdatableHelp' and 'ConsoleSessionConfiguration'
            Transcription transcription;
            transcription = Utils.GetPolicySetting<Transcription>(Utils.SystemWideOnlyConfig);
            fixture.CompareTranscription(transcription, fixture.SystemWidePolicies.Transcription);

            transcription = Utils.GetPolicySetting<Transcription>(Utils.CurrentUserOnlyConfig);
            fixture.CompareTranscription(transcription, null);

            transcription = Utils.GetPolicySetting<Transcription>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareTranscription(transcription, fixture.SystemWidePolicies.Transcription);

            transcription = Utils.GetPolicySetting<Transcription>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareTranscription(transcription, fixture.SystemWidePolicies.Transcription);

            UpdatableHelp updatableHelp;
            updatableHelp = Utils.GetPolicySetting<UpdatableHelp>(Utils.SystemWideOnlyConfig);
            fixture.CompareUpdatableHelp(updatableHelp, fixture.SystemWidePolicies.UpdatableHelp);

            updatableHelp = Utils.GetPolicySetting<UpdatableHelp>(Utils.CurrentUserOnlyConfig);
            fixture.CompareUpdatableHelp(updatableHelp, null);

            updatableHelp = Utils.GetPolicySetting<UpdatableHelp>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareUpdatableHelp(updatableHelp, fixture.SystemWidePolicies.UpdatableHelp);

            updatableHelp = Utils.GetPolicySetting<UpdatableHelp>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareUpdatableHelp(updatableHelp, fixture.SystemWidePolicies.UpdatableHelp);

            ConsoleSessionConfiguration consoleSessionConfiguration;
            consoleSessionConfiguration = Utils.GetPolicySetting<ConsoleSessionConfiguration>(Utils.SystemWideOnlyConfig);
            fixture.CompareConsoleSessionConfiguration(consoleSessionConfiguration, fixture.SystemWidePolicies.ConsoleSessionConfiguration);

            consoleSessionConfiguration = Utils.GetPolicySetting<ConsoleSessionConfiguration>(Utils.CurrentUserOnlyConfig);
            fixture.CompareConsoleSessionConfiguration(consoleSessionConfiguration, null);

            consoleSessionConfiguration = Utils.GetPolicySetting<ConsoleSessionConfiguration>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareConsoleSessionConfiguration(consoleSessionConfiguration, fixture.SystemWidePolicies.ConsoleSessionConfiguration);

            consoleSessionConfiguration = Utils.GetPolicySetting<ConsoleSessionConfiguration>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareConsoleSessionConfiguration(consoleSessionConfiguration, fixture.SystemWidePolicies.ConsoleSessionConfiguration);
        }
</source>
<source file="PowerShell/test/csharp/test_PSConfiguration.cs.ifdefed" startline="605" endline="702" pcid="5741">
        [Fact]
        public void Utils_GetPolicySetting_EmptySystemConfig()
        {
            fixture.SetupConfigFile3();

            // The SystemWide config is empty
            ScriptExecution scriptExecution;
            scriptExecution = Utils.GetPolicySetting<ScriptExecution>(Utils.SystemWideOnlyConfig);
            fixture.CompareScriptExecution(scriptExecution, null);

            scriptExecution = Utils.GetPolicySetting<ScriptExecution>(Utils.CurrentUserOnlyConfig);
            fixture.CompareScriptExecution(scriptExecution, fixture.CurrentUserPolicies.ScriptExecution);

            scriptExecution = Utils.GetPolicySetting<ScriptExecution>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareScriptExecution(scriptExecution, fixture.CurrentUserPolicies.ScriptExecution);

            scriptExecution = Utils.GetPolicySetting<ScriptExecution>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareScriptExecution(scriptExecution, fixture.CurrentUserPolicies.ScriptExecution);

            ScriptBlockLogging scriptBlockLogging;
            scriptBlockLogging = Utils.GetPolicySetting<ScriptBlockLogging>(Utils.SystemWideOnlyConfig);
            fixture.CompareScriptBlockLogging(scriptBlockLogging, null);

            scriptBlockLogging = Utils.GetPolicySetting<ScriptBlockLogging>(Utils.CurrentUserOnlyConfig);
            fixture.CompareScriptBlockLogging(scriptBlockLogging, fixture.CurrentUserPolicies.ScriptBlockLogging);

            scriptBlockLogging = Utils.GetPolicySetting<ScriptBlockLogging>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareScriptBlockLogging(scriptBlockLogging, fixture.CurrentUserPolicies.ScriptBlockLogging);

            scriptBlockLogging = Utils.GetPolicySetting<ScriptBlockLogging>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareScriptBlockLogging(scriptBlockLogging, fixture.CurrentUserPolicies.ScriptBlockLogging);

            ModuleLogging moduleLogging;
            moduleLogging = Utils.GetPolicySetting<ModuleLogging>(Utils.SystemWideOnlyConfig);
            fixture.CompareModuleLogging(moduleLogging, null);

            moduleLogging = Utils.GetPolicySetting<ModuleLogging>(Utils.CurrentUserOnlyConfig);
            fixture.CompareModuleLogging(moduleLogging, fixture.CurrentUserPolicies.ModuleLogging);

            moduleLogging = Utils.GetPolicySetting<ModuleLogging>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareModuleLogging(moduleLogging, fixture.CurrentUserPolicies.ModuleLogging);

            moduleLogging = Utils.GetPolicySetting<ModuleLogging>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareModuleLogging(moduleLogging, fixture.CurrentUserPolicies.ModuleLogging);

            ProtectedEventLogging protectedEventLogging;
            protectedEventLogging = Utils.GetPolicySetting<ProtectedEventLogging>(Utils.SystemWideOnlyConfig);
            fixture.CompareProtectedEventLogging(protectedEventLogging, null);

            protectedEventLogging = Utils.GetPolicySetting<ProtectedEventLogging>(Utils.CurrentUserOnlyConfig);
            fixture.CompareProtectedEventLogging(protectedEventLogging, fixture.CurrentUserPolicies.ProtectedEventLogging);

            protectedEventLogging = Utils.GetPolicySetting<ProtectedEventLogging>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareProtectedEventLogging(protectedEventLogging, fixture.CurrentUserPolicies.ProtectedEventLogging);

            protectedEventLogging = Utils.GetPolicySetting<ProtectedEventLogging>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareProtectedEventLogging(protectedEventLogging, fixture.CurrentUserPolicies.ProtectedEventLogging);

            // The CurrentUser config doesn't contain any settings for 'Transcription', 'UpdatableHelp' and 'ConsoleSessionConfiguration'
            Transcription transcription;
            transcription = Utils.GetPolicySetting<Transcription>(Utils.SystemWideOnlyConfig);
            fixture.CompareTranscription(transcription, null);

            transcription = Utils.GetPolicySetting<Transcription>(Utils.CurrentUserOnlyConfig);
            fixture.CompareTranscription(transcription, null);

            transcription = Utils.GetPolicySetting<Transcription>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareTranscription(transcription, null);

            transcription = Utils.GetPolicySetting<Transcription>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareTranscription(transcription, null);

            UpdatableHelp updatableHelp;
            updatableHelp = Utils.GetPolicySetting<UpdatableHelp>(Utils.SystemWideOnlyConfig);
            fixture.CompareUpdatableHelp(updatableHelp, null);

            updatableHelp = Utils.GetPolicySetting<UpdatableHelp>(Utils.CurrentUserOnlyConfig);
            fixture.CompareUpdatableHelp(updatableHelp, null);

            updatableHelp = Utils.GetPolicySetting<UpdatableHelp>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareUpdatableHelp(updatableHelp, null);

            updatableHelp = Utils.GetPolicySetting<UpdatableHelp>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareUpdatableHelp(updatableHelp, null);

            ConsoleSessionConfiguration consoleSessionConfiguration;
            consoleSessionConfiguration = Utils.GetPolicySetting<ConsoleSessionConfiguration>(Utils.SystemWideOnlyConfig);
            fixture.CompareConsoleSessionConfiguration(consoleSessionConfiguration, null);

            consoleSessionConfiguration = Utils.GetPolicySetting<ConsoleSessionConfiguration>(Utils.CurrentUserOnlyConfig);
            fixture.CompareConsoleSessionConfiguration(consoleSessionConfiguration, null);

            consoleSessionConfiguration = Utils.GetPolicySetting<ConsoleSessionConfiguration>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareConsoleSessionConfiguration(consoleSessionConfiguration, null);

            consoleSessionConfiguration = Utils.GetPolicySetting<ConsoleSessionConfiguration>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareConsoleSessionConfiguration(consoleSessionConfiguration, null);
        }
</source>
<source file="PowerShell/test/csharp/test_PSConfiguration.cs.ifdefed" startline="507" endline="603" pcid="5740">
        [Fact]
        public void Utils_GetPolicySetting_EmptyUserConfig()
        {
            fixture.SetupConfigFile2();

            // The CurrentUser config is empty
            ScriptExecution scriptExecution;
            scriptExecution = Utils.GetPolicySetting<ScriptExecution>(Utils.SystemWideOnlyConfig);
            fixture.CompareScriptExecution(scriptExecution, fixture.SystemWidePolicies.ScriptExecution);

            scriptExecution = Utils.GetPolicySetting<ScriptExecution>(Utils.CurrentUserOnlyConfig);
            fixture.CompareScriptExecution(scriptExecution, null);

            scriptExecution = Utils.GetPolicySetting<ScriptExecution>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareScriptExecution(scriptExecution, fixture.SystemWidePolicies.ScriptExecution);

            scriptExecution = Utils.GetPolicySetting<ScriptExecution>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareScriptExecution(scriptExecution, fixture.SystemWidePolicies.ScriptExecution);

            ScriptBlockLogging scriptBlockLogging;
            scriptBlockLogging = Utils.GetPolicySetting<ScriptBlockLogging>(Utils.SystemWideOnlyConfig);
            fixture.CompareScriptBlockLogging(scriptBlockLogging, fixture.SystemWidePolicies.ScriptBlockLogging);

            scriptBlockLogging = Utils.GetPolicySetting<ScriptBlockLogging>(Utils.CurrentUserOnlyConfig);
            fixture.CompareScriptBlockLogging(scriptBlockLogging, null);

            scriptBlockLogging = Utils.GetPolicySetting<ScriptBlockLogging>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareScriptBlockLogging(scriptBlockLogging, fixture.SystemWidePolicies.ScriptBlockLogging);

            scriptBlockLogging = Utils.GetPolicySetting<ScriptBlockLogging>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareScriptBlockLogging(scriptBlockLogging, fixture.SystemWidePolicies.ScriptBlockLogging);

            ModuleLogging moduleLogging;
            moduleLogging = Utils.GetPolicySetting<ModuleLogging>(Utils.SystemWideOnlyConfig);
            fixture.CompareModuleLogging(moduleLogging, fixture.SystemWidePolicies.ModuleLogging);

            moduleLogging = Utils.GetPolicySetting<ModuleLogging>(Utils.CurrentUserOnlyConfig);
            fixture.CompareModuleLogging(moduleLogging, null);

            moduleLogging = Utils.GetPolicySetting<ModuleLogging>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareModuleLogging(moduleLogging, fixture.SystemWidePolicies.ModuleLogging);

            moduleLogging = Utils.GetPolicySetting<ModuleLogging>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareModuleLogging(moduleLogging, fixture.SystemWidePolicies.ModuleLogging);

            ProtectedEventLogging protectedEventLogging;
            protectedEventLogging = Utils.GetPolicySetting<ProtectedEventLogging>(Utils.SystemWideOnlyConfig);
            fixture.CompareProtectedEventLogging(protectedEventLogging, fixture.SystemWidePolicies.ProtectedEventLogging);

            protectedEventLogging = Utils.GetPolicySetting<ProtectedEventLogging>(Utils.CurrentUserOnlyConfig);
            fixture.CompareProtectedEventLogging(protectedEventLogging, null);

            protectedEventLogging = Utils.GetPolicySetting<ProtectedEventLogging>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareProtectedEventLogging(protectedEventLogging, fixture.SystemWidePolicies.ProtectedEventLogging);

            protectedEventLogging = Utils.GetPolicySetting<ProtectedEventLogging>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareProtectedEventLogging(protectedEventLogging, fixture.SystemWidePolicies.ProtectedEventLogging);

            Transcription transcription;
            transcription = Utils.GetPolicySetting<Transcription>(Utils.SystemWideOnlyConfig);
            fixture.CompareTranscription(transcription, fixture.SystemWidePolicies.Transcription);

            transcription = Utils.GetPolicySetting<Transcription>(Utils.CurrentUserOnlyConfig);
            fixture.CompareTranscription(transcription, null);

            transcription = Utils.GetPolicySetting<Transcription>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareTranscription(transcription, fixture.SystemWidePolicies.Transcription);

            transcription = Utils.GetPolicySetting<Transcription>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareTranscription(transcription, fixture.SystemWidePolicies.Transcription);

            UpdatableHelp updatableHelp;
            updatableHelp = Utils.GetPolicySetting<UpdatableHelp>(Utils.SystemWideOnlyConfig);
            fixture.CompareUpdatableHelp(updatableHelp, fixture.SystemWidePolicies.UpdatableHelp);

            updatableHelp = Utils.GetPolicySetting<UpdatableHelp>(Utils.CurrentUserOnlyConfig);
            fixture.CompareUpdatableHelp(updatableHelp, null);

            updatableHelp = Utils.GetPolicySetting<UpdatableHelp>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareUpdatableHelp(updatableHelp, fixture.SystemWidePolicies.UpdatableHelp);

            updatableHelp = Utils.GetPolicySetting<UpdatableHelp>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareUpdatableHelp(updatableHelp, fixture.SystemWidePolicies.UpdatableHelp);

            ConsoleSessionConfiguration consoleSessionConfiguration;
            consoleSessionConfiguration = Utils.GetPolicySetting<ConsoleSessionConfiguration>(Utils.SystemWideOnlyConfig);
            fixture.CompareConsoleSessionConfiguration(consoleSessionConfiguration, fixture.SystemWidePolicies.ConsoleSessionConfiguration);

            consoleSessionConfiguration = Utils.GetPolicySetting<ConsoleSessionConfiguration>(Utils.CurrentUserOnlyConfig);
            fixture.CompareConsoleSessionConfiguration(consoleSessionConfiguration, null);

            consoleSessionConfiguration = Utils.GetPolicySetting<ConsoleSessionConfiguration>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareConsoleSessionConfiguration(consoleSessionConfiguration, fixture.SystemWidePolicies.ConsoleSessionConfiguration);

            consoleSessionConfiguration = Utils.GetPolicySetting<ConsoleSessionConfiguration>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareConsoleSessionConfiguration(consoleSessionConfiguration, fixture.SystemWidePolicies.ConsoleSessionConfiguration);
        }
</source>
<source file="PowerShell/test/csharp/test_PSConfiguration.cs.ifdefed" startline="704" endline="801" pcid="5742">
        [Fact]
        public void Utils_GetPolicySetting_BothConfigFilesEmpty()
        {
            fixture.SetupConfigFile4();

            // Both config files are empty
            ScriptExecution scriptExecution;
            scriptExecution = Utils.GetPolicySetting<ScriptExecution>(Utils.SystemWideOnlyConfig);
            fixture.CompareScriptExecution(scriptExecution, null);

            scriptExecution = Utils.GetPolicySetting<ScriptExecution>(Utils.CurrentUserOnlyConfig);
            fixture.CompareScriptExecution(scriptExecution, null);

            scriptExecution = Utils.GetPolicySetting<ScriptExecution>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareScriptExecution(scriptExecution, null);

            scriptExecution = Utils.GetPolicySetting<ScriptExecution>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareScriptExecution(scriptExecution, null);

            ScriptBlockLogging scriptBlockLogging;
            scriptBlockLogging = Utils.GetPolicySetting<ScriptBlockLogging>(Utils.SystemWideOnlyConfig);
            fixture.CompareScriptBlockLogging(scriptBlockLogging, null);

            scriptBlockLogging = Utils.GetPolicySetting<ScriptBlockLogging>(Utils.CurrentUserOnlyConfig);
            fixture.CompareScriptBlockLogging(scriptBlockLogging, null);

            scriptBlockLogging = Utils.GetPolicySetting<ScriptBlockLogging>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareScriptBlockLogging(scriptBlockLogging, null);

            scriptBlockLogging = Utils.GetPolicySetting<ScriptBlockLogging>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareScriptBlockLogging(scriptBlockLogging, null);

            ModuleLogging moduleLogging;
            moduleLogging = Utils.GetPolicySetting<ModuleLogging>(Utils.SystemWideOnlyConfig);
            fixture.CompareModuleLogging(moduleLogging, null);

            moduleLogging = Utils.GetPolicySetting<ModuleLogging>(Utils.CurrentUserOnlyConfig);
            fixture.CompareModuleLogging(moduleLogging, null);

            moduleLogging = Utils.GetPolicySetting<ModuleLogging>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareModuleLogging(moduleLogging, null);

            moduleLogging = Utils.GetPolicySetting<ModuleLogging>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareModuleLogging(moduleLogging, null);

            ProtectedEventLogging protectedEventLogging;
            protectedEventLogging = Utils.GetPolicySetting<ProtectedEventLogging>(Utils.SystemWideOnlyConfig);
            fixture.CompareProtectedEventLogging(protectedEventLogging, null);

            protectedEventLogging = Utils.GetPolicySetting<ProtectedEventLogging>(Utils.CurrentUserOnlyConfig);
            fixture.CompareProtectedEventLogging(protectedEventLogging, null);

            protectedEventLogging = Utils.GetPolicySetting<ProtectedEventLogging>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareProtectedEventLogging(protectedEventLogging, null);

            protectedEventLogging = Utils.GetPolicySetting<ProtectedEventLogging>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareProtectedEventLogging(protectedEventLogging, null);

            // The CurrentUser config doesn't contain any settings for 'Transcription', 'UpdatableHelp' and 'ConsoleSessionConfiguration'
            Transcription transcription;
            transcription = Utils.GetPolicySetting<Transcription>(Utils.SystemWideOnlyConfig);
            fixture.CompareTranscription(transcription, null);

            transcription = Utils.GetPolicySetting<Transcription>(Utils.CurrentUserOnlyConfig);
            fixture.CompareTranscription(transcription, null);

            transcription = Utils.GetPolicySetting<Transcription>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareTranscription(transcription, null);

            transcription = Utils.GetPolicySetting<Transcription>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareTranscription(transcription, null);

            UpdatableHelp updatableHelp;
            updatableHelp = Utils.GetPolicySetting<UpdatableHelp>(Utils.SystemWideOnlyConfig);
            fixture.CompareUpdatableHelp(updatableHelp, null);

            updatableHelp = Utils.GetPolicySetting<UpdatableHelp>(Utils.CurrentUserOnlyConfig);
            fixture.CompareUpdatableHelp(updatableHelp, null);

            updatableHelp = Utils.GetPolicySetting<UpdatableHelp>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareUpdatableHelp(updatableHelp, null);

            updatableHelp = Utils.GetPolicySetting<UpdatableHelp>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareUpdatableHelp(updatableHelp, null);

            ConsoleSessionConfiguration consoleSessionConfiguration;
            consoleSessionConfiguration = Utils.GetPolicySetting<ConsoleSessionConfiguration>(Utils.SystemWideOnlyConfig);
            fixture.CompareConsoleSessionConfiguration(consoleSessionConfiguration, null);

            consoleSessionConfiguration = Utils.GetPolicySetting<ConsoleSessionConfiguration>(Utils.CurrentUserOnlyConfig);
            fixture.CompareConsoleSessionConfiguration(consoleSessionConfiguration, null);

            consoleSessionConfiguration = Utils.GetPolicySetting<ConsoleSessionConfiguration>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareConsoleSessionConfiguration(consoleSessionConfiguration, null);

            consoleSessionConfiguration = Utils.GetPolicySetting<ConsoleSessionConfiguration>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareConsoleSessionConfiguration(consoleSessionConfiguration, null);
        }
</source>
<source file="PowerShell/test/csharp/test_PSConfiguration.cs.ifdefed" startline="803" endline="900" pcid="5743">
        [Fact]
        public void Utils_GetPolicySetting_BothConfigFilesNotExist()
        {
            fixture.CleanupConfigFiles();

            // Both config files don't exist
            ScriptExecution scriptExecution;
            scriptExecution = Utils.GetPolicySetting<ScriptExecution>(Utils.SystemWideOnlyConfig);
            fixture.CompareScriptExecution(scriptExecution, null);

            scriptExecution = Utils.GetPolicySetting<ScriptExecution>(Utils.CurrentUserOnlyConfig);
            fixture.CompareScriptExecution(scriptExecution, null);

            scriptExecution = Utils.GetPolicySetting<ScriptExecution>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareScriptExecution(scriptExecution, null);

            scriptExecution = Utils.GetPolicySetting<ScriptExecution>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareScriptExecution(scriptExecution, null);

            ScriptBlockLogging scriptBlockLogging;
            scriptBlockLogging = Utils.GetPolicySetting<ScriptBlockLogging>(Utils.SystemWideOnlyConfig);
            fixture.CompareScriptBlockLogging(scriptBlockLogging, null);

            scriptBlockLogging = Utils.GetPolicySetting<ScriptBlockLogging>(Utils.CurrentUserOnlyConfig);
            fixture.CompareScriptBlockLogging(scriptBlockLogging, null);

            scriptBlockLogging = Utils.GetPolicySetting<ScriptBlockLogging>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareScriptBlockLogging(scriptBlockLogging, null);

            scriptBlockLogging = Utils.GetPolicySetting<ScriptBlockLogging>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareScriptBlockLogging(scriptBlockLogging, null);

            ModuleLogging moduleLogging;
            moduleLogging = Utils.GetPolicySetting<ModuleLogging>(Utils.SystemWideOnlyConfig);
            fixture.CompareModuleLogging(moduleLogging, null);

            moduleLogging = Utils.GetPolicySetting<ModuleLogging>(Utils.CurrentUserOnlyConfig);
            fixture.CompareModuleLogging(moduleLogging, null);

            moduleLogging = Utils.GetPolicySetting<ModuleLogging>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareModuleLogging(moduleLogging, null);

            moduleLogging = Utils.GetPolicySetting<ModuleLogging>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareModuleLogging(moduleLogging, null);

            ProtectedEventLogging protectedEventLogging;
            protectedEventLogging = Utils.GetPolicySetting<ProtectedEventLogging>(Utils.SystemWideOnlyConfig);
            fixture.CompareProtectedEventLogging(protectedEventLogging, null);

            protectedEventLogging = Utils.GetPolicySetting<ProtectedEventLogging>(Utils.CurrentUserOnlyConfig);
            fixture.CompareProtectedEventLogging(protectedEventLogging, null);

            protectedEventLogging = Utils.GetPolicySetting<ProtectedEventLogging>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareProtectedEventLogging(protectedEventLogging, null);

            protectedEventLogging = Utils.GetPolicySetting<ProtectedEventLogging>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareProtectedEventLogging(protectedEventLogging, null);

            // The CurrentUser config doesn't contain any settings for 'Transcription', 'UpdatableHelp' and 'ConsoleSessionConfiguration'
            Transcription transcription;
            transcription = Utils.GetPolicySetting<Transcription>(Utils.SystemWideOnlyConfig);
            fixture.CompareTranscription(transcription, null);

            transcription = Utils.GetPolicySetting<Transcription>(Utils.CurrentUserOnlyConfig);
            fixture.CompareTranscription(transcription, null);

            transcription = Utils.GetPolicySetting<Transcription>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareTranscription(transcription, null);

            transcription = Utils.GetPolicySetting<Transcription>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareTranscription(transcription, null);

            UpdatableHelp updatableHelp;
            updatableHelp = Utils.GetPolicySetting<UpdatableHelp>(Utils.SystemWideOnlyConfig);
            fixture.CompareUpdatableHelp(updatableHelp, null);

            updatableHelp = Utils.GetPolicySetting<UpdatableHelp>(Utils.CurrentUserOnlyConfig);
            fixture.CompareUpdatableHelp(updatableHelp, null);

            updatableHelp = Utils.GetPolicySetting<UpdatableHelp>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareUpdatableHelp(updatableHelp, null);

            updatableHelp = Utils.GetPolicySetting<UpdatableHelp>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareUpdatableHelp(updatableHelp, null);

            ConsoleSessionConfiguration consoleSessionConfiguration;
            consoleSessionConfiguration = Utils.GetPolicySetting<ConsoleSessionConfiguration>(Utils.SystemWideOnlyConfig);
            fixture.CompareConsoleSessionConfiguration(consoleSessionConfiguration, null);

            consoleSessionConfiguration = Utils.GetPolicySetting<ConsoleSessionConfiguration>(Utils.CurrentUserOnlyConfig);
            fixture.CompareConsoleSessionConfiguration(consoleSessionConfiguration, null);

            consoleSessionConfiguration = Utils.GetPolicySetting<ConsoleSessionConfiguration>(Utils.SystemWideThenCurrentUserConfig);
            fixture.CompareConsoleSessionConfiguration(consoleSessionConfiguration, null);

            consoleSessionConfiguration = Utils.GetPolicySetting<ConsoleSessionConfiguration>(Utils.CurrentUserThenSystemWideConfig);
            fixture.CompareConsoleSessionConfiguration(consoleSessionConfiguration, null);
        }
</source>
</class>

</clones>
