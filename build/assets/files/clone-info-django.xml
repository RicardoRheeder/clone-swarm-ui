<clones>
<systeminfo processor="nicad3" system="django" granularity="blocks" threshold="30%" minlines="10" maxlines="2500"/>
<cloneinfo npcs="28384" npairs="9986"/>
<runinfo ncompares="11355361" cputime="7218"/>
<classinfo nclasses="470"/>

<class classid="1" nclones="24" nlines="14" similarity="71">
<source file="django/django/apps/config.py.pyindent" startline="105" endline="115" pcid="17">
            try:
                # If this works, the app module specifies an app config class.
                entry = module.default_app_config
            except AttributeError:
                # Otherwise, it simply uses the default app config class.
                return cls(entry, module)
            else:
                mod_path, _, cls_name = entry.rpartition('.')

        # If we're reaching this point, we must attempt to load the app config
        # class located at <mod_path>.<cls_name>
</source>
<source file="django/django/urls/base.py.pyindent" startline="177" endline="182" pcid="7003">
            try:
                url = reverse(to_be_reversed, args=match.args, kwargs=match.kwargs)
            except NoReverseMatch:
                pass
            else:
                url = urlunsplit((parsed.scheme, parsed.netloc, url, parsed.query, parsed.fragment))
</source>
<source file="django/tests/serializers/test_yaml.py.pyindent" startline="124" endline="130" pcid="23429">
        try:
            yaml.safe_load(StringIO(serial_str))
        except Exception:
            return False
        else:
            return True

</source>
<source file="django/tests/serializers/test_xml.py.pyindent" startline="34" endline="40" pcid="23398">
        try:
            minidom.parseString(serial_str)
        except Exception:
            return False
        else:
            return True

</source>
<source file="django/tests/serializers/test_json.py.pyindent" startline="49" endline="55" pcid="23336">
        try:
            json.loads(serial_str)
        except Exception:
            return False
        else:
            return True

</source>
<source file="django/django/db/migrations/writer.py.pyindent" startline="246" endline="251" pcid="5373">
                try:
                    base_dir = module_dir(base_module)
                except ValueError:
                    continue
                else:
                    break
</source>
<source file="django/django/utils/text.py.pyindent" startline="193" endline="201" pcid="7685">
                # Check for match in open tags list
                try:
                    i = open_tags.index(tagname)
                except ValueError:
                    pass
                else:
                    # SGML: An end tag closes, back to the matching start tag,
                    # all unclosed intervening start tags with omitted end tags
                    open_tags = open_tags[i + 1:]
</source>
<source file="django/django/template/defaultfilters.py.pyindent" startline="466" endline="490" pcid="6389">
    """
    When arg is convertible to float, behave like operator.itemgetter(arg)
    Otherwise, behave like Variable(arg).resolve

    >>> _property_resolver(1)('abc')
    'b'
    >>> _property_resolver('1')('abc')
    Traceback (most recent call last):
    ...
    TypeError: string indices must be integers
    >>> class Foo:
    ...     a = 42
    ...     b = 3.14
    ...     c = 'Hey!'
    >>> _property_resolver('b')(Foo())
    3.14
    """
    try:
        float(arg)
    except ValueError:
        return Variable(arg).resolve
    else:
        return itemgetter(arg)


</source>
<source file="django/django/template/smartif.py.pyindent" startline="174" endline="180" pcid="6662">
        try:
            op = OPERATORS[token]
        except (KeyError, TypeError):
            return self.create_var(token)
        else:
            return op()

</source>
<source file="django/tests/get_or_create/tests.py.pyindent" startline="243" endline="255" pcid="16067">
        """
        Regression test for #15117. Requires a TransactionTestCase on
        databases that delay integrity checks until the end of transactions,
        otherwise the exception is never raised.
        """
        try:
            Profile.objects.get_or_create(person=Person(id=1))
        except IntegrityError:
            pass
        else:
            self.skipTest("This backend does not support integrity checks.")


</source>
<source file="django/django/core/handlers/wsgi.py.pyindent" startline="84" endline="89" pcid="4097">
            try:
                codecs.lookup(self.content_params['charset'])
            except LookupError:
                pass
            else:
                self.encoding = self.content_params['charset']
</source>
<source file="django/django/contrib/auth/management/commands/createsuperuser.py.pyindent" startline="200" endline="205" pcid="516">
            try:
                self.UserModel._default_manager.db_manager(database).get_by_natural_key(username)
            except self.UserModel.DoesNotExist:
                pass
            else:
                return 'Error: That %s is already taken.' % verbose_field_name
</source>
<source file="django/tests/user_commands/management/commands/common_args.py.pyindent" startline="8" endline="14" pcid="27585">
        try:
            parser.add_argument('--version', action='version', version='A.B.C')
        except ArgumentError:
            pass
        else:
            raise CommandError('--version argument does no yet exist')

</source>
<source file="django/django/contrib/sites/managers.py.pyindent" startline="51" endline="56" pcid="3162">
            try:
                self.model._meta.get_field('site')
            except FieldDoesNotExist:
                self.__field_name = 'sites'
            else:
                self.__field_name = 'site'
</source>
<source file="django/django/contrib/auth/management/__init__.py.pyindent" startline="141" endline="146" pcid="544">
        try:
            auth_app.User._default_manager.get(username=default_username)
        except auth_app.User.DoesNotExist:
            pass
        else:
            return ''
</source>
<source file="django/tests/urlpatterns_reverse/tests.py.pyindent" startline="282" endline="288" pcid="27339">
                try:
                    got = reverse(name, args=args, kwargs=kwargs)
                except NoReverseMatch:
                    self.assertEqual(NoReverseMatch, expected)
                else:
                    self.assertEqual(got, expected)

</source>
<source file="django/django/dispatch/dispatcher.py.pyindent" startline="206" endline="211" pcid="6017">
            try:
                response = receiver(signal=self, sender=sender, **named)
            except Exception as err:
                responses.append((receiver, err))
            else:
                responses.append((receiver, response))
</source>
<source file="django/django/contrib/staticfiles/checks.py.pyindent" startline="8" endline="13" pcid="3207">
        try:
            finder_errors = finder.check()
        except NotImplementedError:
            pass
        else:
            errors.extend(finder_errors)
</source>
<source file="django/django/test/runner.py.pyindent" startline="613" endline="627" pcid="6941">
    """
    Check if a test label points to a python package or file directory.

    Relative labels like "." and ".." are seen as directories.
    """
    try:
        mod = import_module(label)
    except (ImportError, TypeError):
        pass
    else:
        return hasattr(mod, '__path__')

    return os.path.isdir(os.path.abspath(label))


</source>
<source file="django/tests/gis_tests/gdal_tests/test_srs.py.pyindent" startline="159" endline="166" pcid="16377">
            try:
                srs = SpatialReference(bad)
                srs.validate()
            except (SRSException, GDALException):
                pass
            else:
                self.fail('Should not have initialized on bad WKT "%s"!')

</source>
<source file="django/django/utils/itercompat.py.pyindent" startline="2" endline="8" pcid="7325">
    "An implementation independent way of checking for iterables"
    try:
        iter(x)
    except TypeError:
        return False
    else:
        return True
</source>
<source file="django/django/contrib/contenttypes/views.py.pyindent" startline="74" endline="83" pcid="769">
                    try:
                        site = getattr(obj, field.name)
                    except Site.DoesNotExist:
                        continue
                    if site is not None:
                        object_domain = site.domain
                        break

    # If all that malarkey found an object domain, use it. Otherwise, fall back
    # to whatever get_absolute_url() returned.
</source>
<source file="django/tests/admin_views/admin.py.pyindent" startline="625" endline="634" pcid="9760">
        queryset, use_distinct = super().get_search_results(request, queryset, search_term)
        try:
            search_term_as_int = int(search_term)
        except ValueError:
            pass
        else:
            queryset |= self.model.objects.filter(age=search_term_as_int)
        return queryset, use_distinct


</source>
<source file="django/django/contrib/auth/base_user.py.pyindent" startline="20" endline="31" pcid="368">
        """
        Normalize the email address by lowercasing the domain part of it.
        """
        email = email or ''
        try:
            email_name, domain_part = email.strip().rsplit('@', 1)
        except ValueError:
            pass
        else:
            email = email_name + '@' + domain_part.lower()
        return email

</source>
</class>

<class classid="2" nclones="218" nlines="10" similarity="70">
<source file="django/django/apps/config.py.pyindent" startline="120" endline="128" pcid="22">
            if module is None:
                # If importing as an app module failed, that error probably
                # contains the most informative traceback. Trigger it again.
                import_module(entry)
            else:
                raise

        # Check for obvious errors. (This check prevents duck typing, but
        # it could be removed if it became a problem in practice.)
</source>
<source file="django/django/core/management/commands/compilemessages.py.pyindent" startline="143" endline="146" pcid="4250">
                        if errors:
                            self.stderr.write("Execution of %s failed: %s" % (self.program, errors))
                        else:
                            self.stderr.write("Execution of %s failed" % self.program)
</source>
<source file="django/django/utils/translation/template.py.pyindent" startline="70" endline="73" pcid="7801">
                    if translators_comment_start is not None and lineno >= translators_comment_start:
                        out.write(' # %s' % line)
                    else:
                        out.write(' #\n')
</source>
<source file="django/django/db/models/lookups.py.pyindent" startline="215" endline="221" pcid="5809">
        if self.rhs_is_direct_value():
            # rhs should be an iterable of values. Use batch_process_rhs()
            # to prepare/transform those values.
            return self.batch_process_rhs(compiler, connection)
        else:
            return super().process_rhs(compiler, connection)

</source>
<source file="django/django/core/management/commands/squashmigrations.py.pyindent" startline="123" endline="126" pcid="4471">
                    if settings.AUTH_USER_MODEL == dependency.setting:
                        dependencies.add(("__setting__", "AUTH_USER_MODEL"))
                    else:
                        dependencies.add(dependency)
</source>
<source file="django/django/test/html.py.pyindent" startline="112" endline="115" pcid="6812">
            if value:
                output += ' %s="%s"' % (key, value)
            else:
                output += ' %s' % key
</source>
<source file="django/django/forms/formsets.py.pyindent" startline="379" endline="387" pcid="6119">
        """
        Return True if the formset needs to be multipart, i.e. it
        has FileInput, or False otherwise.
        """
        if self.forms:
            return self.forms[0].is_multipart()
        else:
            return self.empty_form.is_multipart()

</source>
<source file="django/django/core/management/commands/inspectdb.py.pyindent" startline="178" endline="182" pcid="4319">
            if new_name.endswith('_id'):
                new_name = new_name[:-3]
            else:
                field_params['db_column'] = col_name

</source>
<source file="django/django/utils/timezone.py.pyindent" startline="225" endline="237" pcid="7779">
    """
    Return an aware or naive datetime.datetime, depending on settings.USE_TZ.
    """
    if settings.USE_TZ:
        # timeit shows that datetime.now(tz=utc) is 24% slower
        return datetime.utcnow().replace(tzinfo=utc)
    else:
        return datetime.now()


# By design, these four functions don't perform any checks on their arguments.
# The caller should ensure that they don't receive an invalid value like None.

</source>
<source file="django/django/utils/timezone.py.pyindent" startline="163" endline="170" pcid="7770">
        if self.old_timezone is None:
            deactivate()
        else:
            _active.value = self.old_timezone


# Templates

</source>
<source file="django/django/views/generic/dates.py.pyindent" startline="716" endline="720" pcid="8271">
    """Return the current date in the current time zone."""
    if settings.USE_TZ:
        return timezone.localdate()
    else:
        return datetime.date.today()
</source>
<source file="django/django/views/generic/base.py.pyindent" startline="181" endline="184" pcid="8131">
            if self.permanent:
                return HttpResponsePermanentRedirect(url)
            else:
                return HttpResponseRedirect(url)
</source>
<source file="django/django/core/files/images.py.pyindent" startline="77" endline="80" pcid="3845">
        if close:
            file.close()
        else:
            file.seek(file_pos)
</source>
<source file="django/django/core/files/images.py.pyindent" startline="61" endline="66" pcid="3840">
                # ignore zlib complaining on truncated stream, just feed more
                # data to parser (ticket #19457).
                if e.args[0].startswith("Error -5"):
                    pass
                else:
                    raise
</source>
<source file="django/scripts/manage_translations.py.pyindent" startline="63" endline="69" pcid="8482">
    """ Return the Transifex resource name """
    if name == 'core':
        return "django.core"
    else:
        return "django.contrib-%s" % name


</source>
<source file="django/tests/admin_ordering/models.py.pyindent" startline="36" endline="39" pcid="9140">
        if request.user.is_superuser:
            return ['rank']
        else:
            return ['name']
</source>
<source file="django/tests/admin_views/admin.py.pyindent" startline="466" endline="470" pcid="9723">
        if instance.pk:
            return "%d amount of cool." % instance.pk
        else:
            return "Unknown coolness."

</source>
<source file="django/django/core/cache/backends/db.py.pyindent" startline="161" endline="165" pcid="3526">
                            if func_supports_parameter(converter, 'context'):  # RemovedInDjango30Warning
                                current_expires = converter(current_expires, expression, connection, {})
                            else:
                                current_expires = converter(current_expires, expression, connection)

</source>
<source file="django/django/core/cache/backends/db.py.pyindent" startline="78" endline="82" pcid="3509">
            if func_supports_parameter(converter, 'context'):  # RemovedInDjango30Warning
                expires = converter(expires, expression, connection, {})
            else:
                expires = converter(expires, expression, connection)

</source>
<source file="django/django/core/cache/backends/base.py.pyindent" startline="43" endline="46" pcid="3452">
        if callable(key_func):
            return key_func
        else:
            return import_string(key_func)
</source>
<source file="django/django/dispatch/dispatcher.py.pyindent" startline="246" endline="250" pcid="6030">
                    if not receivers:
                        self.sender_receivers_cache[sender] = NO_RECEIVERS
                    else:
                        # Note, we must cache the weakref versions.
                        self.sender_receivers_cache[sender] = receivers
</source>
<source file="django/django/db/models/lookups.py.pyindent" startline="61" endline="65" pcid="5768">
        if len(new_exprs) == 1:
            self.lhs = new_exprs[0]
        else:
            self.lhs, self.rhs = new_exprs

</source>
<source file="django/django/contrib/staticfiles/management/commands/collectstatic.py.pyindent" startline="237" endline="241" pcid="3340">
                    if not os.path.exists(full_path) and os.path.lexists(full_path):
                        # Delete broken symlinks
                        os.unlink(full_path)
                    else:
                        self.storage.delete(fpath)
</source>
<source file="django/tests/bash_completion/tests.py.pyindent" startline="25" endline="29" pcid="11302">
        if self.old_DJANGO_AUTO_COMPLETE:
            os.environ['DJANGO_AUTO_COMPLETE'] = self.old_DJANGO_AUTO_COMPLETE
        else:
            del os.environ['DJANGO_AUTO_COMPLETE']

</source>
<source file="django/django/core/files/uploadhandler.py.pyindent" startline="40" endline="45" pcid="4003">
        if self.connection_reset:
            return 'StopUpload: Halt current upload.'
        else:
            return 'StopUpload: Consume request data, then halt.'


</source>
<source file="django/django/template/response.py.pyindent" startline="87" endline="96" pcid="6616">
        """Add a new post-rendering callback.

        If the response has already been rendered,
        invoke the callback immediately.
        """
        if self._is_rendered:
            callback(self)
        else:
            self._post_render_callbacks.append(callback)

</source>
<source file="django/django/contrib/sessions/backends/base.py.pyindent" startline="192" endline="195" pcid="2880">
            if self.session_key is None or no_load:
                self._session_cache = {}
            else:
                self._session_cache = self.load()
</source>
<source file="django/django/contrib/sessions/backends/base.py.pyindent" startline="172" endline="179" pcid="2875">
        """
        Validate session key on assignment. Invalid values will set to None.
        """
        if self._validate_session_key(value):
            self.__session_key = value
        else:
            self.__session_key = None

</source>
<source file="django/django/contrib/messages/storage/base.py.pyindent" startline="158" endline="168" pcid="2572">
        """
        Set a custom minimum recorded level.

        If set to ``None``, the default level will be used (see the
        ``_get_level`` method).
        """
        if value is None and hasattr(self, '_level'):
            del self._level
        else:
            self._level = int(value)

</source>
<source file="django/django/utils/six.py.pyindent" startline="146" endline="149" pcid="7502">
                if old_attr is None:
                    new_attr = name
                else:
                    new_attr = old_attr
</source>
<source file="django/django/contrib/gis/serializers/geojson.py.pyindent" startline="59" endline="64" pcid="2370">
        if field.name == self.geometry_field:
            self._geometry = field.value_from_object(obj)
        else:
            super().handle_field(obj, field)


</source>
<source file="django/django/core/files/uploadhandler.py.pyindent" startline="172" endline="177" pcid="4023">
        """Add the data to the BytesIO file."""
        if self.activated:
            self.file.write(raw_data)
        else:
            return raw_data

</source>
<source file="django/django/contrib/gis/geos/prototypes/io.py.pyindent" startline="224" endline="230" pcid="2311">
            if self.srid:
                # PostGIS uses POINT(NaN NaN) for WKB representation of empty
                # points. Use it for EWKB as it's a PostGIS specific format.
                # https://trac.osgeo.org/postgis/ticket/3181
                geom = Point(float('NaN'), float('NaN'), srid=geom.srid)
            else:
                raise ValueError('Empty point is not representable in WKB.')
</source>
<source file="django/django/db/backends/mysql/client.py.pyindent" startline="30" endline="33" pcid="4729">
            if '/' in host:
                args += ["--socket=%s" % host]
            else:
                args += ["--host=%s" % host]
</source>
<source file="django/django/core/paginator.py.pyindent" startline="48" endline="51" pcid="4533">
            if number == 1 and self.allow_empty_first_page:
                pass
            else:
                raise EmptyPage(_('That page contains no results'))
</source>
<source file="django/tests/gis_tests/distapp/tests.py.pyindent" startline="86" endline="93" pcid="16156">
                    if oracle or spatialite:
                        # Result in meters
                        dist = dist[1]
                    else:
                        # Result in units of the field
                        dist = dist[0]

                # Creating the query set.
</source>
<source file="django/django/db/models/sql/where.py.pyindent" startline="96" endline="99" pcid="5939">
                if self.negated:
                    return '', []
                else:
                    raise EmptyResultSet
</source>
<source file="django/django/contrib/gis/geos/polygon.py.pyindent" startline="124" endline="140" pcid="2232">
        """
        Return the ring at the specified index. The first index, 0, will
        always return the exterior ring.  Indices > 0 will return the
        interior ring at the given index (e.g., poly[1] and poly[2] would
        return the first and second interior ring, respectively).

        CAREFUL: Internal/External are not the same as Interior/Exterior!
        Return a pointer from the existing geometries for use internally by the
        object's methods. _get_single_external() returns a clone of the same
        geometry for use by external code.
        """
        if index == 0:
            return capi.get_extring(self.ptr)
        else:
            # Getting the interior ring, have to subtract 1 from the index.
            return capi.get_intring(self.ptr, index - 1)

</source>
<source file="django/django/contrib/gis/geos/polygon.py.pyindent" startline="97" endline="101" pcid="2223">
        if isinstance(g, GEOM_PTR):
            return capi.geom_clone(g)
        else:
            return capi.geom_clone(g.ptr)

</source>
<source file="django/django/contrib/gis/geos/polygon.py.pyindent" startline="80" endline="84" pcid="2218">
            if isinstance(r, GEOM_PTR):
                rings.append(r)
            else:
                rings.append(self._construct_ring(r))

</source>
<source file="django/tests/gis_tests/geoapp/test_functions.py.pyindent" startline="337" endline="343" pcid="16537">
            # Oracle and PostGIS return 1 for the number of geometries on
            # non-collections, whereas MySQL returns None.
            if mysql:
                self.assertIsNone(city.num_geom)
            else:
                self.assertEqual(1, city.num_geom)

</source>
<source file="django/django/contrib/gis/geos/point.py.pyindent" startline="29" endline="33" pcid="2169">
            # Here X, Y, and (optionally) Z were passed in individually, as parameters.
            if isinstance(z, (float, int)):
                coords = [x, y, z]
            else:
                coords = [x, y]
</source>
<source file="django/tests/gis_tests/geos_tests/test_mutable_list.py.pyindent" startline="347" endline="351" pcid="16783">
            if i < 0:
                self.assertEqual(ul._checkindex(i), i + self.limit, '_checkindex(neg index)')
            else:
                self.assertEqual(ul._checkindex(i), i, '_checkindex(pos index)')

</source>
<source file="django/tests/test_client_regress/views.py.pyindent" startline="47" endline="58" pcid="26569">
    """A view that takes a string argument

    The purpose of this view is to check that if a space is provided in
    the argument, the test framework unescapes the %20 before passing
    the value to the view.
    """
    if name == 'Arthur Dent':
        return HttpResponse('Hi, Arthur')
    else:
        return HttpResponse('Howdy, %s' % name)


</source>
<source file="django/django/contrib/admin/helpers.py.pyindent" startline="110" endline="114" pcid="128">
            if field in self.readonly_fields:
                yield AdminReadonlyField(self.form, field, is_first=(i == 0), model_admin=self.model_admin)
            else:
                yield AdminField(self.form, field, is_first=(i == 0))

</source>
<source file="django/django/forms/formsets.py.pyindent" startline="390" endline="396" pcid="6122">
        # All the forms on a FormSet are the same, so you only need to
        # interrogate the first form for media.
        if self.forms:
            return self.forms[0].media
        else:
            return self.empty_form.media

</source>
<source file="django/tests/gis_tests/tests.py.pyindent" startline="27" endline="30" pcid="17013">
                if self.version is None:
                    raise ProgrammingError
                else:
                    return self.version
</source>
<source file="django/django/contrib/gis/geos/geometry.py.pyindent" startline="563" endline="578" pcid="2083">
        """
        Return the Geometry, simplified using the Douglas-Peucker algorithm
        to the specified tolerance (higher tolerance => less points).  If no
        tolerance provided, defaults to 0.

        By default, don't preserve topology - e.g. polygons can be split,
        collapse to lines or disappear holes can be created or disappear, and
        lines can cross. By specifying preserve_topology=True, the result will
        have the same dimension and number of components as the input. This is
        significantly slower.
        """
        if preserve_topology:
            return self._topology(capi.geos_preservesimplify(self.ptr, tolerance))
        else:
            return self._topology(capi.geos_simplify(self.ptr, tolerance))

</source>
<source file="django/django/contrib/gis/geos/geometry.py.pyindent" startline="457" endline="462" pcid="2064">
            # short-circuit where source & dest SRIDs match
            if clone:
                return self.clone()
            else:
                return

</source>
<source file="django/django/utils/regex_helper.py.pyindent" startline="161" endline="170" pcid="7404">
                    if contains(result[-1], Group):
                        # If we are quantifying a capturing group (or
                        # something containing such a group) and the minimum is
                        # zero, we must also handle the case of one occurrence
                        # being present. All the quantifiers (except {0,0},
                        # which we conveniently ignore) that have a 0 minimum
                        # also allow a single occurrence.
                        result[-1] = Choice([None, result[-1]])
                    else:
                        result.pop()
</source>
<source file="django/tests/inspectdb/tests.py.pyindent" startline="121" endline="124" pcid="17624">
            if connection.features.can_introspect_small_integer_field:
                assertFieldType('pos_small_int_field', "models.PositiveSmallIntegerField()")
            else:
                assertFieldType('pos_small_int_field', "models.PositiveIntegerField()")
</source>
<source file="django/django/utils/translation/template.py.pyindent" startline="131" endline="134" pcid="7820">
                if inplural:
                    plural.append('%%(%s)s' % t.contents)
                else:
                    singular.append('%%(%s)s' % t.contents)
</source>
<source file="django/tests/inspectdb/tests.py.pyindent" startline="126" endline="130" pcid="17627">
            if connection.features.can_introspect_small_integer_field:
                assertFieldType('pos_small_int_field', "models.SmallIntegerField()")
            else:
                assertFieldType('pos_small_int_field', "models.IntegerField()")

</source>
<source file="django/django/core/handlers/base.py.pyindent" startline="39" endline="42" pcid="4046">
                    if str(exc):
                        logger.debug('MiddlewareNotUsed(%r): %s', middleware_path, exc)
                    else:
                        logger.debug('MiddlewareNotUsed: %r', middleware_path)
</source>
<source file="django/django/contrib/gis/geos/collections.py.pyindent" startline="23" endline="28" pcid="1906">
            # If only one geometry provided or a list of geometries is provided
            #  in the first argument.
            if isinstance(args[0], (tuple, list)):
                init_geoms = args[0]
            else:
                init_geoms = args
</source>
<source file="django/django/test/html.py.pyindent" startline="166" endline="170" pcid="6829">
        if self.open_tags:
            return self.open_tags[-1]
        else:
            return self.root

</source>
<source file="django/django/contrib/gis/geoip2/base.py.pyindent" startline="124" endline="128" pcid="1871">
        if self._country:
            return self._country.country
        else:
            return self._city.city

</source>
<source file="django/django/contrib/gis/gdal/srs.py.pyindent" startline="95" endline="121" pcid="1804">
        """
        Return the value of the given string attribute node, None if the node
        doesn't exist.  Can also take a tuple as a parameter, (target, child),
        where child is the index of the attribute in the WKT.  For example:

        >>> wkt = 'GEOGCS["WGS 84", DATUM["WGS_1984, ... AUTHORITY["EPSG","4326"]]'
        >>> srs = SpatialReference(wkt) # could also use 'WGS84', or 4326
        >>> print(srs['GEOGCS'])
        WGS 84
        >>> print(srs['DATUM'])
        WGS_1984
        >>> print(srs['AUTHORITY'])
        EPSG
        >>> print(srs['AUTHORITY', 1]) # The authority value
        4326
        >>> print(srs['TOWGS84', 4]) # the fourth value in this wkt
        0
        >>> print(srs['UNIT|AUTHORITY']) # For the units authority, have to use the pipe symbole.
        EPSG
        >>> print(srs['UNIT|AUTHORITY', 1]) # The authority value for the units
        9122
        """
        if isinstance(target, tuple):
            return self.attr_value(*target)
        else:
            return self.attr_value(target)

</source>
<source file="django/django/utils/lorem_ipsum.py.pyindent" startline="90" endline="93" pcid="7354">
        if common and i == 0:
            paras.append(COMMON_P)
        else:
            paras.append(paragraph())
</source>
<source file="django/django/db/backends/sqlite3/operations.py.pyindent" startline="187" endline="191" pcid="4971">
            if settings.USE_TZ:
                value = timezone.make_naive(value, self.connection.timezone)
            else:
                raise ValueError("SQLite backend does not support timezone-aware datetimes when USE_TZ is False.")

</source>
<source file="django/django/db/migrations/operations/fields.py.pyindent" startline="166" endline="169" pcid="5116">
            if name != self.name:
                new_fields.append((name, instance))
            else:
                old_field = instance
</source>
<source file="django/django/db/models/sql/where.py.pyindent" startline="101" endline="104" pcid="5942">
                if self.negated:
                    raise EmptyResultSet
                else:
                    return '', []
</source>
<source file="django/django/template/defaultfilters.py.pyindent" startline="577" endline="580" pcid="6418">
            if not x:
                bits.append(None)
            else:
                bits.append(int(x))
</source>
<source file="django/django/contrib/admin/helpers.py.pyindent" startline="204" endline="207" pcid="155">
                    if hasattr(value, "__html__"):
                        result_repr = value
                    else:
                        result_repr = linebreaksbr(value)
</source>
<source file="django/tests/messages_tests/urls.py.pyindent" startline="30" endline="33" pcid="18813">
        if fail_silently is not None:
            getattr(messages, message_type)(request, msg, fail_silently=fail_silently)
        else:
            getattr(messages, message_type)(request, msg)
</source>
<source file="django/django/views/csrf.py.pyindent" startline="147" endline="153" pcid="8030">
        if template_name == CSRF_FAILURE_TEMPLATE_NAME:
            # If the default template doesn't exist, use the string template.
            t = Engine().from_string(CSRF_FAILURE_TEMPLATE)
            c = Context(c)
        else:
            # Raise if a developer-specified template doesn't exist.
            raise
</source>
<source file="django/django/core/management/commands/squashmigrations.py.pyindent" startline="155" endline="160" pcid="4482">
            if migration.replaces:
                replaces.extend(migration.replaces)
            else:
                replaces.append((migration.app_label, migration.name))

        # Make a new migration with those operations
</source>
<source file="django/tests/migrations/test_commands.py.pyindent" startline="802" endline="806" pcid="19157">
            if migration_recorder.connection is connections['other']:
                raise Exception('Other connection')
            else:
                return mock.DEFAULT

</source>
<source file="django/django/db/models/functions/datetime.py.pyindent" startline="24" endline="27" pcid="5582">
            if self.tzinfo is None:
                tzname = timezone.get_current_timezone_name()
            else:
                tzname = timezone._get_timezone_name(self.tzinfo)
</source>
<source file="django/django/contrib/gis/gdal/geometries.py.pyindent" startline="302" endline="306" pcid="1457">
        if isinstance(srid, int) or srid is None:
            self.srs = srid
        else:
            raise TypeError('SRID must be set with an integer.')

</source>
<source file="django/django/contrib/gis/gdal/envelope.py.pyindent" startline="48" endline="52" pcid="1334">
                # A tuple was passed in.
                if len(args[0]) != 4:
                    raise GDALException('Incorrect number of tuple elements (%d).' % len(args[0]))
                else:
                    self._from_sequence(args[0])
</source>
<source file="django/django/contrib/auth/middleware.py.pyindent" startline="69" endline="77" pcid="558">
            if request.user.get_username() == self.clean_username(username, request):
                return
            else:
                # An authenticated user is associated with the request, but
                # it does not match the authorized user in the header.
                self._remove_invalid_user(request)

        # We are seeing this user for the first time in this session, attempt
        # to authenticate the user.
</source>
<source file="django/django/forms/formsets.py.pyindent" startline="367" endline="371" pcid="6114">
            # Only pre-fill the ordering field for initial forms.
            if index is not None and index < self.initial_form_count():
                form.fields[ORDERING_FIELD_NAME] = IntegerField(label=_('Order'), initial=index + 1, required=False)
            else:
                form.fields[ORDERING_FIELD_NAME] = IntegerField(label=_('Order'), required=False)
</source>
<source file="django/django/core/files/storage.py.pyindent" startline="297" endline="300" pcid="3943">
            if os.path.isdir(name):
                os.rmdir(name)
            else:
                os.remove(name)
</source>
<source file="django/tests/multiple_database/tests.py.pyindent" startline="1585" endline="1590" pcid="20974">
        if db == 'other':
            return model_name == 'pet'
        else:
            return model_name != 'pet'


</source>
<source file="django/django/contrib/gis/gdal/datasource.py.pyindent" startline="95" endline="98" pcid="1302">
            if 0 <= index < self.layer_count:
                layer = capi.get_layer(self._ptr, index)
            else:
                raise IndexError('Index out of range when accessing layers in a datasource: %s.' % index)
</source>
<source file="django/django/core/files/storage.py.pyindent" startline="334" endline="343" pcid="3957">
        """
        If timezone support is enabled, make an aware datetime object in UTC;
        otherwise make a naive one in the local timezone.
        """
        if settings.USE_TZ:
            # Safe to use .replace() because UTC doesn't have DST
            return datetime.utcfromtimestamp(ts).replace(tzinfo=timezone.utc)
        else:
            return datetime.fromtimestamp(ts)

</source>
<source file="django/django/contrib/gis/feeds.py.pyindent" startline="42" endline="46" pcid="1255">
                    # Box: ( (X0, Y0), (X1, Y1) )
                    if len(geom) == 2:
                        box_coords = geom
                    else:
                        raise ValueError('Only should be two sets of coordinates.')
</source>
<source file="django/django/db/models/sql/where.py.pyindent" startline="151" endline="154" pcid="5957">
            if hasattr(child, 'clone'):
                clone.children.append(child.clone())
            else:
                clone.children.append(child)
</source>
<source file="django/django/contrib/gis/db/backends/utils.py.pyindent" startline="19" endline="23" pcid="1192">
        if self.func:
            return '%(func)s(%(lhs)s, %(rhs)s)'
        else:
            return '%(lhs)s %(op)s %(rhs)s'

</source>
<source file="django/django/utils/dateformat.py.pyindent" startline="324" endline="327" pcid="7202">
            if jan1_weekday == 5 or (jan1_weekday == 6 and calendar.isleap(self.data.year - 1)):
                week_number = 53
            else:
                week_number = 52
</source>
<source file="django/django/core/files/storage.py.pyindent" startline="313" endline="316" pcid="3949">
            if os.path.isdir(os.path.join(path, entry)):
                directories.append(entry)
            else:
                files.append(entry)
</source>
<source file="django/django/contrib/gis/db/backends/postgis/operations.py.pyindent" startline="355" endline="360" pcid="1095">
        if agg_name == 'Extent3D':
            return self.extent3d
        else:
            return self.geom_func_prefix + agg_name

    # Routines for getting the OGC-compliant models.
</source>
<source file="django/django/utils/dateformat.py.pyindent" startline="243" endline="246" pcid="7178">
            if self.timezone and self.timezone.dst(self.data):
                return '1'
            else:
                return '0'
</source>
<source file="django/tests/runtests.py.pyindent" startline="243" endline="247" pcid="22790">
        # This doesn't work before django.setup() on some databases.
        if all(conn.features.can_clone_databases for conn in connections.all()):
            return default_test_processes()
        else:
            return 1
</source>
<source file="django/django/utils/translation/trans_null.py.pyindent" startline="64" endline="67" pcid="7870">
    if lang_code == settings.LANGUAGE_CODE:
        return lang_code
    else:
        raise LookupError(lang_code)
</source>
<source file="django/django/contrib/gis/db/backends/postgis/adapter.py.pyindent" startline="30" endline="35" pcid="989">
        """Does the given protocol conform to what Psycopg2 expects?"""
        if proto == ISQLQuote:
            return self
        else:
            raise Exception('Error implementing psycopg2 protocol. Is psycopg2 installed?')

</source>
<source file="django/tests/signals/tests.py.pyindent" startline="199" endline="202" pcid="23830">
                if kwargs['created']:
                    data.append('Is created')
                else:
                    data.append('Is updated')
</source>
<source file="django/django/utils/dateformat.py.pyindent" startline="54" endline="58" pcid="7131">
            if is_naive(obj):
                self.timezone = get_default_timezone()
            else:
                self.timezone = obj.tzinfo

</source>
<source file="django/django/utils/translation/template.py.pyindent" startline="217" endline="220" pcid="7852">
                    if p.find(':_(') >= 0:
                        out.write(' %s ' % p.split(':', 1)[1])
                    else:
                        out.write(blankout(p, 'F'))
</source>
<source file="django/django/contrib/gis/admin/options.py.pyindent" startline="73" endline="76" pcid="840">
            if db_field.geom_type == 'GEOMETRYCOLLECTION':
                collection_type = 'Any'
            else:
                collection_type = OGRGeomType(db_field.geom_type.replace('MULTI', ''))
</source>
<source file="django/tests/staticfiles_tests/storage.py.pyindent" startline="43" endline="46" pcid="24057">
            if os.path.isdir(os.path.join(path, entry)):
                directories.append(entry)
            else:
                files.append(entry)
</source>
<source file="django/django/utils/timezone.py.pyindent" startline="156" endline="161" pcid="7767">
        self.old_timezone = getattr(_active, 'value', None)
        if self.timezone is None:
            deactivate()
        else:
            activate(self.timezone)

</source>
<source file="django/tests/invalid_models_tests/test_models.py.pyindent" startline="913" endline="918" pcid="17859">
            def __call__(self, **kwargs):
                pass

            def dummy_method(self):
                pass

</source>
<source file="django/tests/invalid_models_tests/test_models.py.pyindent" startline="784" endline="789" pcid="17824">
            class Place(models.Model):
                pass

            class ParkingLot(Place):
                parent = models.OneToOneField(Place, models.CASCADE)

</source>
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="1359" endline="1368" pcid="18168">
        """
        ManyToManyField accepts the ``through_fields`` kwarg
        only if an intermediary table is specified.
        """
        class Fan(models.Model):
            pass

        with self.assertRaisesMessage(ValueError, 'Cannot specify through_fields without a through model'):
            models.ManyToManyField(Fan, through_fields=('f1', 'f2'))

</source>
<source file="django/tests/servers/views.py.pyindent" startline="37" endline="40" pcid="23528">
    with urlopen(request.GET['url'] + '/create_model_instance/'):
        pass
    with urlopen(request.GET['url'] + '/model_view/') as response:
        return HttpResponse('subview calling view: {}'.format(response.read().decode()))
</source>
<source file="django/tests/test_runner_apps/simple/tests.py.pyindent" startline="7" endline="14" pcid="26747">

    def test_1(self):
        pass

    def test_2(self):
        pass


</source>
<source file="django/tests/test_runner_apps/simple/tests.py.pyindent" startline="16" endline="23" pcid="26750">

    def test_1(self):
        pass

    def test_2(self):
        pass


</source>
<source file="django/tests/test_runner_apps/simple/tests.py.pyindent" startline="25" endline="32" pcid="26753">

    def test_1(self):
        pass

    def test_2(self):
        pass


</source>
<source file="django/tests/test_runner_apps/simple/tests.py.pyindent" startline="34" endline="41" pcid="26756">

    def test_1(self):
        pass

    def test_2(self):
        pass


</source>
<source file="django/tests/test_runner_apps/simple/tests.py.pyindent" startline="43" endline="50" pcid="26759">

    def test_1(self):
        pass

    def test_2(self):
        pass


</source>
<source file="django/tests/test_runner_apps/simple/tests.py.pyindent" startline="52" endline="57" pcid="26762">

    def test_1(self):
        pass

    def test_2(self):
        pass
</source>
<source file="django/django/db/models/sql/where.py.pyindent" startline="108" endline="114" pcid="5945">
            if self.negated:
                # Some backends (Oracle at least) need parentheses
                # around the inner SQL in the negated case, even if the
                # inner SQL contains just a single expression.
                sql_string = 'NOT (%s)' % sql_string
            elif len(result) > 1 or self.resolved:
                sql_string = '(%s)' % sql_string
</source>
<source file="django/django/utils/translation/template.py.pyindent" startline="136" endline="140" pcid="7823">
                contents = t.contents.replace('%', '%%')
                if inplural:
                    plural.append(contents)
                else:
                    singular.append(contents)
</source>
<source file="django/django/core/cache/backends/filebased.py.pyindent" startline="133" endline="140" pcid="3596">
        """
        Remove all the cache files.
        """
        if not os.path.exists(self._dir):
            return
        for fname in self._list_cache_files():
            self._delete(fname)

</source>
<source file="django/django/test/html.py.pyindent" startline="90" endline="93" pcid="6803">
                    if count:
                        i += child.count(element)
                    elif element in child:
                        return 1
</source>
<source file="django/django/core/files/base.py.pyindent" startline="36" endline="39" pcid="3792">
            try:
                return os.path.getsize(self.file.name)
            except (OSError, TypeError):
                pass
</source>
<source file="django/tests/admin_scripts/tests.py.pyindent" startline="164" endline="168" pcid="9266">
            try:
                os.remove(path)
            except OSError:
                pass

</source>
<source file="django/django/core/cache/backends/filebased.py.pyindent" startline="117" endline="121" pcid="3592">
            try:
                os.makedirs(self._dir, 0o700)
            except FileExistsError:
                pass

</source>
<source file="django/django/middleware/csrf.py.pyindent" startline="293" endline="302" pcid="6259">
                try:
                    request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')
                except IOError:
                    # Handle a broken connection before we've completed reading
                    # the POST data. process_view shouldn't raise any
                    # exceptions, so we'll ignore and serve the user a 403
                    # (assuming they're still listening, which they probably
                    # aren't because of the error).
                    pass

</source>
<source file="django/django/contrib/syndication/views.py.pyindent" startline="162" endline="166" pcid="3436">
            try:
                description_tmp = loader.get_template(self.description_template)
            except TemplateDoesNotExist:
                pass

</source>
<source file="django/django/middleware/csrf.py.pyindent" startline="267" endline="274" pcid="6253">
                    try:
                        # request.get_host() includes the port.
                        good_referer = request.get_host()
                    except DisallowedHost:
                        pass

                # Create a list of all acceptable HTTP referers, including the
                # current host if it's permitted by ALLOWED_HOSTS.
</source>
<source file="django/django/contrib/syndication/views.py.pyindent" startline="155" endline="159" pcid="3433">
            try:
                title_tmp = loader.get_template(self.title_template)
            except TemplateDoesNotExist:
                pass

</source>
<source file="django/tests/runtests.py.pyindent" startline="322" endline="326" pcid="22808">
        try:
            test_labels.remove(label)
        except ValueError:
            pass

</source>
<source file="django/django/core/files/uploadedfile.py.pyindent" startline="69" endline="77" pcid="3989">
        try:
            return self.file.close()
        except FileNotFoundError:
            # The file was moved or deleted before the tempfile could unlink
            # it. Still sets self.file.close_called and calls
            # self.file.file.close() before the exception.
            pass


</source>
<source file="django/django/utils/translation/trans_real.py.pyindent" startline="236" endline="240" pcid="7914">
        try:
            return t.to_language()
        except AttributeError:
            pass
    # If we don't have a real translation object, assume it's the default language.
</source>
<source file="django/tests/bash_completion/management/commands/test_command.py.pyindent" startline="5" endline="9" pcid="11297">
    def add_arguments(self, parser):
        parser.add_argument("--list", action="store_true", help="Print all options")

    def handle(self, *args, **options):
        pass
</source>
<source file="django/tests/bash_completion/tests.py.pyindent" startline="53" endline="56" pcid="11307">
            try:
                util.autocomplete()
            except SystemExit:
                pass
</source>
<source file="django/django/contrib/sitemaps/__init__.py.pyindent" startline="39" endline="44" pcid="3108">
            try:
                # Next, try for the "global" sitemap URL.
                sitemap_url = reverse('django.contrib.sitemaps.views.sitemap')
            except NoReverseMatch:
                pass

</source>
<source file="django/django/contrib/gis/ptr.py.pyindent" startline="35" endline="38" pcid="2352">
            try:
                self.destructor(self.ptr)
            except (AttributeError, ImportError, TypeError):
                pass  # Some part might already have been garbage collected
</source>
<source file="django/django/contrib/gis/geos/geometry.py.pyindent" startline="435" endline="438" pcid="2059">
            try:
                return gdal.SpatialReference(self.srid)
            except gdal.SRSException:
                pass
</source>
<source file="django/tests/runtests.py.pyindent" startline="373" endline="377" pcid="22818">
        try:
            test_labels.remove(label)
        except ValueError:
            pass

</source>
<source file="django/tests/urlpatterns_reverse/method_view_urls.py.pyindent" startline="5" endline="12" pcid="27312">
    def method_view(self, request):
        pass

    @classmethod
    def classmethod_view(cls, request):
        pass


</source>
<source file="django/tests/test_runner_apps/tagged/tests_inheritance.py.pyindent" startline="23" endline="29" pcid="26772">

    def test_new_class_tag_only(self):
        pass

    @tag('baz')
    def test_new_class_and_func_tags(self):
        pass
</source>
<source file="django/django/contrib/gis/gdal/layer.py.pyindent" startline="78" endline="82" pcid="1565">
            # If the Layer supports random reading, return.
            try:
                return Feature(capi.get_feature(self.ptr, feat_id), self)
            except GDALException:
                pass
</source>
<source file="django/django/template/backends/base.py.pyindent" startline="76" endline="81" pcid="6309">
            try:
                yield safe_join(template_dir, template_name)
            except SuspiciousFileOperation:
                # The joined path was located outside of this template_dir
                # (it might be inside another one, so this isn't fatal).
                pass
</source>
<source file="django/tests/test_runner_apps/tagged/tests_inheritance.py.pyindent" startline="12" endline="20" pcid="26769">

    def test_no_new_tags(self):
        pass

    @tag('baz')
    def test_new_func_tag(self):
        pass


</source>
<source file="django/django/urls/base.py.pyindent" startline="121" endline="129" pcid="6988">
    """
    Unset the script prefix for the current thread.
    """
    try:
        del _prefixes.value
    except AttributeError:
        pass


</source>
<source file="django/django/core/management/commands/shell.py.pyindent" startline="98" endline="101" pcid="4399">
            try:
                return getattr(self, shell)(options)
            except ImportError:
                pass
</source>
<source file="django/django/db/migrations/writer.py.pyindent" startline="225" endline="230" pcid="5366">
            try:
                return module_dir(migrations_module)
            except ValueError:
                pass

        # Alright, see if it's a direct submodule of the app
</source>
<source file="django/tests/middleware_exceptions/tests.py.pyindent" startline="107" endline="114" pcid="18976">

    def __init__(self, get_response=None):
        raise MiddlewareNotUsed

    def process_request(self, request):
        pass


</source>
<source file="django/django/forms/formsets.py.pyindent" startline="163" endline="168" pcid="6068">
            try:
                defaults['initial'] = self.initial[i]
            except IndexError:
                pass
        # Allow extra forms to be empty, unless they're part of
        # the minimum forms.
</source>
<source file="django/tests/middleware_exceptions/tests.py.pyindent" startline="116" endline="123" pcid="18979">

    def __init__(self, get_response=None):
        raise MiddlewareNotUsed('spam eggs')

    def process_request(self, request):
        pass


</source>
<source file="django/django/contrib/gis/gdal/raster/source.py.pyindent" startline="76" endline="80" pcid="1731">
            try:
                # GDALOpen will auto-detect the data source type.
                self._ptr = capi.open_ds(force_bytes(ds_input), self._write)
            except GDALException as err:
                raise GDALException('Could not open the datasource at "{}" ({}).'.format(ds_input, err))
</source>
<source file="django/django/core/cache/backends/base.py.pyindent" startline="54" endline="57" pcid="3457">
            try:
                timeout = int(timeout)
            except (ValueError, TypeError):
                timeout = 300
</source>
<source file="django/django/core/cache/backends/locmem.py.pyindent" startline="107" endline="112" pcid="3631">
        try:
            del self._cache[key]
            del self._expire_info[key]
        except KeyError:
            pass

</source>
<source file="django/django/templatetags/cache.py.pyindent" startline="38" endline="42" pcid="6687">
            try:
                fragment_cache = caches['template_fragments']
            except InvalidCacheBackendError:
                fragment_cache = caches['default']

</source>
<source file="django/django/template/defaultfilters.py.pyindent" startline="703" endline="708" pcid="6453">
        try:
            return format(value, arg)
        except AttributeError:
            return ''


</source>
<source file="django/django/contrib/postgres/fields/ranges.py.pyindent" startline="28" endline="32" pcid="2662">
        try:
            return self.__dict__['model']
        except KeyError:
            raise AttributeError("'%s' object has no attribute 'model'" % self.__class__.__name__)

</source>
<source file="django/django/contrib/gis/gdal/layer.py.pyindent" startline="163" endline="167" pcid="1583">
        try:
            return OGRGeometry(geom_api.clone_geom(capi.get_spatial_filter(self.ptr)))
        except GDALException:
            return None

</source>
<source file="django/django/template/defaultfilters.py.pyindent" startline="903" endline="907" pcid="6505">
    """A wrapper around pprint.pprint -- for debugging, really."""
    try:
        return pformat(value)
    except Exception as e:
        return "Error in formatting: %s: %s" % (e.__class__.__name__, e)
</source>
<source file="django/django/contrib/auth/base_user.py.pyindent" startline="132" endline="136" pcid="390">
        try:
            return cls.EMAIL_FIELD
        except AttributeError:
            return 'email'

</source>
<source file="django/django/template/defaultfilters.py.pyindent" startline="493" endline="502" pcid="6393">
    """
    Given a list of dicts, return that list sorted by the property given in
    the argument.
    """
    try:
        return sorted(value, key=_property_resolver(arg))
    except (TypeError, VariableDoesNotExist):
        return ''


</source>
<source file="django/django/template/defaultfilters.py.pyindent" startline="129" endline="132" pcid="6333">
        try:
            d = Decimal(str(float(text)))
        except (ValueError, InvalidOperation, TypeError):
            return ''
</source>
<source file="django/django/contrib/sitemaps/__init__.py.pyindent" startline="91" endline="95" pcid="3124">
                Site = django_apps.get_model('sites.Site')
                try:
                    site = Site.objects.get_current()
                except Site.DoesNotExist:
                    pass
</source>
<source file="django/django/contrib/gis/gdal/datasource.py.pyindent" startline="90" endline="93" pcid="1299">
            try:
                layer = capi.get_layer_by_name(self.ptr, force_bytes(index))
            except GDALException:
                raise IndexError('Invalid OGR layer name given: %s.' % index)
</source>
<source file="django/django/template/loader.py.pyindent" startline="14" endline="18" pcid="6559">
        try:
            return engine.get_template(template_name)
        except TemplateDoesNotExist as e:
            chain.append(e)

</source>
<source file="django/django/utils/six.py.pyindent" startline="188" endline="192" pcid="7515">
        try:
            return self.known_modules[fullname]
        except KeyError:
            raise ImportError("This loader does not know module " + fullname)

</source>
<source file="django/django/template/defaultfilters.py.pyindent" startline="547" endline="553" pcid="6409">
    """Return the length of the value - useful for lists."""
    try:
        return len(value)
    except (ValueError, TypeError):
        return 0


</source>
<source file="django/django/contrib/admin/tests.py.pyindent" startline="101" endline="113" pcid="290">
        """
        Block until page has started to load.
        """
        from selenium.common.exceptions import TimeoutException
        try:
            # Wait for the next page to be loaded
            self.wait_for('body')
        except TimeoutException:
            # IE7 occasionally returns an error "Internet Explorer cannot
            # display the webpage" and doesn't load the next page. We just
            # ignore it.
            pass

</source>
<source file="django/django/utils/six.py.pyindent" startline="494" endline="499" pcid="7544">
        try:
            del moves.__dict__[name]
        except KeyError:
            raise AttributeError("no such move, %r" % (name,))


</source>
<source file="django/django/db/backends/ddl_references.py.pyindent" startline="86" endline="90" pcid="4685">
            try:
                return self.quote_name(column) + self.col_suffixes[idx]
            except IndexError:
                return self.quote_name(column)

</source>
<source file="django/tests/runtests.py.pyindent" startline="259" endline="262" pcid="22796">
            try:
                SeleniumTestCaseBase.import_webdriver(browser)
            except ImportError:
                raise argparse.ArgumentError(self, "Selenium browser specification '%s' is not valid." % browser)
</source>
<source file="django/django/templatetags/tz.py.pyindent" startline="63" endline="66" pcid="6746">
        try:
            tz = pytz.timezone(arg)
        except pytz.UnknownTimeZoneError:
            return ''
</source>
<source file="django/tests/get_or_create/tests.py.pyindent" startline="559" endline="564" pcid="16111">
            try:
                Person.objects.update_or_create(first_name='John', defaults={'birthday': birthday_sleep})
            finally:
                # Avoid leaking connection for Oracle
                connection.close()

</source>
<source file="django/django/utils/text.py.pyindent" startline="364" endline="369" pcid="7720">
        try:
            return chr(html.entities.name2codepoint[text])
        except (ValueError, KeyError):
            return match.group(0)


</source>
<source file="django/django/template/defaultfilters.py.pyindent" startline="505" endline="514" pcid="6396">
    """
    Given a list of dicts, return that list sorted in reverse order by the
    property given in the argument.
    """
    try:
        return sorted(value, key=_property_resolver(arg), reverse=True)
    except (TypeError, VariableDoesNotExist):
        return ''


</source>
<source file="django/django/contrib/admin/models.py.pyindent" startline="145" endline="149" pcid="234">
            url_name = 'admin:%s_%s_change' % (self.content_type.app_label, self.content_type.model)
            try:
                return reverse(url_name, args=(quote(self.object_id),))
            except NoReverseMatch:
                pass
</source>
<source file="django/django/template/defaultfilters.py.pyindent" startline="538" endline="544" pcid="6406">
    """Return the last item in a list."""
    try:
        return value[-1]
    except IndexError:
        return ''


</source>
<source file="django/django/contrib/gis/gdal/srs.py.pyindent" startline="58" endline="64" pcid="1792">
            try:
                # If SRID is a string, e.g., '4326', then make acceptable
                # as user input.
                srid = int(srs_input)
                srs_input = 'EPSG:%d' % srid
            except ValueError:
                pass
</source>
<source file="django/django/db/migrations/questioner.py.pyindent" startline="138" endline="142" pcid="5290">
                try:
                    return eval(code, {}, {'datetime': datetime, 'timezone': timezone})
                except (SyntaxError, NameError) as e:
                    print("Invalid input: %s" % e)

</source>
<source file="django/django/contrib/staticfiles/handlers.py.pyindent" startline="57" endline="60" pcid="3292">
            try:
                return self.serve(request)
            except Http404 as e:
                return response_for_exception(request, e)
</source>
<source file="django/django/templatetags/cache.py.pyindent" startline="24" endline="27" pcid="6679">
            try:
                expire_time = int(expire_time)
            except (ValueError, TypeError):
                raise TemplateSyntaxError('"cache" tag got a non-integer timeout value: %r' % expire_time)
</source>
<source file="django/django/template/loaders/locmem.py.pyindent" startline="17" endline="21" pcid="6599">
        try:
            return self.templates_dict[origin.name]
        except KeyError:
            raise TemplateDoesNotExist(origin)

</source>
<source file="django/tests/foreign_object/models/article.py.pyindent" startline="71" endline="76" pcid="13825">
        try:
            return self.active_translation.title
        except ArticleTranslation.DoesNotExist:
            return '[No translation found]'


</source>
<source file="django/django/template/loader.py.pyindent" startline="41" endline="45" pcid="6565">
            try:
                return engine.get_template(template_name)
            except TemplateDoesNotExist as e:
                chain.append(e)

</source>
<source file="django/django/template/defaultfilters.py.pyindent" startline="517" endline="523" pcid="6399">
    """Return the first item in a list."""
    try:
        return value[0]
    except IndexError:
        return ''


</source>
<source file="django/tests/auth_tests/test_views.py.pyindent" startline="94" endline="99" pcid="10912">
                try:
                    reverse(name, args=args, kwargs=kwargs)
                except NoReverseMatch:
                    self.fail("Reversal of url named '%s' failed with NoReverseMatch" % name)


</source>
<source file="django/django/template/defaultfilters.py.pyindent" startline="556" endline="562" pcid="6412">
    """Return a boolean of whether the value's length is the argument."""
    try:
        return len(value) == int(arg)
    except (ValueError, TypeError):
        return ''


</source>
<source file="django/django/contrib/gis/geos/geometry.py.pyindent" startline="147" endline="150" pcid="2008">
            try:
                other = GEOSGeometry.from_ewkt(other)
            except (ValueError, GEOSException):
                return False
</source>
<source file="django/django/contrib/gis/gdal/raster/band.py.pyindent" startline="249" endline="252" pcid="1709">
        try:
            return GDALBand(self.source, index + 1)
        except GDALException:
            raise GDALException('Unable to get band index %d' % index)
</source>
<source file="django/django/contrib/sessions/backends/base.py.pyindent" startline="262" endline="267" pcid="2897">
            # Remove any custom expiration for this session.
            try:
                del self['_session_expiry']
            except KeyError:
                pass
            return
</source>
<source file="django/django/views/generic/dates.py.pyindent" startline="38" endline="41" pcid="8146">
                try:
                    year = self.request.GET['year']
                except KeyError:
                    raise Http404(_("No year specified"))
</source>
<source file="django/django/views/generic/dates.py.pyindent" startline="53" endline="62" pcid="8151">
        """
        Return the start date of the next interval.

        The interval is defined by start date <= item date < next start date.
        """
        try:
            return date.replace(year=date.year + 1, month=1, day=1)
        except ValueError:
            raise Http404(_("Date out of range"))

</source>
<source file="django/django/views/generic/dates.py.pyindent" startline="87" endline="90" pcid="8160">
                try:
                    month = self.request.GET['month']
                except KeyError:
                    raise Http404(_("No month specified"))
</source>
<source file="django/django/views/generic/dates.py.pyindent" startline="108" endline="111" pcid="8166">
            try:
                return date.replace(year=date.year + 1, month=1, day=1)
            except ValueError:
                raise Http404(_("Date out of range"))
</source>
<source file="django/django/views/generic/dates.py.pyindent" startline="139" endline="142" pcid="8176">
                try:
                    day = self.request.GET['day']
                except KeyError:
                    raise Http404(_("No day specified"))
</source>
<source file="django/tests/view_tests/views.py.pyindent" startline="41" endline="48" pcid="28335">
    # We need to inspect the HTML generated by the fancy 500 debug view but
    # the test client ignores it, so we send it explicitly.
    try:
        raise Exception
    except Exception:
        return technical_500_response(request, *sys.exc_info())


</source>
<source file="django/django/views/generic/dates.py.pyindent" startline="185" endline="188" pcid="8188">
                try:
                    week = self.request.GET['week']
                except KeyError:
                    raise Http404(_("No week specified"))
</source>
<source file="django/django/views/generic/dates.py.pyindent" startline="200" endline="209" pcid="8193">
        """
        Return the start date of the next interval.

        The interval is defined by start date <= item date < next start date.
        """
        try:
            return date + datetime.timedelta(days=7 - self._get_weekday(date))
        except OverflowError:
            raise Http404(_("Date out of range"))

</source>
<source file="django/tests/view_tests/views.py.pyindent" startline="84" endline="91" pcid="28347">
    # We need to inspect the HTML generated by the fancy 500 debug view but
    # the test client ignores it, so we send it explicitly.
    try:
        return render(request, path)
    except TemplateDoesNotExist:
        return technical_500_response(request, *sys.exc_info())


</source>
<source file="django/django/core/files/move.py.pyindent" startline="20" endline="25" pcid="3866">
        try:
            return os.path.samefile(src, dst)
        except OSError:
            return False

    # All other platforms: check for same pathname.
</source>
<source file="django/django/template/smartif.py.pyindent" startline="57" endline="64" pcid="6639">
            try:
                return func(context, self.first, self.second)
            except Exception:
                # Templates shouldn't throw exceptions when rendering.  We are
                # most likely to get exceptions for things like {% if foo in bar
                # %} where 'bar' does not support 'in', so default to False
                return False

</source>
<source file="django/tests/messages_tests/test_api.py.pyindent" startline="52" endline="57" pcid="18757">
        try:
            return super().__getattribute__(attr)
        except AttributeError:
            return getattr(self._request, attr)


</source>
<source file="django/django/template/defaultfilters.py.pyindent" startline="717" endline="722" pcid="6459">
        try:
            return time_format(value, arg)
        except (AttributeError, TypeError):
            return ''


</source>
<source file="django/tests/staticfiles_tests/storage.py.pyindent" startline="50" endline="55" pcid="24060">
        name = self._path(name)
        try:
            os.remove(name)
        except FileNotFoundError:
            pass

</source>
<source file="django/tests/test_client_regress/auth_backends.py.pyindent" startline="17" endline="20" pcid="26547">
        try:
            return CustomUser.custom_objects.get(pk=user_id)
        except CustomUser.DoesNotExist:
            return None
</source>
<source file="django/django/template/defaultfilters.py.pyindent" startline="664" endline="669" pcid="6441">
        try:
            return value + arg
        except Exception:
            return ''


</source>
<source file="django/tests/admin_views/admin.py.pyindent" startline="51" endline="56" pcid="9645">
    try:
        return dt_value.year
    except AttributeError:
        return None


</source>
<source file="django/django/template/smartif.py.pyindent" startline="82" endline="86" pcid="6645">
            try:
                return func(context, self.first)
            except Exception:
                return False

</source>
<source file="django/django/utils/ipv6.py.pyindent" startline="39" endline="46" pcid="7322">
    """
    Return whether or not the `ip_str` string is a valid IPv6 address.
    """
    try:
        ipaddress.IPv6Address(ip_str)
    except ValueError:
        return False
    return True
</source>
<source file="django/django/urls/utils.py.pyindent" startline="56" endline="62" pcid="7037">
    # Convert 'django.views.news.stories.story_detail' to
    # ['django.views.news.stories', 'story_detail']
    try:
        dot = callback.rindex('.')
    except ValueError:
        return callback, ''
    return callback[:dot], callback[dot + 1:]
</source>
<source file="django/django/template/defaultfilters.py.pyindent" startline="250" endline="257" pcid="6357">
    """Truncate a string after `arg` number of characters."""
    try:
        length = int(arg)
    except ValueError:  # Invalid literal for int().
        return value  # Fail silently.
    return Truncator(value).chars(length)


</source>
<source file="django/django/template/defaultfilters.py.pyindent" startline="261" endline="271" pcid="6360">
    """
    Truncate HTML after `arg` number of chars.
    Preserve newlines in the HTML.
    """
    try:
        length = int(arg)
    except ValueError:  # invalid literal for int()
        return value  # Fail silently.
    return Truncator(value).chars(length, html=True)


</source>
<source file="django/django/template/defaultfilters.py.pyindent" startline="275" endline="285" pcid="6363">
    """
    Truncate a string after `arg` number of words.
    Remove newlines within the string.
    """
    try:
        length = int(arg)
    except ValueError:  # Invalid literal for int().
        return value  # Fail silently.
    return Truncator(value).words(length, truncate=' ...')


</source>
<source file="django/django/template/defaultfilters.py.pyindent" startline="289" endline="299" pcid="6366">
    """
    Truncate HTML after `arg` number of words.
    Preserve newlines in the HTML.
    """
    try:
        length = int(arg)
    except ValueError:  # invalid literal for int()
        return value  # Fail silently.
    return Truncator(value).words(length, html=True, truncate=' ...')


</source>
<source file="django/django/utils/archive.py.pyindent" startline="65" endline="69" pcid="7046">
            try:
                filename = file.name
            except AttributeError:
                raise UnrecognizedArchiveFormat(
                    "File object not a recognized archive format.")
</source>
<source file="django/django/contrib/sessions/backends/base.py.pyindent" startline="143" endline="148" pcid="2865">
        "Return True when there is no session_key and the session is empty."
        try:
            return not self._session_key and not self._session_cache
        except AttributeError:
            return True

</source>
<source file="django/django/contrib/sitemaps/management/commands/ping_google.py.pyindent" startline="6" endline="12" pcid="3080">
    help = "Ping Google with an updated sitemap, pass optional url of sitemap"

    def add_arguments(self, parser):
        parser.add_argument('sitemap_url', nargs='?')

    def handle(self, *args, **options):
        ping_google(sitemap_url=options['sitemap_url'])
</source>
<source file="django/tests/user_commands/management/commands/required_option.py.pyindent" startline="5" endline="11" pcid="27605">

    def add_arguments(self, parser):
        parser.add_argument('-n', '--need-me', required=True)
        parser.add_argument('-t', '--need-me-too', required=True, dest='needme2')

    def handle(self, *args, **options):
        self.stdout.write(','.join(options))
</source>
<source file="django/tests/user_commands/management/commands/set_option.py.pyindent" startline="5" endline="10" pcid="27610">

    def add_arguments(self, parser):
        parser.add_argument('--set')

    def handle(self, **options):
        self.stdout.write('Set %s' % options['set'])
</source>
<source file="django/django/contrib/gis/gdal/datasource.py.pyindent" startline="66" endline="74" pcid="1291">
            # The data source driver is a void pointer.
            ds_driver = Driver.ptr_type()
            try:
                # OGROpen will auto-detect the data source type.
                ds = capi.open_ds(force_bytes(ds_input), self._write, byref(ds_driver))
            except GDALException:
                # Making the error message more clear rather than something
                # like "Invalid pointer returned from OGROpen".
                raise GDALException('Could not open the datasource at "%s"' % ds_input)
</source>
<source file="django/django/db/backends/ddl_references.py.pyindent" startline="113" endline="120" pcid="4694">
            try:
                col = self.quote_name(column) + self.col_suffixes[idx]
            except IndexError:
                col = self.quote_name(column)
            # Index.__init__() guarantees that self.opclasses is the same
            # length as self.columns.
            return '{} {}'.format(col, self.opclasses[idx])

</source>
<source file="django/django/contrib/auth/management/__init__.py.pyindent" startline="92" endline="105" pcid="535">
    """
    Return the current system user's username, or an empty string if the
    username could not be determined.
    """
    try:
        result = getpass.getuser()
    except (ImportError, KeyError):
        # KeyError will be raised by os.getpwuid() (called by getuser())
        # if there is no corresponding entry in the /etc/passwd file
        # (a very restricted chroot environment, for example).
        return ''
    return result


</source>
<source file="django/django/contrib/gis/gdal/srs.py.pyindent" startline="182" endline="188" pcid="1822">
        "Return the SRID of top-level authority, or None if undefined."
        try:
            return int(self.attr_value('AUTHORITY', 1))
        except (TypeError, ValueError):
            return None

    # #### Unit Properties ####
</source>
<source file="django/django/core/handlers/base.py.pyindent" startline="122" endline="128" pcid="4065">
            wrapped_callback = self.make_view_atomic(callback)
            try:
                response = wrapped_callback(request, *callback_args, **callback_kwargs)
            except Exception as e:
                response = self.process_exception_by_middleware(e, request)

        # Complain if the view returned None (a common error).
</source>
<source file="django/tests/forms_tests/field_tests/test_datefield.py.pyindent" startline="182" endline="189" pcid="14029">
        """field.strptime() doesn't raise a UnicodeEncodeError (#16123)"""
        f = DateField()
        try:
            f.strptime('31 мая 2011', '%d-%b-%y')
        except Exception as e:
            # assertIsInstance or assertRaises cannot be used because UnicodeEncodeError
            # is a subclass of ValueError
            self.assertEqual(e.__class__, ValueError)
</source>
<source file="django/django/template/engine.py.pyindent" startline="125" endline="129" pcid="6536">
            try:
                template = loader.get_template(name, skip=skip)
                return template, template.origin
            except TemplateDoesNotExist as e:
                tried.extend(e.tried)
</source>
<source file="django/django/core/files/storage.py.pyindent" startline="231" endline="237" pcid="3923">
                    # os.makedirs applies the global umask, so we reset it,
                    # for consistency with file_permissions_mode behavior.
                    old_umask = os.umask(0)
                    try:
                        os.makedirs(directory, self.directory_permissions_mode)
                    finally:
                        os.umask(old_umask)
</source>
<source file="django/tests/syndication_tests/feeds.py.pyindent" startline="45" endline="51" pcid="24355">
    def item_guid(self, item):
        return str(item.pk)

    def item_guid_is_permalink(self, item):
        return False


</source>
<source file="django/tests/migrations/routers.py.pyindent" startline="7" endline="13" pcid="19059">
        """
        The Tribble model should be the only one to appear in the 'other' db.
        """
        if model_name == 'tribble':
            return db == 'other'
        elif db == 'other':
            return False
</source>
<source file="django/django/urls/base.py.pyindent" startline="151" endline="162" pcid="6996">
    """
    Return True if the given path resolves against the default URL resolver,
    False otherwise. This is a convenience method to make working with "is
    this a match?" cases easier, avoiding try...except blocks.
    """
    try:
        resolve(path, urlconf)
        return True
    except Resolver404:
        return False


</source>
<source file="django/django/db/backends/base/features.py.pyindent" startline="292" endline="297" pcid="4652">
        """Confirm support for STDDEV and related stats functions."""
        try:
            self.connection.ops.check_expression_support(StdDev(1))
        except NotSupportedError:
            return False
        return True
</source>
<source file="django/django/contrib/staticfiles/management/commands/collectstatic.py.pyindent" startline="32" endline="37" pcid="3299">
        try:
            self.storage.path('')
        except NotImplementedError:
            return False
        return True

</source>
<source file="django/tests/test_client_regress/session.py.pyindent" startline="27" endline="31" pcid="26559">
        try:
            return self.decode(self.session_key)
        except Exception:
            self.modified = True
            return {}
</source>
<source file="django/tests/view_tests/views.py.pyindent" startline="30" endline="39" pcid="28331">
    # Make sure that a callable that raises an exception in the stack frame's
    # local vars won't hijack the technical 500 response (#15025).
    def callable():
        raise Exception
    try:
        raise Exception
    except Exception:
        return technical_500_response(request, *sys.exc_info())


</source>
<source file="django/tests/user_commands/management/commands/subparser.py.pyindent" startline="5" endline="12" pcid="27613">

    def add_arguments(self, parser):
        subparsers = parser.add_subparsers()
        parser_foo = subparsers.add_parser('foo')
        parser_foo.add_argument('bar', type=int)

    def handle(self, *args, **options):
        self.stdout.write(','.join(options))
</source>
</class>

<class classid="3" nclones="2" nlines="15" similarity="73">
<source file="django/django/contrib/admin/models.py.pyindent" startline="141" endline="150" pcid="233">
        """
        Return the admin URL to edit the object represented by this log entry.
        """
        if self.content_type and self.object_id:
            url_name = 'admin:%s_%s_change' % (self.content_type.app_label, self.content_type.model)
            try:
                return reverse(url_name, args=(quote(self.object_id),))
            except NoReverseMatch:
                pass
        return None
</source>
<source file="django/django/contrib/gis/geos/geometry.py.pyindent" startline="433" endline="440" pcid="2058">
        "Return the OSR SpatialReference for SRID of this Geometry."
        if self.srid:
            try:
                return gdal.SpatialReference(self.srid)
            except gdal.SRSException:
                pass
        return None

</source>
</class>

<class classid="4" nclones="2" nlines="11" similarity="72">
<source file="django/django/contrib/admin/views/decorators.py.pyindent" startline="7" endline="18" pcid="314">
    """
    Decorator for views that checks that the user is logged in and is a staff
    member, redirecting to the login page if necessary.
    """
    actual_decorator = user_passes_test(
        lambda u: u.is_active and u.is_staff,
        login_url=login_url,
        redirect_field_name=redirect_field_name
    )
    if view_func:
        return actual_decorator(view_func)
    return actual_decorator
</source>
<source file="django/django/contrib/auth/decorators.py.pyindent" startline="39" endline="52" pcid="436">
    """
    Decorator for views that checks that the user is logged in, redirecting
    to the log-in page if necessary.
    """
    actual_decorator = user_passes_test(
        lambda u: u.is_authenticated,
        login_url=login_url,
        redirect_field_name=redirect_field_name
    )
    if function:
        return actual_decorator(function)
    return actual_decorator


</source>
</class>

<class classid="5" nclones="2" nlines="22" similarity="78">
<source file="django/django/contrib/admindocs/utils.py.pyindent" startline="111" endline="128" pcid="336">
    def _role(name, rawtext, text, lineno, inliner, options=None, content=None):
        if options is None:
            options = {}
        if content is None:
            content = []
        node = docutils.nodes.reference(
            rawtext,
            text,
            refuri=(urlbase % (
                inliner.document.settings.link_base,
                text.lower(),
            )),
            **options
        )
        return [node], []
    docutils.parsers.rst.roles.register_canonical_role(rolename, _role)


</source>
<source file="django/django/contrib/admindocs/utils.py.pyindent" startline="130" endline="146" pcid="340">
    if options is None:
        options = {}
    if content is None:
        content = []
    context = inliner.document.settings.default_reference_context
    node = docutils.nodes.reference(
        rawtext,
        text,
        refuri=(ROLES[context] % (
            inliner.document.settings.link_base,
            text.lower(),
        )),
        **options
    )
    return [node], []


</source>
</class>

<class classid="6" nclones="2" nlines="20" similarity="90">
<source file="django/django/contrib/admindocs/utils.py.pyindent" startline="172" endline="189" pcid="346">
        # Handle nested parentheses, e.g. '^(?P<a>(x|y))/b'.
        unmatched_open_brackets, prev_char = 1, None
        for idx, val in enumerate(list(pattern[end:])):
            # If brackets are balanced, the end of the string for the current
            # named capture group pattern has been reached.
            if unmatched_open_brackets == 0:
                group_pattern_and_name.append((pattern[start:end + idx], group_name))
                break

            # Check for unescaped `(` and `)`. They mark the start and end of a
            # nested group.
            if val == '(' and prev_char != '\\':
                unmatched_open_brackets += 1
            elif val == ')' and prev_char != '\\':
                unmatched_open_brackets -= 1
            prev_char = val

    # Replace the string for named capture groups with their group names.
</source>
<source file="django/django/contrib/admindocs/utils.py.pyindent" startline="206" endline="221" pcid="353">
        # Handle nested parentheses, e.g. '^b/((x|y)\w+)$'.
        unmatched_open_brackets, prev_char = 1, None
        for idx, val in enumerate(list(pattern[start + 1:])):
            if unmatched_open_brackets == 0:
                group_indices.append((start, start + 1 + idx))
                break

            # Check for unescaped `(` and `)`. They mark the start and end of
            # a nested group.
            if val == '(' and prev_char != '\\':
                unmatched_open_brackets += 1
            elif val == ')' and prev_char != '\\':
                unmatched_open_brackets -= 1
            prev_char = val

    # Remove unnamed group matches inside other unnamed capture groups.
</source>
</class>

<class classid="7" nclones="2" nlines="10" similarity="70">
<source file="django/django/contrib/auth/checks.py.pyindent" startline="75" endline="83" pcid="405">
        errors.append(
            checks.Critical(
                '%s.is_anonymous must be an attribute or property rather than '
                'a method. Ignoring this is a security issue as anonymous '
                'users will be treated as authenticated!' % cls,
                obj=cls,
                id='auth.C009',
            )
        )
</source>
<source file="django/django/contrib/auth/checks.py.pyindent" startline="85" endline="93" pcid="406">
        errors.append(
            checks.Critical(
                '%s.is_authenticated must be an attribute or property rather '
                'than a method. Ignoring this is a security issue as anonymous '
                'users will be treated as authenticated!' % cls,
                obj=cls,
                id='auth.C010',
            )
        )
</source>
</class>

<class classid="8" nclones="2" nlines="23" similarity="86">
<source file="django/django/contrib/auth/handlers/modwsgi.py.pyindent" startline="9" endline="29" pcid="444">
    """
    Authenticate against Django's auth database.

    mod_wsgi docs specify None, True, False as return value depending
    on whether the user exists and authenticates.
    """
    # db connection state is managed similarly to the wsgi handler
    # as mod_wsgi may call these functions outside of a request/response cycle
    db.reset_queries()
    try:
        try:
            user = UserModel._default_manager.get_by_natural_key(username)
        except UserModel.DoesNotExist:
            return None
        if not user.is_active:
            return None
        return user.check_password(password)
    finally:
        db.close_old_connections()


</source>
<source file="django/django/contrib/auth/handlers/modwsgi.py.pyindent" startline="31" endline="44" pcid="450">
    """
    Authorize a user based on groups
    """
    db.reset_queries()
    try:
        try:
            user = UserModel._default_manager.get_by_natural_key(username)
        except UserModel.DoesNotExist:
            return []
        if not user.is_active:
            return []
        return [force_bytes(group.name) for group in user.groups.all()]
    finally:
        db.close_old_connections()
</source>
</class>

<class classid="9" nclones="3" nlines="17" similarity="70">
<source file="django/django/contrib/auth/middleware.py.pyindent" startline="99" endline="112" pcid="565">
        """
        Remove the current authenticated user in the request which is invalid
        but only if the user is authenticated via the RemoteUserBackend.
        """
        try:
            stored_backend = load_backend(request.session.get(auth.BACKEND_SESSION_KEY, ''))
        except ImportError:
            # backend failed to load
            auth.logout(request)
        else:
            if isinstance(stored_backend, RemoteUserBackend):
                auth.logout(request)


</source>
<source file="django/django/contrib/gis/geos/factory.py.pyindent" startline="18" endline="24" pcid="1977">
        try:
            decoded = buf.decode()
        except UnicodeDecodeError:
            pass
        else:
            if wkt_regex.match(decoded) or hex_regex.match(decoded):
                return GEOSGeometry(decoded)
</source>
<source file="django/django/db/migrations/questioner.py.pyindent" startline="100" endline="108" pcid="5277">
            try:
                value = int(result)
            except ValueError:
                pass
            else:
                if 0 < value <= len(choices):
                    return value
            result = input("Please select a valid option: ")

</source>
</class>

<class classid="10" nclones="3" nlines="12" similarity="75">
<source file="django/django/contrib/auth/migrations/0003_alter_user_email_max_length.py.pyindent" startline="5" endline="16" pcid="572">

    dependencies = [
        ('auth', '0002_alter_permission_name_max_length'),
    ]

    operations = [
        migrations.AlterField(
            model_name='user',
            name='email',
            field=models.EmailField(max_length=254, verbose_name='email address', blank=True),
        ),
    ]
</source>
<source file="django/django/contrib/auth/migrations/0005_alter_user_last_login_null.py.pyindent" startline="5" endline="16" pcid="574">

    dependencies = [
        ('auth', '0004_alter_user_username_opts'),
    ]

    operations = [
        migrations.AlterField(
            model_name='user',
            name='last_login',
            field=models.DateTimeField(null=True, verbose_name='last login', blank=True),
        ),
    ]
</source>
<source file="django/django/contrib/auth/migrations/0009_alter_user_last_name_max_length.py.pyindent" startline="5" endline="16" pcid="578">

    dependencies = [
        ('auth', '0008_alter_user_username_max_length'),
    ]

    operations = [
        migrations.AlterField(
            model_name='user',
            name='last_name',
            field=models.CharField(blank=True, max_length=150, verbose_name='last name'),
        ),
    ]
</source>
</class>

<class classid="11" nclones="2" nlines="19" similarity="84">
<source file="django/django/contrib/auth/migrations/0007_alter_validators_add_error_messages.py.pyindent" startline="6" endline="24" pcid="576">

    dependencies = [
        ('auth', '0006_require_contenttypes_0002'),
    ]

    operations = [
        migrations.AlterField(
            model_name='user',
            name='username',
            field=models.CharField(
                error_messages={'unique': 'A user with that username already exists.'},
                help_text='Required. 30 characters or fewer. Letters, digits and @/./+/-/_ only.',
                max_length=30,
                unique=True,
                validators=[validators.UnicodeUsernameValidator()],
                verbose_name='username',
            ),
        ),
    ]
</source>
<source file="django/django/contrib/auth/migrations/0008_alter_user_username_max_length.py.pyindent" startline="6" endline="24" pcid="577">

    dependencies = [
        ('auth', '0007_alter_validators_add_error_messages'),
    ]

    operations = [
        migrations.AlterField(
            model_name='user',
            name='username',
            field=models.CharField(
                error_messages={'unique': 'A user with that username already exists.'},
                help_text='Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.',
                max_length=150,
                unique=True,
                validators=[validators.UnicodeUsernameValidator()],
                verbose_name='username',
            ),
        ),
    ]
</source>
</class>

<class classid="12" nclones="2" nlines="11" similarity="81">
<source file="django/django/contrib/auth/models.py.pyindent" startline="166" endline="172" pcid="622">
    permissions = set()
    for backend in auth.get_backends():
        if hasattr(backend, "get_all_permissions"):
            permissions.update(backend.get_all_permissions(user, obj))
    return permissions


</source>
<source file="django/django/contrib/auth/models.py.pyindent" startline="240" endline="250" pcid="639">
        """
        Return a list of permission strings that this user has through their
        groups. Query all available auth backends. If an object is passed in,
        return only permissions matching this object.
        """
        permissions = set()
        for backend in auth.get_backends():
            if hasattr(backend, "get_group_permissions"):
                permissions.update(backend.get_group_permissions(self, obj))
        return permissions

</source>
</class>

<class classid="13" nclones="2" nlines="21" similarity="90">
<source file="django/django/contrib/auth/models.py.pyindent" startline="174" endline="187" pcid="625">
    """
    A backend can raise `PermissionDenied` to short-circuit permission checking.
    """
    for backend in auth.get_backends():
        if not hasattr(backend, 'has_perm'):
            continue
        try:
            if backend.has_perm(user, perm, obj):
                return True
        except PermissionDenied:
            return False
    return False


</source>
<source file="django/django/contrib/auth/models.py.pyindent" startline="189" endline="202" pcid="631">
    """
    A backend can raise `PermissionDenied` to short-circuit permission checking.
    """
    for backend in auth.get_backends():
        if not hasattr(backend, 'has_module_perms'):
            continue
        try:
            if backend.has_module_perms(user, app_label):
                return True
        except PermissionDenied:
            return False
    return False


</source>
</class>

<class classid="14" nclones="2" nlines="30" similarity="90">
<source file="django/django/contrib/gis/db/backends/postgis/models.py.pyindent" startline="9" endline="46" pcid="1022">
    """
    The 'geometry_columns' view from PostGIS. See the PostGIS
    documentation at Ch. 4.3.2.
    """
    f_table_catalog = models.CharField(max_length=256)
    f_table_schema = models.CharField(max_length=256)
    f_table_name = models.CharField(max_length=256)
    f_geometry_column = models.CharField(max_length=256)
    coord_dimension = models.IntegerField()
    srid = models.IntegerField(primary_key=True)
    type = models.CharField(max_length=30)

    class Meta:
        app_label = 'gis'
        db_table = 'geometry_columns'
        managed = False

    @classmethod
    def table_name_col(cls):
        """
        Return the name of the metadata column used to store the feature table
        name.
        """
        return 'f_table_name'

    @classmethod
    def geom_col_name(cls):
        """
        Return the name of the metadata column used to store the feature
        geometry column.
        """
        return 'f_geometry_column'

    def __str__(self):
        return "%s.%s - %dD %s field (SRID: %d)" %                (self.f_table_name, self.f_geometry_column,
                self.coord_dimension, self.type, self.srid)


</source>
<source file="django/django/contrib/gis/db/backends/spatialite/models.py.pyindent" startline="9" endline="44" pcid="1151">
    """
    The 'geometry_columns' table from SpatiaLite.
    """
    f_table_name = models.CharField(max_length=256)
    f_geometry_column = models.CharField(max_length=256)
    coord_dimension = models.IntegerField()
    srid = models.IntegerField(primary_key=True)
    spatial_index_enabled = models.IntegerField()
    type = models.IntegerField(db_column='geometry_type')

    class Meta:
        app_label = 'gis'
        db_table = 'geometry_columns'
        managed = False

    @classmethod
    def table_name_col(cls):
        """
        Return the name of the metadata column used to store the feature table
        name.
        """
        return 'f_table_name'

    @classmethod
    def geom_col_name(cls):
        """
        Return the name of the metadata column used to store the feature
        geometry column.
        """
        return 'f_geometry_column'

    def __str__(self):
        return "%s.%s - %dD %s field (SRID: %d)" %                (self.f_table_name, self.f_geometry_column,
                self.coord_dimension, self.type, self.srid)


</source>
</class>

<class classid="15" nclones="2" nlines="10" similarity="80">
<source file="django/django/contrib/gis/db/backends/postgis/operations.py.pyindent" startline="68" endline="72" pcid="1039">
            # Operators without raster support.
            if lhs_is_raster:
                template_params['lhs'] = 'ST_Polygon(%s)' % template_params['lhs']
            if rhs_is_raster:
                template_params['rhs'] = 'ST_Polygon(%s)' % template_params['rhs']
</source>
<source file="django/django/contrib/gis/db/backends/postgis/operations.py.pyindent" startline="74" endline="80" pcid="1042">
            # Operators with raster support but don't support mixed (rast-geom)
            # lookups.
            if lhs_is_raster and not rhs_is_raster:
                template_params['lhs'] = 'ST_Polygon(%s)' % template_params['lhs']
            elif rhs_is_raster and not lhs_is_raster:
                template_params['rhs'] = 'ST_Polygon(%s)' % template_params['rhs']

</source>
</class>

<class classid="16" nclones="2" nlines="15" similarity="80">
<source file="django/django/contrib/gis/db/backends/spatialite/schema.py.pyindent" startline="92" endline="100" pcid="1171">
            try:
                self.execute(
                    self.sql_discard_geometry_columns % {
                        "geom_table": geom_table,
                        "table": self.quote_name(model._meta.db_table),
                    }
                )
            except DatabaseError:
                pass
</source>
<source file="django/django/contrib/gis/db/backends/spatialite/schema.py.pyindent" startline="141" endline="151" pcid="1184">
            try:
                self.execute(
                    self.sql_update_geometry_columns % {
                        "geom_table": geom_table,
                        "old_table": self.quote_name(old_db_table),
                        "new_table": self.quote_name(new_db_table),
                    }
                )
            except DatabaseError:
                pass
        # Re-add geometry-ness and rename spatial index tables
</source>
</class>

<class classid="17" nclones="2" nlines="12" similarity="75">
<source file="django/django/contrib/gis/db/models/aggregates.py.pyindent" startline="48" endline="57" pcid="1204">
    name = 'Extent'
    is_extent = '2D'

    def __init__(self, expression, **extra):
        super().__init__(expression, output_field=ExtentField(), **extra)

    def convert_value(self, value, expression, connection):
        return connection.ops.convert_extent(value)


</source>
<source file="django/django/contrib/gis/db/models/aggregates.py.pyindent" startline="59" endline="68" pcid="1207">
    name = 'Extent3D'
    is_extent = '3D'

    def __init__(self, expression, **extra):
        super().__init__(expression, output_field=ExtentField(), **extra)

    def convert_value(self, value, expression, connection):
        return connection.ops.convert_extent3d(value)


</source>
</class>

<class classid="18" nclones="3" nlines="18" similarity="83">
<source file="django/django/contrib/gis/feeds.py.pyindent" startline="82" endline="95" pcid="1271">
    def rss_attributes(self):
        attrs = super().rss_attributes()
        attrs['xmlns:georss'] = 'http://www.georss.org/georss'
        return attrs

    def add_item_elements(self, handler, item):
        super().add_item_elements(handler, item)
        self.add_georss_element(handler, item)

    def add_root_elements(self, handler):
        super().add_root_elements(handler)
        self.add_georss_element(handler, self.feed)


</source>
<source file="django/django/contrib/gis/feeds.py.pyindent" startline="112" endline="126" pcid="1279">
    def rss_attributes(self):
        attrs = super().rss_attributes()
        attrs['xmlns:geo'] = 'http://www.w3.org/2003/01/geo/wgs84_pos#'
        return attrs

    def add_item_elements(self, handler, item):
        super().add_item_elements(handler, item)
        self.add_georss_element(handler, item, w3c_geo=True)

    def add_root_elements(self, handler):
        super().add_root_elements(handler)
        self.add_georss_element(handler, self.feed, w3c_geo=True)


# ### Feed subclass ###
</source>
<source file="django/django/contrib/gis/feeds.py.pyindent" startline="97" endline="110" pcid="1275">
    def root_attributes(self):
        attrs = super().root_attributes()
        attrs['xmlns:georss'] = 'http://www.georss.org/georss'
        return attrs

    def add_item_elements(self, handler, item):
        super().add_item_elements(handler, item)
        self.add_georss_element(handler, item)

    def add_root_elements(self, handler):
        super().add_root_elements(handler)
        self.add_georss_element(handler, self.feed)


</source>
</class>

<class classid="19" nclones="2" nlines="12" similarity="75">
<source file="django/django/contrib/gis/gdal/geometries.py.pyindent" startline="268" endline="274" pcid="1447">
        "Return the Spatial Reference for this Geometry."
        try:
            srs_ptr = capi.get_geom_srs(self.ptr)
            return SpatialReference(srs_api.clone_srs(srs_ptr))
        except SRSException:
            return None

</source>
<source file="django/django/contrib/gis/gdal/layer.py.pyindent" startline="123" endline="129" pcid="1576">
        "Return the Spatial Reference used in this Layer."
        try:
            ptr = capi.get_layer_srs(self.ptr)
            return SpatialReference(srs_api.clone_srs(ptr))
        except SRSException:
            return None

</source>
</class>

<class classid="20" nclones="2" nlines="11" similarity="81">
<source file="django/django/contrib/gis/gdal/geometries.py.pyindent" startline="609" endline="615" pcid="1528">
        "Get the ring at the specified index."
        if 0 <= index < self.geom_count:
            return OGRGeometry(capi.clone_geom(capi.get_geom_ref(self.ptr, index)), self.srs)
        else:
            raise IndexError('Index out of range when accessing rings of a polygon: %s.' % index)

    # Polygon Properties
</source>
<source file="django/django/contrib/gis/gdal/geometries.py.pyindent" startline="648" endline="653" pcid="1536">
        "Get the Geometry at the specified index."
        if 0 <= index < self.geom_count:
            return OGRGeometry(capi.clone_geom(capi.get_geom_ref(self.ptr, index)), self.srs)
        else:
            raise IndexError('Index out of range when accessing geometry in a collection: %s.' % index)

</source>
</class>

<class classid="21" nclones="2" nlines="12" similarity="83">
<source file="django/django/contrib/gis/gdal/prototypes/errcheck.py.pyindent" startline="78" endline="87" pcid="1611">
    "Check a function that returns a geometry."
    # OGR_G_Clone may return an integer, even though the
    # restype is set to c_void_p
    if isinstance(result, int):
        result = c_void_p(result)
    if not result:
        raise GDALException('Invalid geometry pointer returned from "%s".' % func.__name__)
    return result


</source>
<source file="django/django/contrib/gis/gdal/prototypes/errcheck.py.pyindent" startline="97" endline="104" pcid="1615">
    if isinstance(result, int):
        result = c_void_p(result)
    if not result:
        raise SRSException('Invalid spatial reference pointer returned from "%s".' % func.__name__)
    return result


# ### Other error-checking routines ###
</source>
</class>

<class classid="22" nclones="2" nlines="10" similarity="70">
<source file="django/django/contrib/gis/gdal/prototypes/generation.py.pyindent" startline="53" endline="60" pcid="1633">
    "Generate a ctypes function that returns an integer value."
    func.argtypes = argtypes
    func.restype = c_int
    if errcheck:
        func.errcheck = errcheck
    return func


</source>
<source file="django/django/contrib/gis/gdal/prototypes/generation.py.pyindent" startline="144" endline="151" pcid="1651">
    "For functions that return c_void_p."
    func.argtypes = argtypes
    func.restype = c_void_p
    if errcheck:
        func.errcheck = check_pointer
    return func


</source>
</class>

<class classid="23" nclones="2" nlines="22" similarity="72">
<source file="django/django/contrib/gis/gdal/prototypes/generation.py.pyindent" startline="81" endline="96" pcid="1637">
    func.argtypes = argtypes
    if offset:
        func.restype = c_int
    else:
        func.restype = c_char_p

    def _check_const(result, func, cargs):
        res = check_const_string(result, func, cargs, offset=offset, cpl=cpl)
        if res and decoding:
            res = res.decode(decoding)
        return res
    func.errcheck = _check_const

    return func


</source>
<source file="django/django/contrib/gis/gdal/prototypes/generation.py.pyindent" startline="98" endline="124" pcid="1642">
    """
    Generate a ctypes prototype for the given function with the
    given argument types that returns a string from a GDAL pointer.
    The `const` flag indicates whether the allocated pointer should
    be freed via the GDAL library routine VSIFree -- but only applies
    only when `str_result` is True.
    """
    func.argtypes = argtypes
    if str_result:
        # Use subclass of c_char_p so the error checking routine
        # can free the memory at the pointer's address.
        func.restype = gdal_char_p
    else:
        # Error code is returned
        func.restype = c_int

    # Dynamically defining our error-checking function with the
    # given offset.
    def _check_str(result, func, cargs):
        res = check_string(result, func, cargs, offset=offset, str_result=str_result)
        if res and decoding:
            res = res.decode(decoding)
        return res
    func.errcheck = _check_str
    return func


</source>
</class>

<class classid="24" nclones="2" nlines="11" similarity="72">
<source file="django/django/contrib/gis/geoip2/base.py.pyindent" startline="197" endline="202" pcid="1888">
        cdict = self.city(query)
        if cdict is None:
            return None
        else:
            return tuple(cdict[o] for o in ordering)

</source>
<source file="django/django/contrib/gis/geos/linestring.py.pyindent" startline="165" endline="172" pcid="2161">
        "Return a list or numpy array of the Z variable."
        if not self.hasz:
            return None
        else:
            return self._listarr(self._cs.getZ)


# LinearRings are LineStrings used within Polygons.
</source>
</class>

<class classid="25" nclones="2" nlines="11" similarity="81">
<source file="django/django/contrib/gis/geos/collections.py.pyindent" startline="68" endline="75" pcid="1916">
        "Create a new collection, and destroy the contents of the previous pointer."
        prev_ptr = self.ptr
        srid = self.srid
        self.ptr = self._create_collection(length, items)
        if srid:
            self.srid = srid
        capi.destroy_geom(prev_ptr)

</source>
<source file="django/django/contrib/gis/geos/polygon.py.pyindent" startline="114" endline="122" pcid="2230">
        # Getting the current pointer, replacing with the newly constructed
        # geometry, and destroying the old geometry.
        prev_ptr = self.ptr
        srid = self.srid
        self.ptr = self._create_polygon(length, items)
        if srid:
            self.srid = srid
        capi.destroy_geom(prev_ptr)

</source>
</class>

<class classid="26" nclones="3" nlines="13" similarity="76">
<source file="django/django/contrib/gis/ptr.py.pyindent" startline="31" endline="38" pcid="2351">
        """
        Free the memory used by the C++ object.
        """
        if self.destructor and self._ptr:
            try:
                self.destructor(self.ptr)
            except (AttributeError, ImportError, TypeError):
                pass  # Some part might already have been garbage collected
</source>
<source file="django/django/core/cache/backends/filebased.py.pyindent" startline="116" endline="121" pcid="3591">
        if not os.path.exists(self._dir):
            try:
                os.makedirs(self._dir, 0o700)
            except FileExistsError:
                pass

</source>
<source file="django/django/template/backends/base.py.pyindent" startline="69" endline="81" pcid="6308">
        """
        Iterate over candidate files for template_name.

        Ignore files that don't lie inside configured template dirs to avoid
        directory traversal attacks.
        """
        for template_dir in self.template_dirs:
            try:
                yield safe_join(template_dir, template_name)
            except SuspiciousFileOperation:
                # The joined path was located outside of this template_dir
                # (it might be inside another one, so this isn't fatal).
                pass
</source>
</class>

<class classid="27" nclones="4" nlines="10" similarity="70">
<source file="django/django/contrib/gis/serializers/geojson.py.pyindent" startline="32" endline="37" pcid="2361">
            # Find the first declared geometry field
            for field in obj._meta.fields:
                if hasattr(field, 'geom_type'):
                    self.geometry_field = field.name
                    break

</source>
<source file="django/django/utils/text.py.pyindent" startline="94" endline="97" pcid="7664">
            if not unicodedata.combining(char):
                truncate_len -= 1
                if truncate_len == 0:
                    break
</source>
<source file="django/django/utils/six.py.pyindent" startline="755" endline="758" pcid="7614">
            for arg in args:
                if isinstance(arg, unicode):
                    want_unicode = True
                    break
</source>
<source file="django/django/db/models/fields/reverse_related.py.pyindent" startline="283" endline="286" pcid="5558">
            for field in opts.fields:
                rel = getattr(field, 'remote_field', None)
                if rel and rel.model == self.model:
                    break
</source>
</class>

<class classid="28" nclones="2" nlines="27" similarity="77">
<source file="django/django/contrib/humanize/templatetags/humanize.py.pyindent" startline="273" endline="287" pcid="2510">
            delta = now - value
            if delta.days != 0:
                return cls.time_strings['past-day'] % {
                    'delta': defaultfilters.timesince(value, now, time_strings=cls.past_substrings),
                }
            elif delta.seconds == 0:
                return cls.time_strings['now']
            elif delta.seconds < 60:
                return cls.time_strings['past-second'] % {'count': delta.seconds}
            elif delta.seconds // 60 < 60:
                count = delta.seconds // 60
                return cls.time_strings['past-minute'] % {'count': count}
            else:
                count = delta.seconds // 60 // 60
                return cls.time_strings['past-hour'] % {'count': count}
</source>
<source file="django/django/contrib/humanize/templatetags/humanize.py.pyindent" startline="289" endline="303" pcid="2516">
            delta = value - now
            if delta.days != 0:
                return cls.time_strings['future-day'] % {
                    'delta': defaultfilters.timeuntil(value, now, time_strings=cls.future_substrings),
                }
            elif delta.seconds == 0:
                return cls.time_strings['now']
            elif delta.seconds < 60:
                return cls.time_strings['future-second'] % {'count': delta.seconds}
            elif delta.seconds // 60 < 60:
                count = delta.seconds // 60
                return cls.time_strings['future-minute'] % {'count': count}
            else:
                count = delta.seconds // 60 // 60
                return cls.time_strings['future-hour'] % {'count': count}
</source>
</class>

<class classid="29" nclones="2" nlines="15" similarity="73">
<source file="django/django/contrib/postgres/fields/ranges.py.pyindent" startline="39" endline="46" pcid="2666">
        if value is None:
            return None
        elif isinstance(value, Range):
            return value
        elif isinstance(value, (list, tuple)):
            return self.range_type(value[0], value[1])
        return value

</source>
<source file="django/django/db/backends/sqlite3/operations.py.pyindent" startline="195" endline="207" pcid="4974">
        if value is None:
            return None

        # Expression values are adapted by the database.
        if hasattr(value, 'resolve_expression'):
            return value

        # SQLite doesn't support tz-aware datetimes
        if timezone.is_aware(value):
            raise ValueError("SQLite backend does not support timezone-aware times.")

        return str(value)

</source>
</class>

<class classid="30" nclones="2" nlines="26" similarity="75">
<source file="django/django/contrib/sessions/backends/base.py.pyindent" startline="201" endline="224" pcid="2883">
        """Get the number of seconds until the session expires.

        Optionally, this function accepts `modification` and `expiry` keyword
        arguments specifying the modification and expiry of the session.
        """
        try:
            modification = kwargs['modification']
        except KeyError:
            modification = timezone.now()
        # Make the difference between "expiry=None passed in kwargs" and
        # "expiry not passed in kwargs", in order to guarantee not to trigger
        # self.load() when expiry is provided.
        try:
            expiry = kwargs['expiry']
        except KeyError:
            expiry = self.get('_session_expiry')

        if not expiry:   # Checks both None and 0 cases
            return settings.SESSION_COOKIE_AGE
        if not isinstance(expiry, datetime):
            return expiry
        delta = expiry - modification
        return delta.days * 86400 + delta.seconds

</source>
<source file="django/django/contrib/sessions/backends/base.py.pyindent" startline="226" endline="245" pcid="2890">
        """Get session the expiry date (as a datetime object).

        Optionally, this function accepts `modification` and `expiry` keyword
        arguments specifying the modification and expiry of the session.
        """
        try:
            modification = kwargs['modification']
        except KeyError:
            modification = timezone.now()
        # Same comment as in get_expiry_age
        try:
            expiry = kwargs['expiry']
        except KeyError:
            expiry = self.get('_session_expiry')

        if isinstance(expiry, datetime):
            return expiry
        expiry = expiry or settings.SESSION_COOKIE_AGE   # Checks both None and 0 cases
        return modification + timedelta(seconds=expiry)

</source>
</class>

<class classid="31" nclones="3" nlines="18" similarity="78">
<source file="django/django/contrib/sessions/backends/cache.py.pyindent" startline="37" endline="53" pcid="2919">
        # Because a cache can fail silently (e.g. memcache), we don't know if
        # we are failing to create a new session because of a key collision or
        # because the cache is missing. So we try for a (large) number of times
        # and then raise an exception. That's the risk you shoulder if using
        # cache backing.
        for i in range(10000):
            self._session_key = self._get_new_session_key()
            try:
                self.save(must_create=True)
            except CreateError:
                continue
            self.modified = True
            return
        raise RuntimeError(
            "Unable to create a new session key. "
            "It is likely that the cache is unavailable.")

</source>
<source file="django/django/contrib/sessions/backends/db.py.pyindent" startline="50" endline="61" pcid="2959">
        while True:
            self._session_key = self._get_new_session_key()
            try:
                # Save immediately to ensure we have a unique entry in the
                # database.
                self.save(must_create=True)
            except CreateError:
                # Key wasn't unique. Try again.
                continue
            self.modified = True
            return

</source>
<source file="django/django/contrib/sessions/backends/file.py.pyindent" startline="102" endline="110" pcid="2999">
        while True:
            self._session_key = self._get_new_session_key()
            try:
                self.save(must_create=True)
            except CreateError:
                continue
            self.modified = True
            return

</source>
</class>

<class classid="32" nclones="2" nlines="12" similarity="91">
<source file="django/django/contrib/sessions/backends/cache.py.pyindent" startline="73" endline="78" pcid="2930">
        if session_key is None:
            if self.session_key is None:
                return
            session_key = self.session_key
        self._cache.delete(self.cache_key_prefix + session_key)

</source>
<source file="django/django/contrib/sessions/backends/cached_db.py.pyindent" startline="51" endline="57" pcid="2945">
        super().delete(session_key)
        if session_key is None:
            if self.session_key is None:
                return
            session_key = self.session_key
        self._cache.delete(self.cache_key_prefix + session_key)

</source>
</class>

<class classid="33" nclones="2" nlines="18" similarity="88">
<source file="django/django/contrib/sessions/backends/db.py.pyindent" startline="98" endline="106" pcid="2972">
        if session_key is None:
            if self.session_key is None:
                return
            session_key = self.session_key
        try:
            self.model.objects.get(session_key=session_key).delete()
        except self.model.DoesNotExist:
            pass

</source>
<source file="django/django/contrib/sessions/backends/file.py.pyindent" startline="176" endline="184" pcid="3019">
        if session_key is None:
            if self.session_key is None:
                return
            session_key = self.session_key
        try:
            os.unlink(self._key_to_file(session_key))
        except OSError:
            pass

</source>
</class>

<class classid="34" nclones="2" nlines="11" similarity="72">
<source file="django/django/contrib/sessions/serializers.py.pyindent" startline="7" endline="19" pcid="3076">
    """
    Simple wrapper around pickle to be used in signing.dumps and
    signing.loads.
    """
    protocol = pickle.HIGHEST_PROTOCOL

    def dumps(self, obj):
        return pickle.dumps(obj, self.protocol)

    def loads(self, data):
        return pickle.loads(data)


</source>
<source file="django/django/core/signing.py.pyindent" startline="82" endline="92" pcid="4618">
    """
    Simple wrapper around json to be used in signing.dumps and
    signing.loads.
    """
    def dumps(self, obj):
        return json.dumps(obj, separators=(',', ':')).encode('latin-1')

    def loads(self, data):
        return json.loads(data.decode('latin-1'))


</source>
</class>

<class classid="35" nclones="7" nlines="17" similarity="70">
<source file="django/django/contrib/sitemaps/__init__.py.pyindent" startline="35" endline="44" pcid="3106">
        try:
            # First, try to get the "index" sitemap URL.
            sitemap_url = reverse('django.contrib.sitemaps.views.index')
        except NoReverseMatch:
            try:
                # Next, try for the "global" sitemap URL.
                sitemap_url = reverse('django.contrib.sitemaps.views.sitemap')
            except NoReverseMatch:
                pass

</source>
<source file="django/django/utils/six.py.pyindent" startline="490" endline="499" pcid="7542">
    """Remove item from six.moves."""
    try:
        delattr(_MovedItems, name)
    except AttributeError:
        try:
            del moves.__dict__[name]
        except KeyError:
            raise AttributeError("no such move, %r" % (name,))


</source>
<source file="django/django/template/defaultfilters.py.pyindent" startline="660" endline="669" pcid="6439">
    """Add the arg to the value."""
    try:
        return int(value) + int(arg)
    except (ValueError, TypeError):
        try:
            return value + arg
        except Exception:
            return ''


</source>
<source file="django/django/views/generic/dates.py.pyindent" startline="182" endline="188" pcid="8186">
            try:
                week = self.kwargs['week']
            except KeyError:
                try:
                    week = self.request.GET['week']
                except KeyError:
                    raise Http404(_("No week specified"))
</source>
<source file="django/django/views/generic/dates.py.pyindent" startline="136" endline="142" pcid="8174">
            try:
                day = self.kwargs['day']
            except KeyError:
                try:
                    day = self.request.GET['day']
                except KeyError:
                    raise Http404(_("No day specified"))
</source>
<source file="django/django/views/generic/dates.py.pyindent" startline="84" endline="90" pcid="8158">
            try:
                month = self.kwargs['month']
            except KeyError:
                try:
                    month = self.request.GET['month']
                except KeyError:
                    raise Http404(_("No month specified"))
</source>
<source file="django/django/views/generic/dates.py.pyindent" startline="35" endline="41" pcid="8144">
            try:
                year = self.kwargs['year']
            except KeyError:
                try:
                    year = self.request.GET['year']
                except KeyError:
                    raise Http404(_("No year specified"))
</source>
</class>

<class classid="36" nclones="2" nlines="20" similarity="70">
<source file="django/django/contrib/sites/models.py.pyindent" startline="105" endline="119" pcid="3191">
    """
    Clear the cache (if primed) each time a site is saved or deleted.
    """
    instance = kwargs['instance']
    using = kwargs['using']
    try:
        del SITE_CACHE[instance.pk]
    except KeyError:
        pass
    try:
        del SITE_CACHE[Site.objects.using(using).get(pk=instance.pk).domain]
    except (KeyError, Site.DoesNotExist):
        pass


</source>
<source file="django/django/core/files/temp.py.pyindent" startline="50" endline="59" pcid="3970">
                self.close_called = True
                try:
                    self.file.close()
                except (OSError, IOError):
                    pass
                try:
                    self.unlink(self.name)
                except OSError:
                    pass

</source>
</class>

<class classid="37" nclones="2" nlines="12" similarity="75">
<source file="django/django/contrib/syndication/views.py.pyindent" startline="57" endline="64" pcid="3415">
        try:
            return item.get_absolute_url()
        except AttributeError:
            raise ImproperlyConfigured(
                'Give your %s class a get_absolute_url() method, or define an '
                'item_link() method in your Feed class.' % item.__class__.__name__
            )

</source>
<source file="django/django/views/generic/edit.py.pyindent" startline="115" endline="120" pcid="8333">
            try:
                url = self.object.get_absolute_url()
            except AttributeError:
                raise ImproperlyConfigured(
                    "No URL to redirect to.  Either provide a url or define"
                    " a get_absolute_url method on the Model.")
</source>
</class>

<class classid="38" nclones="2" nlines="10" similarity="70">
<source file="django/django/core/cache/backends/db.py.pyindent" startline="177" endline="185" pcid="3530">
                        cursor.execute(
                            'UPDATE %s SET %s = %%s, %s = %%s WHERE %s = %%s' % (
                                table,
                                quote_name('value'),
                                quote_name('expires'),
                                quote_name('cache_key'),
                            ),
                            [b64encoded, exp, key]
                        )
</source>
<source file="django/django/core/cache/backends/db.py.pyindent" startline="187" endline="195" pcid="3531">
                        cursor.execute(
                            'INSERT INTO %s (%s, %s, %s) VALUES (%%s, %%s, %%s)' % (
                                table,
                                quote_name('cache_key'),
                                quote_name('value'),
                                quote_name('expires'),
                            ),
                            [key, b64encoded, exp]
                        )
</source>
</class>

<class classid="39" nclones="4" nlines="13" similarity="71">
<source file="django/django/core/cache/backends/locmem.py.pyindent" startline="26" endline="34" pcid="3607">
        key = self.make_key(key, version=version)
        self.validate_key(key)
        pickled = pickle.dumps(value, self.pickle_protocol)
        with self._lock:
            if self._has_expired(key):
                self._set(key, pickled, timeout)
                return True
            return False

</source>
<source file="django/django/core/cache/backends/locmem.py.pyindent" startline="84" endline="91" pcid="3623">
        key = self.make_key(key, version=version)
        self.validate_key(key)
        with self._lock:
            if self._has_expired(key):
                self._delete(key)
                return False
            return True

</source>
<source file="django/django/core/cache/backends/locmem.py.pyindent" startline="36" endline="45" pcid="3610">
        key = self.make_key(key, version=version)
        self.validate_key(key)
        with self._lock:
            if self._has_expired(key):
                self._delete(key)
                return default
            pickled = self._cache[key]
            self._cache.move_to_end(key, last=False)
        return pickle.loads(pickled)

</source>
<source file="django/django/core/cache/backends/locmem.py.pyindent" startline="61" endline="67" pcid="3617">
        key = self.make_key(key, version=version)
        with self._lock:
            if self._has_expired(key):
                return False
            self._expire_info[key] = self.get_backend_timeout(timeout)
            return True

</source>
</class>

<class classid="40" nclones="2" nlines="19" similarity="78">
<source file="django/django/core/checks/security/sessions.py.pyindent" startline="68" endline="78" pcid="3699">
    errors = []
    if not settings.SESSION_COOKIE_SECURE:
        if _session_app():
            errors.append(W010)
        if _session_middleware():
            errors.append(W011)
        if len(errors) > 1:
            errors = [W012]
    return errors


</source>
<source file="django/django/core/checks/security/sessions.py.pyindent" startline="81" endline="91" pcid="3704">
    errors = []
    if not settings.SESSION_COOKIE_HTTPONLY:
        if _session_app():
            errors.append(W013)
        if _session_middleware():
            errors.append(W014)
        if len(errors) > 1:
            errors = [W015]
    return errors


</source>
</class>

<class classid="41" nclones="2" nlines="16" similarity="93">
<source file="django/django/core/files/storage.py.pyindent" startline="310" endline="318" pcid="3948">
        path = self.path(path)
        directories, files = [], []
        for entry in os.listdir(path):
            if os.path.isdir(os.path.join(path, entry)):
                directories.append(entry)
            else:
                files.append(entry)
        return directories, files

</source>
<source file="django/tests/staticfiles_tests/storage.py.pyindent" startline="40" endline="48" pcid="24056">
        path = self._path(path)
        directories, files = [], []
        for entry in os.listdir(path):
            if os.path.isdir(os.path.join(path, entry)):
                directories.append(entry)
            else:
                files.append(entry)
        return directories, files

</source>
</class>

<class classid="42" nclones="3" nlines="11" similarity="72">
<source file="django/django/core/files/utils.py.pyindent" startline="31" endline="36" pcid="4031">
        if self.closed:
            return False
        if hasattr(self.file, 'readable'):
            return self.file.readable()
        return True

</source>
<source file="django/django/core/files/utils.py.pyindent" startline="38" endline="43" pcid="4034">
        if self.closed:
            return False
        if hasattr(self.file, 'writable'):
            return self.file.writable()
        return 'w' in getattr(self.file, 'mode', '')

</source>
<source file="django/django/core/files/utils.py.pyindent" startline="45" endline="50" pcid="4037">
        if self.closed:
            return False
        if hasattr(self.file, 'seekable'):
            return self.file.seekable()
        return True

</source>
</class>

<class classid="43" nclones="2" nlines="16" similarity="87">
<source file="django/django/core/mail/__init__.py.pyindent" startline="91" endline="103" pcid="4192">
    """Send a message to the admins, as defined by the ADMINS setting."""
    if not settings.ADMINS:
        return
    mail = EmailMultiAlternatives(
        '%s%s' % (settings.EMAIL_SUBJECT_PREFIX, subject), message,
        settings.SERVER_EMAIL, [a[1] for a in settings.ADMINS],
        connection=connection,
    )
    if html_message:
        mail.attach_alternative(html_message, 'text/html')
    mail.send(fail_silently=fail_silently)


</source>
<source file="django/django/core/mail/__init__.py.pyindent" startline="106" endline="116" pcid="4195">
    """Send a message to the managers, as defined by the MANAGERS setting."""
    if not settings.MANAGERS:
        return
    mail = EmailMultiAlternatives(
        '%s%s' % (settings.EMAIL_SUBJECT_PREFIX, subject), message,
        settings.SERVER_EMAIL, [a[1] for a in settings.MANAGERS],
        connection=connection,
    )
    if html_message:
        mail.attach_alternative(html_message, 'text/html')
    mail.send(fail_silently=fail_silently)
</source>
</class>

<class classid="44" nclones="2" nlines="20" similarity="90">
<source file="django/django/core/management/sql.py.pyindent" startline="22" endline="37" pcid="4514">
    # Emit the pre_migrate signal for every application.
    for app_config in apps.get_app_configs():
        if app_config.models_module is None:
            continue
        if verbosity >= 2:
            print("Running pre-migrate handlers for application %s" % app_config.label)
        models.signals.pre_migrate.send(
            sender=app_config,
            app_config=app_config,
            verbosity=verbosity,
            interactive=interactive,
            using=db,
            **kwargs
        )


</source>
<source file="django/django/core/management/sql.py.pyindent" startline="39" endline="52" pcid="4518">
    # Emit the post_migrate signal for every application.
    for app_config in apps.get_app_configs():
        if app_config.models_module is None:
            continue
        if verbosity >= 2:
            print("Running post-migrate handlers for application %s" % app_config.label)
        models.signals.post_migrate.send(
            sender=app_config,
            app_config=app_config,
            verbosity=verbosity,
            interactive=interactive,
            using=db,
            **kwargs
        )
</source>
</class>

<class classid="45" nclones="3" nlines="12" similarity="83">
<source file="django/django/core/serializers/__init__.py.pyindent" startline="86" endline="93" pcid="4575">
    "Unregister a given serializer. This is not a thread-safe operation."
    if not _serializers:
        _load_serializers()
    if format not in _serializers:
        raise SerializerDoesNotExist(format)
    del _serializers[format]


</source>
<source file="django/django/core/serializers/__init__.py.pyindent" startline="115" endline="121" pcid="4585">
    if not _serializers:
        _load_serializers()
    if format not in _serializers:
        raise SerializerDoesNotExist(format)
    return _serializers[format].Deserializer


</source>
<source file="django/django/core/serializers/__init__.py.pyindent" startline="95" endline="101" pcid="4578">
    if not _serializers:
        _load_serializers()
    if format not in _serializers:
        raise SerializerDoesNotExist(format)
    return _serializers[format].Serializer


</source>
</class>

<class classid="46" nclones="2" nlines="10" similarity="90">
<source file="django/django/core/serializers/__init__.py.pyindent" startline="186" endline="192" pcid="4601">
                if field.remote_field:
                    rel_model = field.remote_field.model
                    if hasattr(rel_model, 'natural_key') and rel_model != model:
                        deps.append(rel_model)
            # Also add a dependency for any simple M2M relation with a model
            # that defines a natural key.  M2M relations with explicit through
            # models don't count as dependencies.
</source>
<source file="django/django/core/serializers/__init__.py.pyindent" startline="194" endline="197" pcid="4604">
                if field.remote_field.through._meta.auto_created:
                    rel_model = field.remote_field.model
                    if hasattr(rel_model, 'natural_key') and rel_model != model:
                        deps.append(rel_model)
</source>
</class>

<class classid="47" nclones="2" nlines="23" similarity="73">
<source file="django/django/db/backends/ddl_references.py.pyindent" startline="77" endline="93" pcid="4682">
    """Hold a reference to one or many columns."""

    def __init__(self, table, columns, quote_name, col_suffixes=()):
        self.quote_name = quote_name
        self.col_suffixes = col_suffixes
        super().__init__(table, columns)

    def __str__(self):
        def col_str(column, idx):
            try:
                return self.quote_name(column) + self.col_suffixes[idx]
            except IndexError:
                return self.quote_name(column)

        return ', '.join(col_str(column, idx) for idx, column in enumerate(self.columns))


</source>
<source file="django/django/db/backends/ddl_references.py.pyindent" startline="107" endline="123" pcid="4691">
    def __init__(self, table, columns, quote_name, col_suffixes=(), opclasses=()):
        self.opclasses = opclasses
        super().__init__(table, columns, quote_name, col_suffixes)

    def __str__(self):
        def col_str(column, idx):
            try:
                col = self.quote_name(column) + self.col_suffixes[idx]
            except IndexError:
                col = self.quote_name(column)
            # Index.__init__() guarantees that self.opclasses is the same
            # length as self.columns.
            return '{} {}'.format(col, self.opclasses[idx])

        return ', '.join(col_str(column, idx) for idx, column in enumerate(self.columns))


</source>
</class>

<class classid="48" nclones="2" nlines="11" similarity="81">
<source file="django/django/db/backends/mysql/creation.py.pyindent" startline="34" endline="40" pcid="4752">
            if len(e.args) < 1 or e.args[0] != 1007:
                # All errors except "database exists" (1007) cancel tests.
                self.log('Got an error creating the test database: %s' % e)
                sys.exit(2)
            else:
                raise e

</source>
<source file="django/django/db/backends/postgresql/creation.py.pyindent" startline="44" endline="52" pcid="4847">
            if getattr(e.__cause__, 'pgcode', '') != errorcodes.DUPLICATE_DATABASE:
                # All errors except "database already exists" cancel tests.
                self.log('Got an error creating the test database: %s' % e)
                sys.exit(2)
            elif not keepdb:
                # If the database should be kept, ignore "database already
                # exists".
                raise e

</source>
</class>

<class classid="49" nclones="2" nlines="25" similarity="92">
<source file="django/django/db/backends/mysql/creation.py.pyindent" startline="49" endline="62" pcid="4756">
            try:
                self._execute_create_test_db(cursor, test_db_params, keepdb)
            except Exception:
                try:
                    if verbosity >= 1:
                        self.log('Destroying old test database for alias %s...' % (
                            self._get_database_display_str(verbosity, target_database_name),
                        ))
                    cursor.execute('DROP DATABASE %(dbname)s' % test_db_params)
                    self._execute_create_test_db(cursor, test_db_params, keepdb)
                except Exception as e:
                    self.log('Got an error recreating the test database: %s' % e)
                    sys.exit(2)

</source>
<source file="django/django/db/backends/postgresql/creation.py.pyindent" startline="65" endline="77" pcid="4851">
            try:
                self._execute_create_test_db(cursor, test_db_params, keepdb)
            except Exception as e:
                try:
                    if verbosity >= 1:
                        self.log('Destroying old test database for alias %s...' % (
                            self._get_database_display_str(verbosity, target_database_name),
                        ))
                    cursor.execute('DROP DATABASE %(dbname)s' % test_db_params)
                    self._execute_create_test_db(cursor, test_db_params, keepdb)
                except Exception as e:
                    self.log('Got an error cloning the test database: %s' % e)
                    sys.exit(2)
</source>
</class>

<class classid="50" nclones="2" nlines="10" similarity="80">
<source file="django/django/db/backends/sqlite3/operations.py.pyindent" startline="234" endline="238" pcid="4989">
        if value is not None:
            if not isinstance(value, datetime.date):
                value = parse_date(value)
        return value

</source>
<source file="django/django/db/backends/sqlite3/operations.py.pyindent" startline="240" endline="244" pcid="4992">
        if value is not None:
            if not isinstance(value, datetime.time):
                value = parse_time(value)
        return value

</source>
</class>

<class classid="51" nclones="2" nlines="32" similarity="77">
<source file="django/django/db/migrations/migration.py.pyindent" startline="91" endline="126" pcid="5036">
        """
        Take a project_state representing all migrations prior to this one
        and a schema_editor for a live database and apply the migration
        in a forwards order.

        Return the resulting project state for efficient reuse by following
        Migrations.
        """
        for operation in self.operations:
            # If this operation cannot be represented as SQL, place a comment
            # there instead
            if collect_sql:
                schema_editor.collected_sql.append("--")
                if not operation.reduces_to_sql:
                    schema_editor.collected_sql.append(
                        "-- MIGRATION NOW PERFORMS OPERATION THAT CANNOT BE WRITTEN AS SQL:"
                    )
                schema_editor.collected_sql.append("-- %s" % operation.describe())
                schema_editor.collected_sql.append("--")
                if not operation.reduces_to_sql:
                    continue
            # Save the state before the operation has run
            old_state = project_state.clone()
            operation.state_forwards(self.app_label, project_state)
            # Run the operation
            atomic_operation = operation.atomic or (self.atomic and operation.atomic is not False)
            if not schema_editor.atomic_migration and atomic_operation:
                # Force a transaction on a non-transactional-DDL backend or an
                # atomic operation inside a non-atomic migration.
                with atomic(schema_editor.connection.alias):
                    operation.database_forwards(self.app_label, schema_editor, old_state, project_state)
            else:
                # Normal behaviour
                operation.database_forwards(self.app_label, schema_editor, old_state, project_state)
        return project_state

</source>
<source file="django/django/db/migrations/migration.py.pyindent" startline="157" endline="175" pcid="5047">
            if collect_sql:
                schema_editor.collected_sql.append("--")
                if not operation.reduces_to_sql:
                    schema_editor.collected_sql.append(
                        "-- MIGRATION NOW PERFORMS OPERATION THAT CANNOT BE WRITTEN AS SQL:"
                    )
                schema_editor.collected_sql.append("-- %s" % operation.describe())
                schema_editor.collected_sql.append("--")
                if not operation.reduces_to_sql:
                    continue
            atomic_operation = operation.atomic or (self.atomic and operation.atomic is not False)
            if not schema_editor.atomic_migration and atomic_operation:
                # Force a transaction on a non-transactional-DDL backend or an
                # atomic operation inside a non-atomic migration.
                with atomic(schema_editor.connection.alias):
                    operation.database_backwards(self.app_label, schema_editor, from_state, to_state)
            else:
                # Normal behaviour
                operation.database_backwards(self.app_label, schema_editor, from_state, to_state)
</source>
</class>

<class classid="52" nclones="3" nlines="10" similarity="72">
<source file="django/django/db/migrations/operations/fields.py.pyindent" startline="43" endline="47" pcid="5086">
            if name == self.name:
                return True
            elif self.field and hasattr(self.field, 'from_fields') and name in self.field.from_fields:
                return True
        # Check if this operation remotely references the field.
</source>
<source file="django/tests/admin_ordering/tests.py.pyindent" startline="18" endline="24" pcid="9144">
    def has_perm(self, perm):
        return True

    def has_module_perms(self, module):
        return True


</source>
<source file="django/django/db/migrations/operations/utils.py.pyindent" startline="48" endline="52" pcid="5236">
        if ModelTuple.from_model(remote_field.model) == model_tuple:
            return True
        through = getattr(remote_field, 'through', None)
        if through and ModelTuple.from_model(through) == model_tuple:
            return True
</source>
</class>

<class classid="53" nclones="2" nlines="15" similarity="100">
<source file="django/django/db/migrations/operations/fields.py.pyindent" startline="78" endline="90" pcid="5096">
        kwargs = {
            'model_name': self.model_name,
            'name': self.name,
            'field': self.field,
        }
        if self.preserve_default is not True:
            kwargs['preserve_default'] = self.preserve_default
        return (
            self.__class__.__name__,
            [],
            kwargs
        )

</source>
<source file="django/django/db/migrations/operations/fields.py.pyindent" startline="207" endline="219" pcid="5128">
        kwargs = {
            'model_name': self.model_name,
            'name': self.name,
            'field': self.field,
        }
        if self.preserve_default is not True:
            kwargs['preserve_default'] = self.preserve_default
        return (
            self.__class__.__name__,
            [],
            kwargs
        )

</source>
</class>

<class classid="54" nclones="2" nlines="11" similarity="81">
<source file="django/django/db/migrations/operations/fields.py.pyindent" startline="152" endline="161" pcid="5114">
        kwargs = {
            'model_name': self.model_name,
            'name': self.name,
        }
        return (
            self.__class__.__name__,
            [],
            kwargs
        )

</source>
<source file="django/django/db/migrations/operations/fields.py.pyindent" startline="291" endline="301" pcid="5146">
        kwargs = {
            'model_name': self.model_name,
            'old_name': self.old_name,
            'new_name': self.new_name,
        }
        return (
            self.__class__.__name__,
            [],
            kwargs
        )

</source>
</class>

<class classid="55" nclones="2" nlines="12" similarity="83">
<source file="django/django/db/migrations/operations/fields.py.pyindent" startline="358" endline="366" pcid="5160">
        to_model = to_state.apps.get_model(app_label, self.model_name)
        if self.allow_migrate_model(schema_editor.connection.alias, to_model):
            from_model = from_state.apps.get_model(app_label, self.model_name)
            schema_editor.alter_field(
                from_model,
                from_model._meta.get_field(self.old_name),
                to_model._meta.get_field(self.new_name),
            )

</source>
<source file="django/django/db/migrations/operations/fields.py.pyindent" startline="368" endline="376" pcid="5162">
        to_model = to_state.apps.get_model(app_label, self.model_name)
        if self.allow_migrate_model(schema_editor.connection.alias, to_model):
            from_model = from_state.apps.get_model(app_label, self.model_name)
            schema_editor.alter_field(
                from_model,
                from_model._meta.get_field(self.new_name),
                to_model._meta.get_field(self.old_name),
            )

</source>
</class>

<class classid="56" nclones="2" nlines="21" similarity="76">
<source file="django/django/db/migrations/operations/special.py.pyindent" startline="80" endline="94" pcid="5183">
        kwargs = {
            'sql': self.sql,
        }
        if self.reverse_sql is not None:
            kwargs['reverse_sql'] = self.reverse_sql
        if self.state_operations:
            kwargs['state_operations'] = self.state_operations
        if self.hints:
            kwargs['hints'] = self.hints
        return (
            self.__class__.__qualname__,
            [],
            kwargs
        )

</source>
<source file="django/django/db/migrations/operations/special.py.pyindent" startline="157" endline="171" pcid="5210">
        kwargs = {
            'code': self.code,
        }
        if self.reverse_code is not None:
            kwargs['reverse_code'] = self.reverse_code
        if self.atomic is not None:
            kwargs['atomic'] = self.atomic
        if self.hints:
            kwargs['hints'] = self.hints
        return (
            self.__class__.__qualname__,
            [],
            kwargs
        )

</source>
</class>

<class classid="57" nclones="2" nlines="10" similarity="80">
<source file="django/django/db/migrations/operations/special.py.pyindent" startline="108" endline="112" pcid="5192">
        if self.reverse_sql is None:
            raise NotImplementedError("You cannot reverse this operation")
        if router.allow_migrate(schema_editor.connection.alias, app_label, **self.hints):
            self._run_sql(schema_editor, self.reverse_sql)

</source>
<source file="django/django/db/migrations/operations/special.py.pyindent" startline="193" endline="197" pcid="5218">
        if self.reverse_code is None:
            raise NotImplementedError("You cannot reverse this operation")
        if router.allow_migrate(schema_editor.connection.alias, app_label, **self.hints):
            self.reverse_code(from_state.apps, schema_editor)

</source>
</class>

<class classid="58" nclones="2" nlines="23" similarity="73">
<source file="django/django/db/migrations/questioner.py.pyindent" startline="144" endline="161" pcid="5293">
        """Adding a NOT NULL field to a model."""
        if not self.dry_run:
            choice = self._choice_input(
                "You are trying to add a non-nullable field '%s' to %s without a default; "
                "we can't do that (the database needs something to populate existing rows).\n"
                "Please select a fix:" % (field_name, model_name),
                [
                    ("Provide a one-off default now (will be set on all existing "
                     "rows with a null value for this column)"),
                    "Quit, and let me add a default in models.py",
                ]
            )
            if choice == 2:
                sys.exit(3)
            else:
                return self._ask_default()
        return None

</source>
<source file="django/django/db/migrations/questioner.py.pyindent" startline="208" endline="226" pcid="5305">
        """Adding an auto_now_add field to a model."""
        if not self.dry_run:
            choice = self._choice_input(
                "You are trying to add the field '{}' with 'auto_now_add=True' "
                "to {} without a default; the database needs something to "
                "populate existing rows.\n".format(field_name, model_name),
                [
                    "Provide a one-off default now (will be set on all "
                    "existing rows)",
                    "Quit, and let me add a default in models.py",
                ]
            )
            if choice == 2:
                sys.exit(3)
            else:
                return self._ask_default(default='timezone.now')
        return None


</source>
</class>

<class classid="59" nclones="3" nlines="19" similarity="70">
<source file="django/django/db/migrations/writer.py.pyindent" startline="44" endline="55" pcid="5326">
                        key_string, key_imports = MigrationWriter.serialize(key)
                        arg_string, arg_imports = MigrationWriter.serialize(value)
                        args = arg_string.splitlines()
                        if len(args) > 1:
                            self.feed('%s: %s' % (key_string, args[0]))
                            for arg in args[1:-1]:
                                self.feed(arg)
                            self.feed('%s,' % args[-1])
                        else:
                            self.feed('%s: %s,' % (key_string, arg_string))
                        imports.update(key_imports)
                        imports.update(arg_imports)
</source>
<source file="django/django/db/migrations/writer.py.pyindent" startline="62" endline="70" pcid="5331">
                        arg_string, arg_imports = MigrationWriter.serialize(item)
                        args = arg_string.splitlines()
                        if len(args) > 1:
                            for arg in args[:-1]:
                                self.feed(arg)
                            self.feed('%s,' % args[-1])
                        else:
                            self.feed('%s,' % arg_string)
                        imports.update(arg_imports)
</source>
<source file="django/django/db/migrations/writer.py.pyindent" startline="74" endline="84" pcid="5335">
                arg_string, arg_imports = MigrationWriter.serialize(_arg_value)
                args = arg_string.splitlines()
                if len(args) > 1:
                    self.feed('%s=%s' % (_arg_name, args[0]))
                    for arg in args[1:-1]:
                        self.feed(arg)
                    self.feed('%s,' % args[-1])
                else:
                    self.feed('%s=%s,' % (_arg_name, arg_string))
                imports.update(arg_imports)

</source>
</class>

<class classid="60" nclones="2" nlines="12" similarity="75">
<source file="django/django/db/models/fields/related_lookups.py.pyindent" startline="48" endline="61" pcid="5490">
        if not isinstance(self.lhs, MultiColSource) and self.rhs_is_direct_value():
            # If we get here, we are dealing with single-column relations.
            self.rhs = [get_normalized_value(val, self.lhs)[0] for val in self.rhs]
            # We need to run the related field's get_prep_value(). Consider case
            # ForeignKey to IntegerField given value 'abc'. The ForeignKey itself
            # doesn't have validation for non-integers, so we must run validation
            # using the target field.
            if hasattr(self.lhs.output_field, 'get_path_info'):
                # Run the target field's get_prep_value. We can safely assume there is
                # only one as we don't get to the direct value branch otherwise.
                target_field = self.lhs.output_field.get_path_info()[-1].target_fields[-1]
                self.rhs = [target_field.get_prep_value(v) for v in self.rhs]
        return super().get_prep_lookup()

</source>
<source file="django/django/db/models/fields/related_lookups.py.pyindent" startline="104" endline="118" pcid="5504">
        if not isinstance(self.lhs, MultiColSource) and self.rhs_is_direct_value():
            # If we get here, we are dealing with single-column relations.
            self.rhs = get_normalized_value(self.rhs, self.lhs)[0]
            # We need to run the related field's get_prep_value(). Consider case
            # ForeignKey to IntegerField given value 'abc'. The ForeignKey itself
            # doesn't have validation for non-integers, so we must run validation
            # using the target field.
            if self.prepare_rhs and hasattr(self.lhs.output_field, 'get_path_info'):
                # Get the target field. We can safely assume there is only one
                # as we don't get to the direct value branch otherwise.
                target_field = self.lhs.output_field.get_path_info()[-1].target_fields[-1]
                self.rhs = target_field.get_prep_value(self.rhs)

        return super().get_prep_lookup()

</source>
</class>

<class classid="61" nclones="2" nlines="11" similarity="81">
<source file="django/django/db/models/fields/reverse_related.py.pyindent" startline="194" endline="204" pcid="5545">
        super().__init__(
            field, to,
            related_name=related_name,
            related_query_name=related_query_name,
            limit_choices_to=limit_choices_to,
            parent_link=parent_link,
            on_delete=on_delete,
        )

        self.field_name = field_name

</source>
<source file="django/django/db/models/fields/reverse_related.py.pyindent" startline="233" endline="244" pcid="5551">
        super().__init__(
            field, to, field_name,
            related_name=related_name,
            related_query_name=related_query_name,
            limit_choices_to=limit_choices_to,
            parent_link=parent_link,
            on_delete=on_delete,
        )

        self.multiple = False


</source>
</class>

<class classid="62" nclones="2" nlines="15" similarity="80">
<source file="django/django/db/models/functions/comparison.py.pyindent" startline="55" endline="73" pcid="5572">
    """
    Return the maximum expression.

    If any expression is null the return value is database-specific:
    On PostgreSQL, the maximum not-null expression is returned.
    On MySQL, Oracle, and SQLite, if any expression is null, null is returned.
    """
    function = 'GREATEST'

    def __init__(self, *expressions, **extra):
        if len(expressions) < 2:
            raise ValueError('Greatest must take at least two expressions')
        super().__init__(*expressions, **extra)

    def as_sqlite(self, compiler, connection):
        """Use the MAX function on SQLite."""
        return super().as_sqlite(compiler, connection, function='MAX')


</source>
<source file="django/django/db/models/functions/comparison.py.pyindent" startline="75" endline="91" pcid="5576">
    """
    Return the minimum expression.

    If any expression is null the return value is database-specific:
    On PostgreSQL, return the minimum not-null expression.
    On MySQL, Oracle, and SQLite, if any expression is null, return null.
    """
    function = 'LEAST'

    def __init__(self, *expressions, **extra):
        if len(expressions) < 2:
            raise ValueError('Least must take at least two expressions')
        super().__init__(*expressions, **extra)

    def as_sqlite(self, compiler, connection):
        """Use the MIN function on SQLite."""
        return super().as_sqlite(compiler, connection, function='MIN')
</source>
</class>

<class classid="63" nclones="2" nlines="12" similarity="75">
<source file="django/django/forms/formsets.py.pyindent" startline="217" endline="222" pcid="6080">
                form = self.forms[i]
                # if this is an extra form and hasn't changed, don't consider it
                if i >= self.initial_form_count() and not form.has_changed():
                    continue
                if self._should_delete_form(form):
                    self._deleted_form_indexes.append(i)
</source>
<source file="django/django/forms/formsets.py.pyindent" startline="240" endline="253" pcid="6086">
                form = self.forms[i]
                # if this is an extra form and hasn't changed, don't consider it
                if i >= self.initial_form_count() and not form.has_changed():
                    continue
                # don't add data marked for deletion to self.ordered_data
                if self.can_delete and self._should_delete_form(form):
                    continue
                self._ordering.append((i, form.cleaned_data[ORDERING_FIELD_NAME]))
            # After we're done populating self._ordering, sort it.
            # A sort function to order things numerically ascending, but
            # None should be sorted below anything else. Allowing None as
            # a comparison value makes it so we can leave ordering fields
            # blank.

</source>
</class>

<class classid="64" nclones="3" nlines="14" similarity="71">
<source file="django/django/template/defaultfilters.py.pyindent" startline="222" endline="238" pcid="6352">
    """
    Format the variable according to the arg, a string formatting specifier.

    This specifier uses Python string formatting syntax, with the exception
    that the leading "%" is dropped.

    See https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting
    for documentation of Python string formatting.
    """
    if isinstance(value, tuple):
        value = str(value)
    try:
        return ("%" + str(arg)) % value
    except (ValueError, TypeError):
        return ""


</source>
<source file="django/django/template/defaultfilters.py.pyindent" startline="738" endline="750" pcid="6467">
    """Format a date as the time until that date (i.e. "4 days, 6 hours")."""
    if not value:
        return ''
    try:
        return timeuntil(value, arg)
    except (ValueError, TypeError):
        return ''


###################
# LOGIC           #
###################

</source>
<source file="django/django/template/defaultfilters.py.pyindent" startline="725" endline="735" pcid="6462">
    """Format a date as the time since that date (i.e. "4 days, 6 hours")."""
    if not value:
        return ''
    try:
        if arg:
            return timesince(value, arg)
        return timesince(value)
    except (ValueError, TypeError):
        return ''


</source>
</class>

<class classid="65" nclones="2" nlines="21" similarity="80">
<source file="django/django/template/defaultfilters.py.pyindent" startline="697" endline="708" pcid="6450">
    """Format a date according to the given format."""
    if value in (None, ''):
        return ''
    try:
        return formats.date_format(value, arg)
    except AttributeError:
        try:
            return format(value, arg)
        except AttributeError:
            return ''


</source>
<source file="django/django/template/defaultfilters.py.pyindent" startline="711" endline="722" pcid="6456">
    """Format a time according to the given format."""
    if value in (None, ''):
        return ''
    try:
        return formats.time_format(value, arg)
    except (AttributeError, TypeError):
        try:
            return time_format(value, arg)
        except (AttributeError, TypeError):
            return ''


</source>
</class>

<class classid="66" nclones="3" nlines="14" similarity="71">
<source file="django/django/template/defaultfilters.py.pyindent" startline="887" endline="891" pcid="6500">
        try:
            if len(value) != 1:
                return plural_suffix
        except TypeError:  # len() of unsized object.
            pass
</source>
<source file="django/tests/transaction_hooks/tests.py.pyindent" startline="127" endline="133" pcid="27145">
                self.do(1)
                try:
                    with transaction.atomic():
                        raise ForcedError()
                except ForcedError:
                    pass

</source>
<source file="django/tests/transaction_hooks/tests.py.pyindent" startline="115" endline="121" pcid="27139">
                self.do(1)
                try:
                    with transaction.atomic(savepoint=False):
                        raise ForcedError()
                except ForcedError:
                    pass

</source>
</class>

<class classid="67" nclones="2" nlines="15" similarity="81">
<source file="django/django/template/loader.py.pyindent" startline="6" endline="21" pcid="6558">
    """
    Load and return a template for the given name.

    Raise TemplateDoesNotExist if no such template exists.
    """
    chain = []
    engines = _engine_list(using)
    for engine in engines:
        try:
            return engine.get_template(template_name)
        except TemplateDoesNotExist as e:
            chain.append(e)

    raise TemplateDoesNotExist(template_name, chain=chain)


</source>
<source file="django/django/template/loader.py.pyindent" startline="40" endline="45" pcid="6564">
        for engine in engines:
            try:
                return engine.get_template(template_name)
            except TemplateDoesNotExist as e:
                chain.append(e)

</source>
</class>

<class classid="68" nclones="2" nlines="24" similarity="83">
<source file="django/django/template/smartif.py.pyindent" startline="44" endline="67" pcid="6636">
    """
    Create an infix operator, given a binding power and a function that
    evaluates the node.
    """
    class Operator(TokenBase):
        lbp = bp

        def led(self, left, parser):
            self.first = left
            self.second = parser.expression(bp)
            return self

        def eval(self, context):
            try:
                return func(context, self.first, self.second)
            except Exception:
                # Templates shouldn't throw exceptions when rendering.  We are
                # most likely to get exceptions for things like {% if foo in bar
                # %} where 'bar' does not support 'in', so default to False
                return False

    return Operator


</source>
<source file="django/django/template/smartif.py.pyindent" startline="69" endline="92" pcid="6642">
    """
    Create a prefix operator, given a binding power and a function that
    evaluates the node.
    """
    class Operator(TokenBase):
        lbp = bp

        def nud(self, parser):
            self.first = parser.expression(bp)
            self.second = None
            return self

        def eval(self, context):
            try:
                return func(context, self.first)
            except Exception:
                return False

    return Operator


# Operator precedence follows Python.
# We defer variable evaluation to the lambda to ensure that terms are
# lazily evaluated using Python's boolean parsing logic.
</source>
</class>

<class classid="69" nclones="4" nlines="10" similarity="70">
<source file="django/django/test/html.py.pyindent" startline="129" endline="135" pcid="6818">
    def __init__(self):
        super().__init__(None, ())

    def __str__(self):
        return ''.join(str(c) for c in self.children)


</source>
<source file="django/tests/forms_tests/field_tests/test_charfield.py.pyindent" startline="134" endline="139" pcid="13974">
            def __init__(self, v):
                self.v = v

            def __str__(self):
                return self.v

</source>
<source file="django/tests/messages_tests/test_api.py.pyindent" startline="6" endline="16" pcid="18744">
    """
    dummy message-store to test the api methods
    """

    def __init__(self):
        self.store = []

    def add(self, level, message, extra_tags=''):
        self.store.append(message)


</source>
<source file="django/tests/utils_tests/test_html.py.pyindent" startline="211" endline="217" pcid="27896">
            def __html__(self):
                # defines __html__ on its own
                return 'some html content'

            def __str__(self):
                return 'some non html content'

</source>
</class>

<class classid="70" nclones="3" nlines="18" similarity="72">
<source file="django/django/urls/base.py.pyindent" startline="175" endline="182" pcid="7002">
        to_be_reversed = "%s:%s" % (match.namespace, match.url_name) if match.namespace else match.url_name
        with override(lang_code):
            try:
                url = reverse(to_be_reversed, args=match.args, kwargs=match.kwargs)
            except NoReverseMatch:
                pass
            else:
                url = urlunsplit((parsed.scheme, parsed.netloc, url, parsed.query, parsed.fragment))
</source>
<source file="django/tests/urlpatterns_reverse/tests.py.pyindent" startline="281" endline="288" pcid="27338">
            with self.subTest(name=name, args=args, kwargs=kwargs):
                try:
                    got = reverse(name, args=args, kwargs=kwargs)
                except NoReverseMatch:
                    self.assertEqual(NoReverseMatch, expected)
                else:
                    self.assertEqual(got, expected)

</source>
<source file="django/tests/get_or_create/tests.py.pyindent" startline="239" endline="255" pcid="16066">

    available_apps = ['get_or_create']

    def test_get_or_create_integrityerror(self):
        """
        Regression test for #15117. Requires a TransactionTestCase on
        databases that delay integrity checks until the end of transactions,
        otherwise the exception is never raised.
        """
        try:
            Profile.objects.get_or_create(person=Person(id=1))
        except IntegrityError:
            pass
        else:
            self.skipTest("This backend does not support integrity checks.")


</source>
</class>

<class classid="71" nclones="2" nlines="10" similarity="70">
<source file="django/django/utils/decorators.py.pyindent" startline="9" endline="14" pcid="7236">
    def __get__(self, instance, cls=None):
        if instance is not None:
            raise AttributeError("This method is available only on the class, not on instances.")
        return super().__get__(instance, cls)


</source>
<source file="django/tests/model_meta/models.py.pyindent" startline="13" endline="18" pcid="20666">
    def __get__(self, instance, cls=None):
        if instance is None:
            raise AttributeError('Instance only')
        return 1


</source>
</class>

<class classid="72" nclones="2" nlines="10" similarity="70">
<source file="django/django/utils/six.py.pyindent" startline="742" endline="745" pcid="7607">
            if isinstance(sep, unicode):
                want_unicode = True
            elif not isinstance(sep, str):
                raise TypeError("sep must be None or a string")
</source>
<source file="django/django/utils/six.py.pyindent" startline="748" endline="751" pcid="7610">
            if isinstance(end, unicode):
                want_unicode = True
            elif not isinstance(end, str):
                raise TypeError("end must be None or a string")
</source>
</class>

<class classid="73" nclones="2" nlines="24" similarity="70">
<source file="django/django/utils/translation/template.py.pyindent" startline="84" endline="100" pcid="7808">
                        if message_context:
                            out.write(' npgettext({p}{!r}, {p}{!r}, {p}{!r},count) '.format(
                                message_context,
                                join_tokens(singular, trimmed),
                                join_tokens(plural, trimmed),
                                p=raw_prefix,
                            ))
                        else:
                            out.write(' ngettext({p}{!r}, {p}{!r}, count) '.format(
                                join_tokens(singular, trimmed),
                                join_tokens(plural, trimmed),
                                p=raw_prefix,
                            ))
                        for part in singular:
                            out.write(blankout(part, 'S'))
                        for part in plural:
                            out.write(blankout(part, 'P'))
</source>
<source file="django/django/utils/translation/template.py.pyindent" startline="102" endline="114" pcid="7813">
                        if message_context:
                            out.write(' pgettext({p}{!r}, {p}{!r}) '.format(
                                message_context,
                                join_tokens(singular, trimmed),
                                p=raw_prefix,
                            ))
                        else:
                            out.write(' gettext({p}{!r}) '.format(
                                join_tokens(singular, trimmed),
                                p=raw_prefix,
                            ))
                        for part in singular:
                            out.write(blankout(part, 'S'))
</source>
</class>

<class classid="74" nclones="2" nlines="14" similarity="73">
<source file="django/django/utils/translation/template.py.pyindent" startline="175" endline="185" pcid="7837">
                        # A context is provided
                        context_match = context_re.match(imatch.group(2))
                        message_context = context_match.group(1)
                        if message_context[0] == '"':
                            message_context = message_context.strip('"')
                        elif message_context[0] == "'":
                            message_context = message_context.strip("'")
                        out.write(' pgettext({p}{!r}, {p}{!r}) '.format(
                            message_context, g, p=raw_prefix
                        ))
                        message_context = None
</source>
<source file="django/django/utils/translation/template.py.pyindent" startline="192" endline="198" pcid="7843">
                        # A context is provided
                        context_match = context_re.match(bmatch.group(1))
                        message_context = context_match.group(1)
                        if message_context[0] == '"':
                            message_context = message_context.strip('"')
                        elif message_context[0] == "'":
                            message_context = message_context.strip("'")
</source>
</class>

<class classid="75" nclones="2" nlines="13" similarity="84">
<source file="django/django/utils/translation/trans_real.py.pyindent" startline="260" endline="274" pcid="7920">
    """
    Return the current active catalog for further processing.
    This can be used if you need to modify the catalog or want to access the
    whole message catalog instead of just translating one string.
    """
    global _default

    t = getattr(_active, "value", None)
    if t is not None:
        return t
    if _default is None:
        _default = translation(settings.LANGUAGE_CODE)
    return _default


</source>
<source file="django/django/utils/translation/trans_real.py.pyindent" startline="323" endline="332" pcid="7931">
    global _default

    t = getattr(_active, "value", None)
    if t is not None:
        return getattr(t, translation_function)(singular, plural, number)
    if _default is None:
        _default = translation(settings.LANGUAGE_CODE)
    return getattr(_default, translation_function)(singular, plural, number)


</source>
</class>

<class classid="76" nclones="2" nlines="12" similarity="91">
<source file="django/django/views/decorators/clickjacking.py.pyindent" startline="5" endline="21" pcid="8033">
    """
    Modify a view function so its response has the X-Frame-Options HTTP
    header set to 'DENY' as long as the response doesn't already have that
    header set. Usage:

    @xframe_options_deny
    def some_view(request):
        ...
    """
    def wrapped_view(*args, **kwargs):
        resp = view_func(*args, **kwargs)
        if resp.get('X-Frame-Options') is None:
            resp['X-Frame-Options'] = 'DENY'
        return resp
    return wraps(view_func)(wrapped_view)


</source>
<source file="django/django/views/decorators/clickjacking.py.pyindent" startline="23" endline="39" pcid="8036">
    """
    Modify a view function so its response has the X-Frame-Options HTTP
    header set to 'SAMEORIGIN' as long as the response doesn't already have
    that header set. Usage:

    @xframe_options_sameorigin
    def some_view(request):
        ...
    """
    def wrapped_view(*args, **kwargs):
        resp = view_func(*args, **kwargs)
        if resp.get('X-Frame-Options') is None:
            resp['X-Frame-Options'] = 'SAMEORIGIN'
        return resp
    return wraps(view_func)(wrapped_view)


</source>
</class>

<class classid="77" nclones="2" nlines="10" similarity="90">
<source file="django/django/views/decorators/vary.py.pyindent" startline="18" endline="23" pcid="8075">
        @wraps(func)
        def inner_func(*args, **kwargs):
            response = func(*args, **kwargs)
            patch_vary_headers(response, headers)
            return response
        return inner_func
</source>
<source file="django/django/views/decorators/vary.py.pyindent" startline="28" endline="41" pcid="8077">
    """
    A view decorator that adds "Cookie" to the Vary header of a response. This
    indicates that a page's contents depends on cookies. Usage:

        @vary_on_cookie
        def index(request):
            ...
    """
    @wraps(func)
    def inner_func(*args, **kwargs):
        response = func(*args, **kwargs)
        patch_vary_headers(response, ('Cookie',))
        return response
    return inner_func
</source>
</class>

<class classid="78" nclones="3" nlines="15" similarity="75">
<source file="django/django/views/defaults.py.pyindent" startline="62" endline="77" pcid="8087">
    """
    500 error handler.

    Templates: :template:`500.html`
    Context: None
    """
    try:
        template = loader.get_template(template_name)
    except TemplateDoesNotExist:
        if template_name != ERROR_500_TEMPLATE_NAME:
            # Reraise if it's a missing custom template.
            raise
        return HttpResponseServerError('<h1>Server Error (500)</h1>', content_type='text/html')
    return HttpResponseServerError(template.render())


</source>
<source file="django/django/views/defaults.py.pyindent" startline="80" endline="99" pcid="8091">
    """
    400 error handler.

    Templates: :template:`400.html`
    Context: None
    """
    try:
        template = loader.get_template(template_name)
    except TemplateDoesNotExist:
        if template_name != ERROR_400_TEMPLATE_NAME:
            # Reraise if it's a missing custom template.
            raise
        return HttpResponseBadRequest('<h1>Bad Request (400)</h1>', content_type='text/html')
    # No exception content is passed to the template, to not disclose any sensitive information.
    return HttpResponseBadRequest(template.render())


# This can be called when CsrfViewMiddleware.process_view has not run,
# therefore need @requires_csrf_token in case the template needs
# {% csrf_token %}.
</source>
<source file="django/django/views/defaults.py.pyindent" startline="102" endline="120" pcid="8095">
    """
    Permission denied (403) handler.

    Templates: :template:`403.html`
    Context: None

    If the template does not exist, an Http403 response containing the text
    "403 Forbidden" (as per RFC 7231) will be returned.
    """
    try:
        template = loader.get_template(template_name)
    except TemplateDoesNotExist:
        if template_name != ERROR_403_TEMPLATE_NAME:
            # Reraise if it's a missing custom template.
            raise
        return HttpResponseForbidden('<h1>403 Forbidden</h1>', content_type='text/html')
    return HttpResponseForbidden(
        template.render(request=request, context={'exception': str(exception)})
    )
</source>
</class>

<class classid="79" nclones="4" nlines="22" similarity="72">
<source file="django/django/views/generic/dates.py.pyindent" startline="32" endline="43" pcid="8143">
        """Return the year for which this view should display data."""
        year = self.year
        if year is None:
            try:
                year = self.kwargs['year']
            except KeyError:
                try:
                    year = self.request.GET['year']
                except KeyError:
                    raise Http404(_("No year specified"))
        return year

</source>
<source file="django/django/views/generic/dates.py.pyindent" startline="81" endline="92" pcid="8157">
        """Return the month for which this view should display data."""
        month = self.month
        if month is None:
            try:
                month = self.kwargs['month']
            except KeyError:
                try:
                    month = self.request.GET['month']
                except KeyError:
                    raise Http404(_("No month specified"))
        return month

</source>
<source file="django/django/views/generic/dates.py.pyindent" startline="133" endline="144" pcid="8173">
        """Return the day for which this view should display data."""
        day = self.day
        if day is None:
            try:
                day = self.kwargs['day']
            except KeyError:
                try:
                    day = self.request.GET['day']
                except KeyError:
                    raise Http404(_("No day specified"))
        return day

</source>
<source file="django/django/views/generic/dates.py.pyindent" startline="179" endline="190" pcid="8185">
        """Return the week for which this view should display data."""
        week = self.week
        if week is None:
            try:
                week = self.kwargs['week']
            except KeyError:
                try:
                    week = self.request.GET['week']
                except KeyError:
                    raise Http404(_("No week specified"))
        return week

</source>
</class>

<class classid="80" nclones="2" nlines="11" similarity="72">
<source file="django/django/views/generic/edit.py.pyindent" startline="136" endline="147" pcid="8339">
        """
        Handle POST requests: instantiate a form instance with the passed
        POST variables and then check if it's valid.
        """
        form = self.get_form()
        if form.is_valid():
            return self.form_valid(form)
        else:
            return self.form_invalid(form)

    # PUT is a valid HTTP verb for creating (with a known URL) or editing an
    # object, note that browsers only support POST for now.
</source>
<source file="django/tests/test_client/views.py.pyindent" startline="205" endline="209" pcid="26512">
        form = TestForm(request.POST)
        if form.is_valid():
            message = 'POST data OK'
        else:
            message = 'POST data has errors'
</source>
</class>

<class classid="81" nclones="2" nlines="12" similarity="83">
<source file="django/django/views/generic/edit.py.pyindent" startline="161" endline="174" pcid="8343">
    """
    Base view for creating a new object instance.

    Using this base class requires subclassing to provide a response mixin.
    """
    def get(self, request, *args, **kwargs):
        self.object = None
        return super().get(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        self.object = None
        return super().post(request, *args, **kwargs)


</source>
<source file="django/django/views/generic/edit.py.pyindent" startline="183" endline="196" pcid="8347">
    """
    Base view for updating an existing object.

    Using this base class requires subclassing to provide a response mixin.
    """
    def get(self, request, *args, **kwargs):
        self.object = self.get_object()
        return super().get(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        self.object = self.get_object()
        return super().post(request, *args, **kwargs)


</source>
</class>

<class classid="82" nclones="3" nlines="15" similarity="80">
<source file="django/tests/admin_changelist/tests.py.pyindent" startline="131" endline="147" pcid="8599">
        """
        Regression test for #14982: EMPTY_CHANGELIST_VALUE should be honored
        for relationship fields
        """
        new_child = Child.objects.create(name='name', parent=None)
        request = self.factory.get('/child/')
        request.user = self.superuser
        m = ChildAdmin(Child, custom_site)
        cl = m.get_changelist_instance(request)
        cl.formset = None
        template = Template('{% load admin_list %}{% spaceless %}{% result_list cl %}{% endspaceless %}')
        context = Context({'cl': cl, 'opts': Child._meta})
        table_output = template.render(context)
        link = reverse('admin:admin_changelist_child_change', args=(new_child.id,))
        row_html = build_tbody_html(new_child.id, link, '<td class="field-parent nowrap">-</td>')
        self.assertNotEqual(table_output.find(row_html), -1, 'Failed to find expected row element: %s' % table_output)

</source>
<source file="django/tests/admin_changelist/tests.py.pyindent" startline="149" endline="166" pcid="8600">
        """
        Empty value display can be set on AdminSite.
        """
        new_child = Child.objects.create(name='name', parent=None)
        request = self.factory.get('/child/')
        request.user = self.superuser
        # Set a new empty display value on AdminSite.
        admin.site.empty_value_display = '???'
        m = ChildAdmin(Child, admin.site)
        cl = m.get_changelist_instance(request)
        cl.formset = None
        template = Template('{% load admin_list %}{% spaceless %}{% result_list cl %}{% endspaceless %}')
        context = Context({'cl': cl, 'opts': Child._meta})
        table_output = template.render(context)
        link = reverse('admin:admin_changelist_child_change', args=(new_child.id,))
        row_html = build_tbody_html(new_child.id, link, '<td class="field-parent nowrap">???</td>')
        self.assertNotEqual(table_output.find(row_html), -1, 'Failed to find expected row element: %s' % table_output)

</source>
<source file="django/tests/admin_changelist/tests.py.pyindent" startline="190" endline="207" pcid="8602">
        """
        Inclusion tag result_list generates a table when with default
        ModelAdmin settings.
        """
        new_parent = Parent.objects.create(name='parent')
        new_child = Child.objects.create(name='name', parent=new_parent)
        request = self.factory.get('/child/')
        request.user = self.superuser
        m = ChildAdmin(Child, custom_site)
        cl = m.get_changelist_instance(request)
        cl.formset = None
        template = Template('{% load admin_list %}{% spaceless %}{% result_list cl %}{% endspaceless %}')
        context = Context({'cl': cl, 'opts': Child._meta})
        table_output = template.render(context)
        link = reverse('admin:admin_changelist_child_change', args=(new_child.id,))
        row_html = build_tbody_html(new_child.id, link, '<td class="field-parent nowrap">%s</td>' % new_parent)
        self.assertNotEqual(table_output.find(row_html), -1, 'Failed to find expected row element: %s' % table_output)

</source>
</class>

<class classid="83" nclones="3" nlines="13" similarity="76">
<source file="django/tests/admin_changelist/tests.py.pyindent" startline="305" endline="323" pcid="8610">
        """
        Regression test for #13902: When using a ManyToMany in list_filter,
        results shouldn't appear more than once. With an intermediate model.
        """
        lead = Musician.objects.create(name='Vox')
        band = Group.objects.create(name='The Hype')
        Membership.objects.create(group=band, music=lead, role='lead voice')
        Membership.objects.create(group=band, music=lead, role='bass player')

        m = GroupAdmin(Group, custom_site)
        request = self.factory.get('/group/', data={'members': lead.pk})
        request.user = self.superuser

        cl = m.get_changelist_instance(request)
        cl.get_results(request)

        # There's only one Group instance
        self.assertEqual(cl.result_count, 1)

</source>
<source file="django/tests/admin_changelist/tests.py.pyindent" startline="325" endline="345" pcid="8611">
        """
        When using a ManyToMany in list_filter at the second level behind a
        ForeignKey, distinct() must be called and results shouldn't appear more
        than once.
        """
        lead = Musician.objects.create(name='Vox')
        band = Group.objects.create(name='The Hype')
        Concert.objects.create(name='Woodstock', group=band)
        Membership.objects.create(group=band, music=lead, role='lead voice')
        Membership.objects.create(group=band, music=lead, role='bass player')

        m = ConcertAdmin(Concert, custom_site)
        request = self.factory.get('/concert/', data={'group__members': lead.pk})
        request.user = self.superuser

        cl = m.get_changelist_instance(request)
        cl.get_results(request)

        # There's only one Concert instance
        self.assertEqual(cl.result_count, 1)

</source>
<source file="django/tests/admin_changelist/tests.py.pyindent" startline="424" endline="442" pcid="8616">
        """
        When using a ManyToMany in search_fields at the second level behind a
        ForeignKey, distinct() must be called and results shouldn't appear more
        than once.
        """
        lead = Musician.objects.create(name='Vox')
        band = Group.objects.create(name='The Hype')
        Concert.objects.create(name='Woodstock', group=band)
        Membership.objects.create(group=band, music=lead, role='lead voice')
        Membership.objects.create(group=band, music=lead, role='bass player')

        m = ConcertAdmin(Concert, custom_site)
        request = self.factory.get('/concert/', data={SEARCH_VAR: 'vox'})
        request.user = self.superuser

        cl = m.get_changelist_instance(request)
        # There's only one Concert instance
        self.assertEqual(cl.queryset.count(), 1)

</source>
</class>

<class classid="84" nclones="2" nlines="10" similarity="80">
<source file="django/tests/admin_changelist/tests.py.pyindent" startline="389" endline="405" pcid="8614">
        """
        Regressions tests for #15819: If a field listed in list_filters
        is a non-unique related object, distinct() must be called.
        """
        parent = Parent.objects.create(name='Mary')
        # Two children with the same name
        Child.objects.create(parent=parent, name='Daniel')
        Child.objects.create(parent=parent, name='Daniel')

        m = ParentAdmin(Parent, custom_site)
        request = self.factory.get('/parent/', data={'child__name': 'Daniel'})
        request.user = self.superuser

        cl = m.get_changelist_instance(request)
        # Make sure distinct() was called
        self.assertEqual(cl.queryset.count(), 1)

</source>
<source file="django/tests/admin_changelist/tests.py.pyindent" startline="407" endline="422" pcid="8615">
        """
        Regressions tests for #15819: If a field listed in search_fields
        is a non-unique related object, distinct() must be called.
        """
        parent = Parent.objects.create(name='Mary')
        Child.objects.create(parent=parent, name='Danielle')
        Child.objects.create(parent=parent, name='Daniel')

        m = ParentAdmin(Parent, custom_site)
        request = self.factory.get('/parent/', data={SEARCH_VAR: 'daniel'})
        request.user = self.superuser

        cl = m.get_changelist_instance(request)
        # Make sure distinct() was called
        self.assertEqual(cl.queryset.count(), 1)

</source>
</class>

<class classid="85" nclones="2" nlines="16" similarity="75">
<source file="django/tests/admin_changelist/tests.py.pyindent" startline="872" endline="883" pcid="8648">
            custom_site.register(UnorderedObject, UnorderedObjectAdmin)
            model_admin = UnorderedObjectAdmin(UnorderedObject, custom_site)
            counter = 0 if ascending else 51
            for page in range(0, 5):
                request = self._mocked_authenticated_request('/unorderedobject/?p=%s' % page, superuser)
                response = model_admin.changelist_view(request)
                for result in response.context_data['cl'].result_list:
                    counter += 1 if ascending else -1
                    self.assertEqual(result.id, counter)
            custom_site.unregister(UnorderedObject)

        # When no order is defined at all, everything is ordered by '-pk'.
</source>
<source file="django/tests/admin_changelist/tests.py.pyindent" startline="916" endline="927" pcid="8654">
            custom_site.register(OrderedObject, OrderedObjectAdmin)
            model_admin = OrderedObjectAdmin(OrderedObject, custom_site)
            counter = 0 if ascending else 51
            for page in range(0, 5):
                request = self._mocked_authenticated_request('/orderedobject/?p=%s' % page, superuser)
                response = model_admin.changelist_view(request)
                for result in response.context_data['cl'].result_list:
                    counter += 1 if ascending else -1
                    self.assertEqual(result.id, counter)
            custom_site.unregister(OrderedObject)

        # When no order is defined at all, use the model's default ordering (i.e. 'number')
</source>
</class>

<class classid="86" nclones="2" nlines="10" similarity="70">
<source file="django/tests/admin_checks/tests.py.pyindent" startline="57" endline="66" pcid="8701">
        errors = admin.checks.check_dependencies()
        expected = [
            checks.Error(
                "'django.contrib.contenttypes' must be in "
                "INSTALLED_APPS in order to use the admin application.",
                id="admin.E401",
            )
        ]
        self.assertEqual(errors, expected)

</source>
<source file="django/tests/admin_checks/tests.py.pyindent" startline="87" endline="96" pcid="8703">
        errors = admin.checks.check_dependencies()
        expected = [
            checks.Error(
                "'django.contrib.auth.context_processors.auth' must be in "
                "TEMPLATES in order to use the admin application.",
                id="admin.E402",
            )
        ]
        self.assertEqual(errors, expected)

</source>
</class>

<class classid="87" nclones="2" nlines="15" similarity="73">
<source file="django/tests/admin_checks/tests.py.pyindent" startline="131" endline="144" pcid="8715">
        class SongAdmin(admin.ModelAdmin):
            list_editable = ["original_release"]

        errors = SongAdmin(Song, AdminSite()).check()
        expected = [
            checks.Error(
                "The value of 'list_editable[0]' refers to 'original_release', "
                "which is not contained in 'list_display'.",
                obj=SongAdmin,
                id='admin.E122',
            )
        ]
        self.assertEqual(errors, expected)

</source>
<source file="django/tests/admin_checks/tests.py.pyindent" startline="574" endline="587" pcid="8785">
        class SongAdmin(admin.ModelAdmin):
            readonly_fields = ("title", "nonexistent")

        errors = SongAdmin(Song, AdminSite()).check()
        expected = [
            checks.Error(
                "The value of 'readonly_fields[1]' is not a callable, an attribute "
                "of 'SongAdmin', or an attribute of 'admin_checks.Song'.",
                obj=SongAdmin,
                id='admin.E035',
            )
        ]
        self.assertEqual(errors, expected)

</source>
</class>

<class classid="88" nclones="2" nlines="12" similarity="75">
<source file="django/tests/admin_checks/tests.py.pyindent" startline="146" endline="156" pcid="8717">
        class SongAdmin(admin.ModelAdmin):
            list_editable = 'test'

        self.assertEqual(SongAdmin(Song, AdminSite()).check(), [
            checks.Error(
                "The value of 'list_editable' must be a list or tuple.",
                obj=SongAdmin,
                id='admin.E120',
            )
        ])

</source>
<source file="django/tests/admin_checks/tests.py.pyindent" startline="605" endline="615" pcid="8789">
        class SongAdmin(admin.ModelAdmin):
            readonly_fields = 'test'

        self.assertEqual(SongAdmin(Song, AdminSite()).check(), [
            checks.Error(
                "The value of 'readonly_fields' must be a list or tuple.",
                obj=SongAdmin,
                id='admin.E034',
            )
        ])

</source>
</class>

<class classid="89" nclones="2" nlines="19" similarity="78">
<source file="django/tests/admin_checks/tests.py.pyindent" startline="220" endline="241" pcid="8727">
        """
        The first fieldset's fields must be a list/tuple.
        """
        class NotATupleAdmin(admin.ModelAdmin):
            list_display = ["pk", "title"]
            list_editable = ["title"]
            fieldsets = [
                (None, {
                    "fields": "title"  # not a tuple
                }),
            ]

        errors = NotATupleAdmin(Song, AdminSite()).check()
        expected = [
            checks.Error(
                "The value of 'fieldsets[0][1]['fields']' must be a list or tuple.",
                obj=NotATupleAdmin,
                id='admin.E008',
            )
        ]
        self.assertEqual(errors, expected)

</source>
<source file="django/tests/admin_checks/tests.py.pyindent" startline="243" endline="265" pcid="8729">
        """
        The second fieldset's fields must be a list/tuple.
        """
        class NotATupleAdmin(admin.ModelAdmin):
            fieldsets = [
                (None, {
                    "fields": ("title",)
                }),
                ('foo', {
                    "fields": "author"  # not a tuple
                }),
            ]

        errors = NotATupleAdmin(Song, AdminSite()).check()
        expected = [
            checks.Error(
                "The value of 'fieldsets[1][1]['fields']' must be a list or tuple.",
                obj=NotATupleAdmin,
                id='admin.E008',
            )
        ]
        self.assertEqual(errors, expected)

</source>
</class>

<class classid="90" nclones="2" nlines="12" similarity="75">
<source file="django/tests/admin_checks/tests.py.pyindent" startline="341" endline="353" pcid="8741">
        """
        Regression test for #22034 - check that generic inlines don't look for
        normal ForeignKey relations.
        """
        class InfluenceInline(GenericStackedInline):
            model = Influence

        class SongAdmin(admin.ModelAdmin):
            inlines = [InfluenceInline]

        errors = SongAdmin(Song, AdminSite()).check()
        self.assertEqual(errors, [])

</source>
<source file="django/tests/admin_checks/tests.py.pyindent" startline="533" endline="541" pcid="8772">
        def my_function(obj):
            pass

        class SongAdmin(admin.ModelAdmin):
            readonly_fields = (my_function,)

        errors = SongAdmin(Song, AdminSite()).check()
        self.assertEqual(errors, [])

</source>
</class>

<class classid="91" nclones="4" nlines="19" similarity="80">
<source file="django/tests/admin_checks/tests.py.pyindent" startline="376" endline="396" pcid="8747">
        """
        A GenericInlineModelAdmin errors if the ct_field points to a
        nonexistent field.
        """
        class InfluenceInline(GenericStackedInline):
            model = Influence
            ct_field = 'nonexistent'

        class SongAdmin(admin.ModelAdmin):
            inlines = [InfluenceInline]

        errors = SongAdmin(Song, AdminSite()).check()
        expected = [
            checks.Error(
                "'ct_field' references 'nonexistent', which is not a field on 'admin_checks.Influence'.",
                obj=InfluenceInline,
                id='admin.E302',
            )
        ]
        self.assertEqual(errors, expected)

</source>
<source file="django/tests/admin_checks/tests.py.pyindent" startline="398" endline="418" pcid="8750">
        """
        A GenericInlineModelAdmin errors if the ct_fk_field points to a
        nonexistent field.
        """
        class InfluenceInline(GenericStackedInline):
            model = Influence
            ct_fk_field = 'nonexistent'

        class SongAdmin(admin.ModelAdmin):
            inlines = [InfluenceInline]

        errors = SongAdmin(Song, AdminSite()).check()
        expected = [
            checks.Error(
                "'ct_fk_field' references 'nonexistent', which is not a field on 'admin_checks.Influence'.",
                obj=InfluenceInline,
                id='admin.E303',
            )
        ]
        self.assertEqual(errors, expected)

</source>
<source file="django/tests/admin_checks/tests.py.pyindent" startline="443" endline="464" pcid="8756">
        """
        A GenericInlineModelAdmin raises problems if the ct_fk_field points to
        a field that isn't part of a GenericForeignKey.
        """
        class InfluenceInline(GenericStackedInline):
            model = Influence
            ct_fk_field = 'name'

        class SongAdmin(admin.ModelAdmin):
            inlines = [InfluenceInline]

        errors = SongAdmin(Song, AdminSite()).check()
        expected = [
            checks.Error(
                "'admin_checks.Influence' has no GenericForeignKey using "
                "content type field 'content_type' and object ID field 'name'.",
                obj=InfluenceInline,
                id='admin.E304',
            )
        ]
        self.assertEqual(errors, expected)

</source>
<source file="django/tests/admin_checks/tests.py.pyindent" startline="420" endline="441" pcid="8753">
        """
        A GenericInlineModelAdmin raises problems if the ct_field points to a
        field that isn't part of a GenericForeignKey.
        """
        class InfluenceInline(GenericStackedInline):
            model = Influence
            ct_field = 'name'

        class SongAdmin(admin.ModelAdmin):
            inlines = [InfluenceInline]

        errors = SongAdmin(Song, AdminSite()).check()
        expected = [
            checks.Error(
                "'admin_checks.Influence' has no GenericForeignKey using "
                "content type field 'name' and object ID field 'object_id'.",
                obj=InfluenceInline,
                id='admin.E304',
            )
        ]
        self.assertEqual(errors, expected)

</source>
</class>

<class classid="92" nclones="2" nlines="14" similarity="92">
<source file="django/tests/admin_checks/tests.py.pyindent" startline="481" endline="496" pcid="8761">
        """
        Regression test for #11709 - when testing for fk excluding (when exclude is
        given) make sure fk_name is honored or things blow up when there is more
        than one fk to the parent model.
        """
        class TwoAlbumFKAndAnEInline(admin.TabularInline):
            model = TwoAlbumFKAndAnE
            exclude = ("e",)
            fk_name = "album1"

        class MyAdmin(admin.ModelAdmin):
            inlines = [TwoAlbumFKAndAnEInline]

        errors = MyAdmin(Album, AdminSite()).check()
        self.assertEqual(errors, [])

</source>
<source file="django/tests/admin_checks/tests.py.pyindent" startline="515" endline="524" pcid="8767">
        class TwoAlbumFKAndAnEInline(admin.TabularInline):
            model = TwoAlbumFKAndAnE
            fk_name = "album1"

        class MyAdmin(admin.ModelAdmin):
            inlines = [TwoAlbumFKAndAnEInline]

        errors = MyAdmin(Album, AdminSite()).check()
        self.assertEqual(errors, [])

</source>
</class>

<class classid="93" nclones="2" nlines="18" similarity="72">
<source file="django/tests/admin_docs/test_middleware.py.pyindent" startline="9" endline="25" pcid="8875">
        user = User.objects.get(username='super')
        response = self.client.head('/xview/func/')
        self.assertNotIn('X-View', response)
        self.client.force_login(self.superuser)
        response = self.client.head('/xview/func/')
        self.assertIn('X-View', response)
        self.assertEqual(response['X-View'], 'admin_docs.views.xview')
        user.is_staff = False
        user.save()
        response = self.client.head('/xview/func/')
        self.assertNotIn('X-View', response)
        user.is_staff = True
        user.is_active = False
        user.save()
        response = self.client.head('/xview/func/')
        self.assertNotIn('X-View', response)

</source>
<source file="django/tests/admin_docs/test_middleware.py.pyindent" startline="27" endline="43" pcid="8876">
        user = User.objects.get(username='super')
        response = self.client.head('/xview/class/')
        self.assertNotIn('X-View', response)
        self.client.force_login(self.superuser)
        response = self.client.head('/xview/class/')
        self.assertIn('X-View', response)
        self.assertEqual(response['X-View'], 'admin_docs.views.XViewClass')
        user.is_staff = False
        user.save()
        response = self.client.head('/xview/class/')
        self.assertNotIn('X-View', response)
        user.is_staff = True
        user.is_active = False
        user.save()
        response = self.client.head('/xview/class/')
        self.assertNotIn('X-View', response)

</source>
</class>

<class classid="94" nclones="2" nlines="10" similarity="80">
<source file="django/tests/admin_filters/models.py.pyindent" startline="58" endline="66" pcid="8948">
    tag = models.SlugField()
    content_type = models.ForeignKey(ContentType, models.CASCADE, related_name='tagged_items')
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey('content_type', 'object_id')

    def __str__(self):
        return self.tag


</source>
<source file="django/tests/select_related/models.py.pyindent" startline="109" endline="118" pcid="22928">
    tag = models.CharField(max_length=30)

    content_type = models.ForeignKey(ContentType, models.CASCADE, related_name='select_related_tagged_items')
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey('content_type', 'object_id')

    def __str__(self):
        return self.tag


</source>
</class>

<class classid="95" nclones="2" nlines="25" similarity="73">
<source file="django/tests/admin_inlines/tests.py.pyindent" startline="691" endline="720" pcid="9114">
        permission = Permission.objects.get(codename='change_inner2', content_type=self.inner_ct)
        self.user.user_permissions.add(permission)
        response = self.client.get(self.holder_change_url)
        # Change permission on inner2s, so we can change existing but not add new
        self.assertContains(response, '<h2>Inner2s</h2>', count=2)
        # Just the one form for existing instances
        self.assertContains(
            response, '<input type="hidden" id="id_inner2_set-TOTAL_FORMS" value="1" name="inner2_set-TOTAL_FORMS">',
            html=True
        )
        self.assertContains(
            response,
            '<input type="hidden" id="id_inner2_set-0-id" value="%i" name="inner2_set-0-id">' % self.inner2.id,
            html=True
        )
        # max-num 0 means we can't add new ones
        self.assertContains(
            response,
            '<input type="hidden" id="id_inner2_set-MAX_NUM_FORMS" value="0" name="inner2_set-MAX_NUM_FORMS">',
            html=True
        )
        # TabularInline
        self.assertContains(response, '<th class="required">Dummy</th>', html=True)
        self.assertContains(
            response,
            '<input type="number" name="inner2_set-2-0-dummy" value="%s" '
            'class="vIntegerField" id="id_inner2_set-2-0-dummy">' % self.inner2.dummy,
            html=True,
        )

</source>
<source file="django/tests/admin_inlines/tests.py.pyindent" startline="762" endline="792" pcid="9117">
        permission = Permission.objects.get(codename='add_inner2', content_type=self.inner_ct)
        self.user.user_permissions.add(permission)
        permission = Permission.objects.get(codename='change_inner2', content_type=self.inner_ct)
        self.user.user_permissions.add(permission)
        permission = Permission.objects.get(codename='delete_inner2', content_type=self.inner_ct)
        self.user.user_permissions.add(permission)
        response = self.client.get(self.holder_change_url)
        # All perms on inner2s, so we can add/change/delete
        self.assertContains(response, '<h2>Inner2s</h2>', count=2)
        # One form for existing instance only, three for new
        self.assertContains(
            response,
            '<input type="hidden" id="id_inner2_set-TOTAL_FORMS" value="4" name="inner2_set-TOTAL_FORMS">',
            html=True
        )
        self.assertContains(
            response,
            '<input type="hidden" id="id_inner2_set-0-id" value="%i" name="inner2_set-0-id">' % self.inner2.id,
            html=True
        )
        self.assertContains(response, 'id="id_inner2_set-0-DELETE"')
        # TabularInline
        self.assertContains(response, '<th class="required">Dummy</th>', html=True)
        self.assertContains(
            response,
            '<input type="number" name="inner2_set-2-0-dummy" value="%s" '
            'class="vIntegerField" id="id_inner2_set-2-0-dummy">' % self.inner2.dummy,
            html=True,
        )


</source>
</class>

<class classid="96" nclones="2" nlines="16" similarity="70">
<source file="django/tests/admin_inlines/tests.py.pyindent" startline="722" endline="739" pcid="9115">
        permission = Permission.objects.get(codename='add_inner2', content_type=self.inner_ct)
        self.user.user_permissions.add(permission)
        permission = Permission.objects.get(codename='change_inner2', content_type=self.inner_ct)
        self.user.user_permissions.add(permission)
        response = self.client.get(self.holder_change_url)
        # Add/change perm, so we can add new and change existing
        self.assertContains(response, '<h2>Inner2s</h2>')
        # One form for existing instance and three extra for new
        self.assertContains(
            response, '<input type="hidden" id="id_inner2_set-TOTAL_FORMS" value="4" name="inner2_set-TOTAL_FORMS">',
            html=True
        )
        self.assertContains(
            response,
            '<input type="hidden" id="id_inner2_set-0-id" value="%i" name="inner2_set-0-id">' % self.inner2.id,
            html=True
        )

</source>
<source file="django/tests/admin_inlines/tests.py.pyindent" startline="741" endline="760" pcid="9116">
        permission = Permission.objects.get(codename='change_inner2', content_type=self.inner_ct)
        self.user.user_permissions.add(permission)
        permission = Permission.objects.get(codename='delete_inner2', content_type=self.inner_ct)
        self.user.user_permissions.add(permission)
        response = self.client.get(self.holder_change_url)
        # Change/delete perm on inner2s, so we can change/delete existing
        self.assertContains(response, '<h2>Inner2s</h2>')
        # One form for existing instance only, no new
        self.assertContains(
            response,
            '<input type="hidden" id="id_inner2_set-TOTAL_FORMS" value="1" name="inner2_set-TOTAL_FORMS">',
            html=True
        )
        self.assertContains(
            response,
            '<input type="hidden" id="id_inner2_set-0-id" value="%i" name="inner2_set-0-id">' % self.inner2.id,
            html=True
        )
        self.assertContains(response, 'id="id_inner2_set-0-DELETE"')

</source>
</class>

<class classid="97" nclones="15" nlines="13" similarity="71">
<source file="django/tests/admin_scripts/another_app_waiting_migration/migrations/0001_initial.py.pyindent" startline="5" endline="19" pcid="9208">

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Foo',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=255)),
            ],
        ),
    ]
</source>
<source file="django/tests/admin_scripts/app_waiting_migration/migrations/0001_initial.py.pyindent" startline="5" endline="19" pcid="9215">

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Bar',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=255)),
            ],
        ),
    ]
</source>
<source file="django/tests/migrations/migrations_test_apps/lookuperror_c/migrations/0001_initial.py.pyindent" startline="5" endline="16" pcid="19038">

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='C1',
            fields=[
                ('id', models.AutoField(serialize=False, verbose_name='ID', auto_created=True, primary_key=True)),
            ],
        ),
    ]
</source>
<source file="django/tests/migrations/deprecated_field_migrations/0001_initial.py.pyindent" startline="5" endline="17" pcid="19016">

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='IPAddressField',
            fields=[
                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),
                ('ip', models.IPAddressField(null=True, blank=True)),
            ],
        ),
    ]
</source>
<source file="django/tests/migrations/migrations_test_apps/alter_fk/author_app/migrations/0001_initial.py.pyindent" startline="5" endline="17" pcid="19018">

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Author',
            fields=[
                ('id', models.AutoField(serialize=False, auto_created=True, primary_key=True)),
                ('name', models.CharField(max_length=50)),
            ],
        ),
    ]
</source>
<source file="django/tests/migrations/test_auto_now_add/0001_initial.py.pyindent" startline="5" endline="16" pcid="19064">

    initial = True

    operations = [
        migrations.CreateModel(
            name='Entry',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=255)),
            ],
        ),
    ]
</source>
<source file="django/tests/migrations/migrations_test_apps/lookuperror_b/migrations/0001_initial.py.pyindent" startline="5" endline="16" pcid="19032">

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='B1',
            fields=[
                ('id', models.AutoField(serialize=False, auto_created=True, primary_key=True, verbose_name='ID')),
            ],
        ),
    ]
</source>
<source file="django/tests/migrations/migrations_test_apps/lookuperror_c/migrations/0003_c3.py.pyindent" startline="5" endline="17" pcid="19040">

    dependencies = [
        ('lookuperror_c', '0002_c2'),
    ]

    operations = [
        migrations.CreateModel(
            name='C3',
            fields=[
                ('id', models.AutoField(auto_created=True, serialize=False, verbose_name='ID', primary_key=True)),
            ],
        ),
    ]
</source>
<source file="django/tests/migrations/migrations_test_apps/lookuperror_a/migrations/0001_initial.py.pyindent" startline="5" endline="16" pcid="19024">

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='A1',
            fields=[
                ('id', models.AutoField(serialize=False, verbose_name='ID', auto_created=True, primary_key=True)),
            ],
        ),
    ]
</source>
<source file="django/tests/migrations/migrations_test_apps/lookuperror_a/migrations/0002_a2.py.pyindent" startline="5" endline="17" pcid="19025">

    dependencies = [
        ('lookuperror_a', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='A2',
            fields=[
                ('id', models.AutoField(verbose_name='ID', primary_key=True, serialize=False, auto_created=True)),
            ],
        ),
    ]
</source>
<source file="django/tests/migrations/migrations_test_apps/lookuperror_b/migrations/0003_b3.py.pyindent" startline="5" endline="17" pcid="19034">

    dependencies = [
        ('lookuperror_b', '0002_b2'),
    ]

    operations = [
        migrations.CreateModel(
            name='B3',
            fields=[
                ('id', models.AutoField(verbose_name='ID', serialize=False, primary_key=True, auto_created=True)),
            ],
        ),
    ]
</source>
<source file="django/tests/migrations/migrations_test_apps/lookuperror_a/migrations/0004_a4.py.pyindent" startline="5" endline="17" pcid="19027">

    dependencies = [
        ('lookuperror_a', '0003_a3'),
    ]

    operations = [
        migrations.CreateModel(
            name='A4',
            fields=[
                ('id', models.AutoField(auto_created=True, serialize=False, verbose_name='ID', primary_key=True)),
            ],
        ),
    ]
</source>
<source file="django/tests/migrations/migrations_test_apps/mutate_state_a/migrations/0001_initial.py.pyindent" startline="5" endline="19" pcid="19048">

    dependencies = [
        ('mutate_state_b', '0001_initial'),
    ]

    operations = [
        migrations.SeparateDatabaseAndState([], [
            migrations.CreateModel(
                name='A',
                fields=[
                    ('id', models.AutoField(serialize=False, verbose_name='ID', auto_created=True, primary_key=True)),
                ],
            ),
        ])
    ]
</source>
<source file="django/tests/migrations/migrations_test_apps/mutate_state_b/migrations/0001_initial.py.pyindent" startline="5" endline="18" pcid="19049">

    dependencies = [
    ]

    operations = [
        migrations.SeparateDatabaseAndState([], [
            migrations.CreateModel(
                name='B',
                fields=[
                    ('id', models.AutoField(serialize=False, verbose_name='ID', auto_created=True, primary_key=True)),
                ],
            ),
        ])
    ]
</source>
<source file="django/tests/migrations/migrations_test_apps/alter_fk/book_app/migrations/0001_initial.py.pyindent" startline="5" endline="19" pcid="19020">

    dependencies = [
        ('author_app', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='Book',
            fields=[
                ('id', models.AutoField(serialize=False, auto_created=True, primary_key=True)),
                ('title', models.CharField(max_length=50)),
                ('author', models.ForeignKey('author_app.Author', models.CASCADE)),
            ],
        ),
    ]
</source>
</class>

<class classid="98" nclones="9" nlines="75" similarity="70">
<source file="django/tests/admin_scripts/tests.py.pyindent" startline="246" endline="312" pcid="9281">
    """A series of tests for django-admin.py when using a settings.py file that
    contains the test application.
    """
    def setUp(self):
        self.write_settings('settings.py')

    def tearDown(self):
        self.remove_settings('settings.py')

    def test_builtin_command(self):
        "default: django-admin builtin commands fail with an error when no settings provided"
        args = ['check', 'admin_scripts']
        out, err = self.run_django_admin(args)
        self.assertNoOutput(out)
        self.assertOutput(err, 'settings are not configured')

    def test_builtin_with_settings(self):
        "default: django-admin builtin commands succeed if settings are provided as argument"
        args = ['check', '--settings=test_project.settings', 'admin_scripts']
        out, err = self.run_django_admin(args)
        self.assertNoOutput(err)
        self.assertOutput(out, SYSTEM_CHECK_MSG)

    def test_builtin_with_environment(self):
        "default: django-admin builtin commands succeed if settings are provided in the environment"
        args = ['check', 'admin_scripts']
        out, err = self.run_django_admin(args, 'test_project.settings')
        self.assertNoOutput(err)
        self.assertOutput(out, SYSTEM_CHECK_MSG)

    def test_builtin_with_bad_settings(self):
        "default: django-admin builtin commands fail if settings file (from argument) doesn't exist"
        args = ['check', '--settings=bad_settings', 'admin_scripts']
        out, err = self.run_django_admin(args)
        self.assertNoOutput(out)
        self.assertOutput(err, "No module named '?bad_settings'?", regex=True)

    def test_builtin_with_bad_environment(self):
        "default: django-admin builtin commands fail if settings file (from environment) doesn't exist"
        args = ['check', 'admin_scripts']
        out, err = self.run_django_admin(args, 'bad_settings')
        self.assertNoOutput(out)
        self.assertOutput(err, "No module named '?bad_settings'?", regex=True)

    def test_custom_command(self):
        "default: django-admin can't execute user commands if it isn't provided settings"
        args = ['noargs_command']
        out, err = self.run_django_admin(args)
        self.assertNoOutput(out)
        self.assertOutput(err, "No Django settings specified")
        self.assertOutput(err, "Unknown command: 'noargs_command'")

    def test_custom_command_with_settings(self):
        "default: django-admin can execute user commands if settings are provided as argument"
        args = ['noargs_command', '--settings=test_project.settings']
        out, err = self.run_django_admin(args)
        self.assertNoOutput(err)
        self.assertOutput(out, "EXECUTE: noargs_command")

    def test_custom_command_with_environment(self):
        "default: django-admin can execute user commands if settings are provided in environment"
        args = ['noargs_command']
        out, err = self.run_django_admin(args, 'test_project.settings')
        self.assertNoOutput(err)
        self.assertOutput(out, "EXECUTE: noargs_command")


</source>
<source file="django/tests/admin_scripts/tests.py.pyindent" startline="314" endline="381" pcid="9292">
    """A series of tests for django-admin.py when using a settings.py file that
    contains the test application specified using a full path.
    """
    def setUp(self):
        self.write_settings('settings.py', ['django.contrib.auth', 'django.contrib.contenttypes',
                                            'admin_scripts', 'admin_scripts.complex_app'])

    def tearDown(self):
        self.remove_settings('settings.py')

    def test_builtin_command(self):
        "fulldefault: django-admin builtin commands fail with an error when no settings provided"
        args = ['check', 'admin_scripts']
        out, err = self.run_django_admin(args)
        self.assertNoOutput(out)
        self.assertOutput(err, 'settings are not configured')

    def test_builtin_with_settings(self):
        "fulldefault: django-admin builtin commands succeed if a settings file is provided"
        args = ['check', '--settings=test_project.settings', 'admin_scripts']
        out, err = self.run_django_admin(args)
        self.assertNoOutput(err)
        self.assertOutput(out, SYSTEM_CHECK_MSG)

    def test_builtin_with_environment(self):
        "fulldefault: django-admin builtin commands succeed if the environment contains settings"
        args = ['check', 'admin_scripts']
        out, err = self.run_django_admin(args, 'test_project.settings')
        self.assertNoOutput(err)
        self.assertOutput(out, SYSTEM_CHECK_MSG)

    def test_builtin_with_bad_settings(self):
        "fulldefault: django-admin builtin commands fail if settings file (from argument) doesn't exist"
        args = ['check', '--settings=bad_settings', 'admin_scripts']
        out, err = self.run_django_admin(args)
        self.assertNoOutput(out)
        self.assertOutput(err, "No module named '?bad_settings'?", regex=True)

    def test_builtin_with_bad_environment(self):
        "fulldefault: django-admin builtin commands fail if settings file (from environment) doesn't exist"
        args = ['check', 'admin_scripts']
        out, err = self.run_django_admin(args, 'bad_settings')
        self.assertNoOutput(out)
        self.assertOutput(err, "No module named '?bad_settings'?", regex=True)

    def test_custom_command(self):
        "fulldefault: django-admin can't execute user commands unless settings are provided"
        args = ['noargs_command']
        out, err = self.run_django_admin(args)
        self.assertNoOutput(out)
        self.assertOutput(err, "No Django settings specified")
        self.assertOutput(err, "Unknown command: 'noargs_command'")

    def test_custom_command_with_settings(self):
        "fulldefault: django-admin can execute user commands if settings are provided as argument"
        args = ['noargs_command', '--settings=test_project.settings']
        out, err = self.run_django_admin(args)
        self.assertNoOutput(err)
        self.assertOutput(out, "EXECUTE: noargs_command")

    def test_custom_command_with_environment(self):
        "fulldefault: django-admin can execute user commands if settings are provided in environment"
        args = ['noargs_command']
        out, err = self.run_django_admin(args, 'test_project.settings')
        self.assertNoOutput(err)
        self.assertOutput(out, "EXECUTE: noargs_command")


</source>
<source file="django/tests/admin_scripts/tests.py.pyindent" startline="780" endline="845" pcid="9365">
    """A series of tests for manage.py when using a settings.py file that
    contains the test application specified using a full path.
    """
    def setUp(self):
        self.write_settings('settings.py', ['django.contrib.auth', 'django.contrib.contenttypes', 'admin_scripts'])

    def tearDown(self):
        self.remove_settings('settings.py')

    def test_builtin_command(self):
        "fulldefault: manage.py builtin commands succeed when default settings are appropriate"
        args = ['check', 'admin_scripts']
        out, err = self.run_manage(args)
        self.assertNoOutput(err)
        self.assertOutput(out, SYSTEM_CHECK_MSG)

    def test_builtin_with_settings(self):
        "fulldefault: manage.py builtin commands succeed if settings are provided as argument"
        args = ['check', '--settings=test_project.settings', 'admin_scripts']
        out, err = self.run_manage(args)
        self.assertNoOutput(err)
        self.assertOutput(out, SYSTEM_CHECK_MSG)

    def test_builtin_with_environment(self):
        "fulldefault: manage.py builtin commands succeed if settings are provided in the environment"
        args = ['check', 'admin_scripts']
        out, err = self.run_manage(args, 'test_project.settings')
        self.assertNoOutput(err)
        self.assertOutput(out, SYSTEM_CHECK_MSG)

    def test_builtin_with_bad_settings(self):
        "fulldefault: manage.py builtin commands succeed if settings file (from argument) doesn't exist"
        args = ['check', '--settings=bad_settings', 'admin_scripts']
        out, err = self.run_manage(args)
        self.assertNoOutput(out)
        self.assertOutput(err, "No module named '?bad_settings'?", regex=True)

    def test_builtin_with_bad_environment(self):
        "fulldefault: manage.py builtin commands fail if settings file (from environment) doesn't exist"
        args = ['check', 'admin_scripts']
        out, err = self.run_manage(args, 'bad_settings')
        self.assertNoOutput(out)
        self.assertOutput(err, "No module named '?bad_settings'?", regex=True)

    def test_custom_command(self):
        "fulldefault: manage.py can execute user commands when default settings are appropriate"
        args = ['noargs_command']
        out, err = self.run_manage(args)
        self.assertNoOutput(err)
        self.assertOutput(out, "EXECUTE: noargs_command")

    def test_custom_command_with_settings(self):
        "fulldefault: manage.py can execute user commands when settings are provided as argument"
        args = ['noargs_command', '--settings=test_project.settings']
        out, err = self.run_manage(args)
        self.assertNoOutput(err)
        self.assertOutput(out, "EXECUTE: noargs_command")

    def test_custom_command_with_environment(self):
        "fulldefault: manage.py can execute user commands when settings are provided in environment"
        args = ['noargs_command']
        out, err = self.run_manage(args, 'test_project.settings')
        self.assertNoOutput(err)
        self.assertOutput(out, "EXECUTE: noargs_command")


</source>
<source file="django/tests/admin_scripts/tests.py.pyindent" startline="519" endline="588" pcid="9325">
    """A series of tests for django-admin.py when multiple settings files
    (including the default 'settings.py') are available. The default settings
    file is insufficient for performing the operations described, so the
    alternate settings must be used by the running script.
    """
    def setUp(self):
        self.write_settings('settings.py', apps=['django.contrib.auth', 'django.contrib.contenttypes'])
        self.write_settings('alternate_settings.py')

    def tearDown(self):
        self.remove_settings('settings.py')
        self.remove_settings('alternate_settings.py')

    def test_builtin_command(self):
        "alternate: django-admin builtin commands fail with an error when no settings provided"
        args = ['check', 'admin_scripts']
        out, err = self.run_django_admin(args)
        self.assertNoOutput(out)
        self.assertOutput(err, 'settings are not configured')

    def test_builtin_with_settings(self):
        "alternate: django-admin builtin commands succeed if settings are provided as argument"
        args = ['check', '--settings=test_project.alternate_settings', 'admin_scripts']
        out, err = self.run_django_admin(args)
        self.assertNoOutput(err)
        self.assertOutput(out, SYSTEM_CHECK_MSG)

    def test_builtin_with_environment(self):
        "alternate: django-admin builtin commands succeed if settings are provided in the environment"
        args = ['check', 'admin_scripts']
        out, err = self.run_django_admin(args, 'test_project.alternate_settings')
        self.assertNoOutput(err)
        self.assertOutput(out, SYSTEM_CHECK_MSG)

    def test_builtin_with_bad_settings(self):
        "alternate: django-admin builtin commands fail if settings file (from argument) doesn't exist"
        args = ['check', '--settings=bad_settings', 'admin_scripts']
        out, err = self.run_django_admin(args)
        self.assertOutput(err, "No module named '?bad_settings'?", regex=True)

    def test_builtin_with_bad_environment(self):
        "alternate: django-admin builtin commands fail if settings file (from environment) doesn't exist"
        args = ['check', 'admin_scripts']
        out, err = self.run_django_admin(args, 'bad_settings')
        self.assertNoOutput(out)
        self.assertOutput(err, "No module named '?bad_settings'?", regex=True)

    def test_custom_command(self):
        "alternate: django-admin can't execute user commands unless settings are provided"
        args = ['noargs_command']
        out, err = self.run_django_admin(args)
        self.assertNoOutput(out)
        self.assertOutput(err, "No Django settings specified")
        self.assertOutput(err, "Unknown command: 'noargs_command'")

    def test_custom_command_with_settings(self):
        "alternate: django-admin can execute user commands if settings are provided as argument"
        args = ['noargs_command', '--settings=test_project.alternate_settings']
        out, err = self.run_django_admin(args)
        self.assertNoOutput(err)
        self.assertOutput(out, "EXECUTE: noargs_command")

    def test_custom_command_with_environment(self):
        "alternate: django-admin can execute user commands if settings are provided in environment"
        args = ['noargs_command']
        out, err = self.run_django_admin(args, 'test_project.alternate_settings')
        self.assertNoOutput(err)
        self.assertOutput(out, "EXECUTE: noargs_command")


</source>
<source file="django/tests/admin_scripts/tests.py.pyindent" startline="1003" endline="1072" pcid="9399">
    """A series of tests for manage.py when multiple settings files
    (including the default 'settings.py') are available. The default settings
    file is insufficient for performing the operations described, so the
    alternate settings must be used by the running script.
    """
    def setUp(self):
        self.write_settings('settings.py', apps=['django.contrib.auth', 'django.contrib.contenttypes'])
        self.write_settings('alternate_settings.py')

    def tearDown(self):
        self.remove_settings('settings.py')
        self.remove_settings('alternate_settings.py')

    def test_builtin_command(self):
        "multiple: manage.py builtin commands fail with an error when no settings provided"
        args = ['check', 'admin_scripts']
        out, err = self.run_manage(args)
        self.assertNoOutput(out)
        self.assertOutput(err, "No installed app with label 'admin_scripts'.")

    def test_builtin_with_settings(self):
        "multiple: manage.py builtin commands succeed if settings are provided as argument"
        args = ['check', '--settings=alternate_settings', 'admin_scripts']
        out, err = self.run_manage(args)
        self.assertNoOutput(err)
        self.assertOutput(out, SYSTEM_CHECK_MSG)

    def test_builtin_with_environment(self):
        "multiple: manage.py can execute builtin commands if settings are provided in the environment"
        args = ['check', 'admin_scripts']
        out, err = self.run_manage(args, 'alternate_settings')
        self.assertNoOutput(err)
        self.assertOutput(out, SYSTEM_CHECK_MSG)

    def test_builtin_with_bad_settings(self):
        "multiple: manage.py builtin commands fail if settings file (from argument) doesn't exist"
        args = ['check', '--settings=bad_settings', 'admin_scripts']
        out, err = self.run_manage(args)
        self.assertNoOutput(out)
        self.assertOutput(err, "No module named '?bad_settings'?", regex=True)

    def test_builtin_with_bad_environment(self):
        "multiple: manage.py builtin commands fail if settings file (from environment) doesn't exist"
        args = ['check', 'admin_scripts']
        out, err = self.run_manage(args, 'bad_settings')
        self.assertNoOutput(out)
        self.assertOutput(err, "No module named '?bad_settings'?", regex=True)

    def test_custom_command(self):
        "multiple: manage.py can't execute user commands using default settings"
        args = ['noargs_command']
        out, err = self.run_manage(args)
        self.assertNoOutput(out)
        self.assertOutput(err, "Unknown command: 'noargs_command'")

    def test_custom_command_with_settings(self):
        "multiple: manage.py can execute user commands if settings are provided as argument"
        args = ['noargs_command', '--settings=alternate_settings']
        out, err = self.run_manage(args)
        self.assertNoOutput(err)
        self.assertOutput(out, "EXECUTE: noargs_command")

    def test_custom_command_with_environment(self):
        "multiple: manage.py can execute user commands if settings are provided in environment"
        args = ['noargs_command']
        out, err = self.run_manage(args, 'alternate_settings')
        self.assertNoOutput(err)
        self.assertOutput(out, "EXECUTE: noargs_command")


</source>
<source file="django/tests/admin_scripts/tests.py.pyindent" startline="383" endline="449" pcid="9303">
    """A series of tests for django-admin.py when using a settings.py file that
    doesn't contain the test application.
    """
    def setUp(self):
        self.write_settings('settings.py', apps=['django.contrib.auth', 'django.contrib.contenttypes'])

    def tearDown(self):
        self.remove_settings('settings.py')

    def test_builtin_command(self):
        "minimal: django-admin builtin commands fail with an error when no settings provided"
        args = ['check', 'admin_scripts']
        out, err = self.run_django_admin(args)
        self.assertNoOutput(out)
        self.assertOutput(err, 'settings are not configured')

    def test_builtin_with_settings(self):
        "minimal: django-admin builtin commands fail if settings are provided as argument"
        args = ['check', '--settings=test_project.settings', 'admin_scripts']
        out, err = self.run_django_admin(args)
        self.assertNoOutput(out)
        self.assertOutput(err, "No installed app with label 'admin_scripts'.")

    def test_builtin_with_environment(self):
        "minimal: django-admin builtin commands fail if settings are provided in the environment"
        args = ['check', 'admin_scripts']
        out, err = self.run_django_admin(args, 'test_project.settings')
        self.assertNoOutput(out)
        self.assertOutput(err, "No installed app with label 'admin_scripts'.")

    def test_builtin_with_bad_settings(self):
        "minimal: django-admin builtin commands fail if settings file (from argument) doesn't exist"
        args = ['check', '--settings=bad_settings', 'admin_scripts']
        out, err = self.run_django_admin(args)
        self.assertNoOutput(out)
        self.assertOutput(err, "No module named '?bad_settings'?", regex=True)

    def test_builtin_with_bad_environment(self):
        "minimal: django-admin builtin commands fail if settings file (from environment) doesn't exist"
        args = ['check', 'admin_scripts']
        out, err = self.run_django_admin(args, 'bad_settings')
        self.assertNoOutput(out)
        self.assertOutput(err, "No module named '?bad_settings'?", regex=True)

    def test_custom_command(self):
        "minimal: django-admin can't execute user commands unless settings are provided"
        args = ['noargs_command']
        out, err = self.run_django_admin(args)
        self.assertNoOutput(out)
        self.assertOutput(err, "No Django settings specified")
        self.assertOutput(err, "Unknown command: 'noargs_command'")

    def test_custom_command_with_settings(self):
        "minimal: django-admin can't execute user commands, even if settings are provided as argument"
        args = ['noargs_command', '--settings=test_project.settings']
        out, err = self.run_django_admin(args)
        self.assertNoOutput(out)
        self.assertOutput(err, "Unknown command: 'noargs_command'")

    def test_custom_command_with_environment(self):
        "minimal: django-admin can't execute user commands, even if settings are provided in environment"
        args = ['noargs_command']
        out, err = self.run_django_admin(args, 'test_project.settings')
        self.assertNoOutput(out)
        self.assertOutput(err, "Unknown command: 'noargs_command'")


</source>
<source file="django/tests/admin_scripts/tests.py.pyindent" startline="451" endline="517" pcid="9314">
    """A series of tests for django-admin.py when using a settings file
    with a name other than 'settings.py'.
    """
    def setUp(self):
        self.write_settings('alternate_settings.py')

    def tearDown(self):
        self.remove_settings('alternate_settings.py')

    def test_builtin_command(self):
        "alternate: django-admin builtin commands fail with an error when no settings provided"
        args = ['check', 'admin_scripts']
        out, err = self.run_django_admin(args)
        self.assertNoOutput(out)
        self.assertOutput(err, 'settings are not configured')

    def test_builtin_with_settings(self):
        "alternate: django-admin builtin commands succeed if settings are provided as argument"
        args = ['check', '--settings=test_project.alternate_settings', 'admin_scripts']
        out, err = self.run_django_admin(args)
        self.assertNoOutput(err)
        self.assertOutput(out, SYSTEM_CHECK_MSG)

    def test_builtin_with_environment(self):
        "alternate: django-admin builtin commands succeed if settings are provided in the environment"
        args = ['check', 'admin_scripts']
        out, err = self.run_django_admin(args, 'test_project.alternate_settings')
        self.assertNoOutput(err)
        self.assertOutput(out, SYSTEM_CHECK_MSG)

    def test_builtin_with_bad_settings(self):
        "alternate: django-admin builtin commands fail if settings file (from argument) doesn't exist"
        args = ['check', '--settings=bad_settings', 'admin_scripts']
        out, err = self.run_django_admin(args)
        self.assertNoOutput(out)
        self.assertOutput(err, "No module named '?bad_settings'?", regex=True)

    def test_builtin_with_bad_environment(self):
        "alternate: django-admin builtin commands fail if settings file (from environment) doesn't exist"
        args = ['check', 'admin_scripts']
        out, err = self.run_django_admin(args, 'bad_settings')
        self.assertNoOutput(out)
        self.assertOutput(err, "No module named '?bad_settings'?", regex=True)

    def test_custom_command(self):
        "alternate: django-admin can't execute user commands unless settings are provided"
        args = ['noargs_command']
        out, err = self.run_django_admin(args)
        self.assertNoOutput(out)
        self.assertOutput(err, "No Django settings specified")
        self.assertOutput(err, "Unknown command: 'noargs_command'")

    def test_custom_command_with_settings(self):
        "alternate: django-admin can execute user commands if settings are provided as argument"
        args = ['noargs_command', '--settings=test_project.alternate_settings']
        out, err = self.run_django_admin(args)
        self.assertNoOutput(err)
        self.assertOutput(out, "EXECUTE: noargs_command")

    def test_custom_command_with_environment(self):
        "alternate: django-admin can execute user commands if settings are provided in environment"
        args = ['noargs_command']
        out, err = self.run_django_admin(args, 'test_project.alternate_settings')
        self.assertNoOutput(err)
        self.assertOutput(out, "EXECUTE: noargs_command")


</source>
<source file="django/tests/admin_scripts/tests.py.pyindent" startline="713" endline="778" pcid="9354">
    """A series of tests for manage.py when using a settings.py file that
    contains the test application.
    """
    def setUp(self):
        self.write_settings('settings.py')

    def tearDown(self):
        self.remove_settings('settings.py')

    def test_builtin_command(self):
        "default: manage.py builtin commands succeed when default settings are appropriate"
        args = ['check', 'admin_scripts']
        out, err = self.run_manage(args)
        self.assertNoOutput(err)
        self.assertOutput(out, SYSTEM_CHECK_MSG)

    def test_builtin_with_settings(self):
        "default: manage.py builtin commands succeed if settings are provided as argument"
        args = ['check', '--settings=test_project.settings', 'admin_scripts']
        out, err = self.run_manage(args)
        self.assertNoOutput(err)
        self.assertOutput(out, SYSTEM_CHECK_MSG)

    def test_builtin_with_environment(self):
        "default: manage.py builtin commands succeed if settings are provided in the environment"
        args = ['check', 'admin_scripts']
        out, err = self.run_manage(args, 'test_project.settings')
        self.assertNoOutput(err)
        self.assertOutput(out, SYSTEM_CHECK_MSG)

    def test_builtin_with_bad_settings(self):
        "default: manage.py builtin commands succeed if settings file (from argument) doesn't exist"
        args = ['check', '--settings=bad_settings', 'admin_scripts']
        out, err = self.run_manage(args)
        self.assertNoOutput(out)
        self.assertOutput(err, "No module named '?bad_settings'?", regex=True)

    def test_builtin_with_bad_environment(self):
        "default: manage.py builtin commands fail if settings file (from environment) doesn't exist"
        args = ['check', 'admin_scripts']
        out, err = self.run_manage(args, 'bad_settings')
        self.assertNoOutput(out)
        self.assertOutput(err, "No module named '?bad_settings'?", regex=True)

    def test_custom_command(self):
        "default: manage.py can execute user commands when default settings are appropriate"
        args = ['noargs_command']
        out, err = self.run_manage(args)
        self.assertNoOutput(err)
        self.assertOutput(out, "EXECUTE: noargs_command")

    def test_custom_command_with_settings(self):
        "default: manage.py can execute user commands when settings are provided as argument"
        args = ['noargs_command', '--settings=test_project.settings']
        out, err = self.run_manage(args)
        self.assertNoOutput(err)
        self.assertOutput(out, "EXECUTE: noargs_command")

    def test_custom_command_with_environment(self):
        "default: manage.py can execute user commands when settings are provided in environment"
        args = ['noargs_command']
        out, err = self.run_manage(args, 'test_project.settings')
        self.assertNoOutput(err)
        self.assertOutput(out, "EXECUTE: noargs_command")


</source>
<source file="django/tests/admin_scripts/tests.py.pyindent" startline="847" endline="912" pcid="9376">
    """A series of tests for manage.py when using a settings.py file that
    doesn't contain the test application.
    """
    def setUp(self):
        self.write_settings('settings.py', apps=['django.contrib.auth', 'django.contrib.contenttypes'])

    def tearDown(self):
        self.remove_settings('settings.py')

    def test_builtin_command(self):
        "minimal: manage.py builtin commands fail with an error when no settings provided"
        args = ['check', 'admin_scripts']
        out, err = self.run_manage(args)
        self.assertNoOutput(out)
        self.assertOutput(err, "No installed app with label 'admin_scripts'.")

    def test_builtin_with_settings(self):
        "minimal: manage.py builtin commands fail if settings are provided as argument"
        args = ['check', '--settings=test_project.settings', 'admin_scripts']
        out, err = self.run_manage(args)
        self.assertNoOutput(out)
        self.assertOutput(err, "No installed app with label 'admin_scripts'.")

    def test_builtin_with_environment(self):
        "minimal: manage.py builtin commands fail if settings are provided in the environment"
        args = ['check', 'admin_scripts']
        out, err = self.run_manage(args, 'test_project.settings')
        self.assertNoOutput(out)
        self.assertOutput(err, "No installed app with label 'admin_scripts'.")

    def test_builtin_with_bad_settings(self):
        "minimal: manage.py builtin commands fail if settings file (from argument) doesn't exist"
        args = ['check', '--settings=bad_settings', 'admin_scripts']
        out, err = self.run_manage(args)
        self.assertNoOutput(out)
        self.assertOutput(err, "No module named '?bad_settings'?", regex=True)

    def test_builtin_with_bad_environment(self):
        "minimal: manage.py builtin commands fail if settings file (from environment) doesn't exist"
        args = ['check', 'admin_scripts']
        out, err = self.run_manage(args, 'bad_settings')
        self.assertNoOutput(out)
        self.assertOutput(err, "No module named '?bad_settings'?", regex=True)

    def test_custom_command(self):
        "minimal: manage.py can't execute user commands without appropriate settings"
        args = ['noargs_command']
        out, err = self.run_manage(args)
        self.assertNoOutput(out)
        self.assertOutput(err, "Unknown command: 'noargs_command'")

    def test_custom_command_with_settings(self):
        "minimal: manage.py can't execute user commands, even if settings are provided as argument"
        args = ['noargs_command', '--settings=test_project.settings']
        out, err = self.run_manage(args)
        self.assertNoOutput(out)
        self.assertOutput(err, "Unknown command: 'noargs_command'")

    def test_custom_command_with_environment(self):
        "minimal: manage.py can't execute user commands, even if settings are provided in environment"
        args = ['noargs_command']
        out, err = self.run_manage(args, 'test_project.settings')
        self.assertNoOutput(out)
        self.assertOutput(err, "Unknown command: 'noargs_command'")


</source>
</class>

<class classid="99" nclones="2" nlines="11" similarity="72">
<source file="django/tests/admin_scripts/tests.py.pyindent" startline="966" endline="976" pcid="9396">
        "alternate: manage.py can execute user commands if settings are provided as argument"
        args = ['noargs_command', '--settings=alternate_settings']
        out, err = self.run_manage(args)
        self.assertOutput(
            out,
            "EXECUTE: noargs_command options=[('no_color', False), "
            "('pythonpath', None), ('settings', 'alternate_settings'), "
            "('traceback', False), ('verbosity', 1)]"
        )
        self.assertNoOutput(err)

</source>
<source file="django/tests/admin_scripts/tests.py.pyindent" startline="990" endline="1001" pcid="9398">
        "alternate: manage.py output syntax color can be deactivated with the `--no-color` option"
        args = ['noargs_command', '--no-color', '--settings=alternate_settings']
        out, err = self.run_manage(args)
        self.assertOutput(
            out,
            "EXECUTE: noargs_command options=[('no_color', True), "
            "('pythonpath', None), ('settings', 'alternate_settings'), "
            "('traceback', False), ('verbosity', 1)]"
        )
        self.assertNoOutput(err)


</source>
</class>

<class classid="100" nclones="2" nlines="11" similarity="72">
<source file="django/tests/admin_scripts/tests.py.pyindent" startline="978" endline="988" pcid="9397">
        "alternate: manage.py can execute user commands if settings are provided in environment"
        args = ['noargs_command']
        out, err = self.run_manage(args, 'alternate_settings')
        self.assertOutput(
            out,
            "EXECUTE: noargs_command options=[('no_color', False), "
            "('pythonpath', None), ('settings', None), ('traceback', False), "
            "('verbosity', 1)]"
        )
        self.assertNoOutput(err)

</source>
<source file="django/tests/admin_scripts/tests.py.pyindent" startline="1714" endline="1724" pcid="9494">
        "NoArg Commands can be executed"
        args = ['noargs_command']
        out, err = self.run_manage(args)
        self.assertNoOutput(err)
        self.assertOutput(
            out,
            "EXECUTE: noargs_command options=[('no_color', False), "
            "('pythonpath', None), ('settings', None), ('traceback', False), "
            "('verbosity', 1)]"
        )

</source>
</class>

<class classid="101" nclones="2" nlines="17" similarity="70">
<source file="django/tests/admin_scripts/tests.py.pyindent" startline="1162" endline="1182" pcid="9422">
        """ manage.py check does not raise an ImportError validating a
        complex app with nested calls to load_app """

        self.write_settings(
            'settings.py',
            apps=[
                'admin_scripts.complex_app',
                'admin_scripts.simple_app',
                'django.contrib.admin.apps.SimpleAdminConfig',
                'django.contrib.auth',
                'django.contrib.contenttypes',
            ],
            sdict={
                'DEBUG': True
            }
        )
        args = ['check']
        out, err = self.run_manage(args)
        self.assertNoOutput(err)
        self.assertEqual(out, 'System check identified no issues (0 silenced).\n')

</source>
<source file="django/tests/admin_scripts/tests.py.pyindent" startline="1184" endline="1201" pcid="9423">
        """ manage.py check does not raise errors when an app imports a base
        class that itself has an abstract base. """

        self.write_settings(
            'settings.py',
            apps=[
                'admin_scripts.app_with_import',
                'django.contrib.auth',
                'django.contrib.contenttypes',
                'django.contrib.sites',
            ],
            sdict={'DEBUG': True},
        )
        args = ['check']
        out, err = self.run_manage(args)
        self.assertNoOutput(err)
        self.assertEqual(out, 'System check identified no issues (0 silenced).\n')

</source>
</class>

<class classid="102" nclones="2" nlines="15" similarity="73">
<source file="django/tests/admin_scripts/tests.py.pyindent" startline="1923" endline="1936" pcid="9520">
        "Make sure the startproject management command validates a project name"
        for bad_name in ('7testproject', '../testproject'):
            args = ['startproject', bad_name]
            testproject_dir = os.path.join(self.test_dir, bad_name)
            self.addCleanup(shutil.rmtree, testproject_dir, True)

            out, err = self.run_django_admin(args)
            self.assertOutput(
                err,
                "Error: '%s' is not a valid project name. Please make "
                "sure the name is a valid identifier." % bad_name
            )
            self.assertFalse(os.path.exists(testproject_dir))

</source>
<source file="django/tests/admin_scripts/tests.py.pyindent" startline="2139" endline="2152" pcid="9541">
        """startapp validates that app name is a valid Python identifier."""
        for bad_name in ('7testproject', '../testproject'):
            args = ['startapp', bad_name]
            testproject_dir = os.path.join(self.test_dir, bad_name)
            self.addCleanup(shutil.rmtree, testproject_dir, True)

            out, err = self.run_django_admin(args)
            self.assertOutput(
                err,
                "CommandError: '{}' is not a valid app name. Please make "
                "sure the name is a valid identifier.".format(bad_name)
            )
            self.assertFalse(os.path.exists(testproject_dir))

</source>
</class>

<class classid="103" nclones="2" nlines="13" similarity="84">
<source file="django/tests/admin_scripts/tests.py.pyindent" startline="1938" endline="1955" pcid="9522">
        """
        startproject validates that project name doesn't clash with existing
        Python modules.
        """
        bad_name = 'os'
        args = ['startproject', bad_name]
        testproject_dir = os.path.join(self.test_dir, bad_name)
        self.addCleanup(shutil.rmtree, testproject_dir, True)

        out, err = self.run_django_admin(args)
        self.assertOutput(
            err,
            "CommandError: 'os' conflicts with the name of an existing "
            "Python module and cannot be used as a project name. Please try "
            "another name."
        )
        self.assertFalse(os.path.exists(testproject_dir))

</source>
<source file="django/tests/admin_scripts/tests.py.pyindent" startline="2154" endline="2172" pcid="9543">
        """
        startapp validates that app name doesn't clash with existing Python
        modules.
        """
        bad_name = 'os'
        args = ['startapp', bad_name]
        testproject_dir = os.path.join(self.test_dir, bad_name)
        self.addCleanup(shutil.rmtree, testproject_dir, True)

        out, err = self.run_django_admin(args)
        self.assertOutput(
            err,
            "CommandError: 'os' conflicts with the name of an existing "
            "Python module and cannot be used as an app name. Please try "
            "another name."
        )
        self.assertFalse(os.path.exists(testproject_dir))


</source>
</class>

<class classid="104" nclones="2" nlines="11" similarity="81">
<source file="django/tests/admin_scripts/tests.py.pyindent" startline="1973" endline="1983" pcid="9524">
        "Make sure the startproject management command is able to use a different project template"
        template_path = os.path.join(custom_templates_dir, 'project_template')
        args = ['startproject', '--template', template_path, 'customtestproject']
        testproject_dir = os.path.join(self.test_dir, 'customtestproject')
        self.addCleanup(shutil.rmtree, testproject_dir, True)

        out, err = self.run_django_admin(args)
        self.assertNoOutput(err)
        self.assertTrue(os.path.isdir(testproject_dir))
        self.assertTrue(os.path.exists(os.path.join(testproject_dir, 'additional_dir')))

</source>
<source file="django/tests/admin_scripts/tests.py.pyindent" startline="1985" endline="1995" pcid="9525">
        "Ticket 17475: Template dir passed has a trailing path separator"
        template_path = os.path.join(custom_templates_dir, 'project_template' + os.sep)
        args = ['startproject', '--template', template_path, 'customtestproject']
        testproject_dir = os.path.join(self.test_dir, 'customtestproject')
        self.addCleanup(shutil.rmtree, testproject_dir, True)

        out, err = self.run_django_admin(args)
        self.assertNoOutput(err)
        self.assertTrue(os.path.isdir(testproject_dir))
        self.assertTrue(os.path.exists(os.path.join(testproject_dir, 'additional_dir')))

</source>
</class>

<class classid="105" nclones="2" nlines="11" similarity="81">
<source file="django/tests/admin_scripts/tests.py.pyindent" startline="2022" endline="2036" pcid="9528">
        """
        The startproject management command is able to use a different project
        template from a tarball via a URL.
        """
        template_url = '%s/custom_templates/project_template.tgz' % self.live_server_url

        args = ['startproject', '--template', template_url, 'urltestproject']
        testproject_dir = os.path.join(self.test_dir, 'urltestproject')
        self.addCleanup(shutil.rmtree, testproject_dir, True)

        out, err = self.run_django_admin(args)
        self.assertNoOutput(err)
        self.assertTrue(os.path.isdir(testproject_dir))
        self.assertTrue(os.path.exists(os.path.join(testproject_dir, 'run.py')))

</source>
<source file="django/tests/admin_scripts/tests.py.pyindent" startline="2038" endline="2049" pcid="9529">
        "Startproject management command handles project template tar/zip balls from non-canonical urls"
        template_url = '%s/custom_templates/project_template.tgz/' % self.live_server_url

        args = ['startproject', '--template', template_url, 'urltestproject']
        testproject_dir = os.path.join(self.test_dir, 'urltestproject')
        self.addCleanup(shutil.rmtree, testproject_dir, True)

        out, err = self.run_django_admin(args)
        self.assertNoOutput(err)
        self.assertTrue(os.path.isdir(testproject_dir))
        self.assertTrue(os.path.exists(os.path.join(testproject_dir, 'run.py')))

</source>
</class>

<class classid="106" nclones="2" nlines="11" similarity="72">
<source file="django/tests/admin_scripts/tests.py.pyindent" startline="2209" endline="2219" pcid="9548">
        """--output=unified emits settings diff in unified mode."""
        self.write_settings('settings_to_diff.py', sdict={'FOO': '"bar"'})
        self.addCleanup(self.remove_settings, 'settings_to_diff.py')
        args = ['diffsettings', '--settings=settings_to_diff', '--output=unified']
        out, err = self.run_manage(args)
        self.assertNoOutput(err)
        self.assertOutput(out, "+ FOO = 'bar'")
        self.assertOutput(out, "- SECRET_KEY = ''")
        self.assertOutput(out, "+ SECRET_KEY = 'django_tests_secret_key'")
        self.assertNotInOutput(out, "  APPEND_SLASH = True")

</source>
<source file="django/tests/admin_scripts/tests.py.pyindent" startline="2221" endline="2234" pcid="9549">
        """
        --output=unified --all emits settings diff in unified mode and includes
        settings with the default value.
        """
        self.write_settings('settings_to_diff.py', sdict={'FOO': '"bar"'})
        self.addCleanup(self.remove_settings, 'settings_to_diff.py')
        args = ['diffsettings', '--settings=settings_to_diff', '--output=unified', '--all']
        out, err = self.run_manage(args)
        self.assertNoOutput(err)
        self.assertOutput(out, "  APPEND_SLASH = True")
        self.assertOutput(out, "+ FOO = 'bar'")
        self.assertOutput(out, "- SECRET_KEY = ''")


</source>
</class>

<class classid="107" nclones="2" nlines="17" similarity="76">
<source file="django/tests/admin_scripts/tests.py.pyindent" startline="2236" endline="2254" pcid="9550">
    """Tests for dumpdata management command."""

    def setUp(self):
        self.write_settings('settings.py')

    def tearDown(self):
        self.remove_settings('settings.py')

    def test_pks_parsing(self):
        """Regression for #20509

        Test would raise an exception rather than printing an error message.
        """
        args = ['dumpdata', '--pks=1']
        out, err = self.run_manage(args)
        self.assertOutput(err, "You can only use --pks option with one model")
        self.assertNoOutput(out)


</source>
<source file="django/tests/test_runner/tests.py.pyindent" startline="191" endline="203" pcid="26622">
    def setUp(self):
        self.write_settings('settings.py')

    def tearDown(self):
        self.remove_settings('settings.py')

    def test_ticket_17477(self):
        """'manage.py help test' works after r16352."""
        args = ['help', 'test']
        out, err = self.run_manage(args)
        self.assertNoOutput(err)


</source>
</class>

<class classid="108" nclones="2" nlines="22" similarity="81">
<source file="django/tests/admin_views/admin.py.pyindent" startline="417" endline="433" pcid="9712">
    model = PrePopulatedSubPost

    prepopulated_fields = {
        'subslug': ('subtitle',)
    }

    def get_readonly_fields(self, request, obj=None):
        if obj and obj.published:
            return ('subslug',)
        return self.readonly_fields

    def get_prepopulated_fields(self, request, obj=None):
        if obj and obj.published:
            return {}
        return self.prepopulated_fields


</source>
<source file="django/tests/admin_views/admin.py.pyindent" startline="435" endline="452" pcid="9717">
    list_display = ['title', 'slug']
    prepopulated_fields = {
        'slug': ('title',)
    }

    inlines = [SubPostInline]

    def get_readonly_fields(self, request, obj=None):
        if obj and obj.published:
            return ('slug',)
        return self.readonly_fields

    def get_prepopulated_fields(self, request, obj=None):
        if obj and obj.published:
            return {}
        return self.prepopulated_fields


</source>
</class>

<class classid="109" nclones="16" nlines="11" similarity="71">
<source file="django/tests/admin_views/models.py.pyindent" startline="17" endline="33" pcid="9863">
    """
    A simple section that links to articles, to test linking to related items
    in admin views.
    """
    name = models.CharField(max_length=100)

    def __str__(self):
        return self.name

    @property
    def name_property(self):
        """
        A property that simply returns the name. Used to test #24461
        """
        return self.name


</source>
<source file="django/tests/view_tests/models.py.pyindent" startline="9" endline="17" pcid="28261">
    name = models.CharField(max_length=100)

    def __str__(self):
        return self.name

    def get_absolute_url(self):
        return '/authors/%s/' % self.id


</source>
<source file="django/tests/contenttypes_tests/models.py.pyindent" startline="20" endline="28" pcid="11654">
    name = models.CharField(max_length=100)

    def __str__(self):
        return self.name

    def get_absolute_url(self):
        return '/authors/%s/' % self.id


</source>
<source file="django/tests/contenttypes_tests/models.py.pyindent" startline="40" endline="48" pcid="11659">
    url = models.URLField(max_length=100)

    def __str__(self):
        return self.url

    def get_absolute_url(self):
        return self.url


</source>
<source file="django/tests/admin_widgets/models.py.pyindent" startline="136" endline="144" pcid="10167">
    name = models.CharField(max_length=255)

    def __str__(self):
        return self.name

    class Meta:
        ordering = ('name',)


</source>
<source file="django/tests/queries/models.py.pyindent" startline="388" endline="397" pcid="22383">
    name = models.CharField(max_length=50)

    def __str__(self):
        return self.name

    def __iter__(self):
        # Ticket #23721
        assert False, 'type checking should happen without calling model __iter__'


</source>
<source file="django/tests/admin_views/models.py.pyindent" startline="118" endline="126" pcid="9883">
    string_pk = models.CharField(max_length=255, primary_key=True)

    def __str__(self):
        return self.string_pk

    def get_absolute_url(self):
        return '/dummy/%s/' % self.string_pk


</source>
<source file="django/tests/prefetch_related/models.py.pyindent" startline="243" endline="254" pcid="22089">
    name = models.CharField(max_length=50)
    boss = models.ForeignKey('self', models.SET_NULL, null=True, related_name='serfs')

    def __str__(self):
        return self.name

    class Meta:
        ordering = ['id']


# Ticket #19607

</source>
<source file="django/tests/many_to_many/models.py.pyindent" startline="13" endline="21" pcid="18597">
    title = models.CharField(max_length=30)

    def __str__(self):
        return self.title

    class Meta:
        ordering = ('title',)


</source>
<source file="django/tests/m2m_through_regress/models.py.pyindent" startline="53" endline="61" pcid="18429">
    name = models.CharField(max_length=20, unique=True, null=True)

    def __str__(self):
        return "%s" % self.name

    class Meta:
        ordering = ('name',)


</source>
<source file="django/tests/prefetch_related/models.py.pyindent" startline="78" endline="87" pcid="22057">
    name = models.CharField(max_length=50)
    books_read = models.ManyToManyField(Book, related_name='read_by')

    def __str__(self):
        return self.name

    class Meta:
        ordering = ['id']


</source>
<source file="django/tests/prefetch_related/models.py.pyindent" startline="119" endline="131" pcid="22068">
    name = models.CharField(max_length=50)
    qualifications = models.ManyToManyField(Qualification)

    objects = TeacherManager()
    objects_custom = TeacherQuerySet.as_manager()

    def __str__(self):
        return "%s (%s)" % (self.name, ", ".join(q.name for q in self.qualifications.all()))

    class Meta:
        ordering = ['id']


</source>
<source file="django/tests/prefetch_related/models.py.pyindent" startline="13" endline="24" pcid="22043">
    name = models.CharField(max_length=50, unique=True)
    first_book = models.ForeignKey('Book', models.CASCADE, related_name='first_time_authors')
    favorite_authors = models.ManyToManyField(
        'self', through='FavoriteAuthors', symmetrical=False, related_name='favors_me')

    def __str__(self):
        return self.name

    class Meta:
        ordering = ['id']


</source>
<source file="django/tests/prefetch_related/models.py.pyindent" startline="274" endline="286" pcid="22096">
    name = models.CharField(max_length=50, unique=True)
    first_book = models.ForeignKey('Book', models.CASCADE, related_name='first_time_authors+')
    favorite_books = models.ManyToManyField('Book', related_name='+')

    def __str__(self):
        return self.name

    class Meta:
        ordering = ['id']


# Models for many-to-many with UUID pk test:

</source>
<source file="django/tests/prefetch_related/models.py.pyindent" startline="50" endline="59" pcid="22052">
    title = models.CharField(max_length=255)
    authors = models.ManyToManyField(Author, related_name='books')

    def __str__(self):
        return self.title

    class Meta:
        ordering = ['id']


</source>
<source file="django/tests/fixtures/models.py.pyindent" startline="20" endline="29" pcid="13435">
    title = models.CharField(max_length=100)
    description = models.TextField()

    def __str__(self):
        return self.title

    class Meta:
        ordering = ('title',)


</source>
</class>

<class classid="110" nclones="2" nlines="11" similarity="81">
<source file="django/tests/admin_views/models.py.pyindent" startline="318" endline="324" pcid="9921">
    name = models.CharField(max_length=128)

    def clean(self):
        if self.name == '_invalid':
            raise ValidationError('invalid')


</source>
<source file="django/tests/admin_views/models.py.pyindent" startline="326" endline="333" pcid="9924">
    parent = models.ForeignKey(Parent, models.CASCADE, editable=False)
    name = models.CharField(max_length=30, blank=True)

    def clean(self):
        if self.name == '_invalid':
            raise ValidationError('invalid')


</source>
</class>

<class classid="111" nclones="3" nlines="10" similarity="70">
<source file="django/tests/admin_views/models.py.pyindent" startline="502" endline="510" pcid="9962">
    name = models.CharField(max_length=100)
    team_leader = models.ForeignKey(Villain, models.CASCADE, related_name='lead_plots')
    contact = models.ForeignKey(Villain, models.CASCADE, related_name='contact_plots')
    tags = GenericRelation(FunkyTag)

    def __str__(self):
        return self.name


</source>
<source file="django/tests/admin_widgets/models.py.pyindent" startline="12" endline="20" pcid="10148">
    name = models.CharField(max_length=100)
    birthdate = models.DateTimeField(blank=True, null=True)
    gender = models.CharField(max_length=1, blank=True, choices=[('M', 'Male'), ('F', 'Female')])
    email = models.EmailField(blank=True)

    def __str__(self):
        return self.name


</source>
<source file="django/tests/fixtures/models.py.pyindent" startline="42" endline="50" pcid="13441">
    name = models.CharField(max_length=100)
    featured = models.ForeignKey(Article, models.CASCADE, related_name='fixtures_featured_set')
    articles = models.ManyToManyField(Article, blank=True,
                                      related_name='fixtures_articles_set')

    def __str__(self):
        return self.name


</source>
</class>

<class classid="112" nclones="3" nlines="10" similarity="70">
<source file="django/tests/admin_views/test_actions.py.pyindent" startline="33" endline="42" pcid="10054">
        """A custom action defined in a ModelAdmin method."""
        action_data = {
            ACTION_CHECKBOX_NAME: [self.s1.pk],
            'action': 'mail_admin',
            'index': 0,
        }
        self.client.post(reverse('admin:admin_views_subscriber_changelist'), action_data)
        self.assertEqual(len(mail.outbox), 1)
        self.assertEqual(mail.outbox[0].subject, 'Greetings from a ModelAdmin action')

</source>
<source file="django/tests/admin_views/test_actions.py.pyindent" startline="169" endline="178" pcid="10062">
        """A custom action may be defined in a function."""
        action_data = {
            ACTION_CHECKBOX_NAME: [self.s1.pk],
            'action': 'external_mail',
            'index': 0,
        }
        self.client.post(reverse('admin:admin_views_externalsubscriber_changelist'), action_data)
        self.assertEqual(len(mail.outbox), 1)
        self.assertEqual(mail.outbox[0].subject, 'Greetings from a function action')

</source>
<source file="django/tests/admin_views/test_actions.py.pyindent" startline="190" endline="202" pcid="10064">
        """
        Actions which don't return an HttpResponse are redirected to the same
        page, retaining the querystring (which may contain changelist info).
        """
        action_data = {
            ACTION_CHECKBOX_NAME: [self.s1.pk],
            'action': 'external_mail',
            'index': 0,
        }
        url = reverse('admin:admin_views_externalsubscriber_changelist') + '?o=1'
        response = self.client.post(url, action_data)
        self.assertRedirects(response, url)

</source>
</class>

<class classid="113" nclones="2" nlines="14" similarity="71">
<source file="django/tests/admin_views/test_actions.py.pyindent" startline="295" endline="310" pcid="10073">
        """
        User sees a warning when 'Go' is pressed and no items are selected.
        """
        action_data = {
            ACTION_CHECKBOX_NAME: [],
            'action': 'delete_selected',
            'index': 0,
        }
        url = reverse('admin:admin_views_subscriber_changelist')
        response = self.client.post(url, action_data)
        self.assertRedirects(response, url, fetch_redirect_response=False)
        response = self.client.get(response.url)
        msg = 'Items must be selected in order to perform actions on them. No items have been changed.'
        self.assertContains(response, msg)
        self.assertEqual(Subscriber.objects.count(), 2)

</source>
<source file="django/tests/admin_views/test_actions.py.pyindent" startline="312" endline="326" pcid="10074">
        """
        User sees a warning when 'Go' is pressed and no action is selected.
        """
        action_data = {
            ACTION_CHECKBOX_NAME: [self.s1.pk, self.s2.pk],
            'action': '',
            'index': 0,
        }
        url = reverse('admin:admin_views_subscriber_changelist')
        response = self.client.post(url, action_data)
        self.assertRedirects(response, url, fetch_redirect_response=False)
        response = self.client.get(response.url)
        self.assertContains(response, 'No action selected.')
        self.assertEqual(Subscriber.objects.count(), 2)

</source>
</class>

<class classid="114" nclones="3" nlines="13" similarity="76">
<source file="django/tests/admin_views/test_actions.py.pyindent" startline="341" endline="356" pcid="10077">
        """
        Success on popups shall be rendered from template in order to allow
        easy customization.
        """
        response = self.client.post(
            reverse('admin:admin_views_actor_add') + '?%s=1' % IS_POPUP_VAR,
            {'name': 'Troy McClure', 'age': '55', IS_POPUP_VAR: '1'}
        )
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.template_name, [
            'admin/admin_views/actor/popup_response.html',
            'admin/admin_views/popup_response.html',
            'admin/popup_response.html',
        ])
        self.assertTemplateUsed(response, 'admin/popup_response.html')

</source>
<source file="django/tests/admin_views/test_actions.py.pyindent" startline="372" endline="384" pcid="10079">
        instance = Actor.objects.create(name='David Tennant', age=45)
        response = self.client.post(
            reverse('admin:admin_views_actor_delete', args=(instance.pk,)) + '?%s=1' % IS_POPUP_VAR,
            {IS_POPUP_VAR: '1'}
        )
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.template_name, [
            'admin/admin_views/actor/popup_response.html',
            'admin/admin_views/popup_response.html',
            'admin/popup_response.html',
        ])
        self.assertTemplateUsed(response, 'admin/popup_response.html')

</source>
<source file="django/tests/admin_views/test_actions.py.pyindent" startline="358" endline="370" pcid="10078">
        instance = Actor.objects.create(name='David Tennant', age=45)
        response = self.client.post(
            reverse('admin:admin_views_actor_change', args=(instance.pk,)) + '?%s=1' % IS_POPUP_VAR,
            {'name': 'David Tennant', 'age': '46', IS_POPUP_VAR: '1'}
        )
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.template_name, [
            'admin/admin_views/actor/popup_response.html',
            'admin/admin_views/popup_response.html',
            'admin/popup_response.html',
        ])
        self.assertTemplateUsed(response, 'admin/popup_response.html')

</source>
</class>

<class classid="115" nclones="2" nlines="34" similarity="77">
<source file="django/tests/admin_views/test_autocomplete_view.py.pyindent" startline="165" endline="198" pcid="10117">
        from selenium.webdriver.common.keys import Keys
        from selenium.webdriver.support.ui import Select
        self.selenium.get(self.live_server_url + reverse('autocomplete_admin:admin_views_answer_add'))
        elem = self.selenium.find_element_by_css_selector('.select2-selection')
        elem.click()  # Open the autocomplete dropdown.
        results = self.selenium.find_element_by_css_selector('.select2-results')
        self.assertTrue(results.is_displayed())
        option = self.selenium.find_element_by_css_selector('.select2-results__option')
        self.assertEqual(option.text, 'No results found')
        elem.click()  # Close the autocomplete dropdown.
        q1 = Question.objects.create(question='Who am I?')
        Question.objects.bulk_create(Question(question=str(i)) for i in range(PAGINATOR_SIZE + 10))
        elem.click()  # Reopen the dropdown now that some objects exist.
        result_container = self.selenium.find_element_by_css_selector('.select2-results')
        self.assertTrue(result_container.is_displayed())
        results = result_container.find_elements_by_css_selector('.select2-results__option')
        # PAGINATOR_SIZE results and "Loading more results".
        self.assertEqual(len(results), PAGINATOR_SIZE + 1)
        search = self.selenium.find_element_by_css_selector('.select2-search__field')
        # Load next page of results by scrolling to the bottom of the list.
        for _ in range(len(results)):
            search.send_keys(Keys.ARROW_DOWN)
        results = result_container.find_elements_by_css_selector('.select2-results__option')
        # All objects and "Loading more results".
        self.assertEqual(len(results), PAGINATOR_SIZE + 11)
        # Limit the results with the search field.
        search.send_keys('Who')
        results = result_container.find_elements_by_css_selector('.select2-results__option')
        self.assertEqual(len(results), 1)
        # Select the result.
        search.send_keys(Keys.RETURN)
        select = Select(self.selenium.find_element_by_id('id_question'))
        self.assertEqual(select.first_selected_option.get_attribute('value'), str(q1.pk))

</source>
<source file="django/tests/admin_views/test_autocomplete_view.py.pyindent" startline="200" endline="235" pcid="10119">
        from selenium.webdriver.common.keys import Keys
        from selenium.webdriver.support.ui import Select
        self.selenium.get(self.live_server_url + reverse('autocomplete_admin:admin_views_question_add'))
        elem = self.selenium.find_element_by_css_selector('.select2-selection')
        elem.click()  # Open the autocomplete dropdown.
        results = self.selenium.find_element_by_css_selector('.select2-results')
        self.assertTrue(results.is_displayed())
        option = self.selenium.find_element_by_css_selector('.select2-results__option')
        self.assertEqual(option.text, 'No results found')
        elem.click()  # Close the autocomplete dropdown.
        Question.objects.create(question='Who am I?')
        Question.objects.bulk_create(Question(question=str(i)) for i in range(PAGINATOR_SIZE + 10))
        elem.click()  # Reopen the dropdown now that some objects exist.
        result_container = self.selenium.find_element_by_css_selector('.select2-results')
        self.assertTrue(result_container.is_displayed())
        results = result_container.find_elements_by_css_selector('.select2-results__option')
        self.assertEqual(len(results), PAGINATOR_SIZE + 1)
        search = self.selenium.find_element_by_css_selector('.select2-search__field')
        # Load next page of results by scrolling to the bottom of the list.
        for _ in range(len(results)):
            search.send_keys(Keys.ARROW_DOWN)
        results = result_container.find_elements_by_css_selector('.select2-results__option')
        self.assertEqual(len(results), 31)
        # Limit the results with the search field.
        search.send_keys('Who')
        results = result_container.find_elements_by_css_selector('.select2-results__option')
        self.assertEqual(len(results), 1)
        # Select the result.
        search.send_keys(Keys.RETURN)
        # Reopen the dropdown and add the first result to the selection.
        elem.click()
        search.send_keys(Keys.ARROW_DOWN)
        search.send_keys(Keys.RETURN)
        select = Select(self.selenium.find_element_by_id('id_related_questions'))
        self.assertEqual(len(select.all_selected_options), 2)

</source>
</class>

<class classid="116" nclones="2" nlines="12" similarity="71">
<source file="django/tests/admin_views/test_multidb.py.pyindent" startline="36" endline="46" pcid="10129">
        cls.superusers = {}
        cls.test_book_ids = {}
        for db in connections:
            Router.target_db = db
            cls.superusers[db] = User.objects.create_superuser(
                username='admin', password='something', email='test@test.org',
            )
            b = Book(name='Test Book')
            b.save(using=db)
            cls.test_book_ids[db] = b.id

</source>
<source file="django/tests/auth_tests/test_admin_multidb.py.pyindent" startline="35" endline="41" pcid="10521">
        cls.superusers = {}
        for db in connections:
            Router.target_db = db
            cls.superusers[db] = User.objects.create_superuser(
                username='admin', password='something', email='test@test.org',
            )

</source>
</class>

<class classid="117" nclones="3" nlines="15" similarity="86">
<source file="django/tests/admin_views/test_multidb.py.pyindent" startline="49" endline="58" pcid="10131">
        for db in connections:
            with self.subTest(db=db):
                Router.target_db = db
                self.client.force_login(self.superusers[db])
                self.client.post(
                    reverse('test_adminsite:admin_views_book_add'),
                    {'name': 'Foobar: 5th edition'},
                )
                mock.atomic.assert_called_with(using=db)

</source>
<source file="django/tests/admin_views/test_multidb.py.pyindent" startline="73" endline="81" pcid="10137">
        for db in connections:
            with self.subTest(db=db):
                Router.target_db = db
                self.client.force_login(self.superusers[db])
                self.client.post(
                    reverse('test_adminsite:admin_views_book_delete', args=[self.test_book_ids[db]]),
                    {'post': 'yes'},
                )
                mock.atomic.assert_called_with(using=db)
</source>
<source file="django/tests/admin_views/test_multidb.py.pyindent" startline="61" endline="70" pcid="10134">
        for db in connections:
            with self.subTest(db=db):
                Router.target_db = db
                self.client.force_login(self.superusers[db])
                self.client.post(
                    reverse('test_adminsite:admin_views_book_change', args=[self.test_book_ids[db]]),
                    {'name': 'Test Book 2: Test more'},
                )
                mock.atomic.assert_called_with(using=db)

</source>
</class>

<class classid="118" nclones="3" nlines="17" similarity="75">
<source file="django/tests/aggregation/models.py.pyindent" startline="23" endline="36" pcid="10205">
    isbn = models.CharField(max_length=9)
    name = models.CharField(max_length=255)
    pages = models.IntegerField()
    rating = models.FloatField()
    price = models.DecimalField(decimal_places=2, max_digits=6)
    authors = models.ManyToManyField(Author)
    contact = models.ForeignKey(Author, models.CASCADE, related_name='book_contact_set')
    publisher = models.ForeignKey(Publisher, models.CASCADE)
    pubdate = models.DateField()

    def __str__(self):
        return self.name


</source>
<source file="django/tests/aggregation_regress/models.py.pyindent" startline="33" endline="50" pcid="10314">
    isbn = models.CharField(max_length=9)
    name = models.CharField(max_length=255)
    pages = models.IntegerField()
    rating = models.FloatField()
    price = models.DecimalField(decimal_places=2, max_digits=6)
    authors = models.ManyToManyField(Author)
    contact = models.ForeignKey(Author, models.CASCADE, related_name='book_contact_set')
    publisher = models.ForeignKey(Publisher, models.CASCADE)
    pubdate = models.DateField()
    tags = GenericRelation(ItemTag)

    class Meta:
        ordering = ('name',)

    def __str__(self):
        return self.name


</source>
<source file="django/tests/annotations/models.py.pyindent" startline="22" endline="35" pcid="10414">
    isbn = models.CharField(max_length=9)
    name = models.CharField(max_length=255)
    pages = models.IntegerField()
    rating = models.FloatField()
    price = models.DecimalField(decimal_places=2, max_digits=6)
    authors = models.ManyToManyField(Author)
    contact = models.ForeignKey(Author, models.CASCADE, related_name='book_contact_set')
    publisher = models.ForeignKey(Publisher, models.CASCADE)
    pubdate = models.DateField()

    def __str__(self):
        return self.name


</source>
</class>

<class classid="119" nclones="3" nlines="10" similarity="100">
<source file="django/tests/aggregation/models.py.pyindent" startline="38" endline="44" pcid="10207">
    name = models.CharField(max_length=255)
    books = models.ManyToManyField(Book)
    original_opening = models.DateTimeField()
    friday_night_closing = models.TimeField()

    def __str__(self):
        return self.name
</source>
<source file="django/tests/aggregation_regress/models.py.pyindent" startline="52" endline="60" pcid="10317">
    name = models.CharField(max_length=255)
    books = models.ManyToManyField(Book)
    original_opening = models.DateTimeField()
    friday_night_closing = models.TimeField()

    def __str__(self):
        return self.name


</source>
<source file="django/tests/annotations/models.py.pyindent" startline="37" endline="45" pcid="10416">
    name = models.CharField(max_length=255)
    books = models.ManyToManyField(Book)
    original_opening = models.DateTimeField()
    friday_night_closing = models.TimeField()

    def __str__(self):
        return self.name


</source>
</class>

<class classid="120" nclones="2" nlines="69" similarity="91">
<source file="django/tests/aggregation/tests.py.pyindent" startline="22" endline="101" pcid="10210">
        cls.a1 = Author.objects.create(name='Adrian Holovaty', age=34)
        cls.a2 = Author.objects.create(name='Jacob Kaplan-Moss', age=35)
        cls.a3 = Author.objects.create(name='Brad Dayley', age=45)
        cls.a4 = Author.objects.create(name='James Bennett', age=29)
        cls.a5 = Author.objects.create(name='Jeffrey Forcier', age=37)
        cls.a6 = Author.objects.create(name='Paul Bissex', age=29)
        cls.a7 = Author.objects.create(name='Wesley J. Chun', age=25)
        cls.a8 = Author.objects.create(name='Peter Norvig', age=57)
        cls.a9 = Author.objects.create(name='Stuart Russell', age=46)
        cls.a1.friends.add(cls.a2, cls.a4)
        cls.a2.friends.add(cls.a1, cls.a7)
        cls.a4.friends.add(cls.a1)
        cls.a5.friends.add(cls.a6, cls.a7)
        cls.a6.friends.add(cls.a5, cls.a7)
        cls.a7.friends.add(cls.a2, cls.a5, cls.a6)
        cls.a8.friends.add(cls.a9)
        cls.a9.friends.add(cls.a8)

        cls.p1 = Publisher.objects.create(name='Apress', num_awards=3, duration=datetime.timedelta(days=1))
        cls.p2 = Publisher.objects.create(name='Sams', num_awards=1, duration=datetime.timedelta(days=2))
        cls.p3 = Publisher.objects.create(name='Prentice Hall', num_awards=7)
        cls.p4 = Publisher.objects.create(name='Morgan Kaufmann', num_awards=9)
        cls.p5 = Publisher.objects.create(name="Jonno's House of Books", num_awards=0)

        cls.b1 = Book.objects.create(
            isbn='159059725', name='The Definitive Guide to Django: Web Development Done Right',
            pages=447, rating=4.5, price=Decimal('30.00'), contact=cls.a1, publisher=cls.p1,
            pubdate=datetime.date(2007, 12, 6)
        )
        cls.b2 = Book.objects.create(
            isbn='067232959', name='Sams Teach Yourself Django in 24 Hours',
            pages=528, rating=3.0, price=Decimal('23.09'), contact=cls.a3, publisher=cls.p2,
            pubdate=datetime.date(2008, 3, 3)
        )
        cls.b3 = Book.objects.create(
            isbn='159059996', name='Practical Django Projects',
            pages=300, rating=4.0, price=Decimal('29.69'), contact=cls.a4, publisher=cls.p1,
            pubdate=datetime.date(2008, 6, 23)
        )
        cls.b4 = Book.objects.create(
            isbn='013235613', name='Python Web Development with Django',
            pages=350, rating=4.0, price=Decimal('29.69'), contact=cls.a5, publisher=cls.p3,
            pubdate=datetime.date(2008, 11, 3)
        )
        cls.b5 = Book.objects.create(
            isbn='013790395', name='Artificial Intelligence: A Modern Approach',
            pages=1132, rating=4.0, price=Decimal('82.80'), contact=cls.a8, publisher=cls.p3,
            pubdate=datetime.date(1995, 1, 15)
        )
        cls.b6 = Book.objects.create(
            isbn='155860191', name='Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp',
            pages=946, rating=5.0, price=Decimal('75.00'), contact=cls.a8, publisher=cls.p4,
            pubdate=datetime.date(1991, 10, 15)
        )
        cls.b1.authors.add(cls.a1, cls.a2)
        cls.b2.authors.add(cls.a3)
        cls.b3.authors.add(cls.a4)
        cls.b4.authors.add(cls.a5, cls.a6, cls.a7)
        cls.b5.authors.add(cls.a8, cls.a9)
        cls.b6.authors.add(cls.a8)

        s1 = Store.objects.create(
            name='Amazon.com',
            original_opening=datetime.datetime(1994, 4, 23, 9, 17, 42),
            friday_night_closing=datetime.time(23, 59, 59)
        )
        s2 = Store.objects.create(
            name='Books.com',
            original_opening=datetime.datetime(2001, 3, 15, 11, 23, 37),
            friday_night_closing=datetime.time(23, 59, 59)
        )
        s3 = Store.objects.create(
            name="Mamma and Pappa's Books",
            original_opening=datetime.datetime(1945, 4, 25, 16, 24, 14),
            friday_night_closing=datetime.time(21, 30)
        )
        s1.books.add(cls.b1, cls.b2, cls.b3, cls.b4, cls.b5, cls.b6)
        s2.books.add(cls.b1, cls.b3, cls.b5, cls.b6)
        s3.books.add(cls.b3, cls.b4, cls.b6)

</source>
<source file="django/tests/aggregation_regress/tests.py.pyindent" startline="27" endline="104" pcid="10329">
        cls.a1 = Author.objects.create(name='Adrian Holovaty', age=34)
        cls.a2 = Author.objects.create(name='Jacob Kaplan-Moss', age=35)
        cls.a3 = Author.objects.create(name='Brad Dayley', age=45)
        cls.a4 = Author.objects.create(name='James Bennett', age=29)
        cls.a5 = Author.objects.create(name='Jeffrey Forcier', age=37)
        cls.a6 = Author.objects.create(name='Paul Bissex', age=29)
        cls.a7 = Author.objects.create(name='Wesley J. Chun', age=25)
        cls.a8 = Author.objects.create(name='Peter Norvig', age=57)
        cls.a9 = Author.objects.create(name='Stuart Russell', age=46)
        cls.a1.friends.add(cls.a2, cls.a4)
        cls.a2.friends.add(cls.a1, cls.a7)
        cls.a4.friends.add(cls.a1)
        cls.a5.friends.add(cls.a6, cls.a7)
        cls.a6.friends.add(cls.a5, cls.a7)
        cls.a7.friends.add(cls.a2, cls.a5, cls.a6)
        cls.a8.friends.add(cls.a9)
        cls.a9.friends.add(cls.a8)

        cls.p1 = Publisher.objects.create(name='Apress', num_awards=3)
        cls.p2 = Publisher.objects.create(name='Sams', num_awards=1)
        cls.p3 = Publisher.objects.create(name='Prentice Hall', num_awards=7)
        cls.p4 = Publisher.objects.create(name='Morgan Kaufmann', num_awards=9)
        cls.p5 = Publisher.objects.create(name="Jonno's House of Books", num_awards=0)

        cls.b1 = Book.objects.create(
            isbn='159059725', name='The Definitive Guide to Django: Web Development Done Right',
            pages=447, rating=4.5, price=Decimal('30.00'), contact=cls.a1, publisher=cls.p1,
            pubdate=datetime.date(2007, 12, 6)
        )
        cls.b2 = Book.objects.create(
            isbn='067232959', name='Sams Teach Yourself Django in 24 Hours',
            pages=528, rating=3.0, price=Decimal('23.09'), contact=cls.a3, publisher=cls.p2,
            pubdate=datetime.date(2008, 3, 3)
        )
        cls.b3 = Book.objects.create(
            isbn='159059996', name='Practical Django Projects',
            pages=300, rating=4.0, price=Decimal('29.69'), contact=cls.a4, publisher=cls.p1,
            pubdate=datetime.date(2008, 6, 23)
        )
        cls.b4 = Book.objects.create(
            isbn='013235613', name='Python Web Development with Django',
            pages=350, rating=4.0, price=Decimal('29.69'), contact=cls.a5, publisher=cls.p3,
            pubdate=datetime.date(2008, 11, 3)
        )
        cls.b5 = HardbackBook.objects.create(
            isbn='013790395', name='Artificial Intelligence: A Modern Approach',
            pages=1132, rating=4.0, price=Decimal('82.80'), contact=cls.a8, publisher=cls.p3,
            pubdate=datetime.date(1995, 1, 15), weight=4.5)
        cls.b6 = HardbackBook.objects.create(
            isbn='155860191', name='Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp',
            pages=946, rating=5.0, price=Decimal('75.00'), contact=cls.a8, publisher=cls.p4,
            pubdate=datetime.date(1991, 10, 15), weight=3.7)
        cls.b1.authors.add(cls.a1, cls.a2)
        cls.b2.authors.add(cls.a3)
        cls.b3.authors.add(cls.a4)
        cls.b4.authors.add(cls.a5, cls.a6, cls.a7)
        cls.b5.authors.add(cls.a8, cls.a9)
        cls.b6.authors.add(cls.a8)

        s1 = Store.objects.create(
            name='Amazon.com',
            original_opening=datetime.datetime(1994, 4, 23, 9, 17, 42),
            friday_night_closing=datetime.time(23, 59, 59)
        )
        s2 = Store.objects.create(
            name='Books.com',
            original_opening=datetime.datetime(2001, 3, 15, 11, 23, 37),
            friday_night_closing=datetime.time(23, 59, 59)
        )
        s3 = Store.objects.create(
            name="Mamma and Pappa's Books",
            original_opening=datetime.datetime(1945, 4, 25, 16, 24, 14),
            friday_night_closing=datetime.time(21, 30)
        )
        s1.books.add(cls.b1, cls.b2, cls.b3, cls.b4, cls.b5, cls.b6)
        s2.books.add(cls.b1, cls.b3, cls.b5, cls.b6)
        s3.books.add(cls.b3, cls.b4, cls.b6)

</source>
</class>

<class classid="121" nclones="2" nlines="21" similarity="71">
<source file="django/tests/aggregation_regress/tests.py.pyindent" startline="1216" endline="1241" pcid="10382">
        # Regression test for #17144

        results = Author.objects.annotate(num_contacts=Count('book_contact_set'))

        # There should only be one GROUP BY clause, for the `id` column.
        # `name` and `age` should not be grouped on.
        _, _, group_by = results.query.get_compiler(using='default').pre_sql_setup()
        self.assertEqual(len(group_by), 1)
        self.assertIn('id', group_by[0][0])
        self.assertNotIn('name', group_by[0][0])
        self.assertNotIn('age', group_by[0][0])
        self.assertEqual(
            [(a.name, a.num_contacts) for a in results.order_by('name')],
            [
                ('Adrian Holovaty', 1),
                ('Brad Dayley', 1),
                ('Jacob Kaplan-Moss', 0),
                ('James Bennett', 1),
                ('Jeffrey Forcier', 1),
                ('Paul Bissex', 0),
                ('Peter Norvig', 2),
                ('Stuart Russell', 0),
                ('Wesley J. Chun', 0),
            ]
        )

</source>
<source file="django/tests/aggregation_regress/tests.py.pyindent" startline="1244" endline="1265" pcid="10383">
        # Works with only() too.
        results = Author.objects.only('id', 'name').annotate(num_contacts=Count('book_contact_set'))
        _, _, grouping = results.query.get_compiler(using='default').pre_sql_setup()
        self.assertEqual(len(grouping), 1)
        self.assertIn('id', grouping[0][0])
        self.assertNotIn('name', grouping[0][0])
        self.assertNotIn('age', grouping[0][0])
        self.assertEqual(
            [(a.name, a.num_contacts) for a in results.order_by('name')],
            [
                ('Adrian Holovaty', 1),
                ('Brad Dayley', 1),
                ('Jacob Kaplan-Moss', 0),
                ('James Bennett', 1),
                ('Jeffrey Forcier', 1),
                ('Paul Bissex', 0),
                ('Peter Norvig', 2),
                ('Stuart Russell', 0),
                ('Wesley J. Chun', 0),
            ]
        )

</source>
</class>

<class classid="122" nclones="2" nlines="12" similarity="83">
<source file="django/tests/app_loading/tests.py.pyindent" startline="17" endline="24" pcid="10446">
        """Models module can be loaded from an app in an egg"""
        egg_name = '%s/modelapp.egg' % self.egg_dir
        with extend_sys_path(egg_name):
            with self.settings(INSTALLED_APPS=['app_with_models']):
                models_module = apps.get_app_config('app_with_models').models_module
                self.assertIsNotNone(models_module)
        del apps.all_models['app_with_models']

</source>
<source file="django/tests/app_loading/tests.py.pyindent" startline="35" endline="42" pcid="10452">
        """Models module can be loaded from an app located under an egg's top-level package"""
        egg_name = '%s/omelet.egg' % self.egg_dir
        with extend_sys_path(egg_name):
            with self.settings(INSTALLED_APPS=['omelet.app_with_models']):
                models_module = apps.get_app_config('app_with_models').models_module
                self.assertIsNotNone(models_module)
        del apps.all_models['app_with_models']

</source>
</class>

<class classid="123" nclones="2" nlines="12" similarity="83">
<source file="django/tests/app_loading/tests.py.pyindent" startline="26" endline="33" pcid="10449">
        """Loading an app from an egg that has no models returns no models (and no error)"""
        egg_name = '%s/nomodelapp.egg' % self.egg_dir
        with extend_sys_path(egg_name):
            with self.settings(INSTALLED_APPS=['app_no_models']):
                models_module = apps.get_app_config('app_no_models').models_module
                self.assertIsNone(models_module)
        del apps.all_models['app_no_models']

</source>
<source file="django/tests/app_loading/tests.py.pyindent" startline="44" endline="51" pcid="10455">
        """Loading an app with no models from under the top-level egg package generates no error"""
        egg_name = '%s/omelet.egg' % self.egg_dir
        with extend_sys_path(egg_name):
            with self.settings(INSTALLED_APPS=['omelet.app_no_models']):
                models_module = apps.get_app_config('app_no_models').models_module
                self.assertIsNone(models_module)
        del apps.all_models['app_no_models']

</source>
</class>

<class classid="124" nclones="4" nlines="20" similarity="71">
<source file="django/tests/auth_tests/test_checks.py.pyindent" startline="122" endline="136" pcid="10557">
        class Checked(models.Model):
            class Meta:
                permissions = [
                    ('change_checked', 'Can edit permission (duplicate)')
                ]
        errors = checks.run_checks(self.apps.get_app_configs())
        self.assertEqual(errors, [
            checks.Error(
                "The permission codenamed 'change_checked' clashes with a builtin "
                "permission for model 'auth_tests.Checked'.",
                obj=Checked,
                id='auth.E005',
            ),
        ])

</source>
<source file="django/tests/auth_tests/test_checks.py.pyindent" startline="180" endline="196" pcid="10569">
        custom_permission_name = 'some ridiculously long verbose name that is out of control' * 5

        class Checked(models.Model):
            class Meta:
                permissions = [
                    ('my_custom_permission', custom_permission_name),
                ]
        errors = checks.run_checks(self.apps.get_app_configs())
        self.assertEqual(errors, [
            checks.Error(
                "The permission named '%s' of model 'auth_tests.Checked' is longer "
                "than 255 characters." % custom_permission_name,
                obj=Checked,
                id='auth.E008',
            ),
        ])

</source>
<source file="django/tests/auth_tests/test_checks.py.pyindent" startline="166" endline="178" pcid="10566">
        class Checked(models.Model):
            class Meta:
                verbose_name = 'some ridiculously long verbose name that is out of control' * 5
        errors = checks.run_checks(self.apps.get_app_configs())
        self.assertEqual(errors, [
            checks.Error(
                "The verbose_name of model 'auth_tests.Checked' must be at most 244 "
                "characters for its builtin permission names to be at most 255 characters.",
                obj=Checked,
                id='auth.E007',
            ),
        ])

</source>
<source file="django/tests/auth_tests/test_checks.py.pyindent" startline="148" endline="164" pcid="10563">
        class Checked(models.Model):
            class Meta:
                permissions = [
                    ('my_custom_permission', 'Some permission'),
                    ('other_one', 'Some other permission'),
                    ('my_custom_permission', 'Some permission with duplicate permission code'),
                ]
        errors = checks.run_checks(self.apps.get_app_configs())
        self.assertEqual(errors, [
            checks.Error(
                "The permission codenamed 'my_custom_permission' is duplicated for "
                "model 'auth_tests.Checked'.",
                obj=Checked,
                id='auth.E006',
            ),
        ])

</source>
</class>

<class classid="125" nclones="2" nlines="12" similarity="83">
<source file="django/tests/auth_tests/test_context_processors.py.pyindent" startline="89" endline="99" pcid="10592">
        u = User.objects.create_user(username='normal', password='secret')
        u.user_permissions.add(
            Permission.objects.get(
                content_type=ContentType.objects.get_for_model(Permission),
                codename='add_permission'))
        self.client.force_login(u)
        response = self.client.get('/auth_processor_perms/')
        self.assertContains(response, "Has auth permissions")
        self.assertContains(response, "Has auth.add_permission permissions")
        self.assertNotContains(response, "nonexistent")

</source>
<source file="django/tests/auth_tests/test_context_processors.py.pyindent" startline="101" endline="111" pcid="10593">
        u = User.objects.create_user(username='normal', password='secret')
        u.user_permissions.add(
            Permission.objects.get(
                content_type=ContentType.objects.get_for_model(Permission),
                codename='add_permission'))
        self.client.login(username='normal', password='secret')
        response = self.client.get('/auth_processor_perm_in_perms/')
        self.assertContains(response, "Has auth permissions")
        self.assertContains(response, "Has auth.add_permission permissions")
        self.assertNotContains(response, "nonexistent")

</source>
</class>

<class classid="126" nclones="2" nlines="25" similarity="70">
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="499" endline="521" pcid="10669">
        """createsuperuser uses a default username when one isn't provided."""
        # Get the default username before creating a user.
        default_username = get_default_username()
        new_io = StringIO()
        entered_passwords = ['password', 'password']

        def return_passwords():
            return entered_passwords.pop(0)

        @mock_inputs({'password': return_passwords, 'username': '', 'email': ''})
        def test(self):
            call_command(
                'createsuperuser',
                interactive=True,
                stdin=MockTTY(),
                stdout=new_io,
                stderr=new_io,
            )
            self.assertEqual(new_io.getvalue().strip(), 'Superuser created successfully.')
            self.assertTrue(User.objects.filter(username=default_username).exists())

        test(self)

</source>
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="787" endline="813" pcid="10704">
        """call_command() gets username='janet' and interactive=True."""
        new_io = StringIO()
        entered_passwords = ['password', 'password']
        User.objects.create(username='janet')

        def return_passwords():
            return entered_passwords.pop(0)

        @mock_inputs({
            'password': return_passwords,
            'username': 'janet1',
            'email': 'test@test.com'
        })
        def test(self):
            call_command(
                'createsuperuser',
                username='janet',
                interactive=True,
                stdin=MockTTY(),
                stdout=new_io,
                stderr=new_io,
            )
            msg = 'Error: That username is already taken.\nSuperuser created successfully.'
            self.assertEqual(new_io.getvalue().strip(), msg)

        test(self)

</source>
</class>

<class classid="127" nclones="5" nlines="11" similarity="72">
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="510" endline="519" pcid="10671">
            call_command(
                'createsuperuser',
                interactive=True,
                stdin=MockTTY(),
                stdout=new_io,
                stderr=new_io,
            )
            self.assertEqual(new_io.getvalue().strip(), 'Superuser created successfully.')
            self.assertTrue(User.objects.filter(username=default_username).exists())

</source>
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="658" endline="666" pcid="10689">
                call_command(
                    'createsuperuser',
                    username='',
                    interactive=False,
                    stdin=MockTTY(),
                    stdout=new_io,
                    stderr=new_io,
                )

</source>
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="887" endline="896" pcid="10714">
            call_command(
                'createsuperuser',
                interactive=False,
                stdin=MockTTY(),
                stdout=new_io,
                stderr=new_io,
                username='username',
            )
            self.assertEqual(new_io.getvalue().strip(), 'Superuser created successfully.')

</source>
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="905" endline="913" pcid="10716">
            call_command(
                'createsuperuser',
                interactive=True,
                stdin=MockTTY(),
                stdout=new_io,
                stderr=new_io,
            )
            self.assertEqual(new_io.getvalue().strip(), 'Superuser created successfully.')

</source>
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="801" endline="811" pcid="10706">
            call_command(
                'createsuperuser',
                username='janet',
                interactive=True,
                stdin=MockTTY(),
                stdout=new_io,
                stderr=new_io,
            )
            msg = 'Error: That username is already taken.\nSuperuser created successfully.'
            self.assertEqual(new_io.getvalue().strip(), msg)

</source>
</class>

<class classid="128" nclones="3" nlines="34" similarity="75">
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="523" endline="557" pcid="10672">
        """
        Creation should fail if the password fails validation.
        """
        new_io = StringIO()

        # Returns '1234567890' the first two times it is called, then
        # 'password' subsequently.
        def bad_then_good_password(index=[0]):
            index[0] += 1
            if index[0] <= 2:
                return '1234567890'
            return 'password'

        @mock_inputs({
            'password': bad_then_good_password,
            'username': 'joe1234567890',
            'email': '',
            'bypass': 'n',
        })
        def test(self):
            call_command(
                "createsuperuser",
                interactive=True,
                stdin=MockTTY(),
                stdout=new_io,
                stderr=new_io,
            )
            self.assertEqual(
                new_io.getvalue().strip(),
                "This password is entirely numeric.\n"
                "Superuser created successfully."
            )

        test(self)

</source>
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="601" endline="636" pcid="10680">
        new_io = StringIO()
        username = 'josephine'

        # Returns the username the first two times it's called, then a valid
        # password.
        def bad_then_good_password(index=[0]):
            """Return username the first two times, then a valid password."""
            index[0] += 1
            if index[0] <= 2:
                return username
            return 'superduperunguessablepassword'

        @mock_inputs({
            'password': bad_then_good_password,
            'username': username,
            'first_name': 'josephine',
            'date_of_birth': '1970-01-01',
            'email': 'joey@example.com',
            'bypass': 'n',
        })
        def test(self):
            call_command(
                'createsuperuser',
                interactive=True,
                stdin=MockTTY(),
                stdout=new_io,
                stderr=new_io,
            )
            self.assertEqual(
                new_io.getvalue().strip(),
                "The password is too similar to the first name.\n"
                "Superuser created successfully."
            )

        test(self)

</source>
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="562" endline="593" pcid="10676">
        new_io = StringIO()
        username = 'supremelycomplex'

        def bad_then_good_password(index=[0]):
            """Return username the first two times, then a valid password."""
            index[0] += 1
            if index[0] <= 2:
                return username
            return 'superduperunguessablepassword'

        @mock_inputs({
            'password': bad_then_good_password,
            'username': username,
            'email': '',
            'bypass': 'n',
        })
        def test(self):
            call_command(
                'createsuperuser',
                interactive=True,
                stdin=MockTTY(),
                stdout=new_io,
                stderr=new_io,
            )
            self.assertEqual(
                new_io.getvalue().strip(),
                'The password is too similar to the username.\n'
                'Superuser created successfully.'
            )

        test(self)

</source>
</class>

<class classid="129" nclones="8" nlines="13" similarity="76">
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="543" endline="555" pcid="10675">
            call_command(
                "createsuperuser",
                interactive=True,
                stdin=MockTTY(),
                stdout=new_io,
                stderr=new_io,
            )
            self.assertEqual(
                new_io.getvalue().strip(),
                "This password is entirely numeric.\n"
                "Superuser created successfully."
            )

</source>
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="833" endline="845" pcid="10709">
            call_command(
                "createsuperuser",
                interactive=True,
                stdin=MockTTY(),
                stdout=new_io,
                stderr=new_io,
            )
            self.assertEqual(
                new_io.getvalue().strip(),
                "Error: Your passwords didn't match.\n"
                "Superuser created successfully."
            )

</source>
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="714" endline="726" pcid="10695">
            call_command(
                'createsuperuser',
                interactive=True,
                stdin=MockTTY(),
                stdout=new_io,
                stderr=new_io,
            )
            self.assertEqual(
                new_io.getvalue().strip(),
                'Error: Ensure this value has at most %s characters (it has %s).\n'
                'Superuser created successfully.' % (user_field.max_length, len(invalid_username))
            )

</source>
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="758" endline="770" pcid="10701">
            call_command(
                'createsuperuser',
                interactive=True,
                stdin=MockTTY(),
                stdout=new_io,
                stderr=new_io,
            )
            self.assertEqual(
                new_io.getvalue().strip(),
                'Error: That username is already taken.\n'
                'Superuser created successfully.'
            )

</source>
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="867" endline="879" pcid="10712">
            call_command(
                "createsuperuser",
                interactive=True,
                stdin=MockTTY(),
                stdout=new_io,
                stderr=new_io,
            )
            self.assertEqual(
                new_io.getvalue().strip(),
                "Error: Blank passwords aren't allowed.\n"
                "Superuser created successfully."
            )

</source>
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="682" endline="694" pcid="10691">
            call_command(
                'createsuperuser',
                interactive=True,
                stdin=MockTTY(),
                stdout=new_io,
                stderr=new_io,
            )
            self.assertEqual(
                new_io.getvalue().strip(),
                'This password is entirely numeric.\n'
                'Superuser created successfully.'
            )

</source>
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="622" endline="634" pcid="10683">
            call_command(
                'createsuperuser',
                interactive=True,
                stdin=MockTTY(),
                stdout=new_io,
                stderr=new_io,
            )
            self.assertEqual(
                new_io.getvalue().strip(),
                "The password is too similar to the first name.\n"
                "Superuser created successfully."
            )

</source>
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="579" endline="591" pcid="10679">
            call_command(
                'createsuperuser',
                interactive=True,
                stdin=MockTTY(),
                stdout=new_io,
                stderr=new_io,
            )
            self.assertEqual(
                new_io.getvalue().strip(),
                'The password is too similar to the username.\n'
                'Superuser created successfully.'
            )

</source>
</class>

<class classid="130" nclones="7" nlines="16" similarity="71">
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="638" endline="652" pcid="10684">
        """Creation fails if --username is blank."""
        new_io = StringIO()

        def test(self):
            with self.assertRaisesMessage(CommandError, 'Username cannot be blank.'):
                call_command(
                    'createsuperuser',
                    username='',
                    stdin=MockTTY(),
                    stdout=new_io,
                    stderr=new_io,
                )

        test(self)

</source>
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="654" endline="668" pcid="10687">
        new_io = StringIO()

        def test(self):
            with self.assertRaisesMessage(CommandError, 'Username cannot be blank.'):
                call_command(
                    'createsuperuser',
                    username='',
                    interactive=False,
                    stdin=MockTTY(),
                    stdout=new_io,
                    stderr=new_io,
                )

        test(self)

</source>
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="884" endline="898" pcid="10713">
        new_io = StringIO()

        def test(self):
            call_command(
                'createsuperuser',
                interactive=False,
                stdin=MockTTY(),
                stdout=new_io,
                stderr=new_io,
                username='username',
            )
            self.assertEqual(new_io.getvalue().strip(), 'Superuser created successfully.')

        test(self)

</source>
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="901" endline="916" pcid="10715">
        new_io = StringIO()

        @mock_inputs({'username': 'username'})
        def test(self):
            call_command(
                'createsuperuser',
                interactive=True,
                stdin=MockTTY(),
                stdout=new_io,
                stderr=new_io,
            )
            self.assertEqual(new_io.getvalue().strip(), 'Superuser created successfully.')

        test(self)


</source>
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="731" endline="741" pcid="10696">
        new_io = StringIO()
        with self.assertRaises(SystemExit):
            call_command(
                'createsuperuser',
                interactive=True,
                stdin=MockTTY(),
                stdout=new_io,
                stderr=new_io,
            )
        self.assertEqual(new_io.getvalue(), '\nOperation cancelled.\n')

</source>
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="657" endline="666" pcid="10688">
            with self.assertRaisesMessage(CommandError, 'Username cannot be blank.'):
                call_command(
                    'createsuperuser',
                    username='',
                    interactive=False,
                    stdin=MockTTY(),
                    stdout=new_io,
                    stderr=new_io,
                )

</source>
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="642" endline="650" pcid="10685">
            with self.assertRaisesMessage(CommandError, 'Username cannot be blank.'):
                call_command(
                    'createsuperuser',
                    username='',
                    stdin=MockTTY(),
                    stdout=new_io,
                    stderr=new_io,
                )

</source>
</class>

<class classid="131" nclones="2" nlines="31" similarity="83">
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="698" endline="728" pcid="10692">
        """Creation fails if the username fails validation."""
        user_field = User._meta.get_field(User.USERNAME_FIELD)
        new_io = StringIO()
        entered_passwords = ['password', 'password']
        # Enter an invalid (too long) username first and then a valid one.
        invalid_username = ('x' * user_field.max_length) + 'y'
        entered_usernames = [invalid_username, 'janet']

        def return_passwords():
            return entered_passwords.pop(0)

        def return_usernames():
            return entered_usernames.pop(0)

        @mock_inputs({'password': return_passwords, 'username': return_usernames, 'email': ''})
        def test(self):
            call_command(
                'createsuperuser',
                interactive=True,
                stdin=MockTTY(),
                stdout=new_io,
                stderr=new_io,
            )
            self.assertEqual(
                new_io.getvalue().strip(),
                'Error: Ensure this value has at most %s characters (it has %s).\n'
                'Superuser created successfully.' % (user_field.max_length, len(invalid_username))
            )

        test(self)

</source>
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="743" endline="772" pcid="10698">
        """Creation fails if the username already exists."""
        user = User.objects.create(username='janet')
        new_io = StringIO()
        entered_passwords = ['password', 'password']
        # Enter the existing username first and then a new one.
        entered_usernames = [user.username, 'joe']

        def return_passwords():
            return entered_passwords.pop(0)

        def return_usernames():
            return entered_usernames.pop(0)

        @mock_inputs({'password': return_passwords, 'username': return_usernames, 'email': ''})
        def test(self):
            call_command(
                'createsuperuser',
                interactive=True,
                stdin=MockTTY(),
                stdout=new_io,
                stderr=new_io,
            )
            self.assertEqual(
                new_io.getvalue().strip(),
                'Error: That username is already taken.\n'
                'Superuser created successfully.'
            )

        test(self)

</source>
</class>

<class classid="132" nclones="2" nlines="28" similarity="85">
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="815" endline="847" pcid="10707">
        """
        Creation should fail if the user enters mismatched passwords.
        """
        new_io = StringIO()

        # The first two passwords do not match, but the second two do match and
        # are valid.
        entered_passwords = ["password", "not password", "password2", "password2"]

        def mismatched_passwords_then_matched():
            return entered_passwords.pop(0)

        @mock_inputs({
            'password': mismatched_passwords_then_matched,
            'username': 'joe1234567890',
            'email': '',
        })
        def test(self):
            call_command(
                "createsuperuser",
                interactive=True,
                stdin=MockTTY(),
                stdout=new_io,
                stderr=new_io,
            )
            self.assertEqual(
                new_io.getvalue().strip(),
                "Error: Your passwords didn't match.\n"
                "Superuser created successfully."
            )

        test(self)

</source>
<source file="django/tests/auth_tests/test_management.py.pyindent" startline="849" endline="881" pcid="10710">
        """
        Creation should fail if the user enters blank passwords.
        """
        new_io = StringIO()

        # The first two passwords are empty strings, but the second two are
        # valid.
        entered_passwords = ["", "", "password2", "password2"]

        def blank_passwords_then_valid():
            return entered_passwords.pop(0)

        @mock_inputs({
            'password': blank_passwords_then_valid,
            'username': 'joe1234567890',
            'email': '',
        })
        def test(self):
            call_command(
                "createsuperuser",
                interactive=True,
                stdin=MockTTY(),
                stdout=new_io,
                stderr=new_io,
            )
            self.assertEqual(
                new_io.getvalue().strip(),
                "Error: Blank passwords aren't allowed.\n"
                "Superuser created successfully."
            )

        test(self)

</source>
</class>

<class classid="133" nclones="2" nlines="17" similarity="94">
<source file="django/tests/auth_tests/test_mixins.py.pyindent" startline="69" endline="82" pcid="10743">
        user = models.User.objects.create(username='joe', password='qwerty')
        perms = models.Permission.objects.filter(codename__in=('add_customuser',))
        user.user_permissions.add(*perms)
        request = self.factory.get('/rand')
        request.user = user

        view = StackedMixinsView1.as_view()
        with self.assertRaises(PermissionDenied):
            view(request)

        view = StackedMixinsView2.as_view()
        with self.assertRaises(PermissionDenied):
            view(request)

</source>
<source file="django/tests/auth_tests/test_mixins.py.pyindent" startline="99" endline="113" pcid="10748">
        user = models.User.objects.create(username='joe', password='qwerty')
        perms = models.Permission.objects.filter(codename__in=('add_customuser', 'change_customuser'))
        user.user_permissions.add(*perms)
        request = self.factory.get('/rand')
        request.user = user

        view = StackedMixinsView1.as_view()
        with self.assertRaises(PermissionDenied):
            view(request)

        view = StackedMixinsView2.as_view()
        with self.assertRaises(PermissionDenied):
            view(request)


</source>
</class>

<class classid="134" nclones="2" nlines="18" similarity="78">
<source file="django/tests/auth_tests/test_mixins.py.pyindent" startline="158" endline="170" pcid="10764">
        msg = "You don't have access here"

        class AView(AlwaysFalseView):
            raise_exception = True
            permission_denied_message = msg

        request = self.factory.get('/rand')
        request.user = AnonymousUser()
        view = AView.as_view()
        with self.assertRaises(PermissionDenied) as cm:
            view(request)
        self.assertEqual(cm.exception.args[0], msg)

</source>
<source file="django/tests/auth_tests/test_mixins.py.pyindent" startline="172" endline="186" pcid="10767">
        msg = "You don't have access here"

        class AView(AlwaysFalseView):
            raise_exception = True

            def get_permission_denied_message(self):
                return msg

        request = self.factory.get('/rand')
        request.user = AnonymousUser()
        view = AView.as_view()
        with self.assertRaises(PermissionDenied) as cm:
            view(request)
        self.assertEqual(cm.exception.args[0], msg)

</source>
</class>

<class classid="135" nclones="2" nlines="10" similarity="90">
<source file="django/tests/auth_tests/test_mixins.py.pyindent" startline="235" endline="242" pcid="10778">
        class AView(PermissionRequiredMixin, EmptyResponseView):
            permission_required = ['auth_tests.add_customuser', 'auth_tests.change_customuser']

        request = self.factory.get('/rand')
        request.user = self.user
        resp = AView.as_view()(request)
        self.assertEqual(resp.status_code, 200)

</source>
<source file="django/tests/auth_tests/test_mixins.py.pyindent" startline="244" endline="251" pcid="10780">
        class AView(PermissionRequiredMixin, EmptyResponseView):
            permission_required = 'auth_tests.add_customuser'

        request = self.factory.get('/rand')
        request.user = self.user
        resp = AView.as_view()(request)
        self.assertEqual(resp.status_code, 200)

</source>
</class>

<class classid="136" nclones="2" nlines="16" similarity="82">
<source file="django/tests/auth_tests/test_mixins.py.pyindent" startline="253" endline="267" pcid="10782">
        class AView(PermissionRequiredMixin, EmptyResponseView):
            permission_required = [
                'auth_tests.add_customuser', 'auth_tests.change_customuser', 'nonexistent-permission',
            ]

        # Authenticated users receive PermissionDenied.
        request = self.factory.get('/rand')
        request.user = self.user
        with self.assertRaises(PermissionDenied):
            AView.as_view()(request)
        # Anonymous users are redirected to the login page.
        request.user = AnonymousUser()
        resp = AView.as_view()(request)
        self.assertEqual(resp.status_code, 302)

</source>
<source file="django/tests/auth_tests/test_mixins.py.pyindent" startline="269" endline="278" pcid="10785">
        class AView(PermissionRequiredMixin, EmptyResponseView):
            permission_required = [
                'auth_tests.add_customuser', 'auth_tests.change_customuser', 'nonexistent-permission',
            ]
            raise_exception = True

        request = self.factory.get('/rand')
        request.user = self.user
        with self.assertRaises(PermissionDenied):
            AView.as_view()(request)
</source>
</class>

<class classid="137" nclones="2" nlines="24" similarity="73">
<source file="django/tests/auth_tests/test_validators.py.pyindent" startline="219" endline="233" pcid="10892">
        valid_usernames = ['joe', 'René', 'ᴮᴵᴳᴮᴵᴿᴰ', 'أحمد']
        invalid_usernames = [
            "o'connell", "عبد ال",
            "zerowidth\u200Bspace", "nonbreaking\u00A0space",
            "en\u2013dash",
        ]
        v = validators.UnicodeUsernameValidator()
        for valid in valid_usernames:
            with self.subTest(valid=valid):
                v(valid)
        for invalid in invalid_usernames:
            with self.subTest(invalid=invalid):
                with self.assertRaises(ValidationError):
                    v(invalid)

</source>
<source file="django/tests/auth_tests/test_validators.py.pyindent" startline="235" endline="244" pcid="10898">
        valid_usernames = ['glenn', 'GLEnN', 'jean-marc']
        invalid_usernames = ["o'connell", 'Éric', 'jean marc', "أحمد"]
        v = validators.ASCIIUsernameValidator()
        for valid in valid_usernames:
            with self.subTest(valid=valid):
                v(valid)
        for invalid in invalid_usernames:
            with self.subTest(invalid=invalid):
                with self.assertRaises(ValidationError):
                    v(invalid)
</source>
</class>

<class classid="138" nclones="2" nlines="12" similarity="83">
<source file="django/tests/auth_tests/test_views.py.pyindent" startline="163" endline="180" pcid="10922">
        "Poisoned HTTP_HOST headers can't be used for reset emails"
        # This attack is based on the way browsers handle URLs. The colon
        # should be used to separate the port, but if the URL contains an @,
        # the colon is interpreted as part of a username for login purposes,
        # making 'evil.com' the request domain. Since HTTP_HOST is used to
        # produce a meaningful reset URL, we need to be certain that the
        # HTTP_HOST header isn't poisoned. This is done as a check when get_host()
        # is invoked, but we check here as a practical consequence.
        with self.assertLogs('django.security.DisallowedHost', 'ERROR'):
            response = self.client.post(
                '/password_reset/',
                {'email': 'staffmember@example.com'},
                HTTP_HOST='www.example:dr.frankenstein@evil.tld'
            )
        self.assertEqual(response.status_code, 400)
        self.assertEqual(len(mail.outbox), 0)

    # Skip any 500 handler action (like sending more mail...)
</source>
<source file="django/tests/auth_tests/test_views.py.pyindent" startline="183" endline="192" pcid="10924">
        "Poisoned HTTP_HOST headers can't be used for reset emails on admin views"
        with self.assertLogs('django.security.DisallowedHost', 'ERROR'):
            response = self.client.post(
                '/admin_password_reset/',
                {'email': 'staffmember@example.com'},
                HTTP_HOST='www.example:dr.frankenstein@evil.tld'
            )
        self.assertEqual(response.status_code, 400)
        self.assertEqual(len(mail.outbox), 0)

</source>
</class>

<class classid="139" nclones="2" nlines="55" similarity="80">
<source file="django/tests/auth_tests/test_views.py.pyindent" startline="549" endline="599" pcid="10974">
        login_url = reverse('login')

        # These URLs should not pass the security check.
        bad_urls = (
            'http://example.com',
            'http:///example.com',
            'https://example.com',
            'ftp://example.com',
            '///example.com',
            '//example.com',
            'javascript:alert("XSS")',
        )
        for bad_url in bad_urls:
            with self.subTest(bad_url=bad_url):
                nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {
                    'url': login_url,
                    'next': REDIRECT_FIELD_NAME,
                    'bad_url': quote(bad_url),
                }
                response = self.client.post(nasty_url, {
                    'username': 'testclient',
                    'password': 'password',
                })
                self.assertEqual(response.status_code, 302)
                self.assertNotIn(bad_url, response.url, '%s should be blocked' % bad_url)

        # These URLs should pass the security check.
        good_urls = (
            '/view/?param=http://example.com',
            '/view/?param=https://example.com',
            '/view?param=ftp://example.com',
            'view/?param=//example.com',
            'https://testserver/',
            'HTTPS://testserver/',
            '//testserver/',
            '/url%20with%20spaces/',
        )
        for good_url in good_urls:
            with self.subTest(good_url=good_url):
                safe_url = '%(url)s?%(next)s=%(good_url)s' % {
                    'url': login_url,
                    'next': REDIRECT_FIELD_NAME,
                    'good_url': quote(good_url),
                }
                response = self.client.post(safe_url, {
                    'username': 'testclient',
                    'password': 'password',
                })
                self.assertEqual(response.status_code, 302)
                self.assertIn(good_url, response.url, '%s should be allowed' % good_url)

</source>
<source file="django/tests/auth_tests/test_views.py.pyindent" startline="1013" endline="1061" pcid="11040">
        logout_url = reverse('logout')

        # These URLs should not pass the security check.
        bad_urls = (
            'http://example.com',
            'http:///example.com',
            'https://example.com',
            'ftp://example.com',
            '///example.com',
            '//example.com',
            'javascript:alert("XSS")',
        )
        for bad_url in bad_urls:
            with self.subTest(bad_url=bad_url):
                nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {
                    'url': logout_url,
                    'next': REDIRECT_FIELD_NAME,
                    'bad_url': quote(bad_url),
                }
                self.login()
                response = self.client.get(nasty_url)
                self.assertEqual(response.status_code, 302)
                self.assertNotIn(bad_url, response.url, '%s should be blocked' % bad_url)
                self.confirm_logged_out()

        # These URLs should pass the security check.
        good_urls = (
            '/view/?param=http://example.com',
            '/view/?param=https://example.com',
            '/view?param=ftp://example.com',
            'view/?param=//example.com',
            'https://testserver/',
            'HTTPS://testserver/',
            '//testserver/',
            '/url%20with%20spaces/',
        )
        for good_url in good_urls:
            with self.subTest(good_url=good_url):
                safe_url = '%(url)s?%(next)s=%(good_url)s' % {
                    'url': logout_url,
                    'next': REDIRECT_FIELD_NAME,
                    'good_url': quote(good_url),
                }
                self.login()
                response = self.client.get(safe_url)
                self.assertEqual(response.status_code, 302)
                self.assertIn(good_url, response.url, '%s should be allowed' % good_url)
                self.confirm_logged_out()

</source>
</class>

<class classid="140" nclones="2" nlines="11" similarity="72">
<source file="django/tests/auth_tests/test_views.py.pyindent" startline="859" endline="865" pcid="11014">
            with self.assertRaisesMessage(ValueError, msg):
                self.client.get(self.do_redirect_url)

            url = self.do_redirect_url + '?bla=2'
            with self.assertRaisesMessage(ValueError, msg):
                self.client.get(url)

</source>
<source file="django/tests/model_regress/tests.py.pyindent" startline="177" endline="182" pcid="20834">
        msg = 'get_next/get_previous cannot be used on unsaved objects.'
        with self.assertRaisesMessage(ValueError, msg):
            Event().get_next_by_when()
        with self.assertRaisesMessage(ValueError, msg):
            Event().get_previous_by_when()

</source>
</class>

<class classid="141" nclones="6" nlines="10" similarity="70">
<source file="django/tests/backends/mysql/test_creation.py.pyindent" startline="30" endline="37" pcid="11148">
            with mock.patch('builtins.input', return_value='no'):
                with self.assertRaises(SystemExit):
                    # SystemExit is raised if the user answers "no" to the
                    # prompt asking if it's okay to delete the test database.
                    creation._create_test_db(verbosity=0, autoclobber=False, keepdb=False)
            # "Database exists" shouldn't appear when keepdb is on
            creation._create_test_db(verbosity=0, autoclobber=False, keepdb=True)

</source>
<source file="django/tests/backends/mysql/test_creation.py.pyindent" startline="41" endline="45" pcid="11151">
        # Simulate test database creation raising unexpected error
        creation = DatabaseCreation(connection)
        with self.patch_test_db_creation(self._execute_raise_access_denied):
            with self.assertRaises(SystemExit):
                creation._create_test_db(verbosity=0, autoclobber=False, keepdb=False)
</source>
<source file="django/tests/backends/oracle/test_creation.py.pyindent" startline="64" endline="71" pcid="11204">
                with mock.patch('builtins.input', return_value='no'):
                    with self.assertRaises(SystemExit):
                        # SystemExit is raised if the user answers "no" to the
                        # prompt asking if it's okay to delete the test user.
                        creation._create_test_db(verbosity=0, keepdb=False)
                # "User already exists" error is ignored when keepdb is on
                creation._create_test_db(verbosity=0, keepdb=True)
            # Simulate test user creation raising unexpected error
</source>
<source file="django/tests/backends/oracle/test_creation.py.pyindent" startline="44" endline="51" pcid="11196">
            with mock.patch('builtins.input', return_value='no'):
                with self.assertRaises(SystemExit):
                    # SystemExit is raised if the user answers "no" to the
                    # prompt asking if it's okay to delete the test tablespace.
                    creation._create_test_db(verbosity=0, keepdb=False)
            # "Tablespace already exists" error is ignored when keepdb is on
            creation._create_test_db(verbosity=0, keepdb=True)
        # Simulate test database creation raising unexpected error
</source>
<source file="django/tests/backends/oracle/test_creation.py.pyindent" startline="73" endline="76" pcid="11207">
                with self.assertRaises(SystemExit):
                    creation._create_test_db(verbosity=0, keepdb=False)
                with self.assertRaises(SystemExit):
                    creation._create_test_db(verbosity=0, keepdb=True)
</source>
<source file="django/tests/backends/oracle/test_creation.py.pyindent" startline="53" endline="57" pcid="11199">
            with self.assertRaises(SystemExit):
                creation._create_test_db(verbosity=0, keepdb=False)
            with self.assertRaises(SystemExit):
                creation._create_test_db(verbosity=0, keepdb=True)

</source>
</class>

<class classid="142" nclones="2" nlines="27" similarity="85">
<source file="django/tests/backends/oracle/test_creation.py.pyindent" startline="41" endline="57" pcid="11195">
        creation = DatabaseCreation(connection)
        # Simulate test database creation raising "tablespace already exists"
        with self.patch_execute_statements(self._execute_raise_tablespace_already_exists):
            with mock.patch('builtins.input', return_value='no'):
                with self.assertRaises(SystemExit):
                    # SystemExit is raised if the user answers "no" to the
                    # prompt asking if it's okay to delete the test tablespace.
                    creation._create_test_db(verbosity=0, keepdb=False)
            # "Tablespace already exists" error is ignored when keepdb is on
            creation._create_test_db(verbosity=0, keepdb=True)
        # Simulate test database creation raising unexpected error
        with self.patch_execute_statements(self._execute_raise_insufficient_privileges):
            with self.assertRaises(SystemExit):
                creation._create_test_db(verbosity=0, keepdb=False)
            with self.assertRaises(SystemExit):
                creation._create_test_db(verbosity=0, keepdb=True)

</source>
<source file="django/tests/backends/oracle/test_creation.py.pyindent" startline="60" endline="76" pcid="11202">
        creation = DatabaseCreation(connection)
        with mock.patch.object(DatabaseCreation, '_test_database_passwd', self._test_database_passwd):
            # Simulate test user creation raising "user already exists"
            with self.patch_execute_statements(self._execute_raise_user_already_exists):
                with mock.patch('builtins.input', return_value='no'):
                    with self.assertRaises(SystemExit):
                        # SystemExit is raised if the user answers "no" to the
                        # prompt asking if it's okay to delete the test user.
                        creation._create_test_db(verbosity=0, keepdb=False)
                # "User already exists" error is ignored when keepdb is on
                creation._create_test_db(verbosity=0, keepdb=True)
            # Simulate test user creation raising unexpected error
            with self.patch_execute_statements(self._execute_raise_insufficient_privileges):
                with self.assertRaises(SystemExit):
                    creation._create_test_db(verbosity=0, keepdb=False)
                with self.assertRaises(SystemExit):
                    creation._create_test_db(verbosity=0, keepdb=True)
</source>
</class>

<class classid="143" nclones="3" nlines="10" similarity="70">
<source file="django/tests/backends/test_utils.py.pyindent" startline="89" endline="92" pcid="11294">
        msg = 'Keyword parameters for callproc are not supported on this database backend.'
        with self.assertRaisesMessage(NotSupportedError, msg):
            with connection.cursor() as cursor:
                cursor.callproc('test_procedure', [], {'P_I': 1})
</source>
<source file="django/tests/transactions/tests.py.pyindent" startline="209" endline="213" pcid="27037">
                with transaction.atomic(savepoint=False):
                    with connection.cursor() as cursor:
                        cursor.execute(
                            "SELECT no_such_col FROM transactions_reporter")
            # prevent atomic from rolling back since we're recovering manually
</source>
<source file="django/tests/gis_tests/gis_migrations/test_operations.py.pyindent" startline="33" endline="37" pcid="16812">
        if mysql:
            with connection.cursor() as cursor:
                return connection.introspection.supports_spatial_index(cursor, 'gis_neighborhood')
        return True

</source>
</class>

<class classid="144" nclones="9" nlines="12" similarity="71">
<source file="django/tests/basic/models.py.pyindent" startline="10" endline="19" pcid="11318">
    headline = models.CharField(max_length=100, default='Default headline')
    pub_date = models.DateTimeField()

    class Meta:
        ordering = ('pub_date', 'headline')

    def __str__(self):
        return self.headline


</source>
<source file="django/tests/or_lookups/models.py.pyindent" startline="15" endline="22" pcid="21287">
    headline = models.CharField(max_length=50)
    pub_date = models.DateTimeField()

    class Meta:
        ordering = ('pub_date',)

    def __str__(self):
        return self.headline
</source>
<source file="django/tests/m2m_multiple/models.py.pyindent" startline="24" endline="33" pcid="18266">
    headline = models.CharField(max_length=50)
    pub_date = models.DateTimeField()
    primary_categories = models.ManyToManyField(Category, related_name='primary_article_set')
    secondary_categories = models.ManyToManyField(Category, related_name='secondary_article_set')

    class Meta:
        ordering = ('pub_date',)

    def __str__(self):
        return self.headline
</source>
<source file="django/tests/model_inheritance_regress/models.py.pyindent" startline="93" endline="102" pcid="20588">
    headline = models.CharField(max_length=100)
    pub_date = models.DateTimeField()

    class Meta:
        ordering = ('-pub_date', 'headline')

    def __str__(self):
        return self.headline


</source>
<source file="django/tests/lookup/models.py.pyindent" startline="28" endline="39" pcid="18213">
    headline = models.CharField(max_length=100)
    pub_date = models.DateTimeField()
    author = models.ForeignKey(Author, models.SET_NULL, blank=True, null=True)
    slug = models.SlugField(unique=True, blank=True, null=True)

    class Meta:
        ordering = ('-pub_date', 'headline')

    def __str__(self):
        return self.headline


</source>
<source file="django/tests/many_to_one_null/models.py.pyindent" startline="19" endline="28" pcid="18664">
    headline = models.CharField(max_length=100)
    reporter = models.ForeignKey(Reporter, models.SET_NULL, null=True)

    class Meta:
        ordering = ('headline',)

    def __str__(self):
        return self.headline


</source>
<source file="django/tests/model_regress/models.py.pyindent" startline="10" endline="24" pcid="20808">
    headline = models.CharField(max_length=100, default='Default headline')
    pub_date = models.DateTimeField()
    status = models.IntegerField(blank=True, null=True, choices=CHOICES)
    misc_data = models.CharField(max_length=100, blank=True)
    article_text = models.TextField()

    class Meta:
        ordering = ('pub_date', 'headline')
        # A utf-8 verbose name (Ångström's Articles) to test they are valid.
        verbose_name = "\xc3\x85ngstr\xc3\xb6m's Articles"

    def __str__(self):
        return self.headline


</source>
<source file="django/tests/ordering/models.py.pyindent" startline="27" endline="38" pcid="21249">
    author = models.ForeignKey(Author, models.SET_NULL, null=True)
    second_author = models.ForeignKey(Author, models.SET_NULL, null=True, related_name='+')
    headline = models.CharField(max_length=100)
    pub_date = models.DateTimeField()

    class Meta:
        ordering = ('-pub_date', 'headline')

    def __str__(self):
        return self.headline


</source>
<source file="django/tests/serializers/models/base.py.pyindent" startline="56" endline="68" pcid="23128">
    author = models.ForeignKey(Author, models.CASCADE)
    headline = models.CharField(max_length=50)
    pub_date = models.DateTimeField()
    categories = models.ManyToManyField(Category)
    meta_data = models.ManyToManyField(CategoryMetaData)

    class Meta:
        ordering = ('pub_date',)

    def __str__(self):
        return self.headline


</source>
</class>

<class classid="145" nclones="2" nlines="43" similarity="76">
<source file="django/tests/check_framework/test_model_field_deprecation.py.pyindent" startline="9" endline="46" pcid="11449">
    def test_default_details(self):
        class MyField(models.Field):
            system_check_deprecated_details = {}

        class Model(models.Model):
            name = MyField()

        model = Model()
        self.assertEqual(model.check(), [
            checks.Warning(
                msg='MyField has been deprecated.',
                obj=Model._meta.get_field('name'),
                id='fields.WXXX',
            )
        ])

    def test_user_specified_details(self):
        class MyField(models.Field):
            system_check_deprecated_details = {
                'msg': 'This field is deprecated and will be removed soon.',
                'hint': 'Use something else.',
                'id': 'fields.W999',
            }

        class Model(models.Model):
            name = MyField()

        model = Model()
        self.assertEqual(model.check(), [
            checks.Warning(
                msg='This field is deprecated and will be removed soon.',
                hint='Use something else.',
                obj=Model._meta.get_field('name'),
                id='fields.W999',
            )
        ])


</source>
<source file="django/tests/check_framework/test_model_field_deprecation.py.pyindent" startline="49" endline="84" pcid="11456">
    def test_default_details(self):
        class MyField(models.Field):
            system_check_removed_details = {}

        class Model(models.Model):
            name = MyField()

        model = Model()
        self.assertEqual(model.check(), [
            checks.Error(
                msg='MyField has been removed except for support in historical migrations.',
                obj=Model._meta.get_field('name'),
                id='fields.EXXX',
            )
        ])

    def test_user_specified_details(self):
        class MyField(models.Field):
            system_check_removed_details = {
                'msg': 'Support for this field is gone.',
                'hint': 'Use something else.',
                'id': 'fields.E999',
            }

        class Model(models.Model):
            name = MyField()

        model = Model()
        self.assertEqual(model.check(), [
            checks.Error(
                msg='Support for this field is gone.',
                hint='Use something else.',
                obj=Model._meta.get_field('name'),
                id='fields.E999',
            )
        ])
</source>
</class>

<class classid="146" nclones="2" nlines="44" similarity="70">
<source file="django/tests/check_framework/test_security.py.pyindent" startline="8" endline="61" pcid="11475">
    @property
    def func(self):
        from django.core.checks.security.sessions import check_session_cookie_secure
        return check_session_cookie_secure

    @override_settings(
        SESSION_COOKIE_SECURE=False,
        INSTALLED_APPS=["django.contrib.sessions"],
        MIDDLEWARE=[],
    )
    def test_session_cookie_secure_with_installed_app(self):
        """
        Warn if SESSION_COOKIE_SECURE is off and "django.contrib.sessions" is
        in INSTALLED_APPS.
        """
        self.assertEqual(self.func(None), [sessions.W010])

    @override_settings(
        SESSION_COOKIE_SECURE=False,
        INSTALLED_APPS=[],
        MIDDLEWARE=['django.contrib.sessions.middleware.SessionMiddleware'],
    )
    def test_session_cookie_secure_with_middleware(self):
        """
        Warn if SESSION_COOKIE_SECURE is off and
        "django.contrib.sessions.middleware.SessionMiddleware" is in
        MIDDLEWARE.
        """
        self.assertEqual(self.func(None), [sessions.W011])

    @override_settings(
        SESSION_COOKIE_SECURE=False,
        INSTALLED_APPS=["django.contrib.sessions"],
        MIDDLEWARE=['django.contrib.sessions.middleware.SessionMiddleware'],
    )
    def test_session_cookie_secure_both(self):
        """
        If SESSION_COOKIE_SECURE is off and we find both the session app and
        the middleware, provide one common warning.
        """
        self.assertEqual(self.func(None), [sessions.W012])

    @override_settings(
        SESSION_COOKIE_SECURE=True,
        INSTALLED_APPS=["django.contrib.sessions"],
        MIDDLEWARE=['django.contrib.sessions.middleware.SessionMiddleware'],
    )
    def test_session_cookie_secure_true(self):
        """
        If SESSION_COOKIE_SECURE is on, there's no warning about it.
        """
        self.assertEqual(self.func(None), [])


</source>
<source file="django/tests/check_framework/test_security.py.pyindent" startline="63" endline="116" pcid="11481">
    @property
    def func(self):
        from django.core.checks.security.sessions import check_session_cookie_httponly
        return check_session_cookie_httponly

    @override_settings(
        SESSION_COOKIE_HTTPONLY=False,
        INSTALLED_APPS=["django.contrib.sessions"],
        MIDDLEWARE=[],
    )
    def test_session_cookie_httponly_with_installed_app(self):
        """
        Warn if SESSION_COOKIE_HTTPONLY is off and "django.contrib.sessions"
        is in INSTALLED_APPS.
        """
        self.assertEqual(self.func(None), [sessions.W013])

    @override_settings(
        SESSION_COOKIE_HTTPONLY=False,
        INSTALLED_APPS=[],
        MIDDLEWARE=['django.contrib.sessions.middleware.SessionMiddleware'],
    )
    def test_session_cookie_httponly_with_middleware(self):
        """
        Warn if SESSION_COOKIE_HTTPONLY is off and
        "django.contrib.sessions.middleware.SessionMiddleware" is in
        MIDDLEWARE.
        """
        self.assertEqual(self.func(None), [sessions.W014])

    @override_settings(
        SESSION_COOKIE_HTTPONLY=False,
        INSTALLED_APPS=["django.contrib.sessions"],
        MIDDLEWARE=['django.contrib.sessions.middleware.SessionMiddleware'],
    )
    def test_session_cookie_httponly_both(self):
        """
        If SESSION_COOKIE_HTTPONLY is off and we find both the session app and
        the middleware, provide one common warning.
        """
        self.assertEqual(self.func(None), [sessions.W015])

    @override_settings(
        SESSION_COOKIE_HTTPONLY=True,
        INSTALLED_APPS=["django.contrib.sessions"],
        MIDDLEWARE=['django.contrib.sessions.middleware.SessionMiddleware'],
    )
    def test_session_cookie_httponly_true(self):
        """
        If SESSION_COOKIE_HTTPONLY is on, there's no warning about it.
        """
        self.assertEqual(self.func(None), [])


</source>
</class>

<class classid="147" nclones="3" nlines="10" similarity="70">
<source file="django/tests/contenttypes_tests/models.py.pyindent" startline="30" endline="38" pcid="11657">
    title = models.CharField(max_length=100)
    slug = models.SlugField()
    author = models.ForeignKey(Author, models.CASCADE)
    date_created = models.DateTimeField()

    def __str__(self):
        return self.title


</source>
<source file="django/tests/dates/models.py.pyindent" startline="6" endline="15" pcid="12244">
    title = models.CharField(max_length=100)
    pub_date = models.DateField()
    pub_datetime = models.DateTimeField(default=timezone.now())

    categories = models.ManyToManyField("Category", related_name="articles")

    def __str__(self):
        return self.title


</source>
<source file="django/tests/datetimes/models.py.pyindent" startline="5" endline="14" pcid="12263">
    title = models.CharField(max_length=100)
    pub_date = models.DateTimeField()
    published_on = models.DateField(null=True)

    categories = models.ManyToManyField("Category", related_name="articles")

    def __str__(self):
        return self.title


</source>
</class>

<class classid="148" nclones="3" nlines="13" similarity="71">
<source file="django/tests/contenttypes_tests/models.py.pyindent" startline="94" endline="105" pcid="11672">
    text = models.CharField(max_length=200)
    content_type = models.ForeignKey(ContentType, models.CASCADE)
    object_id = models.PositiveIntegerField()
    question = GenericForeignKey()

    class Meta:
        order_with_respect_to = 'question'

    def __str__(self):
        return self.text


</source>
<source file="django/tests/order_with_respect_to/models.py.pyindent" startline="13" endline="22" pcid="21266">
    text = models.CharField(max_length=200)
    question = models.ForeignKey(Question, models.CASCADE)

    class Meta:
        order_with_respect_to = 'question'

    def __str__(self):
        return self.text


</source>
<source file="django/tests/generic_relations/models.py.pyindent" startline="20" endline="33" pcid="15415">
    """A tag on an item."""
    tag = models.SlugField()
    content_type = models.ForeignKey(ContentType, models.CASCADE)
    object_id = models.PositiveIntegerField()

    content_object = GenericForeignKey()

    class Meta:
        ordering = ["tag", "content_type__model"]

    def __str__(self):
        return self.tag


</source>
</class>

<class classid="149" nclones="22" nlines="14" similarity="71">
<source file="django/tests/contenttypes_tests/operations_migrations/0001_initial.py.pyindent" startline="5" endline="13" pcid="11683">

    operations = [
        migrations.CreateModel(
            'Foo',
            [
                ('id', models.AutoField(primary_key=True)),
            ],
        ),
    ]
</source>
<source file="django/tests/migrate_signals/custom_migrations/0001_initial.py.pyindent" startline="5" endline="13" pcid="19002">

    operations = [
        migrations.CreateModel(
            "Signal",
            [
                ("id", models.AutoField(primary_key=True)),
            ],
        ),
    ]
</source>
<source file="django/tests/migrations/test_migrations_conflict/0002_conflicting_second.py.pyindent" startline="5" endline="17" pcid="19359">

    dependencies = [("migrations", "0001_initial")]

    operations = [

        migrations.CreateModel(
            "Something",
            [
                ("id", models.AutoField(primary_key=True)),
            ],
        )

    ]
</source>
<source file="django/tests/migrations/test_migrations_run_before/0001_initial.py.pyindent" startline="5" endline="17" pcid="19381">

    operations = [

        migrations.CreateModel(
            "Salamander",
            [
                ("id", models.AutoField(primary_key=True)),
                ("size", models.IntegerField(default=0)),
                ("silly_field", models.BooleanField(default=False)),
            ],
        ),

    ]
</source>
<source file="django/tests/migrations/migrations_test_apps/unspecified_app_with_conflict/migrations/0002_conflicting_second.py.pyindent" startline="5" endline="17" pcid="19055">

    dependencies = [("unspecified_app_with_conflict", "0001_initial")]

    operations = [

        migrations.CreateModel(
            "Something",
            [
                ("id", models.AutoField(primary_key=True)),
            ],
        )

    ]
</source>
<source file="django/tests/migrations/migrations_test_apps/migrated_unapplied_app/migrations/0001_initial.py.pyindent" startline="5" endline="19" pcid="19045">

    operations = [

        migrations.CreateModel(
            "OtherAuthor",
            [
                ("id", models.AutoField(primary_key=True)),
                ("name", models.CharField(max_length=255)),
                ("slug", models.SlugField(null=True)),
                ("age", models.IntegerField(default=0)),
                ("silly_field", models.BooleanField(default=False)),
            ],
        ),

    ]
</source>
<source file="django/tests/migrations/migrations_test_apps/unspecified_app_with_conflict/migrations/0002_second.py.pyindent" startline="5" endline="23" pcid="19056">

    dependencies = [("unspecified_app_with_conflict", "0001_initial")]

    operations = [

        migrations.DeleteModel("Tribble"),

        migrations.RemoveField("Author", "silly_field"),

        migrations.AddField("Author", "rating", models.IntegerField(default=0)),

        migrations.CreateModel(
            "Book",
            [
                ("id", models.AutoField(primary_key=True)),
            ],
        )

    ]
</source>
<source file="django/tests/migrations2/test_migrations_2_first/0002_second.py.pyindent" startline="5" endline="19" pcid="19465">

    dependencies = [("migrations2", "0001_initial")]

    operations = [

        migrations.CreateModel(
            "Bookstore",
            [
                ("id", models.AutoField(primary_key=True)),
                ("name", models.CharField(max_length=255)),
                ("slug", models.SlugField(null=True)),
            ],
        ),

    ]
</source>
<source file="django/tests/migrations2/test_migrations_2_first/0001_initial.py.pyindent" startline="5" endline="23" pcid="19464">

    dependencies = [
        ("migrations", "__first__"),
    ]

    operations = [

        migrations.CreateModel(
            "OtherAuthor",
            [
                ("id", models.AutoField(primary_key=True)),
                ("name", models.CharField(max_length=255)),
                ("slug", models.SlugField(null=True)),
                ("age", models.IntegerField(default=0)),
                ("silly_field", models.BooleanField(default=False)),
            ],
        ),

    ]
</source>
<source file="django/tests/migrations2/test_migrations_2/0001_initial.py.pyindent" startline="5" endline="21" pcid="19463">

    dependencies = [("migrations", "0002_second")]

    operations = [

        migrations.CreateModel(
            "OtherAuthor",
            [
                ("id", models.AutoField(primary_key=True)),
                ("name", models.CharField(max_length=255)),
                ("slug", models.SlugField(null=True)),
                ("age", models.IntegerField(default=0)),
                ("silly_field", models.BooleanField(default=False)),
            ],
        ),

    ]
</source>
<source file="django/tests/migrations2/test_migrations_2_no_deps/0001_initial.py.pyindent" startline="5" endline="21" pcid="19466">

    dependencies = []

    operations = [

        migrations.CreateModel(
            "OtherAuthor",
            [
                ("id", models.AutoField(primary_key=True)),
                ("name", models.CharField(max_length=255)),
                ("slug", models.SlugField(null=True)),
                ("age", models.IntegerField(default=0)),
                ("silly_field", models.BooleanField(default=False)),
            ],
        ),

    ]
</source>
<source file="django/tests/migrations/test_migrations_no_changes/0002_second.py.pyindent" startline="5" endline="26" pcid="19371">

    dependencies = [
        ("migrations", "0001_initial"),
    ]

    operations = [

        migrations.DeleteModel("Tribble"),

        migrations.RemoveField("Author", "silly_field"),

        migrations.AddField("Author", "rating", models.IntegerField(default=0)),

        migrations.CreateModel(
            "Book",
            [
                ("id", models.AutoField(primary_key=True)),
                ("author", models.ForeignKey("migrations.Author", models.SET_NULL, null=True)),
            ],
        )

    ]
</source>
<source file="django/tests/migrations/test_migrations_conflict/0002_second.py.pyindent" startline="5" endline="24" pcid="19360">

    dependencies = [("migrations", "0001_initial")]

    operations = [

        migrations.DeleteModel("Tribble"),

        migrations.RemoveField("Author", "silly_field"),

        migrations.AddField("Author", "rating", models.IntegerField(default=0)),

        migrations.CreateModel(
            "Book",
            [
                ("id", models.AutoField(primary_key=True)),
                ("author", models.ForeignKey("migrations.Author", models.SET_NULL, null=True)),
            ],
        )

    ]
</source>
<source file="django/tests/migrations/test_migrations_squashed/0002_second.py.pyindent" startline="5" endline="24" pcid="19386">

    dependencies = [("migrations", "0001_initial")]

    operations = [

        migrations.DeleteModel("Tribble"),

        migrations.RemoveField("Author", "silly_field"),

        migrations.AddField("Author", "rating", models.IntegerField(default=0)),

        migrations.CreateModel(
            "Book",
            [
                ("id", models.AutoField(primary_key=True)),
                ("author", models.ForeignKey("migrations.Author", models.SET_NULL, null=True)),
            ],
        )

    ]
</source>
<source file="django/tests/migrations/test_migrations_first/second.py.pyindent" startline="5" endline="27" pcid="19363">

    dependencies = [
        ("migrations", "thefirst"),
        ("migrations2", "0002_second"),
    ]

    operations = [

        migrations.DeleteModel("Tribble"),

        migrations.RemoveField("Author", "silly_field"),

        migrations.AddField("Author", "rating", models.IntegerField(default=0)),

        migrations.CreateModel(
            "Book",
            [
                ("id", models.AutoField(primary_key=True)),
                ("author", models.ForeignKey("migrations.Author", models.SET_NULL, null=True)),
            ],
        )

    ]
</source>
<source file="django/tests/migrations/test_migrations_no_ancestor/0002_second.py.pyindent" startline="5" endline="26" pcid="19369">

    dependencies = [
        ("migrations", "0001_initial"),
    ]

    operations = [

        migrations.DeleteModel("Tribble"),

        migrations.RemoveField("Author", "silly_field"),

        migrations.AddField("Author", "rating", models.IntegerField(default=0)),

        migrations.CreateModel(
            "Book",
            [
                ("id", models.AutoField(primary_key=True)),
                ("author", models.ForeignKey("migrations.Author", models.SET_NULL, null=True)),
            ],
        )

    ]
</source>
<source file="django/tests/migrations/test_migrations_no_ancestor/0002_conflicting_second.py.pyindent" startline="5" endline="25" pcid="19368">

    dependencies = [
    ]

    operations = [

        migrations.DeleteModel("Tribble"),

        migrations.RemoveField("Author", "silly_field"),

        migrations.AddField("Author", "rating", models.IntegerField(default=0)),

        migrations.CreateModel(
            "Book",
            [
                ("id", models.AutoField(primary_key=True)),
                ("author", models.ForeignKey("migrations.Author", models.SET_NULL, null=True)),
            ],
        )

    ]
</source>
<source file="django/tests/migrations/test_migrations/0002_second.py.pyindent" startline="5" endline="26" pcid="19351">

    dependencies = [
        ("migrations", "0001_initial"),
    ]

    operations = [

        migrations.DeleteModel("Tribble"),

        migrations.RemoveField("Author", "silly_field"),

        migrations.AddField("Author", "rating", models.IntegerField(default=0)),

        migrations.CreateModel(
            "Book",
            [
                ("id", models.AutoField(primary_key=True)),
                ("author", models.ForeignKey("migrations.Author", models.SET_NULL, null=True)),
            ],
        )

    ]
</source>
<source file="django/tests/migrations/test_migrations_unmigdep/0001_initial.py.pyindent" startline="5" endline="20" pcid="19420">

    dependencies = [
        ("auth", "__first__"),
    ]

    operations = [

        migrations.CreateModel(
            "Book",
            [
                ("id", models.AutoField(primary_key=True)),
                ("user", models.ForeignKey("auth.User", models.SET_NULL, null=True)),
            ],
        )

    ]
</source>
<source file="django/tests/migrations/test_migrations_run_before/0002_second.py.pyindent" startline="5" endline="20" pcid="19382">

    dependencies = [
        ("migrations", "0001_initial"),
    ]

    operations = [

        migrations.CreateModel(
            "Book",
            [
                ("id", models.AutoField(primary_key=True)),
                ("author", models.ForeignKey("migrations.Author", models.SET_NULL, null=True)),
            ],
        )

    ]
</source>
<source file="django/tests/migrations/migrations_test_apps/conflicting_app_with_dependencies/migrations/0002_second.py.pyindent" startline="5" endline="21" pcid="19023">

    dependencies = [
        ("conflicting_app_with_dependencies", "0001_initial"),
        ("migrated_app", "0001_initial"),
    ]

    operations = [
        migrations.DeleteModel("Tribble"),
        migrations.RemoveField("Author", "silly_field"),
        migrations.AddField("Author", "rating", models.IntegerField(default=0)),
        migrations.CreateModel(
            "Book",
            [
                ("id", models.AutoField(primary_key=True)),
            ],
        )
    ]
</source>
<source file="django/tests/migrations/test_migrations_fake_split_initial/0002_second.py.pyindent" startline="5" endline="21" pcid="19362">

    initial = True

    dependencies = [
        ("migrations", "0001_initial"),
    ]

    operations = [
        migrations.AddField("Author", "rating", models.IntegerField(default=0)),
        migrations.CreateModel(
            "Book",
            [
                ("id", models.AutoField(primary_key=True)),
                ("author", models.ForeignKey("migrations.Author", models.SET_NULL, null=True)),
            ],
        ),
    ]
</source>
</class>

<class classid="150" nclones="2" nlines="17" similarity="82">
<source file="django/tests/contenttypes_tests/test_checks.py.pyindent" startline="34" endline="50" pcid="11694">
        class Model(models.Model):
            content_type = models.IntegerField()  # should be ForeignKey
            object_id = models.PositiveIntegerField()
            content_object = GenericForeignKey('content_type', 'object_id')

        self.assertEqual(Model.content_object.check(), [
            checks.Error(
                "'Model.content_type' is not a ForeignKey.",
                hint=(
                    "GenericForeignKeys must use a ForeignKey to "
                    "'contenttypes.ContentType' as the 'content_type' field."
                ),
                obj=Model.content_object,
                id='contenttypes.E003',
            )
        ])

</source>
<source file="django/tests/contenttypes_tests/test_checks.py.pyindent" startline="52" endline="68" pcid="11696">
        class Model(models.Model):
            content_type = models.ForeignKey('self', models.CASCADE)  # should point to ContentType
            object_id = models.PositiveIntegerField()
            content_object = GenericForeignKey('content_type', 'object_id')

        self.assertEqual(Model.content_object.check(), [
            checks.Error(
                "'Model.content_type' is not a ForeignKey to 'contenttypes.ContentType'.",
                hint=(
                    "GenericForeignKeys must use a ForeignKey to "
                    "'contenttypes.ContentType' as the 'content_type' field."
                ),
                obj=Model.content_object,
                id='contenttypes.E004',
            )
        ])

</source>
</class>

<class classid="151" nclones="2" nlines="11" similarity="72">
<source file="django/tests/contenttypes_tests/test_views.py.pyindent" startline="56" endline="65" pcid="11756">
        """
        Can view a shortcut when object's get_absolute_url returns a full URL
        the tested URLs are: "http://...", "https://..." and "//..."
        """
        for obj in SchemeIncludedURL.objects.all():
            with self.subTest(obj=obj):
                short_url = '/shortcut/%s/%s/' % (ContentType.objects.get_for_model(SchemeIncludedURL).id, obj.pk)
                response = self.client.get(short_url)
                self.assertRedirects(response, obj.get_absolute_url(), fetch_redirect_response=False)

</source>
<source file="django/tests/contenttypes_tests/test_views.py.pyindent" startline="67" endline="76" pcid="11759">
        """
        Shortcuts for an object that has no get_absolute_url() method raise
        404.
        """
        for obj in Article.objects.all():
            with self.subTest(obj=obj):
                short_url = '/shortcut/%s/%s/' % (ContentType.objects.get_for_model(Article).id, obj.pk)
                response = self.client.get(short_url)
                self.assertEqual(response.status_code, 404)

</source>
</class>

<class classid="152" nclones="2" nlines="10" similarity="80">
<source file="django/tests/csrf_tests/tests.py.pyindent" startline="95" endline="105" pcid="11803">
        """
        If no CSRF cookies is present, the middleware rejects the incoming
        request. This will stop login CSRF.
        """
        req = self._get_POST_no_csrf_cookie_request()
        self.mw.process_request(req)
        with self.assertLogs('django.security.csrf', 'WARNING') as cm:
            req2 = self.mw.process_view(req, post_form_view, (), {})
        self.assertEqual(403, req2.status_code)
        self.assertEqual(cm.records[0].getMessage(), 'Forbidden (%s): ' % REASON_NO_CSRF_COOKIE)

</source>
<source file="django/tests/csrf_tests/tests.py.pyindent" startline="107" endline="117" pcid="11805">
        """
        If a CSRF cookie is present but no token, the middleware rejects
        the incoming request.
        """
        req = self._get_POST_csrf_cookie_request()
        self.mw.process_request(req)
        with self.assertLogs('django.security.csrf', 'WARNING') as cm:
            req2 = self.mw.process_view(req, post_form_view, (), {})
        self.assertEqual(403, req2.status_code)
        self.assertEqual(cm.records[0].getMessage(), 'Forbidden (%s): ' % REASON_BAD_TOKEN)

</source>
</class>

<class classid="153" nclones="3" nlines="13" similarity="71">
<source file="django/tests/csrf_tests/tests.py.pyindent" startline="279" endline="294" pcid="11823">
        """
        A POST HTTPS request with a bad referer is rejected
        """
        req = self._get_POST_request_with_token()
        req._is_secure_override = True
        req.META['HTTP_HOST'] = 'www.example.com'
        req.META['HTTP_REFERER'] = 'https://www.evil.org/somepage'
        req.META['SERVER_PORT'] = '443'
        response = self.mw.process_view(req, post_form_view, (), {})
        self.assertContains(
            response,
            'Referer checking failed - https://www.evil.org/somepage does not '
            'match any trusted origins.',
            status_code=403,
        )

</source>
<source file="django/tests/csrf_tests/tests.py.pyindent" startline="749" endline="763" pcid="11874">
        """
        A POST HTTPS request from an insecure referer should be rejected.
        """
        req = self._get_POST_request_with_token()
        req._is_secure_override = True
        req.META['HTTP_REFERER'] = 'http://example.com/'
        req.META['SERVER_PORT'] = '443'
        response = self.mw.process_view(req, post_form_view, (), {})
        self.assertContains(
            response,
            'Referer checking failed - Referer is insecure while host is secure.',
            status_code=403,
        )


</source>
<source file="django/tests/csrf_tests/tests.py.pyindent" startline="651" endline="665" pcid="11862">
        """
        A POST HTTPS request from an insecure referer should be rejected.
        """
        req = self._get_POST_request_with_token()
        req._is_secure_override = True
        req.META['HTTP_REFERER'] = 'http://example.com/'
        req.META['SERVER_PORT'] = '443'
        response = self.mw.process_view(req, post_form_view, (), {})
        self.assertContains(
            response,
            'Referer checking failed - Referer is insecure while host is secure.',
            status_code=403,
        )


</source>
</class>

<class classid="154" nclones="2" nlines="17" similarity="88">
<source file="django/tests/csrf_tests/tests.py.pyindent" startline="533" endline="552" pcid="11850">
        """
        CSRF cookie age can be set using settings.CSRF_COOKIE_AGE.
        """
        req = self._get_GET_no_csrf_cookie_request()

        MAX_AGE = 123
        with self.settings(CSRF_COOKIE_NAME='csrfcookie',
                           CSRF_COOKIE_DOMAIN='.example.com',
                           CSRF_COOKIE_AGE=MAX_AGE,
                           CSRF_COOKIE_PATH='/test/',
                           CSRF_COOKIE_SECURE=True,
                           CSRF_COOKIE_HTTPONLY=True):
            # token_view calls get_token() indirectly
            self.mw.process_view(req, token_view, (), {})
            resp = token_view(req)

            resp2 = self.mw.process_response(req, resp)
            max_age = resp2.cookies.get('csrfcookie').get('max-age')
            self.assertEqual(max_age, MAX_AGE)

</source>
<source file="django/tests/csrf_tests/tests.py.pyindent" startline="554" endline="574" pcid="11852">
        """
        CSRF cookie age does not have max age set and therefore uses
        session-based cookies.
        """
        req = self._get_GET_no_csrf_cookie_request()

        MAX_AGE = None
        with self.settings(CSRF_COOKIE_NAME='csrfcookie',
                           CSRF_COOKIE_DOMAIN='.example.com',
                           CSRF_COOKIE_AGE=MAX_AGE,
                           CSRF_COOKIE_PATH='/test/',
                           CSRF_COOKIE_SECURE=True,
                           CSRF_COOKIE_HTTPONLY=True):
            # token_view calls get_token() indirectly
            self.mw.process_view(req, token_view, (), {})
            resp = token_view(req)

            resp2 = self.mw.process_response(req, resp)
            max_age = resp2.cookies.get('csrfcookie').get('max-age')
            self.assertEqual(max_age, '')

</source>
</class>

<class classid="155" nclones="2" nlines="10" similarity="70">
<source file="django/tests/custom_columns/tests.py.pyindent" startline="48" endline="53" pcid="11897">
        with self.assertRaises(AttributeError):
            self.a1.firstname

        with self.assertRaises(AttributeError):
            self.a1.last

</source>
<source file="django/tests/sessions_tests/tests.py.pyindent" startline="224" endline="229" pcid="23568">
        def set_session_key(session):
            session.session_key = session._get_new_session_key()
        with self.assertRaises(AttributeError):
            set_session_key(self.session)

    # Custom session expiry
</source>
</class>

<class classid="156" nclones="2" nlines="16" similarity="75">
<source file="django/tests/custom_lookups/tests.py.pyindent" startline="293" endline="305" pcid="11978">
        with register_lookup(models.IntegerField, Div3Transform):
            a1 = Author.objects.create(name='a1', age=1)
            a2 = Author.objects.create(name='a2', age=2)
            a3 = Author.objects.create(name='a3', age=3)
            a4 = Author.objects.create(name='a4', age=4)
            baseqs = Author.objects.order_by('name')
            self.assertSequenceEqual(baseqs.filter(age__div3=2), [a2])
            self.assertSequenceEqual(baseqs.filter(age__div3__lte=3), [a1, a2, a3, a4])
            self.assertSequenceEqual(baseqs.filter(age__div3__in=[0, 2]), [a2, a3])
            self.assertSequenceEqual(baseqs.filter(age__div3__in=[2, 4]), [a2])
            self.assertSequenceEqual(baseqs.filter(age__div3__gte=3), [])
            self.assertSequenceEqual(baseqs.filter(age__div3__range=(1, 2)), [a1, a2, a4])

</source>
<source file="django/tests/custom_lookups/tests.py.pyindent" startline="365" endline="377" pcid="11993">
        with register_lookup(models.IntegerField, Div3BilateralTransform):
            a1 = Author.objects.create(name='a1', age=1)
            a2 = Author.objects.create(name='a2', age=2)
            a3 = Author.objects.create(name='a3', age=3)
            a4 = Author.objects.create(name='a4', age=4)
            baseqs = Author.objects.order_by('name')
            self.assertSequenceEqual(baseqs.filter(age__div3=2), [a2])
            self.assertSequenceEqual(baseqs.filter(age__div3__lte=3), [a3])
            self.assertSequenceEqual(baseqs.filter(age__div3__in=[0, 2]), [a2, a3])
            self.assertSequenceEqual(baseqs.filter(age__div3__in=[2, 4]), [a1, a2, a4])
            self.assertSequenceEqual(baseqs.filter(age__div3__gte=3), [a1, a2, a3, a4])
            self.assertSequenceEqual(baseqs.filter(age__div3__range=(1, 2)), [a1, a2, a4])

</source>
</class>

<class classid="157" nclones="2" nlines="11" similarity="90">
<source file="django/tests/custom_managers/models.py.pyindent" startline="205" endline="215" pcid="12080">
    name = models.CharField(max_length=50)
    is_public = models.BooleanField(default=False)
    related = models.ForeignKey(RelatedModel, models.CASCADE)

    objects = RestrictedManager()
    plain_manager = models.Manager()

    def __str__(self):
        return self.name


</source>
<source file="django/tests/custom_managers/models.py.pyindent" startline="217" endline="227" pcid="12082">
    name = models.CharField(max_length=50)
    is_public = models.BooleanField(default=False)
    related = models.OneToOneField(RelatedModel, models.CASCADE)

    objects = RestrictedManager()
    plain_manager = models.Manager()

    def __str__(self):
        return self.name


</source>
</class>

<class classid="158" nclones="2" nlines="15" similarity="73">
<source file="django/tests/custom_managers/tests.py.pyindent" startline="40" endline="53" pcid="12090">
        """
        The methods of a custom QuerySet are properly copied onto the
        default Manager.
        """
        for manager_name in self.custom_manager_names:
            with self.subTest(manager_name=manager_name):
                manager = getattr(Person, manager_name)

                # Public methods are copied
                manager.public_method()
                # Private methods are not copied
                with self.assertRaises(AttributeError):
                    manager._private_method()

</source>
<source file="django/tests/custom_managers/tests.py.pyindent" startline="55" endline="64" pcid="12094">
        for manager_name in self.custom_manager_names:
            with self.subTest(manager_name=manager_name):
                manager = getattr(Person, manager_name)
                # Methods with queryset_only=False are copied even if they are private.
                manager._optin_private_method()
                # Methods with queryset_only=True aren't copied even if they are public.
                msg = "%r object has no attribute 'optout_public_method'" % manager.__class__.__name__
                with self.assertRaisesMessage(AttributeError, msg):
                    manager.optout_public_method()

</source>
</class>

<class classid="159" nclones="4" nlines="35" similarity="71">
<source file="django/tests/custom_managers/tests.py.pyindent" startline="137" endline="171" pcid="12109">
        Person.objects.create(first_name="Bugs", last_name="Bunny", fun=True, favorite_book=self.b1)
        Person.objects.create(first_name="Droopy", last_name="Dog", fun=False, favorite_book=self.b1)
        FunPerson.objects.create(first_name="Bugs", last_name="Bunny", fun=True, favorite_book=self.b1)
        FunPerson.objects.create(first_name="Droopy", last_name="Dog", fun=False, favorite_book=self.b1)

        self.assertQuerysetEqual(
            self.b1.favorite_books.order_by('first_name').all(), [
                "Bugs",
                "Droopy",
            ],
            lambda c: c.first_name,
            ordered=False,
        )
        self.assertQuerysetEqual(
            self.b1.fun_people_favorite_books.all(), [
                "Bugs",
            ],
            lambda c: c.first_name,
            ordered=False,
        )
        self.assertQuerysetEqual(
            self.b1.favorite_books(manager='boring_people').all(), [
                "Droopy",
            ],
            lambda c: c.first_name,
            ordered=False,
        )
        self.assertQuerysetEqual(
            self.b1.favorite_books(manager='fun_people').all(), [
                "Bugs",
            ],
            lambda c: c.first_name,
            ordered=False,
        )

</source>
<source file="django/tests/custom_managers/tests.py.pyindent" startline="286" endline="324" pcid="12114">
        Person.objects.create(first_name="Bugs", last_name="Bunny", fun=True, favorite_book=self.b1)
        droopy = Person.objects.create(first_name="Droopy", last_name="Dog", fun=False, favorite_book=self.b1)

        # The fun manager DOESN'T remove boring people.
        self.b1.favorite_books(manager='fun_people').remove(droopy, bulk=bulk)
        self.assertQuerysetEqual(
            self.b1.favorite_books(manager='boring_people').all(), [
                "Droopy",
            ],
            lambda c: c.first_name,
            ordered=False,
        )
        # The boring manager DOES remove boring people.
        self.b1.favorite_books(manager='boring_people').remove(droopy, bulk=bulk)
        self.assertQuerysetEqual(
            self.b1.favorite_books(manager='boring_people').all(), [
            ],
            lambda c: c.first_name,
            ordered=False,
        )
        droopy.favorite_book = self.b1
        droopy.save()

        # The fun manager ONLY clears fun people.
        self.b1.favorite_books(manager='fun_people').clear(bulk=bulk)
        self.assertQuerysetEqual(
            self.b1.favorite_books(manager='boring_people').all(), [
                "Droopy",
            ],
            lambda c: c.first_name,
            ordered=False,
        )
        self.assertQuerysetEqual(
            self.b1.favorite_books(manager='fun_people').all(), [
            ],
            lambda c: c.first_name,
            ordered=False,
        )

</source>
<source file="django/tests/custom_managers/tests.py.pyindent" startline="173" endline="207" pcid="12110">
        Person.objects.create(first_name="Bugs", last_name="Bunny", fun=True, favorite_thing=self.b1)
        Person.objects.create(first_name="Droopy", last_name="Dog", fun=False, favorite_thing=self.b1)
        FunPerson.objects.create(first_name="Bugs", last_name="Bunny", fun=True, favorite_thing=self.b1)
        FunPerson.objects.create(first_name="Droopy", last_name="Dog", fun=False, favorite_thing=self.b1)

        self.assertQuerysetEqual(
            self.b1.favorite_things.all(), [
                "Bugs",
                "Droopy",
            ],
            lambda c: c.first_name,
            ordered=False,
        )
        self.assertQuerysetEqual(
            self.b1.fun_people_favorite_things.all(), [
                "Bugs",
            ],
            lambda c: c.first_name,
            ordered=False,
        )
        self.assertQuerysetEqual(
            self.b1.favorite_things(manager='boring_people').all(), [
                "Droopy",
            ],
            lambda c: c.first_name,
            ordered=False,
        )
        self.assertQuerysetEqual(
            self.b1.favorite_things(manager='fun_people').all(), [
                "Bugs",
            ],
            lambda c: c.first_name,
            ordered=False,
        )

</source>
<source file="django/tests/custom_managers/tests.py.pyindent" startline="366" endline="405" pcid="12118">
        Person.objects.create(first_name="Bugs", last_name="Bunny", fun=True, favorite_thing=self.b1)
        droopy = Person.objects.create(first_name="Droopy", last_name="Dog", fun=False, favorite_thing=self.b1)

        # The fun manager DOESN'T remove boring people.
        self.b1.favorite_things(manager='fun_people').remove(droopy, bulk=bulk)
        self.assertQuerysetEqual(
            self.b1.favorite_things(manager='boring_people').all(), [
                "Droopy",
            ],
            lambda c: c.first_name,
            ordered=False,
        )

        # The boring manager DOES remove boring people.
        self.b1.favorite_things(manager='boring_people').remove(droopy, bulk=bulk)
        self.assertQuerysetEqual(
            self.b1.favorite_things(manager='boring_people').all(), [
            ],
            lambda c: c.first_name,
            ordered=False,
        )
        droopy.favorite_thing = self.b1
        droopy.save()

        # The fun manager ONLY clears fun people.
        self.b1.favorite_things(manager='fun_people').clear(bulk=bulk)
        self.assertQuerysetEqual(
            self.b1.favorite_things(manager='boring_people').all(), [
                "Droopy",
            ],
            lambda c: c.first_name,
            ordered=False,
        )
        self.assertQuerysetEqual(
            self.b1.favorite_things(manager='fun_people').all(), [
            ],
            lambda c: c.first_name,
            ordered=False,
        )

</source>
</class>

<class classid="160" nclones="2" nlines="38" similarity="76">
<source file="django/tests/custom_managers/tests.py.pyindent" startline="209" endline="247" pcid="12111">
        bugs = Person.objects.create(first_name="Bugs", last_name="Bunny", fun=True)
        self.b1.authors.add(bugs)
        droopy = Person.objects.create(first_name="Droopy", last_name="Dog", fun=False)
        self.b1.authors.add(droopy)
        bugs = FunPerson.objects.create(first_name="Bugs", last_name="Bunny", fun=True)
        self.b1.fun_authors.add(bugs)
        droopy = FunPerson.objects.create(first_name="Droopy", last_name="Dog", fun=False)
        self.b1.fun_authors.add(droopy)

        self.assertQuerysetEqual(
            self.b1.authors.order_by('first_name').all(), [
                "Bugs",
                "Droopy",
            ],
            lambda c: c.first_name,
            ordered=False,
        )
        self.assertQuerysetEqual(
            self.b1.fun_authors.order_by('first_name').all(), [
                "Bugs",
            ],
            lambda c: c.first_name,
            ordered=False,
        )
        self.assertQuerysetEqual(
            self.b1.authors(manager='boring_people').all(), [
                "Droopy",
            ],
            lambda c: c.first_name,
            ordered=False,
        )
        self.assertQuerysetEqual(
            self.b1.authors(manager='fun_people').all(), [
                "Bugs",
            ],
            lambda c: c.first_name,
            ordered=False,
        )

</source>
<source file="django/tests/custom_managers/tests.py.pyindent" startline="445" endline="485" pcid="12121">
        bugs = Person.objects.create(first_name="Bugs", last_name="Bunny", fun=True)
        self.b1.authors.add(bugs)
        droopy = Person.objects.create(first_name="Droopy", last_name="Dog", fun=False)
        self.b1.authors.add(droopy)

        # The fun manager DOESN'T remove boring people.
        self.b1.authors(manager='fun_people').remove(droopy)
        self.assertQuerysetEqual(
            self.b1.authors(manager='boring_people').all(), [
                "Droopy",
            ],
            lambda c: c.first_name,
            ordered=False,
        )

        # The boring manager DOES remove boring people.
        self.b1.authors(manager='boring_people').remove(droopy)
        self.assertQuerysetEqual(
            self.b1.authors(manager='boring_people').all(), [
            ],
            lambda c: c.first_name,
            ordered=False,
        )
        self.b1.authors.add(droopy)

        # The fun manager ONLY clears fun people.
        self.b1.authors(manager='fun_people').clear()
        self.assertQuerysetEqual(
            self.b1.authors(manager='boring_people').all(), [
                "Droopy",
            ],
            lambda c: c.first_name,
            ordered=False,
        )
        self.assertQuerysetEqual(
            self.b1.authors(manager='fun_people').all(), [
            ],
            lambda c: c.first_name,
            ordered=False,
        )

</source>
</class>

<class classid="161" nclones="2" nlines="31" similarity="74">
<source file="django/tests/custom_managers/tests.py.pyindent" startline="249" endline="281" pcid="12112">
        bugs = FunPerson.objects.create(first_name="Bugs", last_name="Bunny", fun=True, favorite_book=self.b1)
        droopy = FunPerson.objects.create(first_name="Droopy", last_name="Dog", fun=False, favorite_book=self.b1)

        self.b1.fun_people_favorite_books.remove(droopy, bulk=bulk)
        self.assertQuerysetEqual(
            FunPerson._base_manager.filter(favorite_book=self.b1), [
                "Bugs",
                "Droopy",
            ],
            lambda c: c.first_name,
            ordered=False,
        )

        self.b1.fun_people_favorite_books.remove(bugs, bulk=bulk)
        self.assertQuerysetEqual(
            FunPerson._base_manager.filter(favorite_book=self.b1), [
                "Droopy",
            ],
            lambda c: c.first_name,
            ordered=False,
        )
        bugs.favorite_book = self.b1
        bugs.save()

        self.b1.fun_people_favorite_books.clear(bulk=bulk)
        self.assertQuerysetEqual(
            FunPerson._base_manager.filter(favorite_book=self.b1), [
                "Droopy",
            ],
            lambda c: c.first_name,
            ordered=False,
        )

</source>
<source file="django/tests/custom_managers/tests.py.pyindent" startline="329" endline="361" pcid="12116">
        bugs = FunPerson.objects.create(first_name="Bugs", last_name="Bunny", fun=True, favorite_thing=self.b1)
        droopy = FunPerson.objects.create(first_name="Droopy", last_name="Dog", fun=False, favorite_thing=self.b1)

        self.b1.fun_people_favorite_things.remove(droopy, bulk=bulk)
        self.assertQuerysetEqual(
            FunPerson._base_manager.order_by('first_name').filter(favorite_thing_id=self.b1.pk), [
                "Bugs",
                "Droopy",
            ],
            lambda c: c.first_name,
            ordered=False,
        )

        self.b1.fun_people_favorite_things.remove(bugs, bulk=bulk)
        self.assertQuerysetEqual(
            FunPerson._base_manager.order_by('first_name').filter(favorite_thing_id=self.b1.pk), [
                "Droopy",
            ],
            lambda c: c.first_name,
            ordered=False,
        )
        bugs.favorite_book = self.b1
        bugs.save()

        self.b1.fun_people_favorite_things.clear(bulk=bulk)
        self.assertQuerysetEqual(
            FunPerson._base_manager.order_by('first_name').filter(favorite_thing_id=self.b1.pk), [
                "Droopy",
            ],
            lambda c: c.first_name,
            ordered=False,
        )

</source>
</class>

<class classid="162" nclones="2" nlines="34" similarity="100">
<source file="django/tests/custom_migration_operations/more_operations.py.pyindent" startline="5" endline="29" pcid="12146">
    def __init__(self):
        pass

    def deconstruct(self):
        return (
            self.__class__.__name__,
            [],
            {}
        )

    @property
    def reversible(self):
        return True

    def state_forwards(self, app_label, state):
        pass

    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        pass

    def state_backwards(self, app_label, state):
        pass

    def database_backwards(self, app_label, schema_editor, from_state, to_state):
        pass
</source>
<source file="django/tests/custom_migration_operations/operations.py.pyindent" startline="5" endline="31" pcid="12154">
    def __init__(self):
        pass

    def deconstruct(self):
        return (
            self.__class__.__name__,
            [],
            {}
        )

    @property
    def reversible(self):
        return True

    def state_forwards(self, app_label, state):
        pass

    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        pass

    def state_backwards(self, app_label, state):
        pass

    def database_backwards(self, app_label, schema_editor, from_state, to_state):
        pass


</source>
</class>

<class classid="163" nclones="2" nlines="14" similarity="71">
<source file="django/tests/custom_migration_operations/operations.py.pyindent" startline="37" endline="47" pcid="12163">
    def __init__(self, arg1, arg2):
        self.arg1, self.arg2 = arg1, arg2

    def deconstruct(self):
        return (
            self.__class__.__name__,
            [self.arg1, self.arg2],
            {}
        )


</source>
<source file="django/tests/custom_migration_operations/operations.py.pyindent" startline="84" endline="94" pcid="12176">
    serialization_expand_args = ['arg']

    def __init__(self, arg):
        self.arg = arg

    def deconstruct(self):
        return (
            self.__class__.__name__,
            [self.arg],
            {}
        )
</source>
</class>

<class classid="164" nclones="2" nlines="23" similarity="79">
<source file="django/tests/custom_migration_operations/operations.py.pyindent" startline="49" endline="64" pcid="12166">
    def __init__(self, kwarg1=None, kwarg2=None):
        self.kwarg1, self.kwarg2 = kwarg1, kwarg2

    def deconstruct(self):
        kwargs = {}
        if self.kwarg1 is not None:
            kwargs['kwarg1'] = self.kwarg1
        if self.kwarg2 is not None:
            kwargs['kwarg2'] = self.kwarg2
        return (
            self.__class__.__name__,
            [],
            kwargs
        )


</source>
<source file="django/tests/custom_migration_operations/operations.py.pyindent" startline="66" endline="82" pcid="12171">
    def __init__(self, arg1, arg2, kwarg1=None, kwarg2=None):
        self.arg1, self.arg2 = arg1, arg2
        self.kwarg1, self.kwarg2 = kwarg1, kwarg2

    def deconstruct(self):
        kwargs = {}
        if self.kwarg1 is not None:
            kwargs['kwarg1'] = self.kwarg1
        if self.kwarg2 is not None:
            kwargs['kwarg2'] = self.kwarg2
        return (
            self.__class__.__name__,
            [self.arg1, self.arg2],
            kwargs,
        )


</source>
</class>

<class classid="165" nclones="3" nlines="11" similarity="81">
<source file="django/tests/custom_pk/fields.py.pyindent" startline="37" endline="42" pcid="12189">
        if not value:
            return
        if not isinstance(value, MyWrapper):
            value = MyWrapper(value)
        return value

</source>
<source file="django/tests/custom_pk/fields.py.pyindent" startline="56" endline="60" pcid="12197">
        if not value:
            return
        if isinstance(value, MyWrapper):
            return str(value)
        return value
</source>
<source file="django/tests/custom_pk/fields.py.pyindent" startline="49" endline="54" pcid="12194">
        if not value:
            return
        if isinstance(value, MyWrapper):
            return str(value)
        return value

</source>
</class>

<class classid="166" nclones="33" nlines="11" similarity="72">
<source file="django/tests/custom_pk/models.py.pyindent" startline="26" endline="35" pcid="12203">
    name = models.CharField(max_length=20, primary_key=True)
    employees = models.ManyToManyField(Employee)

    class Meta:
        verbose_name_plural = 'businesses'

    def __str__(self):
        return self.name


</source>
<source file="django/tests/m2m_signals/models.py.pyindent" startline="5" endline="13" pcid="18312">
    name = models.CharField(max_length=20)

    class Meta:
        ordering = ('name',)

    def __str__(self):
        return self.name


</source>
<source file="django/tests/queries/models.py.pyindent" startline="326" endline="334" pcid="22367">
    name = models.CharField(max_length=10)

    class Meta:
        ordering = ['name']

    def __str__(self):
        return self.name


</source>
<source file="django/tests/serializers/models/base.py.pyindent" startline="46" endline="54" pcid="23125">
    name = models.CharField(max_length=20)

    class Meta:
        ordering = ('name',)

    def __str__(self):
        return self.name


</source>
<source file="django/tests/serializers/models/base.py.pyindent" startline="78" endline="86" pcid="23133">
    name = models.CharField(max_length=20, primary_key=True)

    class Meta:
        ordering = ('name',)

    def __str__(self):
        return self.name


</source>
<source file="django/tests/m2m_multiple/models.py.pyindent" startline="14" endline="22" pcid="18263">
    name = models.CharField(max_length=20)

    class Meta:
        ordering = ('name',)

    def __str__(self):
        return self.name


</source>
<source file="django/tests/inline_formsets/models.py.pyindent" startline="27" endline="34" pcid="17568">
    poet = models.ForeignKey(Poet, models.CASCADE)
    name = models.CharField(max_length=100)

    class Meta:
        unique_together = ('poet', 'name')

    def __str__(self):
        return self.name
</source>
<source file="django/tests/generic_views/models.py.pyindent" startline="23" endline="32" pcid="15598">
    name = models.CharField(max_length=100)
    slug = models.SlugField()

    class Meta:
        ordering = ['name']

    def __str__(self):
        return self.name


</source>
<source file="django/tests/m2m_through/models.py.pyindent" startline="8" endline="16" pcid="18343">
    name = models.CharField(max_length=128)

    class Meta:
        ordering = ('name',)

    def __str__(self):
        return self.name


</source>
<source file="django/tests/gis_tests/geogapp/models.py.pyindent" startline="5" endline="13" pcid="16598">
    name = models.CharField(max_length=30)

    class Meta:
        abstract = True

    def __str__(self):
        return self.name


</source>
<source file="django/tests/gis_tests/geoadmin/models.py.pyindent" startline="7" endline="16" pcid="16427">
    name = models.CharField(max_length=30)
    point = models.PointField()

    class Meta:
        app_label = 'geoadmin'

    def __str__(self):
        return self.name


</source>
<source file="django/tests/serializers/models/base.py.pyindent" startline="35" endline="44" pcid="23122">
    name = models.CharField(max_length=20)
    meta_data = models.ForeignKey(CategoryMetaData, models.SET_NULL, null=True, default=None)

    class Meta:
        ordering = ('name',)

    def __str__(self):
        return self.name


</source>
<source file="django/tests/model_inheritance_regress/models.py.pyindent" startline="161" endline="169" pcid="20606">
    name = models.CharField(max_length=100)

    class Meta:
        ordering = ('name',)

    def __str__(self):
        return self.name


</source>
<source file="django/tests/queries/models.py.pyindent" startline="344" endline="353" pcid="22372">
    name = models.CharField(max_length=10)
    others = models.ForeignKey(RelatedObject, models.SET_NULL, null=True)

    class Meta:
        ordering = ['others']

    def __str__(self):
        return self.name


</source>
<source file="django/tests/gis_tests/distapp/models.py.pyindent" startline="7" endline="15" pcid="16134">
    name = models.CharField(max_length=30)

    class Meta:
        abstract = True

    def __str__(self):
        return self.name


</source>
<source file="django/tests/gis_tests/geo3d/models.py.pyindent" startline="5" endline="13" pcid="16411">
    name = models.CharField(max_length=30)

    class Meta:
        abstract = True

    def __str__(self):
        return self.name


</source>
<source file="django/tests/gis_tests/geoapp/models.py.pyindent" startline="7" endline="15" pcid="16456">
    name = models.CharField(max_length=30)

    class Meta:
        abstract = True

    def __str__(self):
        return self.name


</source>
<source file="django/tests/gis_tests/layermap/models.py.pyindent" startline="5" endline="13" pcid="16888">
    name = models.CharField(max_length=25)

    class Meta:
        abstract = True

    def __str__(self):
        return self.name


</source>
<source file="django/tests/model_formsets/models.py.pyindent" startline="8" endline="16" pcid="20242">
    name = models.CharField(max_length=100)

    class Meta:
        ordering = ('name',)

    def __str__(self):
        return self.name


</source>
<source file="django/tests/fixtures_regress/models.py.pyindent" startline="80" endline="88" pcid="13563">
    name = models.CharField(max_length=255)

    class Meta:
        ordering = ('name',)

    def __str__(self):
        return self.name


</source>
<source file="django/tests/forms_tests/models.py.pyindent" startline="57" endline="67" pcid="14386">
    """Destination for ChoiceFieldModel's ForeignKey.
    Can't reuse ChoiceModel because error_message tests require that it have no instances."""
    name = models.CharField(max_length=10)

    class Meta:
        ordering = ('name',)

    def __str__(self):
        return 'ChoiceOption %d' % self.pk


</source>
<source file="django/tests/m2m_signals/models.py.pyindent" startline="31" endline="39" pcid="18319">
    name = models.CharField(max_length=20)
    fans = models.ManyToManyField('self', related_name='idols', symmetrical=False)
    friends = models.ManyToManyField('self')

    class Meta:
        ordering = ('name',)

    def __str__(self):
        return self.name
</source>
<source file="django/tests/model_inheritance_regress/models.py.pyindent" startline="171" endline="181" pcid="20609">
    name = models.CharField(max_length=100)
    attendees = models.ManyToManyField(Person, related_name="%(class)s_set")

    class Meta:
        abstract = True
        ordering = ('name',)

    def __str__(self):
        return self.name


</source>
<source file="django/tests/gis_tests/rasterapp/models.py.pyindent" startline="17" endline="23" pcid="16952">
    rastermodel = models.ForeignKey(RasterModel, models.CASCADE)

    class Meta:
        required_db_features = ['supports_raster']

    def __str__(self):
        return str(self.id)
</source>
<source file="django/tests/foreign_object/models/person.py.pyindent" startline="36" endline="47" pcid="13859">
    # Table Column Fields
    name = models.CharField(max_length=128)
    group_country = models.ForeignKey(Country, models.CASCADE)
    members = models.ManyToManyField(Person, related_name='groups', through='Membership')

    class Meta:
        ordering = ('name',)

    def __str__(self):
        return self.name


</source>
<source file="django/tests/model_inheritance_regress/models.py.pyindent" startline="7" endline="16" pcid="20567">
    name = models.CharField(max_length=50)
    address = models.CharField(max_length=80)

    class Meta:
        ordering = ('name',)

    def __str__(self):
        return "%s the place" % self.name


</source>
<source file="django/tests/modeladmin/models.py.pyindent" startline="6" endline="16" pcid="19477">
    name = models.CharField(max_length=100)
    bio = models.TextField()
    sign_date = models.DateField()

    class Meta:
        ordering = ('name',)

    def __str__(self):
        return self.name


</source>
<source file="django/tests/queries/models.py.pyindent" startline="593" endline="601" pcid="22431">
    id = models.IntegerField(primary_key=True)

    class Meta:
        ordering = ('pk',)

    def __str__(self):
        return '%s' % self.pk


</source>
<source file="django/tests/m2m_signals/models.py.pyindent" startline="15" endline="25" pcid="18315">
    name = models.CharField(max_length=20)
    default_parts = models.ManyToManyField(Part)
    optional_parts = models.ManyToManyField(Part, related_name='cars_optional')

    class Meta:
        ordering = ('name',)

    def __str__(self):
        return self.name


</source>
<source file="django/tests/schema/models.py.pyindent" startline="185" endline="193" pcid="22892">
    when = models.CharField(max_length=1, primary_key=True)

    class Meta:
        db_table = 'drop'

    def __str__(self):
        return self.when


</source>
<source file="django/tests/queries/models.py.pyindent" startline="83" endline="93" pcid="22313">
    name = models.CharField(max_length=10)
    num = models.IntegerField(unique=True)
    extra = models.ForeignKey(ExtraInfo, models.CASCADE)

    class Meta:
        ordering = ['name']

    def __str__(self):
        return self.name


</source>
<source file="django/tests/gis_tests/rasterapp/models.py.pyindent" startline="5" endline="15" pcid="16949">
    rast = models.RasterField('A Verbose Raster Name', null=True, srid=4326, spatial_index=True, blank=True)
    rastprojected = models.RasterField('A Projected Raster Table', srid=3086, null=True)
    geom = models.PointField(null=True)

    class Meta:
        required_db_features = ['supports_raster']

    def __str__(self):
        return str(self.id)


</source>
<source file="django/tests/queries/models.py.pyindent" startline="603" endline="612" pcid="22434">
    order = models.ForeignKey(Order, models.CASCADE, related_name='items')
    status = models.IntegerField()

    class Meta:
        ordering = ('pk',)

    def __str__(self):
        return '%s' % self.pk


</source>
</class>

<class classid="167" nclones="2" nlines="10" similarity="80">
<source file="django/tests/dates/models.py.pyindent" startline="17" endline="25" pcid="12246">
    article = models.ForeignKey(Article, models.CASCADE, related_name="comments")
    text = models.TextField()
    pub_date = models.DateField()
    approval_date = models.DateField(null=True)

    def __str__(self):
        return 'Comment to %s (%s)' % (self.article.title, self.pub_date)


</source>
<source file="django/tests/datetimes/models.py.pyindent" startline="16" endline="24" pcid="12265">
    article = models.ForeignKey(Article, models.CASCADE, related_name="comments")
    text = models.TextField()
    pub_date = models.DateTimeField()
    approval_date = models.DateTimeField(null=True)

    def __str__(self):
        return 'Comment to %s (%s)' % (self.article.title, self.pub_date)


</source>
</class>

<class classid="168" nclones="2" nlines="13" similarity="76">
<source file="django/tests/dbshell/test_mysql.py.pyindent" startline="12" endline="23" pcid="12283">
        self.assertEqual(
            ['mysql', '--user=someuser', '--password=somepassword',
             '--host=somehost', '--port=444', 'somedbname'],
            self.get_command_line_arguments({
                'NAME': 'somedbname',
                'USER': 'someuser',
                'PASSWORD': 'somepassword',
                'HOST': 'somehost',
                'PORT': 444,
                'OPTIONS': {},
            }))

</source>
<source file="django/tests/dbshell/test_mysql.py.pyindent" startline="47" endline="58" pcid="12285">
        self.assertEqual(
            ['mysql', '--user=someuser', '--password=somepassword',
             '--socket=/path/to/mysql.socket.file', 'somedbname'],
            self.get_command_line_arguments({
                'NAME': 'somedbname',
                'USER': 'someuser',
                'PASSWORD': 'somepassword',
                'HOST': '/path/to/mysql.socket.file',
                'PORT': None,
                'OPTIONS': {},
            }))

</source>
</class>

<class classid="169" nclones="2" nlines="13" similarity="84">
<source file="django/tests/dbshell/test_postgresql_psycopg2.py.pyindent" startline="33" endline="45" pcid="12295">
        self.assertEqual(
            self._run_it({
                'database': 'dbname',
                'user': 'someuser',
                'password': 'somepassword',
                'host': 'somehost',
                'port': '444',
            }), (
                ['psql', '-U', 'someuser', '-h', 'somehost', '-p', '444', 'dbname'],
                'somehost:444:dbname:someuser:somepassword',
            )
        )

</source>
<source file="django/tests/dbshell/test_postgresql_psycopg2.py.pyindent" startline="47" endline="58" pcid="12296">
        self.assertEqual(
            self._run_it({
                'database': 'dbname',
                'user': 'someuser',
                'host': 'somehost',
                'port': '444',
            }), (
                ['psql', '-U', 'someuser', '-h', 'somehost', '-p', '444', 'dbname'],
                None,
            )
        )

</source>
</class>

<class classid="170" nclones="2" nlines="92" similarity="70">
<source file="django/tests/db_functions/comparison/test_greatest.py.pyindent" startline="15" endline="91" pcid="12323">

    def test_basic(self):
        now = timezone.now()
        before = now - timedelta(hours=1)
        Article.objects.create(title='Testing with Django', written=before, published=now)
        articles = Article.objects.annotate(last_updated=Greatest('written', 'published'))
        self.assertEqual(articles.first().last_updated, now)

    @skipUnlessDBFeature('greatest_least_ignores_nulls')
    def test_ignores_null(self):
        now = timezone.now()
        Article.objects.create(title='Testing with Django', written=now)
        articles = Article.objects.annotate(last_updated=Greatest('written', 'published'))
        self.assertEqual(articles.first().last_updated, now)

    @skipIfDBFeature('greatest_least_ignores_nulls')
    def test_propagates_null(self):
        Article.objects.create(title='Testing with Django', written=timezone.now())
        articles = Article.objects.annotate(last_updated=Greatest('written', 'published'))
        self.assertIsNone(articles.first().last_updated)

    @skipIf(connection.vendor == 'mysql', "This doesn't work on MySQL")
    def test_coalesce_workaround(self):
        past = datetime(1900, 1, 1)
        now = timezone.now()
        Article.objects.create(title='Testing with Django', written=now)
        articles = Article.objects.annotate(
            last_updated=Greatest(
                Coalesce('written', past),
                Coalesce('published', past),
            ),
        )
        self.assertEqual(articles.first().last_updated, now)

    @skipUnless(connection.vendor == 'mysql', "MySQL-specific workaround")
    def test_coalesce_workaround_mysql(self):
        past = datetime(1900, 1, 1)
        now = timezone.now()
        Article.objects.create(title='Testing with Django', written=now)
        past_sql = RawSQL("cast(%s as datetime)", (past,))
        articles = Article.objects.annotate(
            last_updated=Greatest(
                Coalesce('written', past_sql),
                Coalesce('published', past_sql),
            ),
        )
        self.assertEqual(articles.first().last_updated, now)

    def test_all_null(self):
        Article.objects.create(title='Testing with Django', written=timezone.now())
        articles = Article.objects.annotate(last_updated=Greatest('published', 'updated'))
        self.assertIsNone(articles.first().last_updated)

    def test_one_expressions(self):
        with self.assertRaisesMessage(ValueError, 'Greatest must take at least two expressions'):
            Greatest('written')

    def test_related_field(self):
        author = Author.objects.create(name='John Smith', age=45)
        Fan.objects.create(name='Margaret', age=50, author=author)
        authors = Author.objects.annotate(highest_age=Greatest('age', 'fans__age'))
        self.assertEqual(authors.first().highest_age, 50)

    def test_update(self):
        author = Author.objects.create(name='James Smith', goes_by='Jim')
        Author.objects.update(alias=Greatest('name', 'goes_by'))
        author.refresh_from_db()
        self.assertEqual(author.alias, 'Jim')

    def test_decimal_filter(self):
        obj = DecimalModel.objects.create(n1=Decimal('1.1'), n2=Decimal('1.2'))
        self.assertCountEqual(
            DecimalModel.objects.annotate(
                greatest=Greatest('n1', 'n2'),
            ).filter(greatest=Decimal('1.2')),
            [obj],
        )
</source>
<source file="django/tests/db_functions/comparison/test_least.py.pyindent" startline="15" endline="93" pcid="12335">

    def test_basic(self):
        now = timezone.now()
        before = now - timedelta(hours=1)
        Article.objects.create(title='Testing with Django', written=before, published=now)
        articles = Article.objects.annotate(first_updated=Least('written', 'published'))
        self.assertEqual(articles.first().first_updated, before)

    @skipUnlessDBFeature('greatest_least_ignores_nulls')
    def test_ignores_null(self):
        now = timezone.now()
        Article.objects.create(title='Testing with Django', written=now)
        articles = Article.objects.annotate(
            first_updated=Least('written', 'published'),
        )
        self.assertEqual(articles.first().first_updated, now)

    @skipIfDBFeature('greatest_least_ignores_nulls')
    def test_propagates_null(self):
        Article.objects.create(title='Testing with Django', written=timezone.now())
        articles = Article.objects.annotate(first_updated=Least('written', 'published'))
        self.assertIsNone(articles.first().first_updated)

    @skipIf(connection.vendor == 'mysql', "This doesn't work on MySQL")
    def test_coalesce_workaround(self):
        future = datetime(2100, 1, 1)
        now = timezone.now()
        Article.objects.create(title='Testing with Django', written=now)
        articles = Article.objects.annotate(
            last_updated=Least(
                Coalesce('written', future),
                Coalesce('published', future),
            ),
        )
        self.assertEqual(articles.first().last_updated, now)

    @skipUnless(connection.vendor == 'mysql', "MySQL-specific workaround")
    def test_coalesce_workaround_mysql(self):
        future = datetime(2100, 1, 1)
        now = timezone.now()
        Article.objects.create(title='Testing with Django', written=now)
        future_sql = RawSQL("cast(%s as datetime)", (future,))
        articles = Article.objects.annotate(
            last_updated=Least(
                Coalesce('written', future_sql),
                Coalesce('published', future_sql),
            ),
        )
        self.assertEqual(articles.first().last_updated, now)

    def test_all_null(self):
        Article.objects.create(title='Testing with Django', written=timezone.now())
        articles = Article.objects.annotate(first_updated=Least('published', 'updated'))
        self.assertIsNone(articles.first().first_updated)

    def test_one_expressions(self):
        with self.assertRaisesMessage(ValueError, 'Least must take at least two expressions'):
            Least('written')

    def test_related_field(self):
        author = Author.objects.create(name='John Smith', age=45)
        Fan.objects.create(name='Margaret', age=50, author=author)
        authors = Author.objects.annotate(lowest_age=Least('age', 'fans__age'))
        self.assertEqual(authors.first().lowest_age, 45)

    def test_update(self):
        author = Author.objects.create(name='James Smith', goes_by='Jim')
        Author.objects.update(alias=Least('name', 'goes_by'))
        author.refresh_from_db()
        self.assertEqual(author.alias, 'James Smith')

    def test_decimal_filter(self):
        obj = DecimalModel.objects.create(n1=Decimal('1.1'), n2=Decimal('1.2'))
        self.assertCountEqual(
            DecimalModel.objects.annotate(
                least=Least('n1', 'n2'),
            ).filter(least=Decimal('1.1')),
            [obj],
        )
</source>
</class>

<class classid="171" nclones="2" nlines="13" similarity="76">
<source file="django/tests/db_functions/comparison/test_greatest.py.pyindent" startline="38" endline="48" pcid="12327">
        past = datetime(1900, 1, 1)
        now = timezone.now()
        Article.objects.create(title='Testing with Django', written=now)
        articles = Article.objects.annotate(
            last_updated=Greatest(
                Coalesce('written', past),
                Coalesce('published', past),
            ),
        )
        self.assertEqual(articles.first().last_updated, now)

</source>
<source file="django/tests/db_functions/comparison/test_greatest.py.pyindent" startline="51" endline="62" pcid="12328">
        past = datetime(1900, 1, 1)
        now = timezone.now()
        Article.objects.create(title='Testing with Django', written=now)
        past_sql = RawSQL("cast(%s as datetime)", (past,))
        articles = Article.objects.annotate(
            last_updated=Greatest(
                Coalesce('written', past_sql),
                Coalesce('published', past_sql),
            ),
        )
        self.assertEqual(articles.first().last_updated, now)

</source>
</class>

<class classid="172" nclones="2" nlines="13" similarity="76">
<source file="django/tests/db_functions/comparison/test_least.py.pyindent" startline="40" endline="50" pcid="12339">
        future = datetime(2100, 1, 1)
        now = timezone.now()
        Article.objects.create(title='Testing with Django', written=now)
        articles = Article.objects.annotate(
            last_updated=Least(
                Coalesce('written', future),
                Coalesce('published', future),
            ),
        )
        self.assertEqual(articles.first().last_updated, now)

</source>
<source file="django/tests/db_functions/comparison/test_least.py.pyindent" startline="53" endline="64" pcid="12340">
        future = datetime(2100, 1, 1)
        now = timezone.now()
        Article.objects.create(title='Testing with Django', written=now)
        future_sql = RawSQL("cast(%s as datetime)", (future,))
        articles = Article.objects.annotate(
            last_updated=Least(
                Coalesce('written', future_sql),
                Coalesce('published', future_sql),
            ),
        )
        self.assertEqual(articles.first().last_updated, now)

</source>
</class>

<class classid="173" nclones="2" nlines="17" similarity="76">
<source file="django/tests/db_functions/datetime/test_extract_trunc.py.pyindent" startline="110" endline="124" pcid="12367">
        start_datetime = datetime(2015, 6, 15, 14, 10)
        end_datetime = datetime(2016, 6, 15, 14, 10)
        if settings.USE_TZ:
            start_datetime = timezone.make_aware(start_datetime, is_dst=False)
            end_datetime = timezone.make_aware(end_datetime, is_dst=False)
        self.create_model(start_datetime, end_datetime)
        self.create_model(end_datetime, start_datetime)

        qs = DTModel.objects.filter(start_datetime__year__gt=2015)
        self.assertEqual(qs.count(), 1)
        self.assertEqual(str(qs.query).lower().count('extract'), 0)
        qs = DTModel.objects.filter(start_datetime__year__gte=2015)
        self.assertEqual(qs.count(), 2)
        self.assertEqual(str(qs.query).lower().count('extract'), 0)

</source>
<source file="django/tests/db_functions/datetime/test_extract_trunc.py.pyindent" startline="126" endline="140" pcid="12369">
        start_datetime = datetime(2015, 6, 15, 14, 10)
        end_datetime = datetime(2016, 6, 15, 14, 10)
        if settings.USE_TZ:
            start_datetime = timezone.make_aware(start_datetime, is_dst=False)
            end_datetime = timezone.make_aware(end_datetime, is_dst=False)
        self.create_model(start_datetime, end_datetime)
        self.create_model(end_datetime, start_datetime)

        qs = DTModel.objects.filter(start_datetime__year__lt=2016)
        self.assertEqual(qs.count(), 1)
        self.assertEqual(str(qs.query).count('extract'), 0)
        qs = DTModel.objects.filter(start_datetime__year__lte=2016)
        self.assertEqual(qs.count(), 2)
        self.assertEqual(str(qs.query).count('extract'), 0)

</source>
</class>

<class classid="174" nclones="8" nlines="20" similarity="70">
<source file="django/tests/db_functions/datetime/test_extract_trunc.py.pyindent" startline="245" endline="263" pcid="12380">
        start_datetime = datetime(2015, 6, 15, 14, 30, 50, 321)
        end_datetime = datetime(2016, 6, 15, 14, 10, 50, 123)
        if settings.USE_TZ:
            start_datetime = timezone.make_aware(start_datetime, is_dst=False)
            end_datetime = timezone.make_aware(end_datetime, is_dst=False)
        self.create_model(start_datetime, end_datetime)
        self.create_model(end_datetime, start_datetime)
        self.assertQuerysetEqual(
            DTModel.objects.annotate(extracted=ExtractYear('start_datetime')).order_by('start_datetime'),
            [(start_datetime, start_datetime.year), (end_datetime, end_datetime.year)],
            lambda m: (m.start_datetime, m.extracted)
        )
        self.assertQuerysetEqual(
            DTModel.objects.annotate(extracted=ExtractYear('start_date')).order_by('start_datetime'),
            [(start_datetime, start_datetime.year), (end_datetime, end_datetime.year)],
            lambda m: (m.start_datetime, m.extracted)
        )
        self.assertEqual(DTModel.objects.filter(start_datetime__year=ExtractYear('start_datetime')).count(), 2)

</source>
<source file="django/tests/db_functions/datetime/test_extract_trunc.py.pyindent" startline="419" endline="437" pcid="12398">
        start_datetime = datetime(2015, 6, 15, 14, 30, 50, 321)
        end_datetime = datetime(2016, 6, 15, 14, 10, 50, 123)
        if settings.USE_TZ:
            start_datetime = timezone.make_aware(start_datetime, is_dst=False)
            end_datetime = timezone.make_aware(end_datetime, is_dst=False)
        self.create_model(start_datetime, end_datetime)
        self.create_model(end_datetime, start_datetime)
        self.assertQuerysetEqual(
            DTModel.objects.annotate(extracted=ExtractHour('start_datetime')).order_by('start_datetime'),
            [(start_datetime, start_datetime.hour), (end_datetime, end_datetime.hour)],
            lambda m: (m.start_datetime, m.extracted)
        )
        self.assertQuerysetEqual(
            DTModel.objects.annotate(extracted=ExtractHour('start_time')).order_by('start_datetime'),
            [(start_datetime, start_datetime.hour), (end_datetime, end_datetime.hour)],
            lambda m: (m.start_datetime, m.extracted)
        )
        self.assertEqual(DTModel.objects.filter(start_datetime__hour=ExtractHour('start_datetime')).count(), 2)

</source>
<source file="django/tests/db_functions/datetime/test_extract_trunc.py.pyindent" startline="305" endline="324" pcid="12386">
        start_datetime = datetime(2015, 6, 15, 14, 30, 50, 321)
        end_datetime = datetime(2016, 6, 15, 14, 10, 50, 123)
        if settings.USE_TZ:
            start_datetime = timezone.make_aware(start_datetime, is_dst=False)
            end_datetime = timezone.make_aware(end_datetime, is_dst=False)
        self.create_model(start_datetime, end_datetime)
        self.create_model(end_datetime, start_datetime)
        self.assertQuerysetEqual(
            DTModel.objects.annotate(extracted=ExtractWeek('start_datetime')).order_by('start_datetime'),
            [(start_datetime, 25), (end_datetime, 24)],
            lambda m: (m.start_datetime, m.extracted)
        )
        self.assertQuerysetEqual(
            DTModel.objects.annotate(extracted=ExtractWeek('start_date')).order_by('start_datetime'),
            [(start_datetime, 25), (end_datetime, 24)],
            lambda m: (m.start_datetime, m.extracted)
        )
        # both dates are from the same week.
        self.assertEqual(DTModel.objects.filter(start_datetime__week=ExtractWeek('start_datetime')).count(), 2)

</source>
<source file="django/tests/db_functions/datetime/test_extract_trunc.py.pyindent" startline="265" endline="283" pcid="12382">
        start_datetime = datetime(2015, 6, 15, 14, 30, 50, 321)
        end_datetime = datetime(2016, 6, 15, 14, 10, 50, 123)
        if settings.USE_TZ:
            start_datetime = timezone.make_aware(start_datetime, is_dst=False)
            end_datetime = timezone.make_aware(end_datetime, is_dst=False)
        self.create_model(start_datetime, end_datetime)
        self.create_model(end_datetime, start_datetime)
        self.assertQuerysetEqual(
            DTModel.objects.annotate(extracted=ExtractMonth('start_datetime')).order_by('start_datetime'),
            [(start_datetime, start_datetime.month), (end_datetime, end_datetime.month)],
            lambda m: (m.start_datetime, m.extracted)
        )
        self.assertQuerysetEqual(
            DTModel.objects.annotate(extracted=ExtractMonth('start_date')).order_by('start_datetime'),
            [(start_datetime, start_datetime.month), (end_datetime, end_datetime.month)],
            lambda m: (m.start_datetime, m.extracted)
        )
        self.assertEqual(DTModel.objects.filter(start_datetime__month=ExtractMonth('start_datetime')).count(), 2)

</source>
<source file="django/tests/db_functions/datetime/test_extract_trunc.py.pyindent" startline="439" endline="457" pcid="12400">
        start_datetime = datetime(2015, 6, 15, 14, 30, 50, 321)
        end_datetime = datetime(2016, 6, 15, 14, 10, 50, 123)
        if settings.USE_TZ:
            start_datetime = timezone.make_aware(start_datetime, is_dst=False)
            end_datetime = timezone.make_aware(end_datetime, is_dst=False)
        self.create_model(start_datetime, end_datetime)
        self.create_model(end_datetime, start_datetime)
        self.assertQuerysetEqual(
            DTModel.objects.annotate(extracted=ExtractMinute('start_datetime')).order_by('start_datetime'),
            [(start_datetime, start_datetime.minute), (end_datetime, end_datetime.minute)],
            lambda m: (m.start_datetime, m.extracted)
        )
        self.assertQuerysetEqual(
            DTModel.objects.annotate(extracted=ExtractMinute('start_time')).order_by('start_datetime'),
            [(start_datetime, start_datetime.minute), (end_datetime, end_datetime.minute)],
            lambda m: (m.start_datetime, m.extracted)
        )
        self.assertEqual(DTModel.objects.filter(start_datetime__minute=ExtractMinute('start_datetime')).count(), 2)

</source>
<source file="django/tests/db_functions/datetime/test_extract_trunc.py.pyindent" startline="326" endline="344" pcid="12388">
        start_datetime = datetime(2015, 6, 15, 14, 30, 50, 321)
        end_datetime = datetime(2016, 8, 15, 14, 10, 50, 123)
        if settings.USE_TZ:
            start_datetime = timezone.make_aware(start_datetime, is_dst=False)
            end_datetime = timezone.make_aware(end_datetime, is_dst=False)
        self.create_model(start_datetime, end_datetime)
        self.create_model(end_datetime, start_datetime)
        self.assertQuerysetEqual(
            DTModel.objects.annotate(extracted=ExtractQuarter('start_datetime')).order_by('start_datetime'),
            [(start_datetime, 2), (end_datetime, 3)],
            lambda m: (m.start_datetime, m.extracted)
        )
        self.assertQuerysetEqual(
            DTModel.objects.annotate(extracted=ExtractQuarter('start_date')).order_by('start_datetime'),
            [(start_datetime, 2), (end_datetime, 3)],
            lambda m: (m.start_datetime, m.extracted)
        )
        self.assertEqual(DTModel.objects.filter(start_datetime__quarter=ExtractQuarter('start_datetime')).count(), 2)

</source>
<source file="django/tests/db_functions/datetime/test_extract_trunc.py.pyindent" startline="459" endline="477" pcid="12402">
        start_datetime = datetime(2015, 6, 15, 14, 30, 50, 321)
        end_datetime = datetime(2016, 6, 15, 14, 10, 50, 123)
        if settings.USE_TZ:
            start_datetime = timezone.make_aware(start_datetime, is_dst=False)
            end_datetime = timezone.make_aware(end_datetime, is_dst=False)
        self.create_model(start_datetime, end_datetime)
        self.create_model(end_datetime, start_datetime)
        self.assertQuerysetEqual(
            DTModel.objects.annotate(extracted=ExtractSecond('start_datetime')).order_by('start_datetime'),
            [(start_datetime, start_datetime.second), (end_datetime, end_datetime.second)],
            lambda m: (m.start_datetime, m.extracted)
        )
        self.assertQuerysetEqual(
            DTModel.objects.annotate(extracted=ExtractSecond('start_time')).order_by('start_datetime'),
            [(start_datetime, start_datetime.second), (end_datetime, end_datetime.second)],
            lambda m: (m.start_datetime, m.extracted)
        )
        self.assertEqual(DTModel.objects.filter(start_datetime__second=ExtractSecond('start_datetime')).count(), 2)

</source>
<source file="django/tests/db_functions/datetime/test_extract_trunc.py.pyindent" startline="285" endline="303" pcid="12384">
        start_datetime = datetime(2015, 6, 15, 14, 30, 50, 321)
        end_datetime = datetime(2016, 6, 15, 14, 10, 50, 123)
        if settings.USE_TZ:
            start_datetime = timezone.make_aware(start_datetime, is_dst=False)
            end_datetime = timezone.make_aware(end_datetime, is_dst=False)
        self.create_model(start_datetime, end_datetime)
        self.create_model(end_datetime, start_datetime)
        self.assertQuerysetEqual(
            DTModel.objects.annotate(extracted=ExtractDay('start_datetime')).order_by('start_datetime'),
            [(start_datetime, start_datetime.day), (end_datetime, end_datetime.day)],
            lambda m: (m.start_datetime, m.extracted)
        )
        self.assertQuerysetEqual(
            DTModel.objects.annotate(extracted=ExtractDay('start_date')).order_by('start_datetime'),
            [(start_datetime, start_datetime.day), (end_datetime, end_datetime.day)],
            lambda m: (m.start_datetime, m.extracted)
        )
        self.assertEqual(DTModel.objects.filter(start_datetime__day=ExtractDay('start_datetime')).count(), 2)

</source>
</class>

<class classid="175" nclones="2" nlines="34" similarity="70">
<source file="django/tests/db_functions/datetime/test_extract_trunc.py.pyindent" startline="563" endline="593" pcid="12415">
        start_datetime = datetime(2015, 6, 15, 14, 30, 50, 321)
        end_datetime = truncate_to(datetime(2016, 6, 15, 14, 10, 50, 123), 'year')
        if settings.USE_TZ:
            start_datetime = timezone.make_aware(start_datetime, is_dst=False)
            end_datetime = timezone.make_aware(end_datetime, is_dst=False)
        self.create_model(start_datetime, end_datetime)
        self.create_model(end_datetime, start_datetime)
        self.assertQuerysetEqual(
            DTModel.objects.annotate(extracted=TruncYear('start_datetime')).order_by('start_datetime'),
            [
                (start_datetime, truncate_to(start_datetime, 'year')),
                (end_datetime, truncate_to(end_datetime, 'year')),
            ],
            lambda m: (m.start_datetime, m.extracted)
        )
        self.assertQuerysetEqual(
            DTModel.objects.annotate(extracted=TruncYear('start_date')).order_by('start_datetime'),
            [
                (start_datetime, truncate_to(start_datetime.date(), 'year')),
                (end_datetime, truncate_to(end_datetime.date(), 'year')),
            ],
            lambda m: (m.start_datetime, m.extracted)
        )
        self.assertEqual(DTModel.objects.filter(start_datetime=TruncYear('start_datetime')).count(), 1)

        with self.assertRaisesMessage(ValueError, "Cannot truncate TimeField 'start_time' to DateTimeField"):
            list(DTModel.objects.annotate(truncated=TruncYear('start_time')))

        with self.assertRaisesMessage(ValueError, "Cannot truncate TimeField 'start_time' to DateTimeField"):
            list(DTModel.objects.annotate(truncated=TruncYear('start_time', output_field=TimeField())))

</source>
<source file="django/tests/db_functions/datetime/test_extract_trunc.py.pyindent" startline="636" endline="666" pcid="12423">
        start_datetime = datetime(2015, 6, 15, 14, 30, 50, 321)
        end_datetime = truncate_to(datetime(2016, 6, 15, 14, 10, 50, 123), 'month')
        if settings.USE_TZ:
            start_datetime = timezone.make_aware(start_datetime, is_dst=False)
            end_datetime = timezone.make_aware(end_datetime, is_dst=False)
        self.create_model(start_datetime, end_datetime)
        self.create_model(end_datetime, start_datetime)
        self.assertQuerysetEqual(
            DTModel.objects.annotate(extracted=TruncMonth('start_datetime')).order_by('start_datetime'),
            [
                (start_datetime, truncate_to(start_datetime, 'month')),
                (end_datetime, truncate_to(end_datetime, 'month')),
            ],
            lambda m: (m.start_datetime, m.extracted)
        )
        self.assertQuerysetEqual(
            DTModel.objects.annotate(extracted=TruncMonth('start_date')).order_by('start_datetime'),
            [
                (start_datetime, truncate_to(start_datetime.date(), 'month')),
                (end_datetime, truncate_to(end_datetime.date(), 'month')),
            ],
            lambda m: (m.start_datetime, m.extracted)
        )
        self.assertEqual(DTModel.objects.filter(start_datetime=TruncMonth('start_datetime')).count(), 1)

        with self.assertRaisesMessage(ValueError, "Cannot truncate TimeField 'start_time' to DateTimeField"):
            list(DTModel.objects.annotate(truncated=TruncMonth('start_time')))

        with self.assertRaisesMessage(ValueError, "Cannot truncate TimeField 'start_time' to DateTimeField"):
            list(DTModel.objects.annotate(truncated=TruncMonth('start_time', output_field=TimeField())))

</source>
</class>

<class classid="176" nclones="2" nlines="27" similarity="74">
<source file="django/tests/db_functions/datetime/test_extract_trunc.py.pyindent" startline="668" endline="690" pcid="12427">
        start_datetime = datetime(2015, 6, 15, 14, 30, 50, 321)
        end_datetime = truncate_to(datetime(2016, 6, 15, 14, 10, 50, 123), 'week')
        if settings.USE_TZ:
            start_datetime = timezone.make_aware(start_datetime, is_dst=False)
            end_datetime = timezone.make_aware(end_datetime, is_dst=False)
        self.create_model(start_datetime, end_datetime)
        self.create_model(end_datetime, start_datetime)
        self.assertQuerysetEqual(
            DTModel.objects.annotate(extracted=TruncWeek('start_datetime')).order_by('start_datetime'),
            [
                (start_datetime, truncate_to(start_datetime, 'week')),
                (end_datetime, truncate_to(end_datetime, 'week')),
            ],
            lambda m: (m.start_datetime, m.extracted)
        )
        self.assertEqual(DTModel.objects.filter(start_datetime=TruncWeek('start_datetime')).count(), 1)

        with self.assertRaisesMessage(ValueError, "Cannot truncate TimeField 'start_time' to DateTimeField"):
            list(DTModel.objects.annotate(truncated=TruncWeek('start_time')))

        with self.assertRaisesMessage(ValueError, "Cannot truncate TimeField 'start_time' to DateTimeField"):
            list(DTModel.objects.annotate(truncated=TruncWeek('start_time', output_field=TimeField())))

</source>
<source file="django/tests/db_functions/datetime/test_extract_trunc.py.pyindent" startline="740" endline="762" pcid="12439">
        start_datetime = datetime(2015, 6, 15, 14, 30, 50, 321)
        end_datetime = truncate_to(datetime(2016, 6, 15, 14, 10, 50, 123), 'day')
        if settings.USE_TZ:
            start_datetime = timezone.make_aware(start_datetime, is_dst=False)
            end_datetime = timezone.make_aware(end_datetime, is_dst=False)
        self.create_model(start_datetime, end_datetime)
        self.create_model(end_datetime, start_datetime)
        self.assertQuerysetEqual(
            DTModel.objects.annotate(extracted=TruncDay('start_datetime')).order_by('start_datetime'),
            [
                (start_datetime, truncate_to(start_datetime, 'day')),
                (end_datetime, truncate_to(end_datetime, 'day')),
            ],
            lambda m: (m.start_datetime, m.extracted)
        )
        self.assertEqual(DTModel.objects.filter(start_datetime=TruncDay('start_datetime')).count(), 1)

        with self.assertRaisesMessage(ValueError, "Cannot truncate TimeField 'start_time' to DateTimeField"):
            list(DTModel.objects.annotate(truncated=TruncDay('start_time')))

        with self.assertRaisesMessage(ValueError, "Cannot truncate TimeField 'start_time' to DateTimeField"):
            list(DTModel.objects.annotate(truncated=TruncDay('start_time', output_field=TimeField())))

</source>
</class>

<class classid="177" nclones="2" nlines="27" similarity="70">
<source file="django/tests/db_functions/datetime/test_extract_trunc.py.pyindent" startline="692" endline="714" pcid="12431">
        start_datetime = datetime(2015, 6, 15, 14, 30, 50, 321)
        end_datetime = datetime(2016, 6, 15, 14, 10, 50, 123)
        if settings.USE_TZ:
            start_datetime = timezone.make_aware(start_datetime, is_dst=False)
            end_datetime = timezone.make_aware(end_datetime, is_dst=False)
        self.create_model(start_datetime, end_datetime)
        self.create_model(end_datetime, start_datetime)
        self.assertQuerysetEqual(
            DTModel.objects.annotate(extracted=TruncDate('start_datetime')).order_by('start_datetime'),
            [
                (start_datetime, start_datetime.date()),
                (end_datetime, end_datetime.date()),
            ],
            lambda m: (m.start_datetime, m.extracted)
        )
        self.assertEqual(DTModel.objects.filter(start_datetime__date=TruncDate('start_datetime')).count(), 2)

        with self.assertRaisesMessage(ValueError, "Cannot truncate TimeField 'start_time' to DateField"):
            list(DTModel.objects.annotate(truncated=TruncDate('start_time')))

        with self.assertRaisesMessage(ValueError, "Cannot truncate TimeField 'start_time' to DateField"):
            list(DTModel.objects.annotate(truncated=TruncDate('start_time', output_field=TimeField())))

</source>
<source file="django/tests/db_functions/datetime/test_extract_trunc.py.pyindent" startline="716" endline="738" pcid="12435">
        start_datetime = datetime(2015, 6, 15, 14, 30, 50, 321)
        end_datetime = datetime(2016, 6, 15, 14, 10, 50, 123)
        if settings.USE_TZ:
            start_datetime = timezone.make_aware(start_datetime, is_dst=False)
            end_datetime = timezone.make_aware(end_datetime, is_dst=False)
        self.create_model(start_datetime, end_datetime)
        self.create_model(end_datetime, start_datetime)
        self.assertQuerysetEqual(
            DTModel.objects.annotate(extracted=TruncTime('start_datetime')).order_by('start_datetime'),
            [
                (start_datetime, start_datetime.time()),
                (end_datetime, end_datetime.time()),
            ],
            lambda m: (m.start_datetime, m.extracted)
        )
        self.assertEqual(DTModel.objects.filter(start_datetime__time=TruncTime('start_datetime')).count(), 2)

        with self.assertRaisesMessage(ValueError, "Cannot truncate DateField 'start_date' to TimeField"):
            list(DTModel.objects.annotate(truncated=TruncTime('start_date')))

        with self.assertRaisesMessage(ValueError, "Cannot truncate DateField 'start_date' to TimeField"):
            list(DTModel.objects.annotate(truncated=TruncTime('start_date', output_field=DateField())))

</source>
</class>

<class classid="178" nclones="2" nlines="34" similarity="70">
<source file="django/tests/db_functions/datetime/test_extract_trunc.py.pyindent" startline="764" endline="794" pcid="12443">
        start_datetime = datetime(2015, 6, 15, 14, 30, 50, 321)
        end_datetime = truncate_to(datetime(2016, 6, 15, 14, 10, 50, 123), 'hour')
        if settings.USE_TZ:
            start_datetime = timezone.make_aware(start_datetime, is_dst=False)
            end_datetime = timezone.make_aware(end_datetime, is_dst=False)
        self.create_model(start_datetime, end_datetime)
        self.create_model(end_datetime, start_datetime)
        self.assertQuerysetEqual(
            DTModel.objects.annotate(extracted=TruncHour('start_datetime')).order_by('start_datetime'),
            [
                (start_datetime, truncate_to(start_datetime, 'hour')),
                (end_datetime, truncate_to(end_datetime, 'hour')),
            ],
            lambda m: (m.start_datetime, m.extracted)
        )
        self.assertQuerysetEqual(
            DTModel.objects.annotate(extracted=TruncHour('start_time')).order_by('start_datetime'),
            [
                (start_datetime, truncate_to(start_datetime.time(), 'hour')),
                (end_datetime, truncate_to(end_datetime.time(), 'hour')),
            ],
            lambda m: (m.start_datetime, m.extracted)
        )
        self.assertEqual(DTModel.objects.filter(start_datetime=TruncHour('start_datetime')).count(), 1)

        with self.assertRaisesMessage(ValueError, "Cannot truncate DateField 'start_date' to DateTimeField"):
            list(DTModel.objects.annotate(truncated=TruncHour('start_date')))

        with self.assertRaisesMessage(ValueError, "Cannot truncate DateField 'start_date' to DateTimeField"):
            list(DTModel.objects.annotate(truncated=TruncHour('start_date', output_field=DateField())))

</source>
<source file="django/tests/db_functions/datetime/test_extract_trunc.py.pyindent" startline="796" endline="826" pcid="12447">
        start_datetime = datetime(2015, 6, 15, 14, 30, 50, 321)
        end_datetime = truncate_to(datetime(2016, 6, 15, 14, 10, 50, 123), 'minute')
        if settings.USE_TZ:
            start_datetime = timezone.make_aware(start_datetime, is_dst=False)
            end_datetime = timezone.make_aware(end_datetime, is_dst=False)
        self.create_model(start_datetime, end_datetime)
        self.create_model(end_datetime, start_datetime)
        self.assertQuerysetEqual(
            DTModel.objects.annotate(extracted=TruncMinute('start_datetime')).order_by('start_datetime'),
            [
                (start_datetime, truncate_to(start_datetime, 'minute')),
                (end_datetime, truncate_to(end_datetime, 'minute')),
            ],
            lambda m: (m.start_datetime, m.extracted)
        )
        self.assertQuerysetEqual(
            DTModel.objects.annotate(extracted=TruncMinute('start_time')).order_by('start_datetime'),
            [
                (start_datetime, truncate_to(start_datetime.time(), 'minute')),
                (end_datetime, truncate_to(end_datetime.time(), 'minute')),
            ],
            lambda m: (m.start_datetime, m.extracted)
        )
        self.assertEqual(DTModel.objects.filter(start_datetime=TruncMinute('start_datetime')).count(), 1)

        with self.assertRaisesMessage(ValueError, "Cannot truncate DateField 'start_date' to DateTimeField"):
            list(DTModel.objects.annotate(truncated=TruncMinute('start_date')))

        with self.assertRaisesMessage(ValueError, "Cannot truncate DateField 'start_date' to DateTimeField"):
            list(DTModel.objects.annotate(truncated=TruncMinute('start_date', output_field=DateField())))

</source>
</class>

<class classid="179" nclones="5" nlines="14" similarity="71">
<source file="django/tests/db_functions/math/test_asin.py.pyindent" startline="44" endline="51" pcid="12487">
        try:
            DecimalField.register_lookup(ASin)
            DecimalModel.objects.create(n1=Decimal('0.1'), n2=Decimal('0'))
            DecimalModel.objects.create(n1=Decimal('1.0'), n2=Decimal('0'))
            objs = DecimalModel.objects.filter(n1__asin__gt=1)
            self.assertQuerysetEqual(objs, [Decimal('1.0')], lambda a: a.n1)
        finally:
            DecimalField._unregister_lookup(ASin)
</source>
<source file="django/tests/db_functions/math/test_cot.py.pyindent" startline="44" endline="51" pcid="12519">
        try:
            DecimalField.register_lookup(Cot)
            DecimalModel.objects.create(n1=Decimal('12.0'), n2=Decimal('0'))
            DecimalModel.objects.create(n1=Decimal('1.0'), n2=Decimal('0'))
            objs = DecimalModel.objects.filter(n1__cot__gt=0)
            self.assertQuerysetEqual(objs, [Decimal('1.0')], lambda a: a.n1)
        finally:
            DecimalField._unregister_lookup(Cot)
</source>
<source file="django/tests/db_functions/math/test_ln.py.pyindent" startline="44" endline="51" pcid="12547">
        try:
            DecimalField.register_lookup(Ln)
            DecimalModel.objects.create(n1=Decimal('12.0'), n2=Decimal('0'))
            DecimalModel.objects.create(n1=Decimal('1.0'), n2=Decimal('0'))
            objs = DecimalModel.objects.filter(n1__ln__gt=0)
            self.assertQuerysetEqual(objs, [Decimal('12.0')], lambda a: a.n1)
        finally:
            DecimalField._unregister_lookup(Ln)
</source>
<source file="django/tests/db_functions/math/test_tan.py.pyindent" startline="44" endline="51" pcid="12596">
        try:
            DecimalField.register_lookup(Tan)
            DecimalModel.objects.create(n1=Decimal('0.0'), n2=Decimal('0'))
            DecimalModel.objects.create(n1=Decimal('12.0'), n2=Decimal('0'))
            objs = DecimalModel.objects.filter(n1__tan__lt=0)
            self.assertQuerysetEqual(objs, [Decimal('12.0')], lambda a: a.n1)
        finally:
            DecimalField._unregister_lookup(Tan)
</source>
<source file="django/tests/db_functions/math/test_exp.py.pyindent" startline="44" endline="51" pcid="12533">
        try:
            DecimalField.register_lookup(Exp)
            DecimalModel.objects.create(n1=Decimal('12.0'), n2=Decimal('0'))
            DecimalModel.objects.create(n1=Decimal('-1.0'), n2=Decimal('0'))
            objs = DecimalModel.objects.filter(n1__exp__gt=10)
            self.assertQuerysetEqual(objs, [Decimal('12.0')], lambda a: a.n1)
        finally:
            DecimalField._unregister_lookup(Exp)
</source>
</class>

<class classid="180" nclones="2" nlines="14" similarity="71">
<source file="django/tests/db_functions/math/test_atan.py.pyindent" startline="44" endline="51" pcid="12494">
        try:
            DecimalField.register_lookup(ATan)
            DecimalModel.objects.create(n1=Decimal('3.12'), n2=Decimal('0'))
            DecimalModel.objects.create(n1=Decimal('-5'), n2=Decimal('0'))
            objs = DecimalModel.objects.filter(n1__atan__gt=0)
            self.assertQuerysetEqual(objs, [Decimal('3.12')], lambda a: a.n1)
        finally:
            DecimalField._unregister_lookup(ATan)
</source>
<source file="django/tests/db_functions/math/test_ceil.py.pyindent" startline="44" endline="51" pcid="12505">
        try:
            DecimalField.register_lookup(Ceil)
            DecimalModel.objects.create(n1=Decimal('3.12'), n2=Decimal('0'))
            DecimalModel.objects.create(n1=Decimal('1.25'), n2=Decimal('0'))
            objs = DecimalModel.objects.filter(n1__ceil__gt=3)
            self.assertQuerysetEqual(objs, [Decimal('3.12')], lambda a: a.n1)
        finally:
            DecimalField._unregister_lookup(Ceil)
</source>
</class>

<class classid="181" nclones="3" nlines="14" similarity="71">
<source file="django/tests/db_functions/math/test_degrees.py.pyindent" startline="44" endline="51" pcid="12526">
        try:
            DecimalField.register_lookup(Degrees)
            DecimalModel.objects.create(n1=Decimal('5.4'), n2=Decimal('0'))
            DecimalModel.objects.create(n1=Decimal('-30'), n2=Decimal('0'))
            objs = DecimalModel.objects.filter(n1__degrees__gt=0)
            self.assertQuerysetEqual(objs, [Decimal('5.4')], lambda a: a.n1)
        finally:
            DecimalField._unregister_lookup(Degrees)
</source>
<source file="django/tests/db_functions/math/test_floor.py.pyindent" startline="44" endline="51" pcid="12540">
        try:
            DecimalField.register_lookup(Floor)
            DecimalModel.objects.create(n1=Decimal('5.4'), n2=Decimal('0'))
            DecimalModel.objects.create(n1=Decimal('3.4'), n2=Decimal('0'))
            objs = DecimalModel.objects.filter(n1__floor__gt=4)
            self.assertQuerysetEqual(objs, [Decimal('5.4')], lambda a: a.n1)
        finally:
            DecimalField._unregister_lookup(Floor)
</source>
<source file="django/tests/db_functions/math/test_sin.py.pyindent" startline="44" endline="51" pcid="12582">
        try:
            DecimalField.register_lookup(Sin)
            DecimalModel.objects.create(n1=Decimal('5.4'), n2=Decimal('0'))
            DecimalModel.objects.create(n1=Decimal('0.1'), n2=Decimal('0'))
            objs = DecimalModel.objects.filter(n1__sin__lt=0)
            self.assertQuerysetEqual(objs, [Decimal('5.4')], lambda a: a.n1)
        finally:
            DecimalField._unregister_lookup(Sin)
</source>
</class>

<class classid="182" nclones="2" nlines="14" similarity="78">
<source file="django/tests/db_functions/math/test_radians.py.pyindent" startline="44" endline="51" pcid="12568">
        try:
            DecimalField.register_lookup(Radians)
            DecimalModel.objects.create(n1=Decimal('2.0'), n2=Decimal('0'))
            DecimalModel.objects.create(n1=Decimal('-1.0'), n2=Decimal('0'))
            objs = DecimalModel.objects.filter(n1__radians__gt=0)
            self.assertQuerysetEqual(objs, [Decimal('2.0')], lambda a: a.n1)
        finally:
            DecimalField._unregister_lookup(Radians)
</source>
<source file="django/tests/db_functions/math/test_round.py.pyindent" startline="43" endline="50" pcid="12575">
        try:
            DecimalField.register_lookup(Round)
            DecimalModel.objects.create(n1=Decimal('2.0'), n2=Decimal('0'))
            DecimalModel.objects.create(n1=Decimal('-1.0'), n2=Decimal('0'))
            objs = DecimalModel.objects.filter(n1__round__gt=0)
            self.assertQuerysetEqual(objs, [Decimal('2.0')], lambda a: a.n1)
        finally:
            DecimalField._unregister_lookup(Round)
</source>
</class>

<class classid="183" nclones="3" nlines="10" similarity="70">
<source file="django/tests/db_functions/models.py.pyindent" startline="8" endline="16" pcid="12599">
    name = models.CharField(max_length=50)
    alias = models.CharField(max_length=50, null=True, blank=True)
    goes_by = models.CharField(max_length=50, null=True, blank=True)
    age = models.PositiveSmallIntegerField(default=30)

    def __str__(self):
        return self.name


</source>
<source file="django/tests/queries/models.py.pyindent" startline="422" endline="430" pcid="22393">
    name = models.CharField(max_length=50)
    objecta = models.ForeignKey(ObjectA, models.SET_NULL, null=True)
    objectb = models.ForeignKey(ObjectB, models.SET_NULL, null=True)
    childobjecta = models.ForeignKey(ChildObjectA, models.SET_NULL, null=True, related_name='ca_pk')

    def __str__(self):
        return self.name


</source>
<source file="django/tests/db_functions/models.py.pyindent" startline="32" endline="40" pcid="12603">
    name = models.CharField(max_length=50)
    age = models.PositiveSmallIntegerField(default=30)
    author = models.ForeignKey(Author, models.CASCADE, related_name='fans')
    fan_since = models.DateTimeField(null=True, blank=True)

    def __str__(self):
        return self.name


</source>
</class>

<class classid="184" nclones="2" nlines="23" similarity="91">
<source file="django/tests/db_functions/tests.py.pyindent" startline="33" endline="49" pcid="12612">
        class UpperBilateral(Upper):
            bilateral = True

        try:
            CharField.register_lookup(UpperBilateral)
            Author.objects.create(name='John Smith', alias='smithj')
            Author.objects.create(name='Rhonda')
            authors = Author.objects.filter(name__upper__exact='john smith')
            self.assertQuerysetEqual(
                authors.order_by('name'), [
                    'John Smith',
                ],
                lambda a: a.name
            )
        finally:
            CharField._unregister_lookup(UpperBilateral)

</source>
<source file="django/tests/db_functions/tests.py.pyindent" startline="51" endline="68" pcid="12616">
        class UpperBilateral(Upper):
            bilateral = True

        try:
            CharField.register_lookup(UpperBilateral)
            Author.objects.create(name='John Smith', alias='smithj')
            Author.objects.create(name='Rhonda')
            authors = Author.objects.filter(name__upper__in=['john smith', 'rhonda'])
            self.assertQuerysetEqual(
                authors.order_by('name'), [
                    'John Smith',
                    'Rhonda',
                ],
                lambda a: a.name
            )
        finally:
            CharField._unregister_lookup(UpperBilateral)

</source>
</class>

<class classid="185" nclones="3" nlines="11" similarity="75">
<source file="django/tests/db_functions/tests.py.pyindent" startline="37" endline="46" pcid="12614">
            CharField.register_lookup(UpperBilateral)
            Author.objects.create(name='John Smith', alias='smithj')
            Author.objects.create(name='Rhonda')
            authors = Author.objects.filter(name__upper__exact='john smith')
            self.assertQuerysetEqual(
                authors.order_by('name'), [
                    'John Smith',
                ],
                lambda a: a.name
            )
</source>
<source file="django/tests/db_functions/text/test_upper.py.pyindent" startline="32" endline="41" pcid="12711">
            CharField.register_lookup(Upper)
            Author.objects.create(name='John Smith', alias='smithj')
            Author.objects.create(name='Rhonda')
            authors = Author.objects.filter(name__upper__exact='JOHN SMITH')
            self.assertQuerysetEqual(
                authors.order_by('name'), [
                    'John Smith',
                ],
                lambda a: a.name
            )
</source>
<source file="django/tests/db_functions/tests.py.pyindent" startline="55" endline="65" pcid="12618">
            CharField.register_lookup(UpperBilateral)
            Author.objects.create(name='John Smith', alias='smithj')
            Author.objects.create(name='Rhonda')
            authors = Author.objects.filter(name__upper__in=['john smith', 'rhonda'])
            self.assertQuerysetEqual(
                authors.order_by('name'), [
                    'John Smith',
                    'Rhonda',
                ],
                lambda a: a.name
            )
</source>
</class>

<class classid="186" nclones="2" nlines="27" similarity="74">
<source file="django/tests/db_functions/text/test_left.py.pyindent" startline="9" endline="27" pcid="12636">
    @classmethod
    def setUpTestData(cls):
        Author.objects.create(name='John Smith', alias='smithj')
        Author.objects.create(name='Rhonda')

    def test_basic(self):
        authors = Author.objects.annotate(name_part=Left('name', 5))
        self.assertQuerysetEqual(authors.order_by('name'), ['John ', 'Rhond'], lambda a: a.name_part)
        # If alias is null, set it to the first 2 lower characters of the name.
        Author.objects.filter(alias__isnull=True).update(alias=Lower(Left('name', 2)))
        self.assertQuerysetEqual(authors.order_by('name'), ['smithj', 'rh'], lambda a: a.alias)

    def test_invalid_length(self):
        with self.assertRaisesMessage(ValueError, "'length' must be greater than 0"):
            Author.objects.annotate(raises=Left('name', 0))

    def test_expressions(self):
        authors = Author.objects.annotate(name_part=Left('name', Value(3), output_field=CharField()))
        self.assertQuerysetEqual(authors.order_by('name'), ['Joh', 'Rho'], lambda a: a.name_part)
</source>
<source file="django/tests/db_functions/text/test_right.py.pyindent" startline="9" endline="27" pcid="12683">
    @classmethod
    def setUpTestData(cls):
        Author.objects.create(name='John Smith', alias='smithj')
        Author.objects.create(name='Rhonda')

    def test_basic(self):
        authors = Author.objects.annotate(name_part=Right('name', 5))
        self.assertQuerysetEqual(authors.order_by('name'), ['Smith', 'honda'], lambda a: a.name_part)
        # If alias is null, set it to the first 2 lower characters of the name.
        Author.objects.filter(alias__isnull=True).update(alias=Lower(Right('name', 2)))
        self.assertQuerysetEqual(authors.order_by('name'), ['smithj', 'da'], lambda a: a.alias)

    def test_invalid_length(self):
        with self.assertRaisesMessage(ValueError, "'length' must be greater than 0"):
            Author.objects.annotate(raises=Right('name', 0))

    def test_expressions(self):
        authors = Author.objects.annotate(name_part=Right('name', Value(3), output_field=CharField()))
        self.assertQuerysetEqual(authors.order_by('name'), ['ith', 'nda'], lambda a: a.name_part)
</source>
</class>

<class classid="187" nclones="2" nlines="16" similarity="81">
<source file="django/tests/db_functions/text/test_length.py.pyindent" startline="38" endline="48" pcid="12645">
        try:
            CharField.register_lookup(Length)
            Author.objects.create(name='John Smith', alias='smithj')
            Author.objects.create(name='Rhonda')
            authors = Author.objects.filter(name__length__gt=7)
            self.assertQuerysetEqual(
                authors.order_by('name'), ['John Smith'],
                lambda a: a.name
            )
        finally:
            CharField._unregister_lookup(Length)
</source>
<source file="django/tests/db_functions/text/test_lower.py.pyindent" startline="32" endline="42" pcid="12652">
        try:
            CharField.register_lookup(Lower)
            Author.objects.create(name='John Smith', alias='smithj')
            Author.objects.create(name='Rhonda')
            authors = Author.objects.filter(name__lower__exact='john smith')
            self.assertQuerysetEqual(
                authors.order_by('name'), ['John Smith'],
                lambda a: a.name
            )
        finally:
            CharField._unregister_lookup(Lower)
</source>
</class>

<class classid="188" nclones="2" nlines="16" similarity="87">
<source file="django/tests/delete/tests.py.pyindent" startline="264" endline="286" pcid="12919">
        u = User.objects.create(
            avatar=Avatar.objects.create()
        )
        a = Avatar.objects.get(pk=u.avatar_id)
        # 1 query to find the users for the avatar.
        # 1 query to delete the user
        # 1 query to delete the avatar
        # The important thing is that when we can defer constraint checks there
        # is no need to do an UPDATE on User.avatar to null it out.

        # Attach a signal to make sure we will not do fast_deletes.
        calls = []

        def noop(*args, **kwargs):
            calls.append('')
        models.signals.post_delete.connect(noop, sender=User)

        self.assertNumQueries(3, a.delete)
        self.assertFalse(User.objects.exists())
        self.assertFalse(Avatar.objects.exists())
        self.assertEqual(len(calls), 1)
        models.signals.post_delete.disconnect(noop, sender=User)

</source>
<source file="django/tests/delete/tests.py.pyindent" startline="289" endline="312" pcid="12921">
        u = User.objects.create(
            avatar=Avatar.objects.create()
        )
        # Attach a signal to make sure we will not do fast_deletes.
        calls = []

        def noop(*args, **kwargs):
            calls.append('')
        models.signals.post_delete.connect(noop, sender=User)

        a = Avatar.objects.get(pk=u.avatar_id)
        # The below doesn't make sense... Why do we need to null out
        # user.avatar if we are going to delete the user immediately after it,
        # and there are no more cascades.
        # 1 query to find the users for the avatar.
        # 1 query to delete the user
        # 1 query to null out user.avatar, because we can't defer the constraint
        # 1 query to delete the avatar
        self.assertNumQueries(4, a.delete)
        self.assertFalse(User.objects.exists())
        self.assertFalse(Avatar.objects.exists())
        self.assertEqual(len(calls), 1)
        models.signals.post_delete.disconnect(noop, sender=User)

</source>
</class>

<class classid="189" nclones="2" nlines="11" similarity="72">
<source file="django/tests/delete_regress/tests.py.pyindent" startline="244" endline="250" pcid="13001">
        msg = 'Cannot call delete() after .values() or .values_list()'
        with self.assertRaisesMessage(TypeError, msg):
            Image.objects.values().delete()
        with self.assertRaisesMessage(TypeError, msg):
            Image.objects.values_list().delete()


</source>
<source file="django/tests/expressions_case/tests.py.pyindent" startline="1330" endline="1335" pcid="13218">
        msg = '__init__() takes either a Q object or lookups as keyword arguments'
        with self.assertRaisesMessage(TypeError, msg):
            When(condition=object())
        with self.assertRaisesMessage(TypeError, msg):
            When()

</source>
</class>

<class classid="190" nclones="2" nlines="11" similarity="72">
<source file="django/tests/delete_regress/tests.py.pyindent" startline="269" endline="279" pcid="13006">
        with self.assertNumQueries(1):
            Login.objects.order_by('description').filter(
                orgunit__name__isnull=False
            ).annotate(
                n=models.Count('description')
            ).filter(
                n=1, pk=self.l1.pk
            ).delete()
        self.assertFalse(Login.objects.filter(pk=self.l1.pk).exists())
        self.assertTrue(Login.objects.filter(pk=self.l2.pk).exists())

</source>
<source file="django/tests/delete_regress/tests.py.pyindent" startline="282" endline="292" pcid="13008">
        with self.assertNumQueries(1):
            Login.objects.order_by('description').filter(
                orgunit__name__isnull=False
            ).extra(
                select={'extraf': '1'}
            ).filter(
                pk=self.l1.pk
            ).delete()
        self.assertFalse(Login.objects.filter(pk=self.l1.pk).exists())
        self.assertTrue(Login.objects.filter(pk=self.l2.pk).exists())

</source>
</class>

<class classid="191" nclones="2" nlines="11" similarity="90">
<source file="django/tests/delete_regress/tests.py.pyindent" startline="309" endline="319" pcid="13012">
        with self.assertNumQueries(1):
            Login.objects.filter(
                pk=self.l1.pk
            ).filter(
                orgunit__name__isnull=False
            ).order_by(
                'description'
            ).select_related('orgunit').delete()
        self.assertFalse(Login.objects.filter(pk=self.l1.pk).exists())
        self.assertTrue(Login.objects.filter(pk=self.l2.pk).exists())

</source>
<source file="django/tests/delete_regress/tests.py.pyindent" startline="322" endline="333" pcid="13014">
        with self.assertNumQueries(1):
            Login.objects.filter(
                pk=self.l1.pk
            ).filter(
                orgunit__name__isnull=False
            ).order_by(
                'description'
            ).only('id').delete()
        self.assertFalse(Login.objects.filter(pk=self.l1.pk).exists())
        self.assertTrue(Login.objects.filter(pk=self.l2.pk).exists())


</source>
</class>

<class classid="192" nclones="2" nlines="18" similarity="88">
<source file="django/tests/distinct_on_fields/models.py.pyindent" startline="5" endline="20" pcid="13062">
    name = models.CharField(max_length=10)
    parent = models.ForeignKey(
        'self',
        models.SET_NULL,
        blank=True,
        null=True,
        related_name='children',
    )

    class Meta:
        ordering = ['name']

    def __str__(self):
        return self.name


</source>
<source file="django/tests/queries/models.py.pyindent" startline="26" endline="41" pcid="22301">
    name = models.CharField(max_length=10)
    parent = models.ForeignKey(
        'self',
        models.SET_NULL,
        blank=True, null=True,
        related_name='children',
    )
    category = models.ForeignKey(NamedCategory, models.SET_NULL, null=True, default=None)

    class Meta:
        ordering = ['name']

    def __str__(self):
        return self.name


</source>
</class>

<class classid="193" nclones="2" nlines="11" similarity="81">
<source file="django/tests/expressions_case/tests.py.pyindent" startline="64" endline="74" pcid="13129">
        self.assertQuerysetEqual(
            CaseTestModel.objects.annotate(test=Case(
                When(integer=1, then=Value('one')),
                When(integer=2, then=Value('two')),
                default=Value('other'),
                output_field=models.CharField(),
            )).order_by('pk'),
            [(1, 'one'), (2, 'two'), (3, 'other'), (2, 'two'), (3, 'other'), (3, 'other'), (4, 'other')],
            transform=attrgetter('integer', 'test')
        )

</source>
<source file="django/tests/expressions_case/tests.py.pyindent" startline="252" endline="262" pcid="13143">
        self.assertQuerysetEqual(
            CaseTestModel.objects.annotate(test=Case(
                When(integer=1, then=Value('one')),
                When(integer=2, then=Value('two')),
                default=Value('other'),
                output_field=models.CharField(),
            )).exclude(test='other').order_by('pk'),
            [(1, 'one'), (2, 'two'), (2, 'two')],
            transform=attrgetter('integer', 'test')
        )

</source>
</class>

<class classid="194" nclones="3" nlines="14" similarity="71">
<source file="django/tests/expressions_case/tests.py.pyindent" startline="204" endline="217" pcid="13140">
        self.assertQuerysetEqual(
            CaseTestModel.objects.values(*self.non_lob_fields).annotate(
                min=Min('fk_rel__integer'),
                max=Max('fk_rel__integer'),
            ).annotate(
                test=Case(
                    When(integer=2, then='min'),
                    When(integer=3, then='max'),
                ),
            ).order_by('pk'),
            [(1, None, 1, 1), (2, 2, 2, 3), (3, 4, 3, 4), (2, 2, 2, 3), (3, 4, 3, 4), (3, 4, 3, 4), (4, None, 5, 5)],
            transform=itemgetter('integer', 'test', 'min', 'max')
        )

</source>
<source file="django/tests/expressions_case/tests.py.pyindent" startline="499" endline="512" pcid="13162">
        self.assertQuerysetEqual(
            CaseTestModel.objects.values(*self.non_lob_fields).annotate(
                min=Min('fk_rel__integer'),
                max=Max('fk_rel__integer'),
            ).filter(
                integer2=Case(
                    When(integer=2, then='min'),
                    When(integer=3, then='max'),
                ),
            ).order_by('pk'),
            [(3, 4, 3, 4), (2, 2, 2, 3), (3, 4, 3, 4)],
            transform=itemgetter('integer', 'integer2', 'min', 'max')
        )

</source>
<source file="django/tests/expressions_case/tests.py.pyindent" startline="514" endline="527" pcid="13163">
        self.assertQuerysetEqual(
            CaseTestModel.objects.values(*self.non_lob_fields).annotate(
                min=Min('fk_rel__integer'),
                max=Max('fk_rel__integer'),
            ).filter(
                integer=Case(
                    When(integer2=F('min'), then=2),
                    When(integer2=F('max'), then=3),
                ),
            ).order_by('pk'),
            [(3, 4, 3, 4), (2, 2, 2, 3), (3, 4, 3, 4)],
            transform=itemgetter('integer', 'integer2', 'min', 'max')
        )

</source>
</class>

<class classid="195" nclones="3" nlines="11" similarity="72">
<source file="django/tests/expressions_case/tests.py.pyindent" startline="374" endline="384" pcid="13152">
        self.assertQuerysetEqual(
            CaseTestModel.objects.filter(integer2=Case(
                When(integer=2, then=3),
                When(integer=3, then=4),
                default=1,
                output_field=models.IntegerField(),
            )).order_by('pk'),
            [(1, 1), (2, 3), (3, 4), (3, 4)],
            transform=attrgetter('integer', 'integer2')
        )

</source>
<source file="django/tests/expressions_case/tests.py.pyindent" startline="441" endline="451" pcid="13158">
        self.assertQuerysetEqual(
            CaseTestModel.objects.filter(integer2=Case(
                When(o2o_rel__integer=1, then=1),
                When(o2o_rel__integer=2, then=3),
                When(o2o_rel__integer=3, then=4),
                output_field=models.IntegerField(),
            )).order_by('pk'),
            [(1, 1), (2, 3), (3, 4), (3, 4)],
            transform=attrgetter('integer', 'integer2')
        )

</source>
<source file="django/tests/expressions_case/tests.py.pyindent" startline="386" endline="395" pcid="13153">
        self.assertQuerysetEqual(
            CaseTestModel.objects.filter(integer2=Case(
                When(integer=2, then=3),
                When(integer=3, then=4),
                output_field=models.IntegerField(),
            )).order_by('pk'),
            [(2, 3), (3, 4), (3, 4)],
            transform=attrgetter('integer', 'integer2')
        )

</source>
</class>

<class classid="196" nclones="2" nlines="10" similarity="70">
<source file="django/tests/expressions_case/tests.py.pyindent" startline="397" endline="406" pcid="13154">
        self.assertQuerysetEqual(
            CaseTestModel.objects.filter(integer2=Case(
                When(integer=2, then=F('integer') + 1),
                When(integer=3, then=F('integer')),
                default='integer',
            )).order_by('pk'),
            [(1, 1), (2, 3), (3, 3)],
            transform=attrgetter('integer', 'integer2')
        )

</source>
<source file="django/tests/expressions_case/tests.py.pyindent" startline="419" endline="428" pcid="13156">
        self.assertQuerysetEqual(
            CaseTestModel.objects.filter(integer2=Case(
                When(integer=2, then=F('o2o_rel__integer') + 1),
                When(integer=3, then=F('o2o_rel__integer')),
                default='o2o_rel__integer',
            )).order_by('pk'),
            [(1, 1), (2, 3), (3, 3)],
            transform=attrgetter('integer', 'integer2')
        )

</source>
</class>

<class classid="197" nclones="5" nlines="12" similarity="83">
<source file="django/tests/expressions_case/tests.py.pyindent" startline="557" endline="568" pcid="13166">
        CaseTestModel.objects.update(
            integer2=Case(
                When(integer=1, then=1),
                When(integer=2, then=2),
            ),
        )
        self.assertQuerysetEqual(
            CaseTestModel.objects.all().order_by('pk'),
            [(1, 1), (2, 2), (3, None), (2, 2), (3, None), (3, None), (4, None)],
            transform=attrgetter('integer', 'integer2')
        )

</source>
<source file="django/tests/expressions_case/tests.py.pyindent" startline="850" endline="861" pcid="13189">
        CaseTestModel.objects.update(
            positive_small_integer=Case(
                When(integer=1, then=1),
                When(integer=2, then=2),
            ),
        )
        self.assertQuerysetEqual(
            CaseTestModel.objects.all().order_by('pk'),
            [(1, 1), (2, 2), (3, None), (2, 2), (3, None), (3, None), (4, None)],
            transform=attrgetter('integer', 'positive_small_integer')
        )

</source>
<source file="django/tests/expressions_case/tests.py.pyindent" startline="877" endline="888" pcid="13191">
        CaseTestModel.objects.update(
            small_integer=Case(
                When(integer=1, then=1),
                When(integer=2, then=2),
            ),
        )
        self.assertQuerysetEqual(
            CaseTestModel.objects.all().order_by('pk'),
            [(1, 1), (2, 2), (3, None), (2, 2), (3, None), (3, None), (4, None)],
            transform=attrgetter('integer', 'small_integer')
        )

</source>
<source file="django/tests/expressions_case/tests.py.pyindent" startline="619" endline="630" pcid="13173">
        CaseTestModel.objects.update(
            big_integer=Case(
                When(integer=1, then=1),
                When(integer=2, then=2),
            ),
        )
        self.assertQuerysetEqual(
            CaseTestModel.objects.all().order_by('pk'),
            [(1, 1), (2, 2), (3, None), (2, 2), (3, None), (3, None), (4, None)],
            transform=attrgetter('integer', 'big_integer')
        )

</source>
<source file="django/tests/expressions_case/tests.py.pyindent" startline="837" endline="848" pcid="13188">
        CaseTestModel.objects.update(
            positive_integer=Case(
                When(integer=1, then=1),
                When(integer=2, then=2),
            ),
        )
        self.assertQuerysetEqual(
            CaseTestModel.objects.all().order_by('pk'),
            [(1, 1), (2, 2), (3, None), (2, 2), (3, None), (3, None), (4, None)],
            transform=attrgetter('integer', 'positive_integer')
        )

</source>
</class>

<class classid="198" nclones="3" nlines="12" similarity="76">
<source file="django/tests/expressions_case/tests.py.pyindent" startline="742" endline="753" pcid="13181">
        CaseTestModel.objects.update(
            file=Case(
                When(integer=1, then=Value('~/1')),
                When(integer=2, then=Value('~/2')),
            ),
        )
        self.assertQuerysetEqual(
            CaseTestModel.objects.all().order_by('pk'),
            [(1, '~/1'), (2, '~/2'), (3, ''), (2, '~/2'), (3, ''), (3, ''), (4, '')],
            transform=lambda o: (o.integer, str(o.file))
        )

</source>
<source file="django/tests/expressions_case/tests.py.pyindent" startline="783" endline="794" pcid="13184">
        CaseTestModel.objects.update(
            image=Case(
                When(integer=1, then=Value('~/1')),
                When(integer=2, then=Value('~/2')),
            ),
        )
        self.assertQuerysetEqual(
            CaseTestModel.objects.all().order_by('pk'),
            [(1, '~/1'), (2, '~/2'), (3, ''), (2, '~/2'), (3, ''), (3, ''), (4, '')],
            transform=lambda o: (o.integer, str(o.image))
        )

</source>
<source file="django/tests/expressions_case/tests.py.pyindent" startline="755" endline="767" pcid="13182">
        CaseTestModel.objects.update(
            file_path=Case(
                When(integer=1, then=Value('~/1')),
                When(integer=2, then=Value('~/2')),
                default=Value(''),
            ),
        )
        self.assertQuerysetEqual(
            CaseTestModel.objects.all().order_by('pk'),
            [(1, '~/1'), (2, '~/2'), (3, ''), (2, '~/2'), (3, ''), (3, ''), (4, '')],
            transform=attrgetter('integer', 'file_path')
        )

</source>
</class>

<class classid="199" nclones="2" nlines="12" similarity="83">
<source file="django/tests/expressions_case/tests.py.pyindent" startline="811" endline="822" pcid="13186">
        CaseTestModel.objects.update(
            null_boolean=Case(
                When(integer=1, then=True),
                When(integer=2, then=False),
            ),
        )
        self.assertQuerysetEqual(
            CaseTestModel.objects.all().order_by('pk'),
            [(1, True), (2, False), (3, None), (2, False), (3, None), (3, None), (4, None)],
            transform=attrgetter('integer', 'null_boolean')
        )

</source>
<source file="django/tests/expressions_case/tests.py.pyindent" startline="824" endline="835" pcid="13187">
        CaseTestModel.objects.update(
            null_boolean_old=Case(
                When(integer=1, then=True),
                When(integer=2, then=False),
            ),
        )
        self.assertQuerysetEqual(
            CaseTestModel.objects.all().order_by('pk'),
            [(1, True), (2, False), (3, None), (2, False), (3, None), (3, None), (4, None)],
            transform=attrgetter('integer', 'null_boolean_old')
        )

</source>
</class>

<class classid="200" nclones="2" nlines="13" similarity="84">
<source file="django/tests/expressions_case/tests.py.pyindent" startline="863" endline="875" pcid="13190">
        CaseTestModel.objects.update(
            slug=Case(
                When(integer=1, then=Value('1')),
                When(integer=2, then=Value('2')),
                default=Value(''),
            ),
        )
        self.assertQuerysetEqual(
            CaseTestModel.objects.all().order_by('pk'),
            [(1, '1'), (2, '2'), (3, ''), (2, '2'), (3, ''), (3, ''), (4, '')],
            transform=attrgetter('integer', 'slug')
        )

</source>
<source file="django/tests/expressions_case/tests.py.pyindent" startline="903" endline="915" pcid="13193">
        CaseTestModel.objects.update(
            text=Case(
                When(integer=1, then=Value('1')),
                When(integer=2, then=Value('2')),
                default=Value(''),
            ),
        )
        self.assertQuerysetEqual(
            CaseTestModel.objects.all().order_by('pk'),
            [(1, '1'), (2, '2'), (3, ''), (2, '2'), (3, ''), (3, ''), (4, '')],
            transform=attrgetter('integer', 'text')
        )

</source>
</class>

<class classid="201" nclones="2" nlines="14" similarity="78">
<source file="django/tests/expressions_case/tests.py.pyindent" startline="1010" endline="1024" pcid="13199">
        self.assertQuerysetEqual(
            CaseTestModel.objects.annotate(
                test=Case(
                    When(integer=2, integer2=3, then=Value('when')),
                    default=Value('default'),
                    output_field=models.CharField(),
                ),
            ).order_by('pk'),
            [
                (1, 1, 'default'), (2, 3, 'when'), (3, 4, 'default'), (2, 2, 'default'), (3, 4, 'default'),
                (3, 3, 'default'), (4, 5, 'default')
            ],
            transform=attrgetter('integer', 'integer2', 'test')
        )

</source>
<source file="django/tests/expressions_case/tests.py.pyindent" startline="1026" endline="1040" pcid="13200">
        self.assertQuerysetEqual(
            CaseTestModel.objects.annotate(
                test=Case(
                    When(Q(integer=2) | Q(integer2=3), then=Value('when')),
                    default=Value('default'),
                    output_field=models.CharField(),
                ),
            ).order_by('pk'),
            [
                (1, 1, 'default'), (2, 3, 'when'), (3, 4, 'default'), (2, 2, 'when'), (3, 4, 'default'),
                (3, 3, 'when'), (4, 5, 'default')
            ],
            transform=attrgetter('integer', 'integer2', 'test')
        )

</source>
</class>

<class classid="202" nclones="2" nlines="11" similarity="90">
<source file="django/tests/expressions_case/tests.py.pyindent" startline="1042" endline="1052" pcid="13201">
        self.assertQuerysetEqual(
            CaseTestModel.objects.filter(integer__lte=2).annotate(test=Case(
                When(integer=1, then=2),
                When(integer=2, then=1),
                default=3,
                output_field=models.IntegerField(),
            )).order_by('test', 'pk'),
            [(2, 1), (2, 1), (1, 2)],
            transform=attrgetter('integer', 'test')
        )

</source>
<source file="django/tests/expressions_case/tests.py.pyindent" startline="1054" endline="1064" pcid="13202">
        self.assertQuerysetEqual(
            CaseTestModel.objects.filter(integer__lte=2).annotate(test=Case(
                When(integer=1, then=2),
                When(integer=2, then=1),
                default=3,
                output_field=models.IntegerField(),
            )).order_by(F('test').asc(), 'pk'),
            [(2, 1), (2, 1), (1, 2)],
            transform=attrgetter('integer', 'test')
        )

</source>
</class>

<class classid="203" nclones="2" nlines="20" similarity="95">
<source file="django/tests/expressions_window/tests.py.pyindent" startline="115" endline="139" pcid="13232">
        """
        The row number window function computes the number based on the order
        in which the tuples were inserted. Depending on the backend,

        Oracle requires an ordering-clause in the Window expression.
        """
        qs = Employee.objects.annotate(row_number=Window(
            expression=RowNumber(),
            order_by=F('pk').asc(),
        )).order_by('pk')
        self.assertQuerysetEqual(qs, [
            ('Jones', 'Accounting', 1),
            ('Williams', 'Accounting', 2),
            ('Jenson', 'Accounting', 3),
            ('Adams', 'Accounting', 4),
            ('Smith', 'Sales', 5),
            ('Brown', 'Sales', 6),
            ('Johnson', 'Marketing', 7),
            ('Smith', 'Marketing', 8),
            ('Wilkinson', 'IT', 9),
            ('Moore', 'IT', 10),
            ('Miller', 'Management', 11),
            ('Johnson', 'Management', 12),
        ], lambda entry: (entry.name, entry.department, entry.row_number))

</source>
<source file="django/tests/expressions_window/tests.py.pyindent" startline="142" endline="164" pcid="13233">
        """
        The row number window function computes the number based on the order
        in which the tuples were inserted.
        """
        # Add a default ordering for consistent results across databases.
        qs = Employee.objects.annotate(row_number=Window(
            expression=RowNumber(),
        )).order_by('pk')
        self.assertQuerysetEqual(qs, [
            ('Jones', 'Accounting', 1),
            ('Williams', 'Accounting', 2),
            ('Jenson', 'Accounting', 3),
            ('Adams', 'Accounting', 4),
            ('Smith', 'Sales', 5),
            ('Brown', 'Sales', 6),
            ('Johnson', 'Marketing', 7),
            ('Smith', 'Marketing', 8),
            ('Wilkinson', 'IT', 9),
            ('Moore', 'IT', 10),
            ('Miller', 'Management', 11),
            ('Johnson', 'Management', 12),
        ], lambda entry: (entry.name, entry.department, entry.row_number))

</source>
</class>

<class classid="204" nclones="2" nlines="23" similarity="82">
<source file="django/tests/expressions_window/tests.py.pyindent" startline="256" endline="277" pcid="13238">
        qs = Employee.objects.annotate(lead=Window(
            expression=Lead(expression='salary'),
            order_by=[F('hire_date').asc(), F('name').desc()],
            partition_by='department',
        )).values_list('name', 'salary', 'department', 'hire_date', 'lead')
        qs = fix_ordering_for_mariadb(qs, ('department', F('hire_date').asc(), F('name').desc()))
        self.assertNotIn('GROUP BY', str(qs.query))
        self.assertSequenceEqual(qs, [
            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 45000),
            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 37000),
            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 50000),
            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), None),
            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 34000),
            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), None),
            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 80000),
            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), None),
            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 40000),
            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), None),
            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 53000),
            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), None),
        ])

</source>
<source file="django/tests/expressions_window/tests.py.pyindent" startline="374" endline="401" pcid="13243">
        """
        Determine what the next person hired in the same department makes.
        Because the dataset is ambiguous, the name is also part of the
        ordering clause. No default is provided, so None/NULL should be
        returned.
        """
        qs = Employee.objects.annotate(lead=Window(
            expression=Lead(expression='salary'),
            order_by=[F('hire_date').asc(), F('name').desc()],
            partition_by='department',
        )).order_by('department')
        ('department', F('hire_date').asc(), F('name').desc())
        qs = fix_ordering_for_mariadb(qs, ('department', F('hire_date').asc(), F('name').desc()))
        self.assertQuerysetEqual(qs, [
            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 45000),
            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 37000),
            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 50000),
            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), None),
            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 34000),
            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), None),
            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 80000),
            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), None),
            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 40000),
            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), None),
            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 53000),
            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), None),
        ], transform=lambda row: (row.name, row.salary, row.department, row.hire_date, row.lead))

</source>
</class>

<class classid="205" nclones="8" nlines="11" similarity="72">
<source file="django/tests/expressions_window/tests.py.pyindent" startline="679" endline="686" pcid="13262">
        msg = "start argument must be a negative integer, zero, or None, but got '3'."
        with self.assertRaisesMessage(ValueError, msg):
            list(Employee.objects.annotate(test=Window(
                expression=Sum('salary'),
                order_by=F('hire_date').asc(),
                frame=ValueRange(start=3),
            )))

</source>
<source file="django/tests/expressions_window/tests.py.pyindent" startline="706" endline="712" pcid="13268">
        msg = "start argument must be a negative integer, zero, or None, but got 'a'."
        with self.assertRaisesMessage(ValueError, msg):
            list(Employee.objects.annotate(test=Window(
                expression=Sum('salary'),
                frame=ValueRange(start='a'),
            )))

</source>
<source file="django/tests/expressions_window/tests.py.pyindent" startline="714" endline="720" pcid="13270">
        msg = "end argument must be a positive integer, zero, or None, but got 'a'."
        with self.assertRaisesMessage(ValueError, msg):
            list(Employee.objects.annotate(test=Window(
                expression=Sum('salary'),
                frame=RowRange(end='a'),
            )))

</source>
<source file="django/tests/expressions_window/tests.py.pyindent" startline="733" endline="740" pcid="13274">
        msg = 'PostgreSQL only supports UNBOUNDED together with PRECEDING and FOLLOWING.'
        with self.assertRaisesMessage(NotSupportedError, msg):
            list(Employee.objects.annotate(test=Window(
                expression=Sum('salary'),
                order_by=F('hire_date').asc(),
                frame=ValueRange(end=1),
            )))

</source>
<source file="django/tests/expressions_window/tests.py.pyindent" startline="688" endline="695" pcid="13264">
        msg = "end argument must be a positive integer, zero, or None, but got '-3'."
        with self.assertRaisesMessage(ValueError, msg):
            list(Employee.objects.annotate(test=Window(
                expression=Sum('salary'),
                order_by=F('hire_date').asc(),
                frame=ValueRange(end=-3),
            )))

</source>
<source file="django/tests/expressions_window/tests.py.pyindent" startline="742" endline="750" pcid="13276">
        msg = "start argument must be a negative integer, zero, or None, but got 'a'."
        with self.assertRaisesMessage(ValueError, msg):
            list(Employee.objects.annotate(test=Window(
                expression=Sum('salary'),
                order_by=F('hire_date').asc(),
                frame=RowRange(start='a'),
            )))


</source>
<source file="django/tests/expressions_window/tests.py.pyindent" startline="697" endline="704" pcid="13266">
        msg = "end argument must be a positive integer, zero, or None, but got 'a'."
        with self.assertRaisesMessage(ValueError, msg):
            list(Employee.objects.annotate(test=Window(
                expression=Sum('salary'),
                order_by=F('hire_date').asc(),
                frame=ValueRange(end='a'),
            )))

</source>
<source file="django/tests/expressions_window/tests.py.pyindent" startline="723" endline="730" pcid="13272">
        msg = 'PostgreSQL only supports UNBOUNDED together with PRECEDING and FOLLOWING.'
        with self.assertRaisesMessage(NotSupportedError, msg):
            list(Employee.objects.annotate(test=Window(
                expression=Sum('salary'),
                order_by=F('hire_date').asc(),
                frame=ValueRange(start=-1),
            )))

</source>
</class>

<class classid="206" nclones="2" nlines="11" similarity="72">
<source file="django/tests/field_deconstruction/tests.py.pyindent" startline="265" endline="275" pcid="13325">
        with isolate_lru_cache(apps.get_swappable_settings_name):
            # It doesn't matter that we swapped out user for permission;
            # there's no validation. We just want to check the setting stuff works.
            field = models.ForeignKey("auth.Permission", models.CASCADE)
            name, path, args, kwargs = field.deconstruct()

        self.assertEqual(path, "django.db.models.ForeignKey")
        self.assertEqual(args, [])
        self.assertEqual(kwargs, {"to": "auth.Permission", "on_delete": models.CASCADE})
        self.assertEqual(kwargs['to'].setting_name, "AUTH_USER_MODEL")

</source>
<source file="django/tests/field_deconstruction/tests.py.pyindent" startline="424" endline="434" pcid="13333">
        with isolate_lru_cache(apps.get_swappable_settings_name):
            # It doesn't matter that we swapped out user for permission;
            # there's no validation. We just want to check the setting stuff works.
            field = models.ManyToManyField("auth.Permission")
            name, path, args, kwargs = field.deconstruct()

        self.assertEqual(path, "django.db.models.ManyToManyField")
        self.assertEqual(args, [])
        self.assertEqual(kwargs, {"to": "auth.Permission"})
        self.assertEqual(kwargs['to'].setting_name, "AUTH_USER_MODEL")

</source>
</class>

<class classid="207" nclones="2" nlines="25" similarity="84">
<source file="django/tests/filtered_relation/models.py.pyindent" startline="62" endline="85" pcid="13385">
    NEW = 'new'
    STOPPED = 'stopped'
    STATES = (
        (NEW, 'New'),
        (STOPPED, 'Stopped'),
    )
    borrower = models.ForeignKey(
        Borrower,
        models.CASCADE,
        related_name='reservations',
        related_query_name='reservation',
    )
    book = models.ForeignKey(
        Book,
        models.CASCADE,
        related_name='reservations',
        related_query_name='reservation',
    )
    state = models.CharField(max_length=7, choices=STATES, default=NEW)

    def __str__(self):
        return '-'.join((self.book.name, self.borrower.name, self.state))


</source>
<source file="django/tests/filtered_relation/models.py.pyindent" startline="87" endline="108" pcid="13387">
    NEW = 'new'
    STOPPED = 'stopped'
    STATES = (
        (NEW, 'New'),
        (STOPPED, 'Stopped'),
    )
    borrower = models.ForeignKey(
        Borrower,
        models.CASCADE,
        related_name='rental_sessions',
        related_query_name='rental_session',
    )
    book = models.ForeignKey(
        Book,
        models.CASCADE,
        related_name='rental_sessions',
        related_query_name='rental_session',
    )
    state = models.CharField(max_length=7, choices=STATES, default=NEW)

    def __str__(self):
        return '-'.join((self.book.name, self.borrower.name, self.state))
</source>
</class>

<class classid="208" nclones="2" nlines="16" similarity="76">
<source file="django/tests/filtered_relation/tests.py.pyindent" startline="54" endline="64" pcid="13393">
        qs = Book.objects.annotate(
            author_join=FilteredRelation('author'),
        ).select_related('author_join').order_by('pk')
        with self.assertNumQueries(1):
            self.assertQuerysetEqual(qs, [
                (self.book1, self.author1),
                (self.book2, self.author2),
                (self.book3, self.author2),
                (self.book4, self.author1),
            ], lambda x: (x, x.author_join))

</source>
<source file="django/tests/filtered_relation/tests.py.pyindent" startline="67" endline="78" pcid="13395">
        with transaction.atomic():
            qs = Book.objects.annotate(
                author_join=FilteredRelation('author'),
            ).select_related('author_join').select_for_update(of=('self',)).order_by('pk')
            with self.assertNumQueries(1):
                self.assertQuerysetEqual(qs, [
                    (self.book1, self.author1),
                    (self.book2, self.author2),
                    (self.book3, self.author2),
                    (self.book4, self.author1),
                ], lambda x: (x, x.author_join))

</source>
</class>

<class classid="209" nclones="2" nlines="13" similarity="92">
<source file="django/tests/fixtures/models.py.pyindent" startline="31" endline="40" pcid="13438">
    headline = models.CharField(max_length=100, default='Default headline')
    pub_date = models.DateTimeField()

    def __str__(self):
        return self.headline

    class Meta:
        ordering = ('-pub_date', 'headline')


</source>
<source file="django/tests/fixtures_model_package/models/__init__.py.pyindent" startline="5" endline="13" pcid="13538">
    headline = models.CharField(max_length=100, default='Default headline')
    pub_date = models.DateTimeField()

    def __str__(self):
        return self.headline

    class Meta:
        app_label = 'fixtures_model_package'
        ordering = ('-pub_date', 'headline')
</source>
</class>

<class classid="210" nclones="2" nlines="21" similarity="100">
<source file="django/tests/fixtures/models.py.pyindent" startline="122" endline="136" pcid="13462">
    key = models.CharField(max_length=100)
    other_thing = models.ForeignKey('NaturalKeyThing', on_delete=models.CASCADE, null=True)
    other_things = models.ManyToManyField('NaturalKeyThing', related_name='thing_m2m_set')

    class Manager(models.Manager):
        def get_by_natural_key(self, key):
            return self.get(key=key)

    objects = Manager()

    def natural_key(self):
        return (self.key,)

    def __str__(self):
        return self.key
</source>
<source file="django/tests/serializers/models/natural.py.pyindent" startline="25" endline="39" pcid="23231">
    key = models.CharField(max_length=100)
    other_thing = models.ForeignKey('NaturalKeyThing', on_delete=models.CASCADE, null=True)
    other_things = models.ManyToManyField('NaturalKeyThing', related_name='thing_m2m_set')

    class Manager(models.Manager):
        def get_by_natural_key(self, key):
            return self.get(key=key)

    objects = Manager()

    def natural_key(self):
        return (self.key,)

    def __str__(self):
        return self.key
</source>
</class>

<class classid="211" nclones="2" nlines="17" similarity="94">
<source file="django/tests/fixtures_regress/models.py.pyindent" startline="101" endline="114" pcid="13570">
    objects = TestManager()
    name = models.CharField(max_length=255)
    main = models.ForeignKey('self', models.SET_NULL, null=True)

    class Meta:
        ordering = ('name',)

    def __str__(self):
        return self.name

    def natural_key(self):
        return (self.name,)


</source>
<source file="django/tests/fixtures_regress/models.py.pyindent" startline="116" endline="131" pcid="13574">
    objects = TestManager()
    name = models.CharField(max_length=255)

    class Meta:
        ordering = ('name',)

    def __str__(self):
        return self.name

    # Person doesn't actually have a dependency on store, but we need to define
    # one to test the behavior of the dependency resolution algorithm.
    def natural_key(self):
        return (self.name,)
    natural_key.dependencies = ['fixtures_regress.store']


</source>
</class>

<class classid="212" nclones="9" nlines="10" similarity="72">
<source file="django/tests/fixtures_regress/tests.py.pyindent" startline="64" endline="75" pcid="13628">
        """
        Test for ticket #9279 -- Error is raised for entries in
        the serialized data for fields that have been removed
        from the database when not ignored.
        """
        with self.assertRaises(DeserializationError):
            management.call_command(
                'loaddata',
                'sequence_extra',
                verbosity=0,
            )

</source>
<source file="django/tests/fixtures_regress/tests.py.pyindent" startline="195" endline="204" pcid="13642">
        """
        Failing serializer import raises the proper error
        """
        with self.assertRaisesMessage(ImportError, "No module named 'unexistent'"):
            management.call_command(
                'loaddata',
                'bad_fixture1.unkn',
                verbosity=0,
            )

</source>
<source file="django/tests/fixtures_regress/tests.py.pyindent" startline="444" endline="453" pcid="13663">
        """
        Regression for #7043 - Error is quickly reported when no fixtures is provided in the command line.
        """
        msg = "No database fixture specified. Please provide the path of at least one fixture in the command line."
        with self.assertRaisesMessage(management.CommandError, msg):
            management.call_command(
                'loaddata',
                verbosity=0,
            )

</source>
<source file="django/tests/fixtures_regress/tests.py.pyindent" startline="181" endline="192" pcid="13640">
        """
        Test for ticket #4371 -- Loading data of an unknown format should fail
        Validate that error conditions are caught correctly
        """
        msg = "Problem installing fixture 'bad_fixture1': unkn is not a known serialization format."
        with self.assertRaisesMessage(management.CommandError, msg):
            management.call_command(
                'loaddata',
                'bad_fixture1.unkn',
                verbosity=0,
            )

</source>
<source file="django/tests/fixtures_regress/tests.py.pyindent" startline="416" endline="425" pcid="13660">
        """
        Regression for #3615 - Ensure data with nonexistent child key references raises error
        """
        with self.assertRaisesMessage(IntegrityError, "Problem installing fixture"):
            management.call_command(
                'loaddata',
                'forward_ref_bad_data.json',
                verbosity=0,
            )

</source>
<source file="django/tests/fixtures_regress/tests.py.pyindent" startline="206" endline="218" pcid="13644">
        """
        Test for ticket #4371 -- Loading a fixture file with invalid data
        using explicit filename.
        Test for ticket #18213 -- warning conditions are caught correctly
        """
        msg = "No fixture data found for 'bad_fixture2'. (File format may be invalid.)"
        with self.assertWarnsMessage(RuntimeWarning, msg):
            management.call_command(
                'loaddata',
                'bad_fixture2.xml',
                verbosity=0,
            )

</source>
<source file="django/tests/fixtures_regress/tests.py.pyindent" startline="234" endline="245" pcid="13648">
        """
        Test for ticket #18213 -- Loading a fixture file with no data output a warning.
        Previously empty fixture raises an error exception, see ticket #4371.
        """
        msg = "No fixture data found for 'empty'. (File format may be invalid.)"
        with self.assertWarnsMessage(RuntimeWarning, msg):
            management.call_command(
                'loaddata',
                'empty',
                verbosity=0,
            )

</source>
<source file="django/tests/fixtures_regress/tests.py.pyindent" startline="220" endline="232" pcid="13646">
        """
        Test for ticket #4371 -- Loading a fixture file with invalid data
        without file extension.
        Test for ticket #18213 -- warning conditions are caught correctly
        """
        msg = "No fixture data found for 'bad_fixture2'. (File format may be invalid.)"
        with self.assertWarnsMessage(RuntimeWarning, msg):
            management.call_command(
                'loaddata',
                'bad_fixture2',
                verbosity=0,
            )

</source>
<source file="django/tests/fixtures_regress/tests.py.pyindent" startline="247" endline="259" pcid="13650">
        """
        Regression for #9011 - error message is correct.
        Change from error to warning for ticket #18213.
        """
        msg = "No fixture data found for 'bad_fixture2'. (File format may be invalid.)"
        with self.assertWarnsMessage(RuntimeWarning, msg):
            management.call_command(
                'loaddata',
                'bad_fixture2',
                'animal',
                verbosity=0,
            )

</source>
</class>

<class classid="213" nclones="4" nlines="21" similarity="83">
<source file="django/tests/flatpages_tests/test_csrf.py.pyindent" startline="29" endline="53" pcid="13710">
        # don't use the manager because we want to ensure the site exists
        # with pk=1, regardless of whether or not it already exists.
        cls.site1 = Site(pk=1, domain='example.com', name='example.com')
        cls.site1.save()
        cls.fp1 = FlatPage.objects.create(
            url='/flatpage/', title='A Flatpage', content="Isn't it flat!",
            enable_comments=False, template_name='', registration_required=False
        )
        cls.fp2 = FlatPage.objects.create(
            url='/location/flatpage/', title='A Nested Flatpage', content="Isn't it flat and deep!",
            enable_comments=False, template_name='', registration_required=False
        )
        cls.fp3 = FlatPage.objects.create(
            url='/sekrit/', title='Sekrit Flatpage', content="Isn't it sekrit!",
            enable_comments=False, template_name='', registration_required=True
        )
        cls.fp4 = FlatPage.objects.create(
            url='/location/sekrit/', title='Sekrit Nested Flatpage', content="Isn't it sekrit and deep!",
            enable_comments=False, template_name='', registration_required=True
        )
        cls.fp1.sites.add(cls.site1)
        cls.fp2.sites.add(cls.site1)
        cls.fp3.sites.add(cls.site1)
        cls.fp4.sites.add(cls.site1)

</source>
<source file="django/tests/flatpages_tests/test_views.py.pyindent" startline="11" endline="39" pcid="13777">

    @classmethod
    def setUpTestData(cls):
        # don't use the manager because we want to ensure the site exists
        # with pk=1, regardless of whether or not it already exists.
        cls.site1 = Site(pk=1, domain='example.com', name='example.com')
        cls.site1.save()
        cls.fp1 = FlatPage.objects.create(
            url='/flatpage/', title='A Flatpage', content="Isn't it flat!",
            enable_comments=False, template_name='', registration_required=False
        )
        cls.fp2 = FlatPage.objects.create(
            url='/location/flatpage/', title='A Nested Flatpage', content="Isn't it flat and deep!",
            enable_comments=False, template_name='', registration_required=False
        )
        cls.fp3 = FlatPage.objects.create(
            url='/sekrit/', title='Sekrit Flatpage', content="Isn't it sekrit!",
            enable_comments=False, template_name='', registration_required=True
        )
        cls.fp4 = FlatPage.objects.create(
            url='/location/sekrit/', title='Sekrit Nested Flatpage', content="Isn't it sekrit and deep!",
            enable_comments=False, template_name='', registration_required=True
        )
        cls.fp1.sites.add(cls.site1)
        cls.fp2.sites.add(cls.site1)
        cls.fp3.sites.add(cls.site1)
        cls.fp4.sites.add(cls.site1)


</source>
<source file="django/tests/flatpages_tests/test_middleware.py.pyindent" startline="11" endline="39" pcid="13733">

    @classmethod
    def setUpTestData(cls):
        # don't use the manager because we want to ensure the site exists
        # with pk=1, regardless of whether or not it already exists.
        cls.site1 = Site(pk=1, domain='example.com', name='example.com')
        cls.site1.save()
        cls.fp1 = FlatPage.objects.create(
            url='/flatpage/', title='A Flatpage', content="Isn't it flat!",
            enable_comments=False, template_name='', registration_required=False
        )
        cls.fp2 = FlatPage.objects.create(
            url='/location/flatpage/', title='A Nested Flatpage', content="Isn't it flat and deep!",
            enable_comments=False, template_name='', registration_required=False
        )
        cls.fp3 = FlatPage.objects.create(
            url='/sekrit/', title='Sekrit Flatpage', content="Isn't it sekrit!",
            enable_comments=False, template_name='', registration_required=True
        )
        cls.fp4 = FlatPage.objects.create(
            url='/location/sekrit/', title='Sekrit Nested Flatpage', content="Isn't it sekrit and deep!",
            enable_comments=False, template_name='', registration_required=True
        )
        cls.fp1.sites.add(cls.site1)
        cls.fp2.sites.add(cls.site1)
        cls.fp3.sites.add(cls.site1)
        cls.fp4.sites.add(cls.site1)


</source>
<source file="django/tests/flatpages_tests/test_templatetags.py.pyindent" startline="12" endline="36" pcid="13760">
        # don't use the manager because we want to ensure the site exists
        # with pk=1, regardless of whether or not it already exists.
        cls.site1 = Site(pk=1, domain='example.com', name='example.com')
        cls.site1.save()
        cls.fp1 = FlatPage.objects.create(
            url='/flatpage/', title='A Flatpage', content="Isn't it flat!",
            enable_comments=False, template_name='', registration_required=False
        )
        cls.fp2 = FlatPage.objects.create(
            url='/location/flatpage/', title='A Nested Flatpage', content="Isn't it flat and deep!",
            enable_comments=False, template_name='', registration_required=False
        )
        cls.fp3 = FlatPage.objects.create(
            url='/sekrit/', title='Sekrit Flatpage', content="Isn't it sekrit!",
            enable_comments=False, template_name='', registration_required=True
        )
        cls.fp4 = FlatPage.objects.create(
            url='/location/sekrit/', title='Sekrit Nested Flatpage', content="Isn't it sekrit and deep!",
            enable_comments=False, template_name='', registration_required=True
        )
        cls.fp1.sites.add(cls.site1)
        cls.fp2.sites.add(cls.site1)
        cls.fp3.sites.add(cls.site1)
        cls.fp4.sites.add(cls.site1)

</source>
</class>

<class classid="214" nclones="2" nlines="53" similarity="72">
<source file="django/tests/flatpages_tests/test_middleware.py.pyindent" startline="56" endline="115" pcid="13735">

    def test_view_flatpage(self):
        "A flatpage can be served through a view, even when the middleware is in use"
        response = self.client.get('/flatpage_root/flatpage/')
        self.assertContains(response, "<p>Isn't it flat!</p>")

    def test_view_non_existent_flatpage(self):
        """
        A nonexistent flatpage raises 404 when served through a view, even when
        the middleware is in use.
        """
        response = self.client.get('/flatpage_root/no_such_flatpage/')
        self.assertEqual(response.status_code, 404)

    def test_view_authenticated_flatpage(self):
        "A flatpage served through a view can require authentication"
        response = self.client.get('/flatpage_root/sekrit/')
        self.assertRedirects(response, '/accounts/login/?next=/flatpage_root/sekrit/')
        user = User.objects.create_user('testuser', 'test@example.com', 's3krit')
        self.client.force_login(user)
        response = self.client.get('/flatpage_root/sekrit/')
        self.assertContains(response, "<p>Isn't it sekrit!</p>")

    def test_fallback_flatpage(self):
        "A flatpage can be served by the fallback middleware"
        response = self.client.get('/flatpage/')
        self.assertContains(response, "<p>Isn't it flat!</p>")

    def test_fallback_non_existent_flatpage(self):
        """
        A nonexistent flatpage raises a 404 when served by the fallback
        middleware.
        """
        response = self.client.get('/no_such_flatpage/')
        self.assertEqual(response.status_code, 404)

    def test_fallback_authenticated_flatpage(self):
        "A flatpage served by the middleware can require authentication"
        response = self.client.get('/sekrit/')
        self.assertRedirects(response, '/accounts/login/?next=/sekrit/')
        user = User.objects.create_user('testuser', 'test@example.com', 's3krit')
        self.client.force_login(user)
        response = self.client.get('/sekrit/')
        self.assertContains(response, "<p>Isn't it sekrit!</p>")

    def test_fallback_flatpage_special_chars(self):
        "A flatpage with special chars in the URL can be served by the fallback middleware"
        fp = FlatPage.objects.create(
            url="/some.very_special~chars-here/",
            title="A very special page",
            content="Isn't it special!",
            enable_comments=False,
            registration_required=False,
        )
        fp.sites.add(settings.SITE_ID)

        response = self.client.get('/some.very_special~chars-here/')
        self.assertContains(response, "<p>Isn't it special!</p>")


</source>
<source file="django/tests/flatpages_tests/test_views.py.pyindent" startline="56" endline="103" pcid="13779">

    def test_view_flatpage(self):
        "A flatpage can be served through a view"
        response = self.client.get('/flatpage_root/flatpage/')
        self.assertContains(response, "<p>Isn't it flat!</p>")

    def test_view_non_existent_flatpage(self):
        """A nonexistent flatpage raises 404 when served through a view."""
        response = self.client.get('/flatpage_root/no_such_flatpage/')
        self.assertEqual(response.status_code, 404)

    def test_view_authenticated_flatpage(self):
        "A flatpage served through a view can require authentication"
        response = self.client.get('/flatpage_root/sekrit/')
        self.assertRedirects(response, '/accounts/login/?next=/flatpage_root/sekrit/')
        user = User.objects.create_user('testuser', 'test@example.com', 's3krit')
        self.client.force_login(user)
        response = self.client.get('/flatpage_root/sekrit/')
        self.assertContains(response, "<p>Isn't it sekrit!</p>")

    def test_fallback_flatpage(self):
        "A fallback flatpage won't be served if the middleware is disabled"
        response = self.client.get('/flatpage/')
        self.assertEqual(response.status_code, 404)

    def test_fallback_non_existent_flatpage(self):
        """
        A nonexistent flatpage won't be served if the fallback middleware is
        disabled.
        """
        response = self.client.get('/no_such_flatpage/')
        self.assertEqual(response.status_code, 404)

    def test_view_flatpage_special_chars(self):
        "A flatpage with special chars in the URL can be served through a view"
        fp = FlatPage.objects.create(
            url="/some.very_special~chars-here/",
            title="A very special page",
            content="Isn't it special!",
            enable_comments=False,
            registration_required=False,
        )
        fp.sites.add(settings.SITE_ID)

        response = self.client.get('/flatpage_root/some.very_special~chars-here/')
        self.assertContains(response, "<p>Isn't it special!</p>")


</source>
</class>

<class classid="215" nclones="4" nlines="13" similarity="76">
<source file="django/tests/flatpages_tests/test_middleware.py.pyindent" startline="102" endline="115" pcid="13742">
        "A flatpage with special chars in the URL can be served by the fallback middleware"
        fp = FlatPage.objects.create(
            url="/some.very_special~chars-here/",
            title="A very special page",
            content="Isn't it special!",
            enable_comments=False,
            registration_required=False,
        )
        fp.sites.add(settings.SITE_ID)

        response = self.client.get('/some.very_special~chars-here/')
        self.assertContains(response, "<p>Isn't it special!</p>")


</source>
<source file="django/tests/flatpages_tests/test_middleware.py.pyindent" startline="161" endline="173" pcid="13748">
        "A flatpage with special chars in the URL can be served by the fallback middleware and should add a slash"
        fp = FlatPage.objects.create(
            url="/some.very_special~chars-here/",
            title="A very special page",
            content="Isn't it special!",
            enable_comments=False,
            registration_required=False,
        )
        fp.sites.add(settings.SITE_ID)

        response = self.client.get('/some.very_special~chars-here')
        self.assertRedirects(response, '/some.very_special~chars-here/', status_code=301)

</source>
<source file="django/tests/flatpages_tests/test_views.py.pyindent" startline="149" endline="160" pcid="13791">
        "A flatpage with special chars in the URL can be served through a view and should add a slash"
        fp = FlatPage.objects.create(
            url="/some.very_special~chars-here/",
            title="A very special page",
            content="Isn't it special!",
            enable_comments=False,
            registration_required=False,
        )
        fp.sites.add(settings.SITE_ID)

        response = self.client.get('/flatpage_root/some.very_special~chars-here')
        self.assertRedirects(response, '/flatpage_root/some.very_special~chars-here/', status_code=301)
</source>
<source file="django/tests/flatpages_tests/test_views.py.pyindent" startline="90" endline="103" pcid="13785">
        "A flatpage with special chars in the URL can be served through a view"
        fp = FlatPage.objects.create(
            url="/some.very_special~chars-here/",
            title="A very special page",
            content="Isn't it special!",
            enable_comments=False,
            registration_required=False,
        )
        fp.sites.add(settings.SITE_ID)

        response = self.client.get('/flatpage_root/some.very_special~chars-here/')
        self.assertContains(response, "<p>Isn't it special!</p>")


</source>
</class>

<class classid="216" nclones="2" nlines="10" similarity="70">
<source file="django/tests/flatpages_tests/test_templatetags.py.pyindent" startline="38" endline="47" pcid="13761">
        "The flatpage template tag retrieves unregistered prefixed flatpages by default"
        out = Template(
            "{% load flatpages %}"
            "{% get_flatpages as flatpages %}"
            "{% for page in flatpages %}"
            "{{ page.title }},"
            "{% endfor %}"
        ).render(Context())
        self.assertEqual(out, "A Flatpage,A Nested Flatpage,")

</source>
<source file="django/tests/flatpages_tests/test_templatetags.py.pyindent" startline="76" endline="85" pcid="13764">
        "The flatpage template tag retrieves unregistered prefixed flatpages by default"
        out = Template(
            "{% load flatpages %}"
            "{% get_flatpages '/location/' as location_flatpages %}"
            "{% for page in location_flatpages %}"
            "{{ page.title }},"
            "{% endfor %}"
        ).render(Context())
        self.assertEqual(out, "A Nested Flatpage,")

</source>
</class>

<class classid="217" nclones="2" nlines="11" similarity="72">
<source file="django/tests/flatpages_tests/test_templatetags.py.pyindent" startline="87" endline="98" pcid="13765">
        "The flatpage template tag retrieves unregistered prefixed flatpages for an anonymous user"
        out = Template(
            "{% load flatpages %}"
            "{% get_flatpages '/location/' for anonuser as location_flatpages %}"
            "{% for page in location_flatpages %}"
            "{{ page.title }},"
            "{% endfor %}"
        ).render(Context({
            'anonuser': AnonymousUser()
        }))
        self.assertEqual(out, "A Nested Flatpage,")

</source>
<source file="django/tests/flatpages_tests/test_templatetags.py.pyindent" startline="114" endline="125" pcid="13767">
        "The prefix for the flatpage template tag can be a template variable"
        out = Template(
            "{% load flatpages %}"
            "{% get_flatpages location_prefix as location_flatpages %}"
            "{% for page in location_flatpages %}"
            "{{ page.title }},"
            "{% endfor %}"
        ).render(Context({
            'location_prefix': '/location/'
        }))
        self.assertEqual(out, "A Nested Flatpage,")

</source>
</class>

<class classid="218" nclones="2" nlines="13" similarity="76">
<source file="django/tests/foreign_object/models/empty_join.py.pyindent" startline="57" endline="68" pcid="13846">
        to_opts = self.remote_field.model._meta
        from_opts = self.model._meta
        return [PathInfo(
            from_opts=from_opts,
            to_opts=to_opts,
            target_fields=(to_opts.pk,),
            join_field=self,
            m2m=False,
            direct=False,
            filtered_relation=filtered_relation,
        )]

</source>
<source file="django/tests/foreign_object/models/empty_join.py.pyindent" startline="70" endline="81" pcid="13847">
        to_opts = self.model._meta
        from_opts = self.remote_field.model._meta
        return [PathInfo(
            from_opts=from_opts,
            to_opts=to_opts,
            target_fields=(to_opts.pk,),
            join_field=self.remote_field,
            m2m=False,
            direct=False,
            filtered_relation=filtered_relation,
        )]

</source>
</class>

<class classid="219" nclones="2" nlines="10" similarity="70">
<source file="django/tests/foreign_object/tests.py.pyindent" startline="303" endline="312" pcid="13888">
        Membership.objects.create(membership_country=self.usa, person=self.bob, group=self.cia)
        Membership.objects.create(membership_country=self.usa, person=self.jim, group=self.democrat)

        with self.assertNumQueries(2):
            members_lists = [list(g.members.all())
                             for g in Group.objects.prefetch_related('members')]

        normal_members_lists = [list(g.members.all()) for g in Group.objects.all()]
        self.assertEqual(members_lists, normal_members_lists)

</source>
<source file="django/tests/foreign_object/tests.py.pyindent" startline="314" endline="322" pcid="13890">
        Membership.objects.create(membership_country=self.usa, person=self.bob, group=self.cia)
        Membership.objects.create(membership_country=self.usa, person=self.jim, group=self.democrat)

        with self.assertNumQueries(2):
            groups_lists = [list(p.groups.all()) for p in Person.objects.prefetch_related('groups')]

        normal_groups_lists = [list(p.groups.all()) for p in Person.objects.all()]
        self.assertEqual(groups_lists, normal_groups_lists)

</source>
</class>

<class classid="220" nclones="2" nlines="26" similarity="81">
<source file="django/tests/foreign_object/tests.py.pyindent" startline="430" endline="450" pcid="13906">
        class Parent(models.Model):
            a = models.PositiveIntegerField()
            b = models.PositiveIntegerField()

            class Meta:
                unique_together = (('a', 'b'),)

        class Child(models.Model):
            a = models.PositiveIntegerField()
            b = models.PositiveIntegerField()
            value = models.CharField(max_length=255)
            parent = ForeignObject(
                Parent,
                on_delete=models.SET_NULL,
                from_fields=('a', 'b'),
                to_fields=('a', 'b'),
                related_name='children',
            )

        self.assertEqual(Child._meta.get_field('parent').check(from_model=Child), [])

</source>
<source file="django/tests/foreign_object/tests.py.pyindent" startline="453" endline="476" pcid="13910">
        class Parent(models.Model):
            a = models.PositiveIntegerField()
            b = models.PositiveIntegerField()
            c = models.PositiveIntegerField()

            class Meta:
                unique_together = (('a', 'b'),)

        class Child(models.Model):
            a = models.PositiveIntegerField()
            b = models.PositiveIntegerField()
            c = models.PositiveIntegerField()
            d = models.CharField(max_length=255)
            parent = ForeignObject(
                Parent,
                on_delete=models.SET_NULL,
                from_fields=('a', 'b', 'c'),
                to_fields=('a', 'b', 'c'),
                related_name='children',
            )

        self.assertEqual(Child._meta.get_field('parent').check(from_model=Child), [])


</source>
</class>

<class classid="221" nclones="5" nlines="11" similarity="75">
<source file="django/tests/foreign_object/tests.py.pyindent" startline="438" endline="448" pcid="13909">
            a = models.PositiveIntegerField()
            b = models.PositiveIntegerField()
            value = models.CharField(max_length=255)
            parent = ForeignObject(
                Parent,
                on_delete=models.SET_NULL,
                from_fields=('a', 'b'),
                to_fields=('a', 'b'),
                related_name='children',
            )

</source>
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="695" endline="703" pcid="18079">
            a = models.PositiveIntegerField()
            b = models.PositiveIntegerField()
            parent = ForeignObject(
                'invalid_models_tests.Parent',
                on_delete=models.SET_NULL,
                from_fields=('a', 'b'),
                to_fields=('a', 'b'),
            )

</source>
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="670" endline="678" pcid="18077">
            a = models.PositiveIntegerField()
            b = models.PositiveIntegerField()
            parent = ForeignObject(
                Parent,
                on_delete=models.SET_NULL,
                from_fields=('a', 'b'),
                to_fields=('a', 'b'),
            )

</source>
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="1510" endline="1521" pcid="18190">
            a = models.PositiveIntegerField()
            b = models.PositiveIntegerField()
            d = models.PositiveIntegerField()
            value = models.CharField(max_length=255)
            parent = ForeignObject(
                Parent,
                on_delete=models.SET_NULL,
                from_fields=('a', 'b', 'd'),
                to_fields=('a', 'b', 'd'),
                related_name='children',
            )

</source>
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="1475" endline="1485" pcid="18186">
            a = models.PositiveIntegerField()
            b = models.PositiveIntegerField()
            value = models.CharField(max_length=255)
            parent = ForeignObject(
                Parent,
                on_delete=models.SET_NULL,
                from_fields=('a', 'b'),
                to_fields=('a', 'b'),
                related_name='children',
            )

</source>
</class>

<class classid="222" nclones="3" nlines="10" similarity="80">
<source file="django/tests/forms_tests/field_tests/test_genericipaddressfield.py.pyindent" startline="8" endline="12" pcid="14103">
        with self.assertRaises(ValueError):
            GenericIPAddressField(protocol='hamster')
        with self.assertRaises(ValueError):
            GenericIPAddressField(protocol='ipv4', unpack_ipv4=True)

</source>
<source file="django/tests/gis_tests/geos_tests/test_mutable_list.py.pyindent" startline="322" endline="325" pcid="16774">
            with self.assertRaises(ValueError):
                delfcn(ul, i)
            with self.assertRaises(ValueError):
                setfcn(ul, i)
</source>
<source file="django/tests/model_fields/test_imagefield.py.pyindent" startline="84" endline="87" pcid="20024">
            with self.assertRaises(ValueError):
                getattr(field, 'width')
            with self.assertRaises(ValueError):
                getattr(field, 'height')
</source>
</class>

<class classid="223" nclones="3" nlines="48" similarity="80">
<source file="django/tests/forms_tests/field_tests/test_genericipaddressfield.py.pyindent" startline="14" endline="42" pcid="14106">
        # The edge cases of the IPv6 validation code are not deeply tested
        # here, they are covered in the tests for django.utils.ipv6
        f = GenericIPAddressField()
        with self.assertRaisesMessage(ValidationError, "'This field is required.'"):
            f.clean('')
        with self.assertRaisesMessage(ValidationError, "'This field is required.'"):
            f.clean(None)
        self.assertEqual(f.clean(' 127.0.0.1 '), '127.0.0.1')
        with self.assertRaisesMessage(ValidationError, "'Enter a valid IPv4 or IPv6 address.'"):
            f.clean('foo')
        with self.assertRaisesMessage(ValidationError, "'Enter a valid IPv4 or IPv6 address.'"):
            f.clean('127.0.0.')
        with self.assertRaisesMessage(ValidationError, "'Enter a valid IPv4 or IPv6 address.'"):
            f.clean('1.2.3.4.5')
        with self.assertRaisesMessage(ValidationError, "'Enter a valid IPv4 or IPv6 address.'"):
            f.clean('256.125.1.5')
        self.assertEqual(f.clean(' fe80::223:6cff:fe8a:2e8a '), 'fe80::223:6cff:fe8a:2e8a')
        self.assertEqual(f.clean(' 2a02::223:6cff:fe8a:2e8a '), '2a02::223:6cff:fe8a:2e8a')
        with self.assertRaisesMessage(ValidationError, "'This is not a valid IPv6 address.'"):
            f.clean('12345:2:3:4')
        with self.assertRaisesMessage(ValidationError, "'This is not a valid IPv6 address.'"):
            f.clean('1::2:3::4')
        with self.assertRaisesMessage(ValidationError, "'This is not a valid IPv6 address.'"):
            f.clean('foo::223:6cff:fe8a:2e8a')
        with self.assertRaisesMessage(ValidationError, "'This is not a valid IPv6 address.'"):
            f.clean('1::2:3:4:5:6:7:8')
        with self.assertRaisesMessage(ValidationError, "'This is not a valid IPv6 address.'"):
            f.clean('1:2')

</source>
<source file="django/tests/forms_tests/field_tests/test_genericipaddressfield.py.pyindent" startline="93" endline="117" pcid="14140">
        f = GenericIPAddressField(required=False)
        self.assertEqual(f.clean(''), '')
        self.assertEqual(f.clean(None), '')
        self.assertEqual(f.clean('127.0.0.1'), '127.0.0.1')
        with self.assertRaisesMessage(ValidationError, "'Enter a valid IPv4 or IPv6 address.'"):
            f.clean('foo')
        with self.assertRaisesMessage(ValidationError, "'Enter a valid IPv4 or IPv6 address.'"):
            f.clean('127.0.0.')
        with self.assertRaisesMessage(ValidationError, "'Enter a valid IPv4 or IPv6 address.'"):
            f.clean('1.2.3.4.5')
        with self.assertRaisesMessage(ValidationError, "'Enter a valid IPv4 or IPv6 address.'"):
            f.clean('256.125.1.5')
        self.assertEqual(f.clean(' fe80::223:6cff:fe8a:2e8a '), 'fe80::223:6cff:fe8a:2e8a')
        self.assertEqual(f.clean(' 2a02::223:6cff:fe8a:2e8a '), '2a02::223:6cff:fe8a:2e8a')
        with self.assertRaisesMessage(ValidationError, "'This is not a valid IPv6 address.'"):
            f.clean('12345:2:3:4')
        with self.assertRaisesMessage(ValidationError, "'This is not a valid IPv6 address.'"):
            f.clean('1::2:3::4')
        with self.assertRaisesMessage(ValidationError, "'This is not a valid IPv6 address.'"):
            f.clean('foo::223:6cff:fe8a:2e8a')
        with self.assertRaisesMessage(ValidationError, "'This is not a valid IPv6 address.'"):
            f.clean('1::2:3:4:5:6:7:8')
        with self.assertRaisesMessage(ValidationError, "'This is not a valid IPv6 address.'"):
            f.clean('1:2')

</source>
<source file="django/tests/forms_tests/field_tests/test_genericipaddressfield.py.pyindent" startline="64" endline="91" pcid="14127">
        f = GenericIPAddressField(protocol="IPv6")
        with self.assertRaisesMessage(ValidationError, "'This field is required.'"):
            f.clean('')
        with self.assertRaisesMessage(ValidationError, "'This field is required.'"):
            f.clean(None)
        with self.assertRaisesMessage(ValidationError, "'Enter a valid IPv6 address.'"):
            f.clean('127.0.0.1')
        with self.assertRaisesMessage(ValidationError, "'Enter a valid IPv6 address.'"):
            f.clean('foo')
        with self.assertRaisesMessage(ValidationError, "'Enter a valid IPv6 address.'"):
            f.clean('127.0.0.')
        with self.assertRaisesMessage(ValidationError, "'Enter a valid IPv6 address.'"):
            f.clean('1.2.3.4.5')
        with self.assertRaisesMessage(ValidationError, "'Enter a valid IPv6 address.'"):
            f.clean('256.125.1.5')
        self.assertEqual(f.clean(' fe80::223:6cff:fe8a:2e8a '), 'fe80::223:6cff:fe8a:2e8a')
        self.assertEqual(f.clean(' 2a02::223:6cff:fe8a:2e8a '), '2a02::223:6cff:fe8a:2e8a')
        with self.assertRaisesMessage(ValidationError, "'This is not a valid IPv6 address.'"):
            f.clean('12345:2:3:4')
        with self.assertRaisesMessage(ValidationError, "'This is not a valid IPv6 address.'"):
            f.clean('1::2:3::4')
        with self.assertRaisesMessage(ValidationError, "'This is not a valid IPv6 address.'"):
            f.clean('foo::223:6cff:fe8a:2e8a')
        with self.assertRaisesMessage(ValidationError, "'This is not a valid IPv6 address.'"):
            f.clean('1::2:3:4:5:6:7:8')
        with self.assertRaisesMessage(ValidationError, "'This is not a valid IPv6 address.'"):
            f.clean('1:2')

</source>
</class>

<class classid="224" nclones="2" nlines="23" similarity="79">
<source file="django/tests/forms_tests/field_tests/test_multivaluefield.py.pyindent" startline="14" endline="32" pcid="14212">
    def __init__(self, attrs=None):
        widgets = (
            TextInput(),
            SelectMultiple(choices=beatles),
            SplitDateTimeWidget(),
        )
        super().__init__(widgets, attrs)

    def decompress(self, value):
        if value:
            data = value.split(',')
            return [
                data[0],
                list(data[1]),
                datetime.strptime(data[2], "%Y-%m-%d %H:%M:%S"),
            ]
        return [None, None, None]


</source>
<source file="django/tests/forms_tests/widget_tests/test_multiwidget.py.pyindent" startline="21" endline="37" pcid="15171">
    def __init__(self, attrs=None):
        widgets = (
            TextInput(),
            SelectMultiple(choices=WidgetTest.beatles),
            SplitDateTimeWidget(),
        )
        super().__init__(widgets, attrs)

    def decompress(self, value):
        if value:
            data = value.split(',')
            return [
                data[0], list(data[1]), datetime.strptime(data[2], "%Y-%m-%d %H:%M:%S")
            ]
        return [None, None, None]


</source>
</class>

<class classid="225" nclones="2" nlines="20" similarity="71">
<source file="django/tests/forms_tests/field_tests/test_multivaluefield.py.pyindent" startline="34" endline="47" pcid="14216">
    def __init__(self, **kwargs):
        fields = (
            CharField(),
            MultipleChoiceField(choices=beatles),
            SplitDateTimeField(),
        )
        super().__init__(fields, **kwargs)

    def compress(self, data_list):
        if data_list:
            return '%s,%s,%s' % (data_list[0], ''.join(data_list[1]), data_list[2])
        return None


</source>
<source file="django/tests/forms_tests/widget_tests/test_multiwidget.py.pyindent" startline="39" endline="54" pcid="15175">
    def __init__(self, required=True, widget=None, label=None, initial=None):
        fields = (
            CharField(),
            MultipleChoiceField(choices=WidgetTest.beatles),
            SplitDateTimeField(),
        )
        super().__init__(fields, required, widget, label, initial)

    def compress(self, data_list):
        if data_list:
            return '%s,%s,%s' % (
                data_list[0], ''.join(data_list[1]), data_list[2],
            )
        return None


</source>
</class>

<class classid="226" nclones="2" nlines="19" similarity="76">
<source file="django/tests/forms_tests/field_tests/test_regexfield.py.pyindent" startline="10" endline="21" pcid="14250">
        f = RegexField('^[0-9][A-F][0-9]$')
        self.assertEqual('2A2', f.clean('2A2'))
        self.assertEqual('3F3', f.clean('3F3'))
        with self.assertRaisesMessage(ValidationError, "'Enter a valid value.'"):
            f.clean('3G3')
        with self.assertRaisesMessage(ValidationError, "'Enter a valid value.'"):
            f.clean(' 2A2')
        with self.assertRaisesMessage(ValidationError, "'Enter a valid value.'"):
            f.clean('2A2 ')
        with self.assertRaisesMessage(ValidationError, "'This field is required.'"):
            f.clean('')

</source>
<source file="django/tests/forms_tests/field_tests/test_regexfield.py.pyindent" startline="31" endline="40" pcid="14257">
        f = RegexField(re.compile('^[0-9][A-F][0-9]$'))
        self.assertEqual('2A2', f.clean('2A2'))
        self.assertEqual('3F3', f.clean('3F3'))
        with self.assertRaisesMessage(ValidationError, "'Enter a valid value.'"):
            f.clean('3G3')
        with self.assertRaisesMessage(ValidationError, "'Enter a valid value.'"):
            f.clean(' 2A2')
        with self.assertRaisesMessage(ValidationError, "'Enter a valid value.'"):
            f.clean('2A2 ')

</source>
</class>

<class classid="227" nclones="2" nlines="12" similarity="75">
<source file="django/tests/forms_tests/field_tests/test_typedchoicefield.py.pyindent" startline="27" endline="36" pcid="14303">
        # Even more weirdness: if you have a valid choice but your coercion function
        # can't coerce, you'll still get a validation error. Don't do this!
        f = TypedChoiceField(choices=[('A', 'A'), ('B', 'B')], coerce=int)
        msg = "'Select a valid choice. B is not one of the available choices.'"
        with self.assertRaisesMessage(ValidationError, msg):
            f.clean('B')
        # Required fields require values
        with self.assertRaisesMessage(ValidationError, "'This field is required.'"):
            f.clean('')

</source>
<source file="django/tests/forms_tests/field_tests/test_typedmultiplechoicefield.py.pyindent" startline="34" endline="43" pcid="14320">
        # Even more weirdness: if you have a valid choice but your coercion function
        # can't coerce, you'll still get a validation error. Don't do this!
        f = TypedMultipleChoiceField(choices=[('A', 'A'), ('B', 'B')], coerce=int)
        msg = "'Select a valid choice. B is not one of the available choices.'"
        with self.assertRaisesMessage(ValidationError, msg):
            f.clean(['B'])
        # Required fields require values
        with self.assertRaisesMessage(ValidationError, "'This field is required.'"):
            f.clean([])

</source>
</class>

<class classid="228" nclones="2" nlines="18" similarity="72">
<source file="django/tests/forms_tests/field_tests/test_typedchoicefield.py.pyindent" startline="63" endline="76" pcid="14309">
        """
        A coerce function which results in a value not present in choices
        should raise an appropriate error (#21397).
        """
        def coerce_func(val):
            return decimal.Decimal('1.%s' % val)

        f = TypedChoiceField(choices=[(1, "1"), (2, "2")], coerce=coerce_func, required=True)
        self.assertEqual(decimal.Decimal('1.2'), f.clean('2'))
        with self.assertRaisesMessage(ValidationError, "'This field is required.'"):
            f.clean('')
        msg = "'Select a valid choice. 3 is not one of the available choices.'"
        with self.assertRaisesMessage(ValidationError, msg):
            f.clean('3')
</source>
<source file="django/tests/forms_tests/field_tests/test_typedmultiplechoicefield.py.pyindent" startline="60" endline="74" pcid="14326">
        """
        A coerce function which results in a value not present in choices
        should raise an appropriate error (#21397).
        """
        def coerce_func(val):
            return decimal.Decimal('1.%s' % val)

        f = TypedMultipleChoiceField(
            choices=[(1, "1"), (2, "2")], coerce=coerce_func, required=True)
        self.assertEqual([decimal.Decimal('1.2')], f.clean(['2']))
        with self.assertRaisesMessage(ValidationError, "'This field is required.'"):
            f.clean([])
        msg = "'Select a valid choice. 3 is not one of the available choices.'"
        with self.assertRaisesMessage(ValidationError, msg):
            f.clean(['3'])
</source>
</class>

<class classid="229" nclones="2" nlines="12" similarity="75">
<source file="django/tests/forms_tests/tests/tests.py.pyindent" startline="288" endline="298" pcid="14439">
        f = EmptyCharLabelChoiceForm()
        self.assertHTMLEqual(
            f.as_p(),
            """<p><label for="id_name">Name:</label> <input id="id_name" maxlength="10" name="name" type="text" required></p>
<p><label for="id_choice">Choice:</label> <select id="id_choice" name="choice">
<option value="" selected>No Preference</option>
<option value="f">Foo</option>
<option value="b">Bar</option>
</select></p>"""
        )

</source>
<source file="django/tests/forms_tests/tests/tests.py.pyindent" startline="300" endline="311" pcid="14440">
        f = EmptyCharLabelNoneChoiceForm()
        self.assertHTMLEqual(
            f.as_p(),
            """<p><label for="id_name">Name:</label> <input id="id_name" maxlength="10" name="name" type="text" required></p>
<p><label for="id_choice_string_w_none">Choice string w none:</label>
<select id="id_choice_string_w_none" name="choice_string_w_none">
<option value="" selected>No Preference</option>
<option value="f">Foo</option>
<option value="b">Bar</option>
</select></p>"""
        )

</source>
</class>

<class classid="230" nclones="2" nlines="12" similarity="76">
<source file="django/tests/forms_tests/tests/test_error_messages.py.pyindent" startline="25" endline="34" pcid="14451">
        e = {
            'required': 'REQUIRED',
            'min_length': 'LENGTH %(show_value)s, MIN LENGTH %(limit_value)s',
            'max_length': 'LENGTH %(show_value)s, MAX LENGTH %(limit_value)s',
        }
        f = CharField(min_length=5, max_length=10, error_messages=e)
        self.assertFormErrors(['REQUIRED'], f.clean, '')
        self.assertFormErrors(['LENGTH 4, MIN LENGTH 5'], f.clean, '1234')
        self.assertFormErrors(['LENGTH 11, MAX LENGTH 10'], f.clean, '12345678901')

</source>
<source file="django/tests/forms_tests/tests/test_error_messages.py.pyindent" startline="110" endline="121" pcid="14458">
        e = {
            'required': 'REQUIRED',
            'invalid': 'INVALID',
            'min_length': 'LENGTH %(show_value)s, MIN LENGTH %(limit_value)s',
            'max_length': 'LENGTH %(show_value)s, MAX LENGTH %(limit_value)s',
        }
        f = RegexField(r'^[0-9]+$', min_length=5, max_length=10, error_messages=e)
        self.assertFormErrors(['REQUIRED'], f.clean, '')
        self.assertFormErrors(['INVALID'], f.clean, 'abcde')
        self.assertFormErrors(['LENGTH 4, MIN LENGTH 5'], f.clean, '1234')
        self.assertFormErrors(['LENGTH 11, MAX LENGTH 10'], f.clean, '12345678901')

</source>
</class>

<class classid="231" nclones="2" nlines="13" similarity="92">
<source file="django/tests/forms_tests/tests/test_error_messages.py.pyindent" startline="36" endline="47" pcid="14452">
        e = {
            'required': 'REQUIRED',
            'invalid': 'INVALID',
            'min_value': 'MIN VALUE IS %(limit_value)s',
            'max_value': 'MAX VALUE IS %(limit_value)s',
        }
        f = IntegerField(min_value=5, max_value=10, error_messages=e)
        self.assertFormErrors(['REQUIRED'], f.clean, '')
        self.assertFormErrors(['INVALID'], f.clean, 'abc')
        self.assertFormErrors(['MIN VALUE IS 5'], f.clean, '4')
        self.assertFormErrors(['MAX VALUE IS 10'], f.clean, '11')

</source>
<source file="django/tests/forms_tests/tests/test_error_messages.py.pyindent" startline="49" endline="60" pcid="14453">
        e = {
            'required': 'REQUIRED',
            'invalid': 'INVALID',
            'min_value': 'MIN VALUE IS %(limit_value)s',
            'max_value': 'MAX VALUE IS %(limit_value)s',
        }
        f = FloatField(min_value=5, max_value=10, error_messages=e)
        self.assertFormErrors(['REQUIRED'], f.clean, '')
        self.assertFormErrors(['INVALID'], f.clean, 'abc')
        self.assertFormErrors(['MIN VALUE IS 5'], f.clean, '4')
        self.assertFormErrors(['MAX VALUE IS 10'], f.clean, '11')

</source>
</class>

<class classid="232" nclones="2" nlines="15" similarity="86">
<source file="django/tests/forms_tests/tests/test_error_messages.py.pyindent" startline="219" endline="227" pcid="14470">
            def __str__(self):
                return self.as_divs()

            def as_divs(self):
                if not self:
                    return ''
                return mark_safe('<div class="error">%s</div>' % ''.join('<p>%s</p>' % e for e in self))

        # This form should print errors the default way.
</source>
<source file="django/tests/forms_tests/tests/test_forms.py.pyindent" startline="3389" endline="3397" pcid="14808">
            def __str__(self):
                return self.as_divs()

            def as_divs(self):
                if not self:
                    return ''
                return '<div class="errorlist">%s</div>' % ''.join(
                    '<div class="error">%s</div>' % e for e in self)

</source>
</class>

<class classid="233" nclones="2" nlines="11" similarity="72">
<source file="django/tests/forms_tests/tests/test_forms.py.pyindent" startline="369" endline="381" pcid="14499">
        # If auto_id is any True value whose str() does not contain '%s', the "id"
        # attribute will be the name of the field.
        p = Person(auto_id=True)
        self.assertHTMLEqual(
            p.as_ul(),
            """<li><label for="first_name">First name:</label>
<input type="text" name="first_name" id="first_name" required></li>
<li><label for="last_name">Last name:</label>
<input type="text" name="last_name" id="last_name" required></li>
<li><label for="birthday">Birthday:</label>
<input type="text" name="birthday" id="birthday" required></li>"""
        )

</source>
<source file="django/tests/forms_tests/tests/test_forms.py.pyindent" startline="406" endline="418" pcid="14502">
        # If the "id" attribute is specified in the Form and auto_id is True, the "id"
        # attribute in the Form gets precedence.
        p = PersonNew(auto_id=True)
        self.assertHTMLEqual(
            p.as_ul(),
            """<li><label for="first_name_id">First name:</label>
<input type="text" id="first_name_id" name="first_name" required></li>
<li><label for="last_name">Last name:</label>
<input type="text" name="last_name" id="last_name" required></li>
<li><label for="birthday">Birthday:</label>
<input type="text" name="birthday" id="birthday" required></li>"""
        )

</source>
</class>

<class classid="234" nclones="3" nlines="14" similarity="78">
<source file="django/tests/forms_tests/tests/test_forms.py.pyindent" startline="1029" endline="1039" pcid="14554">
            username = CharField(max_length=10)
            password1 = CharField(widget=PasswordInput)
            password2 = CharField(widget=PasswordInput)

            def clean_password2(self):
                if (self.cleaned_data.get('password1') and self.cleaned_data.get('password2') and
                        self.cleaned_data['password1'] != self.cleaned_data['password2']):
                    raise ValidationError('Please make sure your passwords match.')

                return self.cleaned_data['password2']

</source>
<source file="django/tests/forms_tests/tests/test_forms.py.pyindent" startline="2464" endline="2474" pcid="14690">
            username = CharField(max_length=10)
            password1 = CharField(widget=PasswordInput)
            password2 = CharField(widget=PasswordInput)

            def clean(self):
                if (self.cleaned_data.get('password1') and self.cleaned_data.get('password2') and
                        self.cleaned_data['password1'] != self.cleaned_data['password2']):
                    raise ValidationError('Please make sure your passwords match.')

                return self.cleaned_data

</source>
<source file="django/tests/forms_tests/tests/test_forms.py.pyindent" startline="2522" endline="2537" pcid="14698">
            username = CharField(max_length=10, help_text="Good luck picking a username that doesn't already exist.")
            password1 = CharField(widget=PasswordInput)
            password2 = CharField(widget=PasswordInput)

            def clean(self):
                if (self.cleaned_data.get('password1') and self.cleaned_data.get('password2') and
                        self.cleaned_data['password1'] != self.cleaned_data['password2']):
                    raise ValidationError('Please make sure your passwords match.')

                return self.cleaned_data

        # You have full flexibility in displaying form fields in a template. Just pass a
        # Form instance to the template, and use "dot" access to refer to individual
        # fields. Note, however, that this flexibility comes with the responsibility of
        # displaying all the errors, including any that might not be associated with a
        # particular field.
</source>
</class>

<class classid="235" nclones="2" nlines="11" similarity="83">
<source file="django/tests/forms_tests/tests/test_forms.py.pyindent" startline="1262" endline="1267" pcid="14588">
            def __init__(self, data=None, auto_id=False, field_list=[]):
                Form.__init__(self, data, auto_id=auto_id)

                for field in field_list:
                    self.fields[field[0]] = field[1]

</source>
<source file="django/tests/forms_tests/tests/test_forms.py.pyindent" startline="1284" endline="1292" pcid="14591">
            default_field_1 = CharField()
            default_field_2 = CharField()

            def __init__(self, data=None, auto_id=False, field_list=[]):
                Form.__init__(self, data, auto_id=auto_id)

                for field in field_list:
                    self.fields[field[0]] = field[1]

</source>
</class>

<class classid="236" nclones="3" nlines="18" similarity="84">
<source file="django/tests/forms_tests/tests/test_forms.py.pyindent" startline="3088" endline="3103" pcid="14776">
        """#5749 - `field_name` may be used as a key in _html_output()."""
        class SomeForm(Form):
            some_field = CharField()

            def as_p(self):
                return self._html_output(
                    normal_row='<p id="p_%(field_name)s"></p>',
                    error_row='%s',
                    row_ender='</p>',
                    help_text_html=' %s',
                    errors_on_separate_row=True,
                )

        form = SomeForm()
        self.assertHTMLEqual(form.as_p(), '<p id="p_some_field"></p>')

</source>
<source file="django/tests/forms_tests/tests/test_forms.py.pyindent" startline="3124" endline="3143" pcid="14782">
        """
        `css_classes` may be used as a key in _html_output() (class comes
        from required_css_class in this case).
        """
        class SomeForm(Form):
            some_field = CharField()
            required_css_class = 'foo'

            def as_p(self):
                return self._html_output(
                    normal_row='<p class="%(css_classes)s"></p>',
                    error_row='%s',
                    row_ender='</p>',
                    help_text_html=' %s',
                    errors_on_separate_row=True,
                )

        form = SomeForm()
        self.assertHTMLEqual(form.as_p(), '<p class="foo"></p>')

</source>
<source file="django/tests/forms_tests/tests/test_forms.py.pyindent" startline="3105" endline="3122" pcid="14779">
        """
        `css_classes` may be used as a key in _html_output() (empty classes).
        """
        class SomeForm(Form):
            some_field = CharField()

            def as_p(self):
                return self._html_output(
                    normal_row='<p class="%(css_classes)s"></p>',
                    error_row='%s',
                    row_ender='</p>',
                    help_text_html=' %s',
                    errors_on_separate_row=True,
                )

        form = SomeForm()
        self.assertHTMLEqual(form.as_p(), '<p class=""></p>')

</source>
</class>

<class classid="237" nclones="4" nlines="14" similarity="73">
<source file="django/tests/forms_tests/tests/test_forms.py.pyindent" startline="3090" endline="3100" pcid="14777">
            some_field = CharField()

            def as_p(self):
                return self._html_output(
                    normal_row='<p id="p_%(field_name)s"></p>',
                    error_row='%s',
                    row_ender='</p>',
                    help_text_html=' %s',
                    errors_on_separate_row=True,
                )

</source>
<source file="django/tests/forms_tests/tests/test_forms.py.pyindent" startline="3150" endline="3162" pcid="14786">
            hidden1 = CharField(widget=HiddenInput)
            custom = CharField()
            hidden2 = CharField(widget=HiddenInput)

            def as_p(self):
                return self._html_output(
                    normal_row='<p%(html_class_attr)s>%(field)s %(field_name)s</p>',
                    error_row='%s',
                    row_ender='</p>',
                    help_text_html=' %s',
                    errors_on_separate_row=True,
                )

</source>
<source file="django/tests/forms_tests/tests/test_forms.py.pyindent" startline="3109" endline="3119" pcid="14780">
            some_field = CharField()

            def as_p(self):
                return self._html_output(
                    normal_row='<p class="%(css_classes)s"></p>',
                    error_row='%s',
                    row_ender='</p>',
                    help_text_html=' %s',
                    errors_on_separate_row=True,
                )

</source>
<source file="django/tests/forms_tests/tests/test_forms.py.pyindent" startline="3129" endline="3140" pcid="14783">
            some_field = CharField()
            required_css_class = 'foo'

            def as_p(self):
                return self._html_output(
                    normal_row='<p class="%(css_classes)s"></p>',
                    error_row='%s',
                    row_ender='</p>',
                    help_text_html=' %s',
                    errors_on_separate_row=True,
                )

</source>
</class>

<class classid="238" nclones="2" nlines="24" similarity="79">
<source file="django/tests/forms_tests/tests/test_forms.py.pyindent" startline="3145" endline="3170" pcid="14785">
        """
        BaseForm._html_output() should merge all the hidden input fields and
        put them in the last row.
        """
        class SomeForm(Form):
            hidden1 = CharField(widget=HiddenInput)
            custom = CharField()
            hidden2 = CharField(widget=HiddenInput)

            def as_p(self):
                return self._html_output(
                    normal_row='<p%(html_class_attr)s>%(field)s %(field_name)s</p>',
                    error_row='%s',
                    row_ender='</p>',
                    help_text_html=' %s',
                    errors_on_separate_row=True,
                )

        form = SomeForm()
        self.assertHTMLEqual(
            form.as_p(),
            '<p><input id="id_custom" name="custom" type="text" required> custom'
            '<input id="id_hidden1" name="hidden1" type="hidden">'
            '<input id="id_hidden2" name="hidden2" type="hidden"></p>'
        )

</source>
<source file="django/tests/forms_tests/tests/test_forms.py.pyindent" startline="3172" endline="3197" pcid="14788">
        """
        BaseForm._html_output() should merge all the hidden input fields and
        put them in the last row ended with the specific row ender.
        """
        class SomeForm(Form):
            hidden1 = CharField(widget=HiddenInput)
            custom = CharField()
            hidden2 = CharField(widget=HiddenInput)

            def as_p(self):
                return self._html_output(
                    normal_row='<p%(html_class_attr)s>%(field)s %(field_name)s</p>',
                    error_row='%s',
                    row_ender='<hr><hr>',
                    help_text_html=' %s',
                    errors_on_separate_row=True
                )

        form = SomeForm()
        self.assertHTMLEqual(
            form.as_p(),
            '<p><input id="id_custom" name="custom" type="text" required> custom</p>\n'
            '<input id="id_hidden1" name="hidden1" type="hidden">'
            '<input id="id_hidden2" name="hidden2" type="hidden"><hr><hr>'
        )

</source>
</class>

<class classid="239" nclones="3" nlines="18" similarity="72">
<source file="django/tests/forms_tests/tests/test_forms.py.pyindent" startline="3459" endline="3474" pcid="14819">
        class UserForm(Form):
            username = CharField(max_length=10)
            password = CharField(widget=PasswordInput)

            def clean(self):
                data = self.cleaned_data

                if not self.errors:
                    data['username'] = data['username'].lower()

                return data

        f = UserForm({'username': 'SirRobin', 'password': 'blue'})
        self.assertTrue(f.is_valid())
        self.assertEqual(f.cleaned_data['username'], 'sirrobin')

</source>
<source file="django/tests/forms_tests/tests/test_forms.py.pyindent" startline="3489" endline="3505" pcid="14826">
        class UserForm(Form):
            username = CharField(max_length=10)
            password = CharField(widget=PasswordInput)

            def clean(self):
                data = self.cleaned_data

                # Return a different dict. We have not changed self.cleaned_data.
                return {
                    'username': data['username'].lower(),
                    'password': 'this_is_not_a_secret',
                }

        f = UserForm({'username': 'SirRobin', 'password': 'blue'})
        self.assertTrue(f.is_valid())
        self.assertEqual(f.cleaned_data['username'], 'sirrobin')

</source>
<source file="django/tests/forms_tests/tests/test_forms.py.pyindent" startline="3476" endline="3487" pcid="14823">
        class UserForm(Form):
            username = CharField(max_length=10)
            password = CharField(widget=PasswordInput)

            def clean(self):
                self.cleaned_data['username'] = self.cleaned_data['username'].lower()
                # don't return anything

        f = UserForm({'username': 'SirRobin', 'password': 'blue'})
        self.assertTrue(f.is_valid())
        self.assertEqual(f.cleaned_data['username'], 'sirrobin')

</source>
</class>

<class classid="240" nclones="2" nlines="47" similarity="81">
<source file="django/tests/forms_tests/tests/test_forms.py.pyindent" startline="3532" endline="3577" pcid="14835">
        class MyForm(Form):
            use_required_attribute = True
            f1 = CharField(max_length=30)
            f2 = CharField(max_length=30, required=False)
            f3 = CharField(widget=Textarea)
            f4 = ChoiceField(choices=[('P', 'Python'), ('J', 'Java')])

        form = MyForm()
        self.assertHTMLEqual(
            form.as_p(),
            '<p><label for="id_f1">F1:</label> <input id="id_f1" maxlength="30" name="f1" type="text" required></p>'
            '<p><label for="id_f2">F2:</label> <input id="id_f2" maxlength="30" name="f2" type="text"></p>'
            '<p><label for="id_f3">F3:</label> <textarea cols="40" id="id_f3" name="f3" rows="10" required>'
            '</textarea></p>'
            '<p><label for="id_f4">F4:</label> <select id="id_f4" name="f4">'
            '<option value="P">Python</option>'
            '<option value="J">Java</option>'
            '</select></p>',
        )
        self.assertHTMLEqual(
            form.as_ul(),
            '<li><label for="id_f1">F1:</label> '
            '<input id="id_f1" maxlength="30" name="f1" type="text" required></li>'
            '<li><label for="id_f2">F2:</label> <input id="id_f2" maxlength="30" name="f2" type="text"></li>'
            '<li><label for="id_f3">F3:</label> <textarea cols="40" id="id_f3" name="f3" rows="10" required>'
            '</textarea></li>'
            '<li><label for="id_f4">F4:</label> <select id="id_f4" name="f4">'
            '<option value="P">Python</option>'
            '<option value="J">Java</option>'
            '</select></li>',
        )
        self.assertHTMLEqual(
            form.as_table(),
            '<tr><th><label for="id_f1">F1:</label></th>'
            '<td><input id="id_f1" maxlength="30" name="f1" type="text" required></td></tr>'
            '<tr><th><label for="id_f2">F2:</label></th>'
            '<td><input id="id_f2" maxlength="30" name="f2" type="text"></td></tr>'
            '<tr><th><label for="id_f3">F3:</label></th>'
            '<td><textarea cols="40" id="id_f3" name="f3" rows="10" required>'
            '</textarea></td></tr>'
            '<tr><th><label for="id_f4">F4:</label></th><td><select id="id_f4" name="f4">'
            '<option value="P">Python</option>'
            '<option value="J">Java</option>'
            '</select></td></tr>',
        )

</source>
<source file="django/tests/forms_tests/tests/test_forms.py.pyindent" startline="3579" endline="3622" pcid="14837">
        class MyForm(Form):
            use_required_attribute = False
            f1 = CharField(max_length=30)
            f2 = CharField(max_length=30, required=False)
            f3 = CharField(widget=Textarea)
            f4 = ChoiceField(choices=[('P', 'Python'), ('J', 'Java')])

        form = MyForm()
        self.assertHTMLEqual(
            form.as_p(),
            '<p><label for="id_f1">F1:</label> <input id="id_f1" maxlength="30" name="f1" type="text"></p>'
            '<p><label for="id_f2">F2:</label> <input id="id_f2" maxlength="30" name="f2" type="text"></p>'
            '<p><label for="id_f3">F3:</label> <textarea cols="40" id="id_f3" name="f3" rows="10">'
            '</textarea></p>'
            '<p><label for="id_f4">F4:</label> <select id="id_f4" name="f4">'
            '<option value="P">Python</option>'
            '<option value="J">Java</option>'
            '</select></p>',
        )
        self.assertHTMLEqual(
            form.as_ul(),
            '<li><label for="id_f1">F1:</label> <input id="id_f1" maxlength="30" name="f1" type="text"></li>'
            '<li><label for="id_f2">F2:</label> <input id="id_f2" maxlength="30" name="f2" type="text"></li>'
            '<li><label for="id_f3">F3:</label> <textarea cols="40" id="id_f3" name="f3" rows="10">'
            '</textarea></li>'
            '<li><label for="id_f4">F4:</label> <select id="id_f4" name="f4">'
            '<option value="P">Python</option>'
            '<option value="J">Java</option>'
            '</select></li>',
        )
        self.assertHTMLEqual(
            form.as_table(),
            '<tr><th><label for="id_f1">F1:</label></th>'
            '<td><input id="id_f1" maxlength="30" name="f1" type="text"></td></tr>'
            '<tr><th><label for="id_f2">F2:</label></th>'
            '<td><input id="id_f2" maxlength="30" name="f2" type="text"></td></tr>'
            '<tr><th><label for="id_f3">F3:</label></th><td><textarea cols="40" id="id_f3" name="f3" rows="10">'
            '</textarea></td></tr>'
            '<tr><th><label for="id_f4">F4:</label></th><td><select id="id_f4" name="f4">'
            '<option value="P">Python</option>'
            '<option value="J">Java</option>'
            '</select></td></tr>',
        )

</source>
</class>

<class classid="241" nclones="2" nlines="83" similarity="72">
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="10" endline="118" pcid="14866">
    def setUp(self):
        # nl/formats.py has customized TIME_INPUT_FORMATS:
        # ['%H:%M:%S', '%H.%M:%S', '%H.%M', '%H:%M']
        activate('nl')

    def tearDown(self):
        deactivate()

    def test_timeField(self):
        "TimeFields can parse dates in the default format"
        f = forms.TimeField()
        # Parse a time in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('1:30:05 PM')

        # Parse a time in a valid format, get a parsed result
        result = f.clean('13:30:05')
        self.assertEqual(result, time(13, 30, 5))

        # The parsed result does a round trip
        text = f.widget.format_value(result)
        self.assertEqual(text, '13:30:05')

        # Parse a time in a valid, but non-default format, get a parsed result
        result = f.clean('13:30')
        self.assertEqual(result, time(13, 30, 0))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "13:30:00")

        # ISO formats are accepted, even if not specified in formats.py
        result = f.clean('13:30:05.000155')
        self.assertEqual(result, time(13, 30, 5, 155))

    def test_localized_timeField(self):
        "Localized TimeFields act as unlocalized widgets"
        f = forms.TimeField(localize=True)
        # Parse a time in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('1:30:05 PM')

        # Parse a time in a valid format, get a parsed result
        result = f.clean('13:30:05')
        self.assertEqual(result, time(13, 30, 5))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, '13:30:05')

        # Parse a time in a valid format, get a parsed result
        result = f.clean('13:30')
        self.assertEqual(result, time(13, 30, 0))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "13:30:00")

    def test_timeField_with_inputformat(self):
        "TimeFields with manually specified input formats can accept those formats"
        f = forms.TimeField(input_formats=["%H.%M.%S", "%H.%M"])
        # Parse a time in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('1:30:05 PM')
        with self.assertRaises(forms.ValidationError):
            f.clean('13:30:05')

        # Parse a time in a valid format, get a parsed result
        result = f.clean('13.30.05')
        self.assertEqual(result, time(13, 30, 5))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "13:30:05")

        # Parse a time in a valid format, get a parsed result
        result = f.clean('13.30')
        self.assertEqual(result, time(13, 30, 0))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "13:30:00")

    def test_localized_timeField_with_inputformat(self):
        "Localized TimeFields with manually specified input formats can accept those formats"
        f = forms.TimeField(input_formats=["%H.%M.%S", "%H.%M"], localize=True)
        # Parse a time in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('1:30:05 PM')
        with self.assertRaises(forms.ValidationError):
            f.clean('13:30:05')

        # Parse a time in a valid format, get a parsed result
        result = f.clean('13.30.05')
        self.assertEqual(result, time(13, 30, 5))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "13:30:05")

        # Parse a time in a valid format, get a parsed result
        result = f.clean('13.30')
        self.assertEqual(result, time(13, 30, 0))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "13:30:00")


</source>
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="121" endline="217" pcid="14879">
    def test_timeField(self):
        "TimeFields can parse dates in the default format"
        f = forms.TimeField()
        # Parse a time in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('13:30:05')

        # Parse a time in a valid format, get a parsed result
        result = f.clean('1:30:05 PM')
        self.assertEqual(result, time(13, 30, 5))

        # The parsed result does a round trip
        text = f.widget.format_value(result)
        self.assertEqual(text, '01:30:05 PM')

        # Parse a time in a valid, but non-default format, get a parsed result
        result = f.clean('1:30 PM')
        self.assertEqual(result, time(13, 30, 0))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "01:30:00 PM")

    def test_localized_timeField(self):
        "Localized TimeFields act as unlocalized widgets"
        f = forms.TimeField(localize=True)
        # Parse a time in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('13:30:05')

        # Parse a time in a valid format, get a parsed result
        result = f.clean('1:30:05 PM')
        self.assertEqual(result, time(13, 30, 5))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, '01:30:05 PM')

        # Parse a time in a valid format, get a parsed result
        result = f.clean('01:30 PM')
        self.assertEqual(result, time(13, 30, 0))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "01:30:00 PM")

    def test_timeField_with_inputformat(self):
        "TimeFields with manually specified input formats can accept those formats"
        f = forms.TimeField(input_formats=["%H.%M.%S", "%H.%M"])
        # Parse a time in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('1:30:05 PM')
        with self.assertRaises(forms.ValidationError):
            f.clean('13:30:05')

        # Parse a time in a valid format, get a parsed result
        result = f.clean('13.30.05')
        self.assertEqual(result, time(13, 30, 5))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "01:30:05 PM")

        # Parse a time in a valid format, get a parsed result
        result = f.clean('13.30')
        self.assertEqual(result, time(13, 30, 0))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "01:30:00 PM")

    def test_localized_timeField_with_inputformat(self):
        "Localized TimeFields with manually specified input formats can accept those formats"
        f = forms.TimeField(input_formats=["%H.%M.%S", "%H.%M"], localize=True)
        # Parse a time in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('1:30:05 PM')
        with self.assertRaises(forms.ValidationError):
            f.clean('13:30:05')

        # Parse a time in a valid format, get a parsed result
        result = f.clean('13.30.05')
        self.assertEqual(result, time(13, 30, 5))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "01:30:05 PM")

        # Parse a time in a valid format, get a parsed result
        result = f.clean('13.30')
        self.assertEqual(result, time(13, 30, 0))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "01:30:00 PM")


</source>
</class>

<class classid="242" nclones="4" nlines="17" similarity="77">
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="19" endline="44" pcid="14869">
        "TimeFields can parse dates in the default format"
        f = forms.TimeField()
        # Parse a time in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('1:30:05 PM')

        # Parse a time in a valid format, get a parsed result
        result = f.clean('13:30:05')
        self.assertEqual(result, time(13, 30, 5))

        # The parsed result does a round trip
        text = f.widget.format_value(result)
        self.assertEqual(text, '13:30:05')

        # Parse a time in a valid, but non-default format, get a parsed result
        result = f.clean('13:30')
        self.assertEqual(result, time(13, 30, 0))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "13:30:00")

        # ISO formats are accepted, even if not specified in formats.py
        result = f.clean('13:30:05.000155')
        self.assertEqual(result, time(13, 30, 5, 155))

</source>
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="46" endline="67" pcid="14871">
        "Localized TimeFields act as unlocalized widgets"
        f = forms.TimeField(localize=True)
        # Parse a time in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('1:30:05 PM')

        # Parse a time in a valid format, get a parsed result
        result = f.clean('13:30:05')
        self.assertEqual(result, time(13, 30, 5))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, '13:30:05')

        # Parse a time in a valid format, get a parsed result
        result = f.clean('13:30')
        self.assertEqual(result, time(13, 30, 0))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "13:30:00")

</source>
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="243" endline="264" pcid="14893">
        "Localized TimeFields in a non-localized environment act as unlocalized widgets"
        f = forms.TimeField()
        # Parse a time in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('1:30:05 PM')

        # Parse a time in a valid format, get a parsed result
        result = f.clean('13:30:05')
        self.assertEqual(result, time(13, 30, 5))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "13:30:05")

        # Parse a time in a valid format, get a parsed result
        result = f.clean('13:30')
        self.assertEqual(result, time(13, 30, 0))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "13:30:00")

</source>
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="220" endline="241" pcid="14891">
        "TimeFields can parse dates in the default format"
        f = forms.TimeField()
        # Parse a time in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('1:30:05 PM')

        # Parse a time in a valid format, get a parsed result
        result = f.clean('13:30:05')
        self.assertEqual(result, time(13, 30, 5))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "13:30:05")

        # Parse a time in a valid, but non-default format, get a parsed result
        result = f.clean('13:30')
        self.assertEqual(result, time(13, 30, 0))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "13:30:00")

</source>
</class>

<class classid="243" nclones="2" nlines="20" similarity="90">
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="69" endline="92" pcid="14873">
        "TimeFields with manually specified input formats can accept those formats"
        f = forms.TimeField(input_formats=["%H.%M.%S", "%H.%M"])
        # Parse a time in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('1:30:05 PM')
        with self.assertRaises(forms.ValidationError):
            f.clean('13:30:05')

        # Parse a time in a valid format, get a parsed result
        result = f.clean('13.30.05')
        self.assertEqual(result, time(13, 30, 5))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "13:30:05")

        # Parse a time in a valid format, get a parsed result
        result = f.clean('13.30')
        self.assertEqual(result, time(13, 30, 0))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "13:30:00")

</source>
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="94" endline="118" pcid="14876">
        "Localized TimeFields with manually specified input formats can accept those formats"
        f = forms.TimeField(input_formats=["%H.%M.%S", "%H.%M"], localize=True)
        # Parse a time in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('1:30:05 PM')
        with self.assertRaises(forms.ValidationError):
            f.clean('13:30:05')

        # Parse a time in a valid format, get a parsed result
        result = f.clean('13.30.05')
        self.assertEqual(result, time(13, 30, 5))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "13:30:05")

        # Parse a time in a valid format, get a parsed result
        result = f.clean('13.30')
        self.assertEqual(result, time(13, 30, 0))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "13:30:00")


</source>
</class>

<class classid="244" nclones="4" nlines="16" similarity="75">
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="122" endline="143" pcid="14880">
        "TimeFields can parse dates in the default format"
        f = forms.TimeField()
        # Parse a time in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('13:30:05')

        # Parse a time in a valid format, get a parsed result
        result = f.clean('1:30:05 PM')
        self.assertEqual(result, time(13, 30, 5))

        # The parsed result does a round trip
        text = f.widget.format_value(result)
        self.assertEqual(text, '01:30:05 PM')

        # Parse a time in a valid, but non-default format, get a parsed result
        result = f.clean('1:30 PM')
        self.assertEqual(result, time(13, 30, 0))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "01:30:00 PM")

</source>
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="266" endline="287" pcid="14895">
        "TimeFields with manually specified input formats can accept those formats"
        f = forms.TimeField(input_formats=["%I:%M:%S %p", "%I:%M %p"])
        # Parse a time in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('13:30:05')

        # Parse a time in a valid format, get a parsed result
        result = f.clean('1:30:05 PM')
        self.assertEqual(result, time(13, 30, 5))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "13:30:05")

        # Parse a time in a valid format, get a parsed result
        result = f.clean('1:30 PM')
        self.assertEqual(result, time(13, 30, 0))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "13:30:00")

</source>
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="145" endline="166" pcid="14882">
        "Localized TimeFields act as unlocalized widgets"
        f = forms.TimeField(localize=True)
        # Parse a time in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('13:30:05')

        # Parse a time in a valid format, get a parsed result
        result = f.clean('1:30:05 PM')
        self.assertEqual(result, time(13, 30, 5))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, '01:30:05 PM')

        # Parse a time in a valid format, get a parsed result
        result = f.clean('01:30 PM')
        self.assertEqual(result, time(13, 30, 0))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "01:30:00 PM")

</source>
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="289" endline="311" pcid="14897">
        "Localized TimeFields with manually specified input formats can accept those formats"
        f = forms.TimeField(input_formats=["%I:%M:%S %p", "%I:%M %p"], localize=True)
        # Parse a time in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('13:30:05')

        # Parse a time in a valid format, get a parsed result
        result = f.clean('1:30:05 PM')
        self.assertEqual(result, time(13, 30, 5))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "13:30:05")

        # Parse a time in a valid format, get a parsed result
        result = f.clean('1:30 PM')
        self.assertEqual(result, time(13, 30, 0))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "13:30:00")


</source>
</class>

<class classid="245" nclones="2" nlines="20" similarity="90">
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="168" endline="191" pcid="14884">
        "TimeFields with manually specified input formats can accept those formats"
        f = forms.TimeField(input_formats=["%H.%M.%S", "%H.%M"])
        # Parse a time in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('1:30:05 PM')
        with self.assertRaises(forms.ValidationError):
            f.clean('13:30:05')

        # Parse a time in a valid format, get a parsed result
        result = f.clean('13.30.05')
        self.assertEqual(result, time(13, 30, 5))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "01:30:05 PM")

        # Parse a time in a valid format, get a parsed result
        result = f.clean('13.30')
        self.assertEqual(result, time(13, 30, 0))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "01:30:00 PM")

</source>
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="193" endline="217" pcid="14887">
        "Localized TimeFields with manually specified input formats can accept those formats"
        f = forms.TimeField(input_formats=["%H.%M.%S", "%H.%M"], localize=True)
        # Parse a time in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('1:30:05 PM')
        with self.assertRaises(forms.ValidationError):
            f.clean('13:30:05')

        # Parse a time in a valid format, get a parsed result
        result = f.clean('13.30.05')
        self.assertEqual(result, time(13, 30, 5))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "01:30:05 PM")

        # Parse a time in a valid format, get a parsed result
        result = f.clean('13.30')
        self.assertEqual(result, time(13, 30, 0))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "01:30:00 PM")


</source>
</class>

<class classid="246" nclones="2" nlines="87" similarity="73">
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="314" endline="423" pcid="14899">
    def setUp(self):
        activate('de')

    def tearDown(self):
        deactivate()

    def test_dateField(self):
        "DateFields can parse dates in the default format"
        f = forms.DateField()
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('21/12/2010')

        # ISO formats are accepted, even if not specified in formats.py
        self.assertEqual(f.clean('2010-12-21'), date(2010, 12, 21))

        # Parse a date in a valid format, get a parsed result
        result = f.clean('21.12.2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip
        text = f.widget.format_value(result)
        self.assertEqual(text, '21.12.2010')

        # Parse a date in a valid, but non-default format, get a parsed result
        result = f.clean('21.12.10')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010")

    def test_localized_dateField(self):
        "Localized DateFields act as unlocalized widgets"
        f = forms.DateField(localize=True)
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('21/12/2010')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('21.12.2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, '21.12.2010')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('21.12.10')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010")

    def test_dateField_with_inputformat(self):
        "DateFields with manually specified input formats can accept those formats"
        f = forms.DateField(input_formats=["%m.%d.%Y", "%m-%d-%Y"])
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('2010-12-21')
        with self.assertRaises(forms.ValidationError):
            f.clean('21/12/2010')
        with self.assertRaises(forms.ValidationError):
            f.clean('21.12.2010')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('12.21.2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010")

        # Parse a date in a valid format, get a parsed result
        result = f.clean('12-21-2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010")

    def test_localized_dateField_with_inputformat(self):
        "Localized DateFields with manually specified input formats can accept those formats"
        f = forms.DateField(input_formats=["%m.%d.%Y", "%m-%d-%Y"], localize=True)
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('2010-12-21')
        with self.assertRaises(forms.ValidationError):
            f.clean('21/12/2010')
        with self.assertRaises(forms.ValidationError):
            f.clean('21.12.2010')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('12.21.2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010")

        # Parse a date in a valid format, get a parsed result
        result = f.clean('12-21-2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010")


</source>
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="426" endline="522" pcid="14914">
    def test_dateField(self):
        "DateFields can parse dates in the default format"
        f = forms.DateField()
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('2010-12-21')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('21.12.2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip
        text = f.widget.format_value(result)
        self.assertEqual(text, '21.12.2010')

        # Parse a date in a valid, but non-default format, get a parsed result
        result = f.clean('21-12-2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010")

    def test_localized_dateField(self):
        "Localized DateFields act as unlocalized widgets"
        f = forms.DateField(localize=True)
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('2010-12-21')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('21.12.2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, '21.12.2010')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('21-12-2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010")

    def test_dateField_with_inputformat(self):
        "DateFields with manually specified input formats can accept those formats"
        f = forms.DateField(input_formats=["%m.%d.%Y", "%m-%d-%Y"])
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('21.12.2010')
        with self.assertRaises(forms.ValidationError):
            f.clean('2010-12-21')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('12.21.2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010")

        # Parse a date in a valid format, get a parsed result
        result = f.clean('12-21-2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010")

    def test_localized_dateField_with_inputformat(self):
        "Localized DateFields with manually specified input formats can accept those formats"
        f = forms.DateField(input_formats=["%m.%d.%Y", "%m-%d-%Y"], localize=True)
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('21.12.2010')
        with self.assertRaises(forms.ValidationError):
            f.clean('2010-12-21')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('12.21.2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010")

        # Parse a date in a valid format, get a parsed result
        result = f.clean('12-21-2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010")


</source>
</class>

<class classid="247" nclones="2" nlines="17" similarity="82">
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="321" endline="345" pcid="14902">
        "DateFields can parse dates in the default format"
        f = forms.DateField()
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('21/12/2010')

        # ISO formats are accepted, even if not specified in formats.py
        self.assertEqual(f.clean('2010-12-21'), date(2010, 12, 21))

        # Parse a date in a valid format, get a parsed result
        result = f.clean('21.12.2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip
        text = f.widget.format_value(result)
        self.assertEqual(text, '21.12.2010')

        # Parse a date in a valid, but non-default format, get a parsed result
        result = f.clean('21.12.10')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010")

</source>
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="347" endline="368" pcid="14904">
        "Localized DateFields act as unlocalized widgets"
        f = forms.DateField(localize=True)
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('21/12/2010')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('21.12.2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, '21.12.2010')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('21.12.10')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010")

</source>
</class>

<class classid="248" nclones="2" nlines="24" similarity="91">
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="370" endline="395" pcid="14906">
        "DateFields with manually specified input formats can accept those formats"
        f = forms.DateField(input_formats=["%m.%d.%Y", "%m-%d-%Y"])
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('2010-12-21')
        with self.assertRaises(forms.ValidationError):
            f.clean('21/12/2010')
        with self.assertRaises(forms.ValidationError):
            f.clean('21.12.2010')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('12.21.2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010")

        # Parse a date in a valid format, get a parsed result
        result = f.clean('12-21-2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010")

</source>
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="397" endline="423" pcid="14910">
        "Localized DateFields with manually specified input formats can accept those formats"
        f = forms.DateField(input_formats=["%m.%d.%Y", "%m-%d-%Y"], localize=True)
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('2010-12-21')
        with self.assertRaises(forms.ValidationError):
            f.clean('21/12/2010')
        with self.assertRaises(forms.ValidationError):
            f.clean('21.12.2010')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('12.21.2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010")

        # Parse a date in a valid format, get a parsed result
        result = f.clean('12-21-2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010")


</source>
</class>

<class classid="249" nclones="4" nlines="16" similarity="75">
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="427" endline="448" pcid="14915">
        "DateFields can parse dates in the default format"
        f = forms.DateField()
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('2010-12-21')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('21.12.2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip
        text = f.widget.format_value(result)
        self.assertEqual(text, '21.12.2010')

        # Parse a date in a valid, but non-default format, get a parsed result
        result = f.clean('21-12-2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010")

</source>
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="450" endline="471" pcid="14917">
        "Localized DateFields act as unlocalized widgets"
        f = forms.DateField(localize=True)
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('2010-12-21')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('21.12.2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, '21.12.2010')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('21-12-2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010")

</source>
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="594" endline="616" pcid="14932">
        "Localized DateFields with manually specified input formats can accept those formats"
        f = forms.DateField(input_formats=["%d.%m.%Y", "%d-%m-%Y"], localize=True)
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('2010-12-21')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('21.12.2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "2010-12-21")

        # Parse a date in a valid format, get a parsed result
        result = f.clean('21-12-2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "2010-12-21")


</source>
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="571" endline="592" pcid="14930">
        "DateFields with manually specified input formats can accept those formats"
        f = forms.DateField(input_formats=["%d.%m.%Y", "%d-%m-%Y"])
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('2010-12-21')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('21.12.2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "2010-12-21")

        # Parse a date in a valid format, get a parsed result
        result = f.clean('21-12-2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "2010-12-21")

</source>
</class>

<class classid="250" nclones="2" nlines="20" similarity="90">
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="473" endline="496" pcid="14919">
        "DateFields with manually specified input formats can accept those formats"
        f = forms.DateField(input_formats=["%m.%d.%Y", "%m-%d-%Y"])
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('21.12.2010')
        with self.assertRaises(forms.ValidationError):
            f.clean('2010-12-21')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('12.21.2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010")

        # Parse a date in a valid format, get a parsed result
        result = f.clean('12-21-2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010")

</source>
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="498" endline="522" pcid="14922">
        "Localized DateFields with manually specified input formats can accept those formats"
        f = forms.DateField(input_formats=["%m.%d.%Y", "%m-%d-%Y"], localize=True)
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('21.12.2010')
        with self.assertRaises(forms.ValidationError):
            f.clean('2010-12-21')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('12.21.2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010")

        # Parse a date in a valid format, get a parsed result
        result = f.clean('12-21-2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010")


</source>
</class>

<class classid="251" nclones="2" nlines="16" similarity="93">
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="525" endline="546" pcid="14926">
        "DateFields can parse dates in the default format"
        f = forms.DateField()
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('21.12.2010')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('2010-12-21')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "2010-12-21")

        # Parse a date in a valid, but non-default format, get a parsed result
        result = f.clean('12/21/2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "2010-12-21")

</source>
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="548" endline="569" pcid="14928">
        "Localized DateFields in a non-localized environment act as unlocalized widgets"
        f = forms.DateField()
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('21.12.2010')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('2010-12-21')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "2010-12-21")

        # Parse a date in a valid format, get a parsed result
        result = f.clean('12/21/2010')
        self.assertEqual(result, date(2010, 12, 21))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "2010-12-21")

</source>
</class>

<class classid="252" nclones="2" nlines="17" similarity="82">
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="626" endline="650" pcid="14937">
        "DateTimeFields can parse dates in the default format"
        f = forms.DateTimeField()
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('1:30:05 PM 21/12/2010')

        # ISO formats are accepted, even if not specified in formats.py
        self.assertEqual(f.clean('2010-12-21 13:30:05'), datetime(2010, 12, 21, 13, 30, 5))

        # Parse a date in a valid format, get a parsed result
        result = f.clean('21.12.2010 13:30:05')
        self.assertEqual(result, datetime(2010, 12, 21, 13, 30, 5))

        # The parsed result does a round trip
        text = f.widget.format_value(result)
        self.assertEqual(text, '21.12.2010 13:30:05')

        # Parse a date in a valid, but non-default format, get a parsed result
        result = f.clean('21.12.2010 13:30')
        self.assertEqual(result, datetime(2010, 12, 21, 13, 30))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010 13:30:00")

</source>
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="652" endline="673" pcid="14939">
        "Localized DateTimeFields act as unlocalized widgets"
        f = forms.DateTimeField(localize=True)
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('1:30:05 PM 21/12/2010')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('21.12.2010 13:30:05')
        self.assertEqual(result, datetime(2010, 12, 21, 13, 30, 5))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, '21.12.2010 13:30:05')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('21.12.2010 13:30')
        self.assertEqual(result, datetime(2010, 12, 21, 13, 30))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010 13:30:00")

</source>
</class>

<class classid="253" nclones="2" nlines="24" similarity="87">
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="675" endline="700" pcid="14941">
        "DateTimeFields with manually specified input formats can accept those formats"
        f = forms.DateTimeField(input_formats=["%H.%M.%S %m.%d.%Y", "%H.%M %m-%d-%Y"])
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('2010-12-21 13:30:05 13:30:05')
        with self.assertRaises(forms.ValidationError):
            f.clean('1:30:05 PM 21/12/2010')
        with self.assertRaises(forms.ValidationError):
            f.clean('13:30:05 21.12.2010')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('13.30.05 12.21.2010')
        self.assertEqual(result, datetime(2010, 12, 21, 13, 30, 5))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010 13:30:05")

        # Parse a date in a valid format, get a parsed result
        result = f.clean('13.30 12-21-2010')
        self.assertEqual(result, datetime(2010, 12, 21, 13, 30))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010 13:30:00")

</source>
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="702" endline="728" pcid="14945">
        "Localized DateTimeFields with manually specified input formats can accept those formats"
        f = forms.DateTimeField(input_formats=["%H.%M.%S %m.%d.%Y", "%H.%M %m-%d-%Y"], localize=True)
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('2010-12-21 13:30:05')
        with self.assertRaises(forms.ValidationError):
            f.clean('1:30:05 PM 21/12/2010')
        with self.assertRaises(forms.ValidationError):
            f.clean('13:30:05 21.12.2010')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('13.30.05 12.21.2010')
        self.assertEqual(result, datetime(2010, 12, 21, 13, 30, 5))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010 13:30:05")

        # Parse a date in a valid format, get a parsed result
        result = f.clean('13.30 12-21-2010')
        self.assertEqual(result, datetime(2010, 12, 21, 13, 30))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "21.12.2010 13:30:00")


</source>
</class>

<class classid="254" nclones="2" nlines="16" similarity="87">
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="732" endline="753" pcid="14950">
        "DateTimeFields can parse dates in the default format"
        f = forms.DateTimeField()
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('2010-12-21 13:30:05')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('1:30:05 PM 21/12/2010')
        self.assertEqual(result, datetime(2010, 12, 21, 13, 30, 5))

        # The parsed result does a round trip
        text = f.widget.format_value(result)
        self.assertEqual(text, '01:30:05 PM 21/12/2010')

        # Parse a date in a valid, but non-default format, get a parsed result
        result = f.clean('1:30 PM 21-12-2010')
        self.assertEqual(result, datetime(2010, 12, 21, 13, 30))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "01:30:00 PM 21/12/2010")

</source>
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="755" endline="776" pcid="14952">
        "Localized DateTimeFields act as unlocalized widgets"
        f = forms.DateTimeField(localize=True)
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('2010-12-21 13:30:05')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('1:30:05 PM 21/12/2010')
        self.assertEqual(result, datetime(2010, 12, 21, 13, 30, 5))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, '01:30:05 PM 21/12/2010')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('1:30 PM 21-12-2010')
        self.assertEqual(result, datetime(2010, 12, 21, 13, 30))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "01:30:00 PM 21/12/2010")

</source>
</class>

<class classid="255" nclones="2" nlines="20" similarity="90">
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="778" endline="801" pcid="14954">
        "DateTimeFields with manually specified input formats can accept those formats"
        f = forms.DateTimeField(input_formats=["%m.%d.%Y %H:%M:%S", "%m-%d-%Y %H:%M"])
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('13:30:05 21.12.2010')
        with self.assertRaises(forms.ValidationError):
            f.clean('2010-12-21 13:30:05')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('12.21.2010 13:30:05')
        self.assertEqual(result, datetime(2010, 12, 21, 13, 30, 5))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "01:30:05 PM 21/12/2010")

        # Parse a date in a valid format, get a parsed result
        result = f.clean('12-21-2010 13:30')
        self.assertEqual(result, datetime(2010, 12, 21, 13, 30))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "01:30:00 PM 21/12/2010")

</source>
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="803" endline="827" pcid="14957">
        "Localized DateTimeFields with manually specified input formats can accept those formats"
        f = forms.DateTimeField(input_formats=["%m.%d.%Y %H:%M:%S", "%m-%d-%Y %H:%M"], localize=True)
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('13:30:05 21.12.2010')
        with self.assertRaises(forms.ValidationError):
            f.clean('2010-12-21 13:30:05')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('12.21.2010 13:30:05')
        self.assertEqual(result, datetime(2010, 12, 21, 13, 30, 5))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "01:30:05 PM 21/12/2010")

        # Parse a date in a valid format, get a parsed result
        result = f.clean('12-21-2010 13:30')
        self.assertEqual(result, datetime(2010, 12, 21, 13, 30))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "01:30:00 PM 21/12/2010")


</source>
</class>

<class classid="256" nclones="2" nlines="16" similarity="93">
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="830" endline="851" pcid="14961">
        "DateTimeFields can parse dates in the default format"
        f = forms.DateTimeField()
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('13:30:05 21.12.2010')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('2010-12-21 13:30:05')
        self.assertEqual(result, datetime(2010, 12, 21, 13, 30, 5))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "2010-12-21 13:30:05")

        # Parse a date in a valid, but non-default format, get a parsed result
        result = f.clean('12/21/2010 13:30:05')
        self.assertEqual(result, datetime(2010, 12, 21, 13, 30, 5))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "2010-12-21 13:30:05")

</source>
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="853" endline="874" pcid="14963">
        "Localized DateTimeFields in a non-localized environment act as unlocalized widgets"
        f = forms.DateTimeField()
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('13:30:05 21.12.2010')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('2010-12-21 13:30:05')
        self.assertEqual(result, datetime(2010, 12, 21, 13, 30, 5))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "2010-12-21 13:30:05")

        # Parse a date in a valid format, get a parsed result
        result = f.clean('12/21/2010 13:30:05')
        self.assertEqual(result, datetime(2010, 12, 21, 13, 30, 5))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "2010-12-21 13:30:05")

</source>
</class>

<class classid="257" nclones="2" nlines="16" similarity="87">
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="876" endline="897" pcid="14965">
        "DateTimeFields with manually specified input formats can accept those formats"
        f = forms.DateTimeField(input_formats=["%I:%M:%S %p %d.%m.%Y", "%I:%M %p %d-%m-%Y"])
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('2010-12-21 13:30:05')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('1:30:05 PM 21.12.2010')
        self.assertEqual(result, datetime(2010, 12, 21, 13, 30, 5))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "2010-12-21 13:30:05")

        # Parse a date in a valid format, get a parsed result
        result = f.clean('1:30 PM 21-12-2010')
        self.assertEqual(result, datetime(2010, 12, 21, 13, 30))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "2010-12-21 13:30:00")

</source>
<source file="django/tests/forms_tests/tests/test_input_formats.py.pyindent" startline="899" endline="919" pcid="14967">
        "Localized DateTimeFields with manually specified input formats can accept those formats"
        f = forms.DateTimeField(input_formats=["%I:%M:%S %p %d.%m.%Y", "%I:%M %p %d-%m-%Y"], localize=True)
        # Parse a date in an unaccepted format; get an error
        with self.assertRaises(forms.ValidationError):
            f.clean('2010-12-21 13:30:05')

        # Parse a date in a valid format, get a parsed result
        result = f.clean('1:30:05 PM 21.12.2010')
        self.assertEqual(result, datetime(2010, 12, 21, 13, 30, 5))

        # The parsed result does a round trip to the same format
        text = f.widget.format_value(result)
        self.assertEqual(text, "2010-12-21 13:30:05")

        # Parse a date in a valid format, get a parsed result
        result = f.clean('1:30 PM 21-12-2010')
        self.assertEqual(result, datetime(2010, 12, 21, 13, 30))

        # The parsed result does a round trip to default format
        text = f.widget.format_value(result)
        self.assertEqual(text, "2010-12-21 13:30:00")
</source>
</class>

<class classid="258" nclones="2" nlines="30" similarity="80">
<source file="django/tests/forms_tests/tests/test_media.py.pyindent" startline="301" endline="328" pcid="15010">
        # A widget can explicitly enable full media inheritance by specifying 'extend=True'
        class MyWidget1(TextInput):
            class Media:
                css = {
                    'all': ('path/to/css1', '/path/to/css2')
                }
                js = ('/path/to/js1', 'http://media.other.com/path/to/js2', 'https://secure.other.com/path/to/js3')

        class MyWidget11(MyWidget1):
            class Media:
                extend = True
                css = {
                    'all': ('/path/to/css3', 'path/to/css1')
                }
                js = ('/path/to/js1', '/path/to/js4')

        w11 = MyWidget11()
        self.assertEqual(
            str(w11.media),
            """<link href="/path/to/css3" type="text/css" media="all" rel="stylesheet">
<link href="http://media.example.com/static/path/to/css1" type="text/css" media="all" rel="stylesheet">
<link href="/path/to/css2" type="text/css" media="all" rel="stylesheet">
<script type="text/javascript" src="/path/to/js1"></script>
<script type="text/javascript" src="http://media.other.com/path/to/js2"></script>
<script type="text/javascript" src="https://secure.other.com/path/to/js3"></script>
<script type="text/javascript" src="/path/to/js4"></script>"""
        )

</source>
<source file="django/tests/forms_tests/tests/test_media.py.pyindent" startline="330" endline="355" pcid="15015">
        # A widget can enable inheritance of one media type by specifying extend as a tuple
        class MyWidget1(TextInput):
            class Media:
                css = {
                    'all': ('path/to/css1', '/path/to/css2')
                }
                js = ('/path/to/js1', 'http://media.other.com/path/to/js2', 'https://secure.other.com/path/to/js3')

        class MyWidget12(MyWidget1):
            class Media:
                extend = ('css',)
                css = {
                    'all': ('/path/to/css3', 'path/to/css1')
                }
                js = ('/path/to/js1', '/path/to/js4')

        w12 = MyWidget12()
        self.assertEqual(
            str(w12.media),
            """<link href="/path/to/css3" type="text/css" media="all" rel="stylesheet">
<link href="http://media.example.com/static/path/to/css1" type="text/css" media="all" rel="stylesheet">
<link href="/path/to/css2" type="text/css" media="all" rel="stylesheet">
<script type="text/javascript" src="/path/to/js1"></script>
<script type="text/javascript" src="/path/to/js4"></script>"""
        )

</source>
</class>

<class classid="259" nclones="2" nlines="15" similarity="86">
<source file="django/tests/forms_tests/widget_tests/test_checkboxselectmultiple.py.pyindent" startline="122" endline="138" pcid="15104">
        """
        Each input gets a separate ID.
        """
        choices = [('a', 'A'), ('b', 'B'), ('c', 'C')]
        html = """
        <ul id="abc">
        <li>
        <label for="abc_0"><input checked type="checkbox" name="letters" value="a" id="abc_0"> A</label>
        </li>
        <li><label for="abc_1"><input type="checkbox" name="letters" value="b" id="abc_1"> B</label></li>
        <li>
        <label for="abc_2"><input checked type="checkbox" name="letters" value="c" id="abc_2"> C</label>
        </li>
        </ul>
        """
        self.check_html(self.widget(choices=choices), 'letters', ['a', 'c'], attrs={'id': 'abc'}, html=html)

</source>
<source file="django/tests/forms_tests/widget_tests/test_checkboxselectmultiple.py.pyindent" startline="140" endline="156" pcid="15105">
        """
        Each input gets a separate ID when the ID is passed to the constructor.
        """
        widget = CheckboxSelectMultiple(attrs={'id': 'abc'}, choices=[('a', 'A'), ('b', 'B'), ('c', 'C')])
        html = """
        <ul id="abc">
        <li>
        <label for="abc_0"><input checked type="checkbox" name="letters" value="a" id="abc_0"> A</label>
        </li>
        <li><label for="abc_1"><input type="checkbox" name="letters" value="b" id="abc_1"> B</label></li>
        <li>
        <label for="abc_2"><input checked type="checkbox" name="letters" value="c" id="abc_2"> C</label>
        </li>
        </ul>
        """
        self.check_html(widget, 'letters', ['a', 'c'], html=html)

</source>
</class>

<class classid="260" nclones="2" nlines="26" similarity="73">
<source file="django/tests/forms_tests/widget_tests/test_checkboxselectmultiple.py.pyindent" startline="159" endline="184" pcid="15106">
        choices = [
            (1, 'One'),
            (1000, 'One thousand'),
            (1000000, 'One million'),
        ]
        html = """
        <ul>
        <li><label><input type="checkbox" name="numbers" value="1"> One</label></li>
        <li><label><input type="checkbox" name="numbers" value="1000"> One thousand</label></li>
        <li><label><input type="checkbox" name="numbers" value="1000000"> One million</label></li>
        </ul>
        """
        self.check_html(self.widget(choices=choices), 'numbers', None, html=html)

        choices = [
            (datetime.time(0, 0), 'midnight'),
            (datetime.time(12, 0), 'noon'),
        ]
        html = """
        <ul>
        <li><label><input type="checkbox" name="times" value="00:00:00"> midnight</label></li>
        <li><label><input type="checkbox" name="times" value="12:00:00"> noon</label></li>
        </ul>
        """
        self.check_html(self.widget(choices=choices), 'times', None, html=html)

</source>
<source file="django/tests/forms_tests/widget_tests/test_radioselect.py.pyindent" startline="108" endline="133" pcid="15212">
        choices = [
            (1, 'One'),
            (1000, 'One thousand'),
            (1000000, 'One million'),
        ]
        html = """
        <ul>
        <li><label><input type="radio" name="number" value="1"> One</label></li>
        <li><label><input type="radio" name="number" value="1000"> One thousand</label></li>
        <li><label><input type="radio" name="number" value="1000000"> One million</label></li>
        </ul>
        """
        self.check_html(self.widget(choices=choices), 'number', None, html=html)

        choices = [
            (datetime.time(0, 0), 'midnight'),
            (datetime.time(12, 0), 'noon'),
        ]
        html = """
        <ul>
        <li><label><input type="radio" name="time" value="00:00:00"> midnight</label></li>
        <li><label><input type="radio" name="time" value="12:00:00"> noon</label></li>
        </ul>
        """
        self.check_html(self.widget(choices=choices), 'time', None, html=html)

</source>
</class>

<class classid="261" nclones="2" nlines="11" similarity="90">
<source file="django/tests/forms_tests/widget_tests/test_clearablefileinput.py.pyindent" startline="123" endline="129" pcid="15124">
            @property
            def url(self):
                raise ValueError('Canary')

            def __str__(self):
                return 'value'

</source>
<source file="django/tests/forms_tests/widget_tests/test_clearablefileinput.py.pyindent" startline="135" endline="141" pcid="15129">
            @property
            def url(self):
                return 'https://www.python.org/'

            def __str__(self):
                return 'value'

</source>
</class>

<class classid="262" nclones="3" nlines="10" similarity="80">
<source file="django/tests/forms_tests/widget_tests/test_select.py.pyindent" startline="188" endline="200" pcid="15227">
        """
        Choices can be nested one level in order to create HTML optgroups.
        """
        self.check_html(self.nested_widget, 'nestchoice', None, html=(
            """<select name="nestchoice">
            <option value="outer1">Outer 1</option>
            <optgroup label="Group &quot;1&quot;">
            <option value="inner1">Inner 1</option>
            <option value="inner2">Inner 2</option>
            </optgroup>
            </select>"""
        ))

</source>
<source file="django/tests/forms_tests/widget_tests/test_select.py.pyindent" startline="213" endline="222" pcid="15229">
        self.check_html(self.nested_widget, 'nestchoice', 'inner1', html=(
            """<select name="nestchoice">
            <option value="outer1">Outer 1</option>
            <optgroup label="Group &quot;1&quot;">
            <option value="inner1" selected>Inner 1</option>
            <option value="inner2">Inner 2</option>
            </optgroup>
            </select>"""
        ))

</source>
<source file="django/tests/forms_tests/widget_tests/test_select.py.pyindent" startline="202" endline="211" pcid="15228">
        self.check_html(self.nested_widget, 'nestchoice', 'outer1', html=(
            """<select name="nestchoice">
            <option value="outer1" selected>Outer 1</option>
            <optgroup label="Group &quot;1&quot;">
            <option value="inner1">Inner 1</option>
            <option value="inner2">Inner 2</option>
            </optgroup>
            </select>"""
        ))

</source>
</class>

<class classid="263" nclones="6" nlines="65" similarity="74">
<source file="django/tests/forms_tests/widget_tests/test_selectdatewidget.py.pyindent" startline="18" endline="86" pcid="15241">
        self.check_html(self.widget, 'mydate', '', html=(
            """
            <select name="mydate_month" id="id_mydate_month">
                <option selected value="">---</option>
                <option value="1">January</option>
                <option value="2">February</option>
                <option value="3">March</option>
                <option value="4">April</option>
                <option value="5">May</option>
                <option value="6">June</option>
                <option value="7">July</option>
                <option value="8">August</option>
                <option value="9">September</option>
                <option value="10">October</option>
                <option value="11">November</option>
                <option value="12">December</option>
            </select>

            <select name="mydate_day" id="id_mydate_day">
                <option selected value="">---</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
                <option value="6">6</option>
                <option value="7">7</option>
                <option value="8">8</option>
                <option value="9">9</option>
                <option value="10">10</option>
                <option value="11">11</option>
                <option value="12">12</option>
                <option value="13">13</option>
                <option value="14">14</option>
                <option value="15">15</option>
                <option value="16">16</option>
                <option value="17">17</option>
                <option value="18">18</option>
                <option value="19">19</option>
                <option value="20">20</option>
                <option value="21">21</option>
                <option value="22">22</option>
                <option value="23">23</option>
                <option value="24">24</option>
                <option value="25">25</option>
                <option value="26">26</option>
                <option value="27">27</option>
                <option value="28">28</option>
                <option value="29">29</option>
                <option value="30">30</option>
                <option value="31">31</option>
            </select>

            <select name="mydate_year" id="id_mydate_year">
                <option selected value="">---</option>
                <option value="2007">2007</option>
                <option value="2008">2008</option>
                <option value="2009">2009</option>
                <option value="2010">2010</option>
                <option value="2011">2011</option>
                <option value="2012">2012</option>
                <option value="2013">2013</option>
                <option value="2014">2014</option>
                <option value="2015">2015</option>
                <option value="2016">2016</option>
            </select>
            """
        ))

</source>
<source file="django/tests/forms_tests/widget_tests/test_selectdatewidget.py.pyindent" startline="246" endline="306" pcid="15246">
        widget = SelectDateWidget(months=MONTHS_AP, years=('2013',))
        self.check_html(widget, 'mydate', '', html=(
            """
            <select name="mydate_month" id="id_mydate_month">
                <option selected value="">---</option>
                <option value="1">Jan.</option>
                <option value="2">Feb.</option>
                <option value="3">March</option>
                <option value="4">April</option>
                <option value="5">May</option>
                <option value="6">June</option>
                <option value="7">July</option>
                <option value="8">Aug.</option>
                <option value="9">Sept.</option>
                <option value="10">Oct.</option>
                <option value="11">Nov.</option>
                <option value="12">Dec.</option>
            </select>

            <select name="mydate_day" id="id_mydate_day">
                <option selected value="">---</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
                <option value="6">6</option>
                <option value="7">7</option>
                <option value="8">8</option>
                <option value="9">9</option>
                <option value="10">10</option>
                <option value="11">11</option>
                <option value="12">12</option>
                <option value="13">13</option>
                <option value="14">14</option>
                <option value="15">15</option>
                <option value="16">16</option>
                <option value="17">17</option>
                <option value="18">18</option>
                <option value="19">19</option>
                <option value="20">20</option>
                <option value="21">21</option>
                <option value="22">22</option>
                <option value="23">23</option>
                <option value="24">24</option>
                <option value="25">25</option>
                <option value="26">26</option>
                <option value="27">27</option>
                <option value="28">28</option>
                <option value="29">29</option>
                <option value="30">30</option>
                <option value="31">31</option>
            </select>

            <select name="mydate_year" id="id_mydate_year">
                <option selected value="">---</option>
                <option value="2013">2013</option>
            </select>
            """
        ))

</source>
<source file="django/tests/forms_tests/widget_tests/test_selectdatewidget.py.pyindent" startline="535" endline="592" pcid="15264">
        widget = SelectDateWidget(years=(2007,))
        self.check_html(widget, 'mydate', '', html=(
            """
            <select name="mydate_month" id="id_mydate_month">
                <option selected value="">---</option>
                <option value="1">January</option>
                <option value="2">February</option>
                <option value="3">March</option>
                <option value="4">April</option>
                <option value="5">May</option>
                <option value="6">June</option>
                <option value="7">July</option>
                <option value="8">August</option>
                <option value="9">September</option>
                <option value="10">October</option>
                <option value="11">November</option>
                <option value="12">December</option>
            </select>
            <select name="mydate_day" id="id_mydate_day">
                <option selected value="">---</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
                <option value="6">6</option>
                <option value="7">7</option>
                <option value="8">8</option>
                <option value="9">9</option>
                <option value="10">10</option>
                <option value="11">11</option>
                <option value="12">12</option>
                <option value="13">13</option>
                <option value="14">14</option>
                <option value="15">15</option>
                <option value="16">16</option>
                <option value="17">17</option>
                <option value="18">18</option>
                <option value="19">19</option>
                <option value="20">20</option>
                <option value="21">21</option>
                <option value="22">22</option>
                <option value="23">23</option>
                <option value="24">24</option>
                <option value="25">25</option>
                <option value="26">26</option>
                <option value="27">27</option>
                <option value="28">28</option>
                <option value="29">29</option>
                <option value="30">30</option>
                <option value="31">31</option>
            </select>
            <select name="mydate_year" id="id_mydate_year">
                <option selected value="">---</option>
                <option value="2007">2007</option>
            </select>
            """
        ))
</source>
<source file="django/tests/forms_tests/widget_tests/test_selectdatewidget.py.pyindent" startline="173" endline="244" pcid="15245">
        """
        Invalid dates should still render the failed date.
        """
        self.check_html(self.widget, 'mydate', '2010-02-31', html=(
            """
            <select name="mydate_month" id="id_mydate_month">
                <option value="">---</option>
                <option value="1">January</option>
                <option value="2" selected>February</option>
                <option value="3">March</option>
                <option value="4">April</option>
                <option value="5">May</option>
                <option value="6">June</option>
                <option value="7">July</option>
                <option value="8">August</option>
                <option value="9">September</option>
                <option value="10">October</option>
                <option value="11">November</option>
                <option value="12">December</option>
            </select>

            <select name="mydate_day" id="id_mydate_day">
                <option value="">---</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
                <option value="6">6</option>
                <option value="7">7</option>
                <option value="8">8</option>
                <option value="9">9</option>
                <option value="10">10</option>
                <option value="11">11</option>
                <option value="12">12</option>
                <option value="13">13</option>
                <option value="14">14</option>
                <option value="15">15</option>
                <option value="16">16</option>
                <option value="17">17</option>
                <option value="18">18</option>
                <option value="19">19</option>
                <option value="20">20</option>
                <option value="21">21</option>
                <option value="22">22</option>
                <option value="23">23</option>
                <option value="24">24</option>
                <option value="25">25</option>
                <option value="26">26</option>
                <option value="27">27</option>
                <option value="28">28</option>
                <option value="29">29</option>
                <option value="30">30</option>
                <option value="31" selected>31</option>
            </select>

            <select name="mydate_year" id="id_mydate_year">
                <option value="">---</option>
                <option value="2007">2007</option>
                <option value="2008">2008</option>
                <option value="2009">2009</option>
                <option value="2010" selected>2010</option>
                <option value="2011">2011</option>
                <option value="2012">2012</option>
                <option value="2013">2013</option>
                <option value="2014">2014</option>
                <option value="2015">2015</option>
                <option value="2016">2016</option>
            </select>
            """
        ))

</source>
<source file="django/tests/forms_tests/widget_tests/test_selectdatewidget.py.pyindent" startline="318" endline="389" pcid="15250">
        w = SelectDateWidget(years=('2014',), empty_label='empty_label')

        # Rendering the default state with empty_label set as string.
        self.assertInHTML('<option selected value="">empty_label</option>', w.render('mydate', ''), count=3)

        w = SelectDateWidget(years=('2014',), empty_label=('empty_year', 'empty_month', 'empty_day'))

        # Rendering the default state with empty_label tuple.
        self.assertHTMLEqual(
            w.render('mydate', ''),
            """
            <select name="mydate_month" id="id_mydate_month">
                <option selected value="">empty_month</option>
                <option value="1">January</option>
                <option value="2">February</option>
                <option value="3">March</option>
                <option value="4">April</option>
                <option value="5">May</option>
                <option value="6">June</option>
                <option value="7">July</option>
                <option value="8">August</option>
                <option value="9">September</option>
                <option value="10">October</option>
                <option value="11">November</option>
                <option value="12">December</option>
            </select>

            <select name="mydate_day" id="id_mydate_day">
                <option selected value="">empty_day</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
                <option value="6">6</option>
                <option value="7">7</option>
                <option value="8">8</option>
                <option value="9">9</option>
                <option value="10">10</option>
                <option value="11">11</option>
                <option value="12">12</option>
                <option value="13">13</option>
                <option value="14">14</option>
                <option value="15">15</option>
                <option value="16">16</option>
                <option value="17">17</option>
                <option value="18">18</option>
                <option value="19">19</option>
                <option value="20">20</option>
                <option value="21">21</option>
                <option value="22">22</option>
                <option value="23">23</option>
                <option value="24">24</option>
                <option value="25">25</option>
                <option value="26">26</option>
                <option value="27">27</option>
                <option value="28">28</option>
                <option value="29">29</option>
                <option value="30">30</option>
                <option value="31">31</option>
            </select>

            <select name="mydate_year" id="id_mydate_year">
                <option selected value="">empty_year</option>
                <option value="2014">2014</option>
            </select>
            """,
        )

        with self.assertRaisesMessage(ValueError, 'empty_label list/tuple must have 3 elements.'):
            SelectDateWidget(years=('2014',), empty_label=('not enough', 'values'))

</source>
<source file="django/tests/forms_tests/widget_tests/test_selectdatewidget.py.pyindent" startline="97" endline="165" pcid="15243">
        self.check_html(self.widget, 'mydate', '2010-04-15', html=(
            """
            <select name="mydate_month" id="id_mydate_month">
                <option value="">---</option>
                <option value="1">January</option>
                <option value="2">February</option>
                <option value="3">March</option>
                <option value="4" selected>April</option>
                <option value="5">May</option>
                <option value="6">June</option>
                <option value="7">July</option>
                <option value="8">August</option>
                <option value="9">September</option>
                <option value="10">October</option>
                <option value="11">November</option>
                <option value="12">December</option>
            </select>

            <select name="mydate_day" id="id_mydate_day">
                <option value="">---</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
                <option value="6">6</option>
                <option value="7">7</option>
                <option value="8">8</option>
                <option value="9">9</option>
                <option value="10">10</option>
                <option value="11">11</option>
                <option value="12">12</option>
                <option value="13">13</option>
                <option value="14">14</option>
                <option value="15" selected>15</option>
                <option value="16">16</option>
                <option value="17">17</option>
                <option value="18">18</option>
                <option value="19">19</option>
                <option value="20">20</option>
                <option value="21">21</option>
                <option value="22">22</option>
                <option value="23">23</option>
                <option value="24">24</option>
                <option value="25">25</option>
                <option value="26">26</option>
                <option value="27">27</option>
                <option value="28">28</option>
                <option value="29">29</option>
                <option value="30">30</option>
                <option value="31">31</option>
            </select>

            <select name="mydate_year" id="id_mydate_year">
                <option value="">---</option>
                <option value="2007">2007</option>
                <option value="2008">2008</option>
                <option value="2009">2009</option>
                <option value="2010" selected>2010</option>
                <option value="2011">2011</option>
                <option value="2012">2012</option>
                <option value="2013">2013</option>
                <option value="2014">2014</option>
                <option value="2015">2015</option>
                <option value="2016">2016</option>
            </select>
            """
        ))

</source>
</class>

<class classid="264" nclones="3" nlines="17" similarity="70">
<source file="django/tests/generic_inline_admin/tests.py.pyindent" startline="121" endline="138" pcid="15364">
        """
        With extra=0, there should be one form.
        """
        class ExtraInline(GenericTabularInline):
            model = Media
            extra = 0

        modeladmin = admin.ModelAdmin(Episode, admin_site)
        modeladmin.inlines = [ExtraInline]

        e = self._create_object(Episode)
        request = self.factory.get(reverse('admin:generic_inline_admin_episode_change', args=(e.pk,)))
        request.user = User(username='super', is_superuser=True)
        response = modeladmin.changeform_view(request, object_id=str(e.pk))
        formset = response.context_data['inline_admin_formsets'][0].formset
        self.assertEqual(formset.total_form_count(), 1)
        self.assertEqual(formset.initial_form_count(), 1)

</source>
<source file="django/tests/generic_inline_admin/tests.py.pyindent" startline="140" endline="158" pcid="15366">
        """
        With extra=5 and max_num=2, there should be only 2 forms.
        """
        class MaxNumInline(GenericTabularInline):
            model = Media
            extra = 5
            max_num = 2

        modeladmin = admin.ModelAdmin(Episode, admin_site)
        modeladmin.inlines = [MaxNumInline]

        e = self._create_object(Episode)
        request = self.factory.get(reverse('admin:generic_inline_admin_episode_change', args=(e.pk,)))
        request.user = User(username='super', is_superuser=True)
        response = modeladmin.changeform_view(request, object_id=str(e.pk))
        formset = response.context_data['inline_admin_formsets'][0].formset
        self.assertEqual(formset.total_form_count(), 2)
        self.assertEqual(formset.initial_form_count(), 1)

</source>
<source file="django/tests/generic_inline_admin/tests.py.pyindent" startline="160" endline="178" pcid="15368">
        """
        With extra=3 and min_num=2, there should be five forms.
        """
        class MinNumInline(GenericTabularInline):
            model = Media
            extra = 3
            min_num = 2

        modeladmin = admin.ModelAdmin(Episode, admin_site)
        modeladmin.inlines = [MinNumInline]

        e = self._create_object(Episode)
        request = self.factory.get(reverse('admin:generic_inline_admin_episode_change', args=(e.pk,)))
        request.user = User(username='super', is_superuser=True)
        response = modeladmin.changeform_view(request, object_id=str(e.pk))
        formset = response.context_data['inline_admin_formsets'][0].formset
        self.assertEqual(formset.total_form_count(), 5)
        self.assertEqual(formset.initial_form_count(), 1)

</source>
</class>

<class classid="265" nclones="3" nlines="19" similarity="73">
<source file="django/tests/generic_inline_admin/tests.py.pyindent" startline="180" endline="197" pcid="15370">

        class GetExtraInline(GenericTabularInline):
            model = Media
            extra = 4

            def get_extra(self, request, obj):
                return 2

        modeladmin = admin.ModelAdmin(Episode, admin_site)
        modeladmin.inlines = [GetExtraInline]
        e = self._create_object(Episode)
        request = self.factory.get(reverse('admin:generic_inline_admin_episode_change', args=(e.pk,)))
        request.user = User(username='super', is_superuser=True)
        response = modeladmin.changeform_view(request, object_id=str(e.pk))
        formset = response.context_data['inline_admin_formsets'][0].formset

        self.assertEqual(formset.extra, 2)

</source>
<source file="django/tests/generic_inline_admin/tests.py.pyindent" startline="218" endline="236" pcid="15376">

        class GetMaxNumInline(GenericTabularInline):
            model = Media
            extra = 5

            def get_max_num(self, request, obj):
                return 2

        modeladmin = admin.ModelAdmin(Episode, admin_site)
        modeladmin.inlines = [GetMaxNumInline]
        e = self._create_object(Episode)
        request = self.factory.get(reverse('admin:generic_inline_admin_episode_change', args=(e.pk,)))
        request.user = User(username='super', is_superuser=True)
        response = modeladmin.changeform_view(request, object_id=str(e.pk))
        formset = response.context_data['inline_admin_formsets'][0].formset

        self.assertEqual(formset.max_num, 2)


</source>
<source file="django/tests/generic_inline_admin/tests.py.pyindent" startline="199" endline="216" pcid="15373">

        class GetMinNumInline(GenericTabularInline):
            model = Media
            min_num = 5

            def get_min_num(self, request, obj):
                return 2

        modeladmin = admin.ModelAdmin(Episode, admin_site)
        modeladmin.inlines = [GetMinNumInline]
        e = self._create_object(Episode)
        request = self.factory.get(reverse('admin:generic_inline_admin_episode_change', args=(e.pk,)))
        request.user = User(username='super', is_superuser=True)
        response = modeladmin.changeform_view(request, object_id=str(e.pk))
        formset = response.context_data['inline_admin_formsets'][0].formset

        self.assertEqual(formset.min_num, 2)

</source>
</class>

<class classid="266" nclones="2" nlines="11" similarity="81">
<source file="django/tests/generic_relations/tests.py.pyindent" startline="248" endline="256" pcid="15458">
        bacon = Vegetable.objects.create(name="Bacon", is_yucky=False)
        t1 = TaggedItem.objects.create(content_object=self.quartz, tag="shiny")
        t2 = TaggedItem.objects.create(content_object=self.quartz, tag="clearish")
        # One update() query.
        with self.assertNumQueries(1):
            bacon.tags.add(t1, t2)
        self.assertEqual(t1.content_object, bacon)
        self.assertEqual(t2.content_object, bacon)

</source>
<source file="django/tests/generic_relations/tests.py.pyindent" startline="258" endline="266" pcid="15460">
        bacon = Vegetable.objects.create(name="Bacon", is_yucky=False)
        t1 = TaggedItem.objects.create(content_object=self.quartz, tag="shiny")
        t2 = TaggedItem.objects.create(content_object=self.quartz, tag="clearish")
        # One save() for each object.
        with self.assertNumQueries(2):
            bacon.tags.add(t1, t2, bulk=False)
        self.assertEqual(t1.content_object, bacon)
        self.assertEqual(t2.content_object, bacon)

</source>
</class>

<class classid="267" nclones="2" nlines="14" similarity="85">
<source file="django/tests/generic_relations/test_forms.py.pyindent" startline="177" endline="189" pcid="15511">
        Formset = generic_inlineformset_factory(ForProxyModelModel, fields='__all__', for_concrete_model=False)
        instance = ProxyRelatedModel.objects.create()
        data = {
            'form-TOTAL_FORMS': '1',
            'form-INITIAL_FORMS': '0',
            'form-MAX_NUM_FORMS': '',
            'form-0-title': 'foo',
        }
        formset = Formset(data, instance=instance, prefix='form')
        self.assertTrue(formset.is_valid())
        new_obj, = formset.save()
        self.assertEqual(new_obj.obj, instance)

</source>
<source file="django/tests/generic_relations/test_forms.py.pyindent" startline="191" endline="203" pcid="15512">
        Formset = generic_inlineformset_factory(ForProxyModelModel, fields='__all__', for_concrete_model=True)
        instance = ProxyRelatedModel.objects.create()
        data = {
            'form-TOTAL_FORMS': '1',
            'form-INITIAL_FORMS': '0',
            'form-MAX_NUM_FORMS': '',
            'form-0-title': 'foo',
        }
        formset = Formset(data, instance=instance, prefix='form')
        self.assertTrue(formset.is_valid())
        new_obj, = formset.save()
        self.assertNotIsInstance(new_obj.obj, ProxyRelatedModel)

</source>
</class>

<class classid="268" nclones="2" nlines="12" similarity="75">
<source file="django/tests/generic_views/test_base.py.pyindent" startline="316" endline="336" pcid="15661">
        """
        A template view can be cached
        """
        response = self.client.get('/template/cached/bar/')
        self.assertEqual(response.status_code, 200)

        time.sleep(1.0)

        response2 = self.client.get('/template/cached/bar/')
        self.assertEqual(response2.status_code, 200)

        self.assertEqual(response.content, response2.content)

        time.sleep(2.0)

        # Let the cache expire and test again
        response2 = self.client.get('/template/cached/bar/')
        self.assertEqual(response2.status_code, 200)

        self.assertNotEqual(response.content, response2.content)

</source>
<source file="django/tests/template_tests/test_response.py.pyindent" startline="345" endline="361" pcid="26309">
        response = self.client.get('/template_response_view/')
        self.assertEqual(response.status_code, 200)

        time.sleep(1.0)

        response2 = self.client.get('/template_response_view/')
        self.assertEqual(response2.status_code, 200)

        self.assertEqual(response.content, response2.content)

        time.sleep(2.0)

        # Let the cache expire and test again
        response2 = self.client.get('/template_response_view/')
        self.assertEqual(response2.status_code, 200)

        self.assertNotEqual(response.content, response2.content)
</source>
</class>

<class classid="269" nclones="3" nlines="13" similarity="73">
<source file="django/tests/generic_views/test_dates.py.pyindent" startline="22" endline="37" pcid="15696">

    @classmethod
    def setUpTestData(cls):
        cls.artist1 = Artist.objects.create(name='Rene Magritte')
        cls.author1 = Author.objects.create(name='Roberto Bolaño', slug='roberto-bolano')
        cls.author2 = Author.objects.create(name='Scott Rosenberg', slug='scott-rosenberg')
        cls.book1 = Book.objects.create(name='2066', slug='2066', pages=800, pubdate=datetime.date(2008, 10, 1))
        cls.book1.authors.add(cls.author1)
        cls.book2 = Book.objects.create(
            name='Dreaming in Code', slug='dreaming-in-code', pages=300, pubdate=datetime.date(2006, 5, 1)
        )
        cls.page1 = Page.objects.create(
            content='I was once bitten by a moose.', template='generic_views/page_template.html'
        )


</source>
<source file="django/tests/generic_views/test_list.py.pyindent" startline="15" endline="26" pcid="15866">
        cls.artist1 = Artist.objects.create(name='Rene Magritte')
        cls.author1 = Author.objects.create(name='Roberto Bolaño', slug='roberto-bolano')
        cls.author2 = Author.objects.create(name='Scott Rosenberg', slug='scott-rosenberg')
        cls.book1 = Book.objects.create(name='2066', slug='2066', pages=800, pubdate=datetime.date(2008, 10, 1))
        cls.book1.authors.add(cls.author1)
        cls.book2 = Book.objects.create(
            name='Dreaming in Code', slug='dreaming-in-code', pages=300, pubdate=datetime.date(2006, 5, 1)
        )
        cls.page1 = Page.objects.create(
            content='I was once bitten by a moose.', template='generic_views/page_template.html'
        )

</source>
<source file="django/tests/generic_views/test_detail.py.pyindent" startline="18" endline="29" pcid="15783">
        cls.artist1 = Artist.objects.create(name='Rene Magritte')
        cls.author1 = Author.objects.create(name='Roberto Bolaño', slug='roberto-bolano')
        cls.author2 = Author.objects.create(name='Scott Rosenberg', slug='scott-rosenberg')
        cls.book1 = Book.objects.create(name='2066', slug='2066', pages=800, pubdate=datetime.date(2008, 10, 1))
        cls.book1.authors.add(cls.author1)
        cls.book2 = Book.objects.create(
            name='Dreaming in Code', slug='dreaming-in-code', pages=300, pubdate=datetime.date(2006, 5, 1)
        )
        cls.page1 = Page.objects.create(
            content='I was once bitten by a moose.', template='generic_views/page_template.html'
        )

</source>
</class>

<class classid="270" nclones="2" nlines="13" similarity="76">
<source file="django/tests/generic_views/test_dates.py.pyindent" startline="637" endline="651" pcid="15766">
        bs = BookSigning.objects.create(event_date=datetime.datetime(2008, 4, 2, 12, 0, tzinfo=timezone.utc))
        res = self.client.get('/dates/booksignings/2008/apr/2/')
        self.assertEqual(res.status_code, 200)
        # 2008-04-02T00:00:00+03:00 (beginning of day) > 2008-04-01T22:00:00+00:00 (book signing event date)
        bs.event_date = datetime.datetime(2008, 4, 1, 22, 0, tzinfo=timezone.utc)
        bs.save()
        res = self.client.get('/dates/booksignings/2008/apr/2/')
        self.assertEqual(res.status_code, 200)
        # 2008-04-03T00:00:00+03:00 (end of day) > 2008-04-02T22:00:00+00:00 (book signing event date)
        bs.event_date = datetime.datetime(2008, 4, 2, 22, 0, tzinfo=timezone.utc)
        bs.save()
        res = self.client.get('/dates/booksignings/2008/apr/2/')
        self.assertEqual(res.status_code, 404)


</source>
<source file="django/tests/generic_views/test_dates.py.pyindent" startline="733" endline="745" pcid="15781">
        bs = BookSigning.objects.create(event_date=datetime.datetime(2008, 4, 2, 12, 0, tzinfo=timezone.utc))
        res = self.client.get('/dates/booksignings/2008/apr/2/%d/' % bs.pk)
        self.assertEqual(res.status_code, 200)
        # 2008-04-02T00:00:00+03:00 (beginning of day) > 2008-04-01T22:00:00+00:00 (book signing event date)
        bs.event_date = datetime.datetime(2008, 4, 1, 22, 0, tzinfo=timezone.utc)
        bs.save()
        res = self.client.get('/dates/booksignings/2008/apr/2/%d/' % bs.pk)
        self.assertEqual(res.status_code, 200)
        # 2008-04-03T00:00:00+03:00 (end of day) > 2008-04-02T22:00:00+00:00 (book signing event date)
        bs.event_date = datetime.datetime(2008, 4, 2, 22, 0, tzinfo=timezone.utc)
        bs.save()
        res = self.client.get('/dates/booksignings/2008/apr/2/%d/' % bs.pk)
        self.assertEqual(res.status_code, 404)
</source>
</class>

<class classid="271" nclones="2" nlines="13" similarity="76">
<source file="django/tests/generic_views/test_edit.py.pyindent" startline="193" endline="202" pcid="15841">
        class MyCreateView(CreateView):
            model = Author

        message = (
            "Using ModelFormMixin (base class of MyCreateView) without the "
            "'fields' attribute is prohibited."
        )
        with self.assertRaisesMessage(ImproperlyConfigured, message):
            MyCreateView().get_form_class()

</source>
<source file="django/tests/generic_views/test_edit.py.pyindent" startline="204" endline="213" pcid="15844">
        class MyCreateView(CreateView):
            model = Author
            form_class = AuthorForm
            fields = ['name']

        message = "Specifying both 'fields' and 'form_class' is not permitted."
        with self.assertRaisesMessage(ImproperlyConfigured, message):
            MyCreateView().get_form_class()


</source>
</class>

<class classid="272" nclones="2" nlines="19" similarity="73">
<source file="django/tests/generic_views/test_edit.py.pyindent" startline="218" endline="238" pcid="15848">
        a = Author.objects.create(
            name='Randall Munroe',
            slug='randall-munroe',
        )
        res = self.client.get('/edit/author/%d/update/' % a.pk)
        self.assertEqual(res.status_code, 200)
        self.assertIsInstance(res.context['form'], forms.ModelForm)
        self.assertEqual(res.context['object'], Author.objects.get(pk=a.pk))
        self.assertEqual(res.context['author'], Author.objects.get(pk=a.pk))
        self.assertTemplateUsed(res, 'generic_views/author_form.html')
        self.assertEqual(res.context['view'].get_form_called_count, 1)

        # Modification with both POST and PUT (browser compatible)
        res = self.client.post(
            '/edit/author/%d/update/' % a.pk,
            {'name': 'Randall Munroe (xkcd)', 'slug': 'randall-munroe'}
        )
        self.assertEqual(res.status_code, 302)
        self.assertRedirects(res, '/list/authors/')
        self.assertQuerysetEqual(Author.objects.all(), ['<Author: Randall Munroe (xkcd)>'])

</source>
<source file="django/tests/generic_views/test_edit.py.pyindent" startline="330" endline="349" pcid="15856">
        a = Author.objects.create(
            pk=1,
            name='Randall Munroe',
            slug='randall-munroe',
        )
        res = self.client.get('/edit/author/update/')
        self.assertEqual(res.status_code, 200)
        self.assertIsInstance(res.context['form'], forms.ModelForm)
        self.assertIsInstance(res.context['view'], View)
        self.assertEqual(res.context['object'], Author.objects.get(pk=a.pk))
        self.assertEqual(res.context['author'], Author.objects.get(pk=a.pk))
        self.assertTemplateUsed(res, 'generic_views/author_form.html')

        # Modification with both POST and PUT (browser compatible)
        res = self.client.post('/edit/author/update/', {'name': 'Randall Munroe (xkcd)', 'slug': 'randall-munroe'})
        self.assertEqual(res.status_code, 302)
        self.assertRedirects(res, '/list/authors/')
        self.assertQuerysetEqual(Author.objects.all(), ['<Author: Randall Munroe (xkcd)>'])


</source>
</class>

<class classid="273" nclones="3" nlines="10" similarity="70">
<source file="django/tests/generic_views/test_list.py.pyindent" startline="69" endline="77" pcid="15871">
        self._make_authors(100)
        res = self.client.get('/list/authors/paginated/', {'page': '2'})
        self.assertEqual(res.status_code, 200)
        self.assertTemplateUsed(res, 'generic_views/author_list.html')
        self.assertEqual(len(res.context['object_list']), 30)
        self.assertIs(res.context['author_list'], res.context['object_list'])
        self.assertEqual(res.context['author_list'][0].name, 'Author 30')
        self.assertEqual(res.context['page_obj'].number, 2)

</source>
<source file="django/tests/generic_views/test_list.py.pyindent" startline="88" endline="96" pcid="15873">
        self._make_authors(100)
        res = self.client.get('/list/authors/paginated/3/')
        self.assertEqual(res.status_code, 200)
        self.assertTemplateUsed(res, 'generic_views/author_list.html')
        self.assertEqual(len(res.context['object_list']), 30)
        self.assertIs(res.context['author_list'], res.context['object_list'])
        self.assertEqual(res.context['author_list'][0].name, 'Author 60')
        self.assertEqual(res.context['page_obj'].number, 3)

</source>
<source file="django/tests/generic_views/test_list.py.pyindent" startline="116" endline="124" pcid="15877">
        self._make_authors(100)
        res = self.client.get('/list/authors/paginated/custom_page_kwarg/', {'pagina': '2'})
        self.assertEqual(res.status_code, 200)
        self.assertTemplateUsed(res, 'generic_views/author_list.html')
        self.assertEqual(len(res.context['object_list']), 30)
        self.assertIs(res.context['author_list'], res.context['object_list'])
        self.assertEqual(res.context['author_list'][0].name, 'Author 30')
        self.assertEqual(res.context['page_obj'].number, 2)

</source>
</class>

<class classid="274" nclones="2" nlines="10" similarity="100">
<source file="django/tests/generic_views/views.py.pyindent" startline="121" endline="129" pcid="15923">
    model = Author
    form_class = AuthorForm
    template_name = 'generic_views/form.html'
    context_object_name = 'thingy'

    def get_success_url(self):
        return reverse('author_detail', args=[self.object.id])


</source>
<source file="django/tests/generic_views/views.py.pyindent" startline="164" endline="172" pcid="15932">
    model = Author
    form_class = AuthorForm
    template_name = 'generic_views/form.html'
    context_object_name = 'thingy'

    def get_success_url(self):
        return reverse('author_detail', args=[self.object.id])


</source>
</class>

<class classid="275" nclones="2" nlines="14" similarity="78">
<source file="django/tests/get_earliest_or_latest/tests.py.pyindent" startline="205" endline="213" pcid="15999">
            # We know that we've broken the __iter__ method, so the queryset
            # should always raise an exception.
            with self.assertRaises(IndexError):
                IndexErrorArticle.objects.all()[:10:2]
            with self.assertRaises(IndexError):
                IndexErrorArticle.objects.all().first()
            with self.assertRaises(IndexError):
                IndexErrorArticle.objects.all().last()

</source>
<source file="django/tests/gis_tests/geos_tests/test_mutable_list.py.pyindent" startline="228" endline="234" pcid="16750">
            with self.assertRaises(IndexError):  # 'set index %d' % i)
                setfcn(ul, i)
            with self.assertRaises(IndexError):  # 'get index %d' % i)
                getfcn(ul, i)
            with self.assertRaises(IndexError):  # 'del index %d' % i)
                delfcn(ul, i)

</source>
</class>

<class classid="276" nclones="2" nlines="16" similarity="75">
<source file="django/tests/get_or_create/tests.py.pyindent" startline="140" endline="160" pcid="16050">
        """
        If you have a field named defaults and want to use it as an exact
        lookup, you need to use 'defaults__exact'.
        """
        obj, created = Person.objects.get_or_create(
            first_name='George', last_name='Harrison', defaults__exact='testing', defaults={
                'birthday': date(1943, 2, 25),
                'defaults': 'testing',
            }
        )
        self.assertTrue(created)
        self.assertEqual(obj.defaults, 'testing')
        obj2, created = Person.objects.get_or_create(
            first_name='George', last_name='Harrison', defaults__exact='testing', defaults={
                'birthday': date(1943, 2, 25),
                'defaults': 'testing',
            }
        )
        self.assertFalse(created)
        self.assertEqual(obj, obj2)

</source>
<source file="django/tests/get_or_create/tests.py.pyindent" startline="414" endline="434" pcid="16093">
        """
        If you have a field named defaults and want to use it as an exact
        lookup, you need to use 'defaults__exact'.
        """
        obj, created = Person.objects.update_or_create(
            first_name='George', last_name='Harrison', defaults__exact='testing', defaults={
                'birthday': date(1943, 2, 25),
                'defaults': 'testing',
            }
        )
        self.assertTrue(created)
        self.assertEqual(obj.defaults, 'testing')
        obj, created = Person.objects.update_or_create(
            first_name='George', last_name='Harrison', defaults__exact='testing', defaults={
                'birthday': date(1943, 2, 25),
                'defaults': 'another testing',
            }
        )
        self.assertFalse(created)
        self.assertEqual(obj.defaults, 'another testing')

</source>
</class>

<class classid="277" nclones="3" nlines="10" similarity="80">
<source file="django/tests/get_or_create/tests.py.pyindent" startline="173" endline="179" pcid="16052">
        def raise_exception():
            raise AssertionError
        obj, created = Person.objects.get_or_create(
            first_name="John", last_name="Lennon",
            defaults={"birthday": lambda: raise_exception()},
        )

</source>
<source file="django/tests/get_or_create/tests.py.pyindent" startline="181" endline="189" pcid="16054">
        """`defaults` aren't evaluated if the instance isn't created."""
        def raise_exception():
            raise AssertionError
        obj, created = Person.objects.get_or_create(
            first_name='John', defaults=lazy(raise_exception, object)(),
        )
        self.assertFalse(created)


</source>
<source file="django/tests/get_or_create/tests.py.pyindent" startline="455" endline="467" pcid="16096">
        """`defaults` aren't evaluated if the instance isn't created."""
        Person.objects.create(
            first_name='John', last_name='Lennon', birthday=date(1940, 10, 9)
        )

        def raise_exception():
            raise AssertionError
        obj, created = Person.objects.get_or_create(
            first_name='John', defaults=lazy(raise_exception, object)(),
        )
        self.assertFalse(created)


</source>
</class>

<class classid="278" nclones="2" nlines="11" similarity="90">
<source file="django/tests/get_or_create/tests.py.pyindent" startline="205" endline="216" pcid="16060">
        """
        get_or_create should raise IntegrityErrors with the full traceback.
        This is tested by checking that a known method call is in the traceback.
        We cannot use assertRaises here because we need to inspect
        the actual traceback. Refs #16340.
        """
        try:
            ManualPrimaryKeyTest.objects.get_or_create(id=1, data="Different")
        except IntegrityError:
            formatted_traceback = traceback.format_exc()
            self.assertIn('obj.save', formatted_traceback)

</source>
<source file="django/tests/get_or_create/tests.py.pyindent" startline="350" endline="361" pcid="16086">
        """
        update_or_create should raise IntegrityErrors with the full traceback.
        This is tested by checking that a known method call is in the traceback.
        We cannot use assertRaises/assertRaises here because we need to inspect
        the actual traceback. Refs #16340.
        """
        try:
            ManualPrimaryKeyTest.objects.update_or_create(id=1, data="Different")
        except IntegrityError:
            formatted_traceback = traceback.format_exc()
            self.assertIn('obj.save', formatted_traceback)

</source>
</class>

<class classid="279" nclones="2" nlines="11" similarity="81">
<source file="django/tests/get_or_create/tests.py.pyindent" startline="509" endline="515" pcid="16105">
            # timeout after ~0.5 seconds
            for i in range(20):
                time.sleep(0.025)
                if lock_status['has_grabbed_lock']:
                    return True
            return False

</source>
<source file="django/tests/get_or_create/tests.py.pyindent" startline="566" endline="573" pcid="16114">
            # timeout after ~0.5 seconds
            for i in range(20):
                time.sleep(0.025)
                if lock_status['lock_count'] == expected_lock_count:
                    return True
            self.skipTest('Database took too long to lock the row')

        # update_or_create in a separate thread.
</source>
</class>

<class classid="280" nclones="2" nlines="11" similarity="72">
<source file="django/tests/gis_tests/distapp/tests.py.pyindent" startline="323" endline="327" pcid="16180">
            for i, c in enumerate(qs):
                with self.subTest(c=c):
                    self.assertAlmostEqual(m_distances[i], c.distance.m, tol)
                    self.assertAlmostEqual(ft_distances[i], c.distance.survey_ft, tol)

</source>
<source file="django/tests/gis_tests/distapp/tests.py.pyindent" startline="380" endline="387" pcid="16189">
            # PostGIS uses sphere-only distances by default, testing these as well.
            qs = AustraliaCity.objects.exclude(id=hillsdale.id).annotate(
                distance=Distance('point', hillsdale.point)
            ).order_by('id')
            for i, c in enumerate(qs):
                with self.subTest(c=c):
                    self.assertAlmostEqual(sphere_distances[i], c.distance.m, tol)

</source>
</class>

<class classid="281" nclones="2" nlines="10" similarity="70">
<source file="django/tests/gis_tests/gdal_tests/test_driver.py.pyindent" startline="37" endline="41" pcid="16215">
        "Testing invalid GDAL/OGR Data Source Drivers."
        for i in invalid_drivers:
            with self.assertRaises(GDALException):
                Driver(i)

</source>
<source file="django/tests/gis_tests/gdal_tests/test_ds.py.pyindent" startline="89" endline="93" pcid="16231">
        "Testing invalid SHP files for the Data Source."
        for source in bad_ds:
            with self.assertRaises(GDALException):
                DataSource(source.ds)

</source>
</class>

<class classid="282" nclones="3" nlines="12" similarity="75">
<source file="django/tests/gis_tests/geoapp/test_functions.py.pyindent" startline="193" endline="201" pcid="16510">
        geom = Point(5, 23, srid=4326)
        qs = Country.objects.annotate(diff=functions.Difference('mpoly', geom))
        # Oracle does something screwy with the Texas geometry.
        if oracle:
            qs = qs.exclude(name='Texas')

        for c in qs:
            self.assertTrue(c.mpoly.difference(geom).equals(c.diff))

</source>
<source file="django/tests/gis_tests/geoapp/test_functions.py.pyindent" startline="204" endline="212" pcid="16513">
        """Testing with mixed SRID (Country has default 4326)."""
        geom = Point(556597.4, 2632018.6, srid=3857)  # Spherical Mercator
        qs = Country.objects.annotate(difference=functions.Difference('mpoly', geom))
        # Oracle does something screwy with the Texas geometry.
        if oracle:
            qs = qs.exclude(name='Texas')
        for c in qs:
            self.assertTrue(c.mpoly.difference(geom).equals(c.difference))

</source>
<source file="django/tests/gis_tests/geoapp/test_functions.py.pyindent" startline="472" endline="479" pcid="16560">
        geom = Point(5, 23, srid=4326)
        qs = Country.objects.annotate(sym_difference=functions.SymDifference('mpoly', geom))
        # Oracle does something screwy with the Texas geometry.
        if oracle:
            qs = qs.exclude(name='Texas')
        for country in qs:
            self.assertTrue(country.mpoly.sym_difference(geom).equals(country.sym_difference))

</source>
</class>

<class classid="283" nclones="2" nlines="13" similarity="84">
<source file="django/tests/gis_tests/geoapp/test_functions.py.pyindent" startline="221" endline="232" pcid="16518">
        rings = (
            ((0, 0), (5, 0), (0, 5), (0, 0)),
            ((1, 1), (1, 3), (3, 1), (1, 1)),
        )
        rhr_rings = (
            ((0, 0), (0, 5), (5, 0), (0, 0)),
            ((1, 1), (3, 1), (1, 3), (1, 1)),
        )
        State.objects.create(name='Foo', poly=Polygon(*rings))
        st = State.objects.annotate(force_polygon_cw=functions.ForcePolygonCW('poly')).get(name='Foo')
        self.assertEqual(rhr_rings, st.force_polygon_cw.coords)

</source>
<source file="django/tests/gis_tests/geoapp/test_functions.py.pyindent" startline="236" endline="247" pcid="16519">
        rings = (
            ((0, 0), (5, 0), (0, 5), (0, 0)),
            ((1, 1), (1, 3), (3, 1), (1, 1)),
        )
        rhr_rings = (
            ((0, 0), (0, 5), (5, 0), (0, 0)),
            ((1, 1), (3, 1), (1, 3), (1, 1)),
        )
        State.objects.create(name='Foo', poly=Polygon(*rings))
        st = State.objects.annotate(force_rhr=functions.ForceRHR('poly')).get(name='Foo')
        self.assertEqual(rhr_rings, st.force_rhr.coords)

</source>
</class>

<class classid="284" nclones="2" nlines="13" similarity="76">
<source file="django/tests/gis_tests/geoapp/test_functions.py.pyindent" startline="397" endline="402" pcid="16551">
            for p1, p2 in zip(country.mpoly, country.scaled):
                for r1, r2 in zip(p1, p2):
                    for c1, c2 in zip(r1.coords, r2.coords):
                        self.assertAlmostEqual(c1[0] * xfac, c2[0], tol)
                        self.assertAlmostEqual(c1[1] * yfac, c2[1], tol)
        # Test float/Decimal values
</source>
<source file="django/tests/gis_tests/geoapp/test_functions.py.pyindent" startline="498" endline="505" pcid="16565">
            for p1, p2 in zip(c.mpoly, c.translated):
                for r1, r2 in zip(p1, p2):
                    for c1, c2 in zip(r1.coords, r2.coords):
                        # The low precision is for SpatiaLite
                        self.assertAlmostEqual(c1[0] + xfac, c2[0], 5)
                        self.assertAlmostEqual(c1[1] + yfac, c2[1], 5)

    # Some combined function tests
</source>
</class>

<class classid="285" nclones="2" nlines="12" similarity="91">
<source file="django/tests/gis_tests/gis_migrations/test_operations.py.pyindent" startline="108" endline="121" pcid="16834">
        """
        Test the AddField operation with a geometry-enabled column.
        """
        self.alter_gis_model(migrations.AddField, 'Neighborhood', 'path', False, fields.LineStringField)
        self.assertColumnExists('gis_neighborhood', 'path')

        # Test GeometryColumns when available
        if HAS_GEOMETRY_COLUMNS:
            self.assertGeometryColumnsCount(2)

        # Test spatial indices when available
        if self.has_spatial_indexes:
            self.assertSpatialIndexExists('gis_neighborhood', 'path')

</source>
<source file="django/tests/gis_tests/gis_migrations/test_operations.py.pyindent" startline="135" endline="148" pcid="16839">
        """
        Should be able to add a GeometryField with blank=True.
        """
        self.alter_gis_model(migrations.AddField, 'Neighborhood', 'path', True, fields.LineStringField)
        self.assertColumnExists('gis_neighborhood', 'path')

        # Test GeometryColumns when available
        if HAS_GEOMETRY_COLUMNS:
            self.assertGeometryColumnsCount(2)

        # Test spatial indices when available
        if self.has_spatial_indexes:
            self.assertSpatialIndexExists('gis_neighborhood', 'path')

</source>
</class>

<class classid="286" nclones="2" nlines="15" similarity="80">
<source file="django/tests/gis_tests/test_geoforms.py.pyindent" startline="258" endline="269" pcid="17067">
        class LineStringForm(forms.Form):
            f = forms.LineStringField()

        geom = self.geometries['linestring']
        form = LineStringForm(data={'f': geom})
        self.assertTextarea(geom, form.as_p())
        self.assertMapWidget(form)
        self.assertFalse(LineStringForm().is_valid())

        for invalid in [geo for key, geo in self.geometries.items() if key != 'linestring']:
            self.assertFalse(LineStringForm(data={'p': invalid.wkt}).is_valid())

</source>
<source file="django/tests/gis_tests/test_geoforms.py.pyindent" startline="271" endline="282" pcid="17070">
        class LineStringForm(forms.Form):
            f = forms.MultiLineStringField()

        geom = self.geometries['multilinestring']
        form = LineStringForm(data={'f': geom})
        self.assertTextarea(geom, form.as_p())
        self.assertMapWidget(form)
        self.assertFalse(LineStringForm().is_valid())

        for invalid in [geo for key, geo in self.geometries.items() if key != 'multilinestring']:
            self.assertFalse(LineStringForm(data={'p': invalid.wkt}).is_valid())

</source>
</class>

<class classid="287" nclones="2" nlines="15" similarity="80">
<source file="django/tests/gis_tests/test_geoforms.py.pyindent" startline="284" endline="295" pcid="17073">
        class PolygonForm(forms.Form):
            p = forms.PolygonField()

        geom = self.geometries['polygon']
        form = PolygonForm(data={'p': geom})
        self.assertTextarea(geom, form.as_p())
        self.assertMapWidget(form)
        self.assertFalse(PolygonForm().is_valid())

        for invalid in [geo for key, geo in self.geometries.items() if key != 'polygon']:
            self.assertFalse(PolygonForm(data={'p': invalid.wkt}).is_valid())

</source>
<source file="django/tests/gis_tests/test_geoforms.py.pyindent" startline="297" endline="308" pcid="17076">
        class PolygonForm(forms.Form):
            p = forms.MultiPolygonField()

        geom = self.geometries['multipolygon']
        form = PolygonForm(data={'p': geom})
        self.assertTextarea(geom, form.as_p())
        self.assertMapWidget(form)
        self.assertFalse(PolygonForm().is_valid())

        for invalid in [geo for key, geo in self.geometries.items() if key != 'multipolygon']:
            self.assertFalse(PolygonForm(data={'p': invalid.wkt}).is_valid())

</source>
</class>

<class classid="288" nclones="2" nlines="13" similarity="84">
<source file="django/tests/handlers/tests.py.pyindent" startline="99" endline="106" pcid="17241">
        old_atomic_requests = connection.settings_dict['ATOMIC_REQUESTS']
        try:
            connection.settings_dict['ATOMIC_REQUESTS'] = True
            response = self.client.get('/in_transaction/')
        finally:
            connection.settings_dict['ATOMIC_REQUESTS'] = old_atomic_requests
        self.assertContains(response, 'True')

</source>
<source file="django/tests/handlers/tests.py.pyindent" startline="108" endline="116" pcid="17244">
        old_atomic_requests = connection.settings_dict['ATOMIC_REQUESTS']
        try:
            connection.settings_dict['ATOMIC_REQUESTS'] = True
            response = self.client.get('/not_in_transaction/')
        finally:
            connection.settings_dict['ATOMIC_REQUESTS'] = old_atomic_requests
        self.assertContains(response, 'False')


</source>
</class>

<class classid="289" nclones="2" nlines="11" similarity="75">
<source file="django/tests/handlers/tests_custom_error_handlers.py.pyindent" startline="8" endline="18" pcid="17266">
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        response = self.get_response(request)
        # Response.content should be available in the middleware even with a
        # TemplateResponse-based exception response.
        assert response.content
        return response


</source>
<source file="django/tests/middleware_exceptions/middleware.py.pyindent" startline="9" endline="15" pcid="18940">
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        return self.get_response(request)


</source>
</class>

<class classid="290" nclones="4" nlines="10" similarity="72">
<source file="django/tests/i18n/patterns/tests.py.pyindent" startline="46" endline="58" pcid="17417">
    """
    TestCase base-class for the URL tests.
    """

    def setUp(self):
        # Make sure the cache is empty before we are doing our tests.
        clear_url_caches()

    def tearDown(self):
        # Make sure we will leave an empty cache for other testcases.
        clear_url_caches()


</source>
<source file="django/tests/transactions/tests.py.pyindent" startline="221" endline="230" pcid="27040">
    """All basic tests for atomic should also pass within an existing transaction."""

    def setUp(self):
        self.atomic = transaction.atomic()
        self.atomic.__enter__()

    def tearDown(self):
        self.atomic.__exit__(*sys.exc_info())


</source>
<source file="django/tests/template_tests/syntax_tests/i18n/base.py.pyindent" startline="15" endline="24" pcid="24985">
    """
    Tests for template rendering when multiple locales are activated during the
    lifetime of the same process.
    """

    def setUp(self):
        self._old_language = get_language()

    def tearDown(self):
        activate(self._old_language)
</source>
<source file="django/tests/transactions/tests.py.pyindent" startline="236" endline="247" pcid="27043">
    """All basic tests for atomic should also pass when autocommit is turned off."""

    def setUp(self):
        transaction.set_autocommit(False)

    def tearDown(self):
        # The tests access the database after exercising 'atomic', initiating
        # a transaction ; a rollback is required before restoring autocommit.
        transaction.rollback()
        transaction.set_autocommit(True)


</source>
</class>

<class classid="291" nclones="2" nlines="16" similarity="75">
<source file="django/tests/indexes/tests.py.pyindent" startline="75" endline="87" pcid="17543">
    available_apps = ['indexes']

    def test_create_index_ignores_opclasses(self):
        index = Index(
            name='test_ops_class',
            fields=['headline'],
            opclasses=['varchar_pattern_ops'],
        )
        with connection.schema_editor() as editor:
            # This would error if opclasses weren't ignored.
            editor.add_index(IndexedArticle2, index)


</source>
<source file="django/tests/indexes/tests.py.pyindent" startline="115" endline="125" pcid="17549">
        index = Index(
            name='test_ops_class',
            fields=['headline'],
            opclasses=['varchar_pattern_ops'],
        )
        with connection.schema_editor() as editor:
            editor.add_index(IndexedArticle2, index)
        with editor.connection.cursor() as cursor:
            cursor.execute(self.get_opclass_query % 'test_ops_class')
            self.assertEqual(cursor.fetchall(), [('varchar_pattern_ops', 'test_ops_class')])

</source>
</class>

<class classid="292" nclones="2" nlines="21" similarity="76">
<source file="django/tests/inline_formsets/tests.py.pyindent" startline="28" endline="54" pcid="17573">
        """
        Make sure that an add form that is filled out, but marked for deletion
        doesn't cause validation errors.
        """
        PoemFormSet = inlineformset_factory(Poet, Poem, can_delete=True, fields="__all__")
        poet = Poet.objects.create(name='test')
        data = {
            'poem_set-TOTAL_FORMS': '1',
            'poem_set-INITIAL_FORMS': '0',
            'poem_set-MAX_NUM_FORMS': '0',
            'poem_set-0-id': '',
            'poem_set-0-poem': '1',
            'poem_set-0-name': 'x' * 1000,
        }
        formset = PoemFormSet(data, instance=poet)
        # Make sure this form doesn't pass validation.
        self.assertIs(formset.is_valid(), False)
        self.assertEqual(Poem.objects.count(), 0)

        # Then make sure that it *does* pass validation and delete the object,
        # even though the data isn't actually valid.
        data['poem_set-0-DELETE'] = 'on'
        formset = PoemFormSet(data, instance=poet)
        self.assertIs(formset.is_valid(), True)
        formset.save()
        self.assertEqual(Poem.objects.count(), 0)

</source>
<source file="django/tests/inline_formsets/tests.py.pyindent" startline="56" endline="83" pcid="17574">
        """
        Make sure that a change form that is filled out, but marked for deletion
        doesn't cause validation errors.
        """
        PoemFormSet = inlineformset_factory(Poet, Poem, can_delete=True, fields="__all__")
        poet = Poet.objects.create(name='test')
        poem = poet.poem_set.create(name='test poem')
        data = {
            'poem_set-TOTAL_FORMS': '1',
            'poem_set-INITIAL_FORMS': '1',
            'poem_set-MAX_NUM_FORMS': '0',
            'poem_set-0-id': str(poem.id),
            'poem_set-0-poem': str(poem.id),
            'poem_set-0-name': 'x' * 1000,
        }
        formset = PoemFormSet(data, instance=poet)
        # Make sure this form doesn't pass validation.
        self.assertIs(formset.is_valid(), False)
        self.assertEqual(Poem.objects.count(), 1)

        # Then make sure that it *does* pass validation and delete the object,
        # even though the data isn't actually valid.
        data['poem_set-0-DELETE'] = 'on'
        formset = PoemFormSet(data, instance=poet)
        self.assertIs(formset.is_valid(), True)
        formset.save()
        self.assertEqual(Poem.objects.count(), 0)

</source>
</class>

<class classid="293" nclones="15" nlines="16" similarity="72">
<source file="django/tests/invalid_models_tests/test_models.py.pyindent" startline="32" endline="43" pcid="17686">
        class Model(models.Model):
            class Meta:
                index_together = 42

        self.assertEqual(Model.check(), [
            Error(
                "'index_together' must be a list or tuple.",
                obj=Model,
                id='models.E008',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_models.py.pyindent" startline="154" endline="165" pcid="17712">
        class Model(models.Model):
            class Meta:
                unique_together = 'not-a-list'

        self.assertEqual(Model.check(), [
            Error(
                "'unique_together' must be a list or tuple.",
                obj=Model,
                id='models.E010',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_models.py.pyindent" startline="71" endline="82" pcid="17695">
        class Model(models.Model):
            class Meta:
                index_together = [['missing_field']]

        self.assertEqual(Model.check(), [
            Error(
                "'index_together' refers to the nonexistent field 'missing_field'.",
                obj=Model,
                id='models.E012',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_models.py.pyindent" startline="748" endline="759" pcid="17816">
        class Model(models.Model):
            class Meta:
                swappable = 'TEST_SWAPPED_MODEL_BAD_MODEL'

        self.assertEqual(Model.check(), [
            Error(
                "'TEST_SWAPPED_MODEL_BAD_MODEL' references 'not_an_app.Target', "
                'which has not been installed, or is abstract.',
                id='models.E002',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_models.py.pyindent" startline="138" endline="152" pcid="17709">
        class Model(models.Model):
            one = models.IntegerField()
            two = models.IntegerField()

            class Meta:
                unique_together = [('a', 'b'), 42]

        self.assertEqual(Model.check(), [
            Error(
                "All 'unique_together' elements must be lists or tuples.",
                obj=Model,
                id='models.E011',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_models.py.pyindent" startline="58" endline="69" pcid="17692">
        class Model(models.Model):
            class Meta:
                index_together = [('a', 'b'), 42]

        self.assertEqual(Model.check(), [
            Error(
                "All 'index_together' elements must be lists or tuples.",
                obj=Model,
                id='models.E009',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_models.py.pyindent" startline="45" endline="56" pcid="17689">
        class Model(models.Model):
            class Meta:
                index_together = 'not-a-list'

        self.assertEqual(Model.check(), [
            Error(
                "'index_together' must be a list or tuple.",
                obj=Model,
                id='models.E008',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_models.py.pyindent" startline="224" endline="238" pcid="17728">
        class Model(models.Model):
            m2m = models.ManyToManyField('self')

            class Meta:
                indexes = [models.Index(fields=['m2m'], name='name')]

        self.assertEqual(Model.check(), [
            Error(
                "'indexes' refers to a ManyToManyField 'm2m', but "
                "ManyToManyFields are not permitted in 'indexes'.",
                obj=Model,
                id='models.E013',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_models.py.pyindent" startline="191" endline="206" pcid="17721">
        class Model(models.Model):
            m2m = models.ManyToManyField('self')

            class Meta:
                unique_together = [['m2m']]

        self.assertEqual(Model.check(), [
            Error(
                "'unique_together' refers to a ManyToManyField 'm2m', but "
                "ManyToManyFields are not permitted in 'unique_together'.",
                obj=Model,
                id='models.E013',
            ),
        ])


</source>
<source file="django/tests/invalid_models_tests/test_models.py.pyindent" startline="178" endline="189" pcid="17718">
        class Model(models.Model):
            class Meta:
                unique_together = [['missing_field']]

        self.assertEqual(Model.check(), [
            Error(
                "'unique_together' refers to the nonexistent field 'missing_field'.",
                obj=Model,
                id='models.E012',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_models.py.pyindent" startline="735" endline="745" pcid="17813">
        class Model(models.Model):
            class Meta:
                swappable = 'TEST_SWAPPED_MODEL_BAD_VALUE'

        self.assertEqual(Model.check(), [
            Error(
                "'TEST_SWAPPED_MODEL_BAD_VALUE' is not of the form 'app_label.app_name'.",
                id='models.E001',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_models.py.pyindent" startline="125" endline="136" pcid="17706">
        class Model(models.Model):
            class Meta:
                unique_together = 42

        self.assertEqual(Model.check(), [
            Error(
                "'unique_together' must be a list or tuple.",
                obj=Model,
                id='models.E010',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_models.py.pyindent" startline="553" endline="565" pcid="17774">
        class Model(models.Model):
            class Meta:
                ordering = 'missing_field'

        self.assertEqual(Model.check(), [
            Error(
                "'ordering' must be a tuple or list "
                "(even if you want to order by only one field).",
                obj=Model,
                id='models.E014',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_models.py.pyindent" startline="104" endline="120" pcid="17702">
        class Model(models.Model):
            m2m = models.ManyToManyField('self')

            class Meta:
                index_together = [['m2m']]

        self.assertEqual(Model.check(), [
            Error(
                "'index_together' refers to a ManyToManyField 'm2m', but "
                "ManyToManyFields are not permitted in 'index_together'.",
                obj=Model,
                id='models.E013',
            ),
        ])


# unique_together tests are very similar to index_together tests.
</source>
<source file="django/tests/invalid_models_tests/test_models.py.pyindent" startline="211" endline="222" pcid="17725">
        class Model(models.Model):
            class Meta:
                indexes = [models.Index(fields=['missing_field'], name='name')]

        self.assertEqual(Model.check(), [
            Error(
                "'indexes' refers to the nonexistent field 'missing_field'.",
                obj=Model,
                id='models.E012',
            ),
        ])

</source>
</class>

<class classid="294" nclones="2" nlines="23" similarity="86">
<source file="django/tests/invalid_models_tests/test_models.py.pyindent" startline="84" endline="102" pcid="17698">
        class Foo(models.Model):
            field1 = models.IntegerField()

        class Bar(Foo):
            field2 = models.IntegerField()

            class Meta:
                index_together = [['field2', 'field1']]

        self.assertEqual(Bar.check(), [
            Error(
                "'index_together' refers to field 'field1' which is not "
                "local to model 'Bar'.",
                hint='This issue may be caused by multi-table inheritance.',
                obj=Bar,
                id='models.E016',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_models.py.pyindent" startline="240" endline="259" pcid="17731">
        class Foo(models.Model):
            field1 = models.IntegerField()

        class Bar(Foo):
            field2 = models.IntegerField()

            class Meta:
                indexes = [models.Index(fields=['field2', 'field1'], name='name')]

        self.assertEqual(Bar.check(), [
            Error(
                "'indexes' refers to field 'field1' which is not local to "
                "model 'Bar'.",
                hint='This issue may be caused by multi-table inheritance.',
                obj=Bar,
                id='models.E016',
            ),
        ])


</source>
</class>

<class classid="295" nclones="2" nlines="12" similarity="75">
<source file="django/tests/invalid_models_tests/test_models.py.pyindent" startline="167" endline="176" pcid="17715">
        class Model(models.Model):
            one = models.IntegerField()
            two = models.IntegerField()

            class Meta:
                # unique_together can be a simple tuple
                unique_together = ('one', 'two')

        self.assertEqual(Model.check(), [])

</source>
<source file="django/tests/invalid_models_tests/test_models.py.pyindent" startline="567" endline="574" pcid="17777">
        class Model(models.Model):
            order = models.PositiveIntegerField()

            class Meta:
                ordering = ['order']

        self.assertEqual(Model.check(), [])

</source>
</class>

<class classid="296" nclones="2" nlines="16" similarity="81">
<source file="django/tests/invalid_models_tests/test_models.py.pyindent" startline="626" endline="637" pcid="17792">
        class Model(models.Model):
            class Meta:
                ordering = ('missing_field',)

        self.assertEqual(Model.check(), [
            Error(
                "'ordering' refers to the nonexistent field 'missing_field'.",
                obj=Model,
                id='models.E015',
            )
        ])

</source>
<source file="django/tests/invalid_models_tests/test_models.py.pyindent" startline="639" endline="652" pcid="17795">
        class Model(models.Model):
            missing_fk_field = models.IntegerField()

            class Meta:
                ordering = ('missing_fk_field_id',)

        self.assertEqual(Model.check(), [
            Error(
                "'ordering' refers to the nonexistent field 'missing_fk_field_id'.",
                obj=Model,
                id='models.E015',
            )
        ])

</source>
</class>

<class classid="297" nclones="2" nlines="24" similarity="70">
<source file="django/tests/invalid_models_tests/test_models.py.pyindent" startline="791" endline="809" pcid="17827">
        class Foo(models.Model):
            bar = models.ManyToManyField('Bar', db_table='myapp_bar')

            class Meta:
                db_table = 'myapp_foo'

        class Bar(models.Model):
            class Meta:
                db_table = 'myapp_bar'

        self.assertEqual(Foo.check(), [
            Error(
                "The field's intermediary table 'myapp_bar' clashes with the "
                "table name of 'invalid_models_tests.Bar'.",
                obj=Foo._meta.get_field('bar'),
                id='fields.E340',
            )
        ])

</source>
<source file="django/tests/invalid_models_tests/test_models.py.pyindent" startline="836" endline="855" pcid="17836">
        class Foo(models.Model):
            class Meta:
                db_table = 'bar_foos'

        class Bar(models.Model):
            # The autogenerated `db_table` will be bar_foos.
            foos = models.ManyToManyField(Foo)

            class Meta:
                db_table = 'bar'

        self.assertEqual(Bar.check(), [
            Error(
                "The field's intermediary table 'bar_foos' clashes with the "
                "table name of 'invalid_models_tests.Foo'.",
                obj=Bar._meta.get_field('foos'),
                id='fields.E340',
            )
        ])

</source>
</class>

<class classid="298" nclones="16" nlines="15" similarity="72">
<source file="django/tests/invalid_models_tests/test_ordinary_fields.py.pyindent" startline="23" endline="41" pcid="17870">
        # primary_key must be True. Refs #12467.
        class Model(models.Model):
            field = models.AutoField(primary_key=False)

            # Prevent Django from autocreating `id` AutoField, which would
            # result in an error, because a model must have exactly one
            # AutoField.
            another = models.IntegerField(primary_key=True)

        field = Model._meta.get_field('field')
        self.assertEqual(field.check(), [
            Error(
                'AutoFields must set primary_key=True.',
                obj=field,
                id='fields.E100',
            ),
        ])


</source>
<source file="django/tests/invalid_models_tests/test_ordinary_fields.py.pyindent" startline="73" endline="84" pcid="17877">
        class Model(models.Model):
            field = models.CharField(max_length=-1)

        field = Model._meta.get_field('field')
        self.assertEqual(field.check(), [
            Error(
                "'max_length' must be a positive integer.",
                obj=field,
                id='fields.E121',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_ordinary_fields.py.pyindent" startline="86" endline="97" pcid="17879">
        class Model(models.Model):
            field = models.CharField(max_length="bad")

        field = Model._meta.get_field('field')
        self.assertEqual(field.check(), [
            Error(
                "'max_length' must be a positive integer.",
                obj=field,
                id='fields.E121',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_ordinary_fields.py.pyindent" startline="60" endline="71" pcid="17875">
        class Model(models.Model):
            field = models.CharField()

        field = Model._meta.get_field('field')
        self.assertEqual(field.check(), [
            Error(
                "CharFields must define a 'max_length' attribute.",
                obj=field,
                id='fields.E120',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="506" endline="518" pcid="18057">
        class Model(models.Model):
            field = models.IntegerField(primary_key=True, null=True)

        field = Model._meta.get_field('field')
        self.assertEqual(field.check(), [
            Error(
                'Primary keys must not have null=True.',
                hint='Set null=False on the field, or remove primary_key=True argument.',
                obj=field,
                id='fields.E007',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_ordinary_fields.py.pyindent" startline="471" endline="482" pcid="17935">
        class Model(models.Model):
            field = models.DecimalField(max_digits=9, decimal_places=10)

        field = Model._meta.get_field('field')
        self.assertEqual(field.check(), [
            Error(
                "'max_digits' must be greater or equal to 'decimal_places'.",
                obj=field,
                id='fields.E134',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_ordinary_fields.py.pyindent" startline="550" endline="562" pcid="17952">
        class Model(models.Model):
            field = models.FilePathField(allow_files=False, allow_folders=False)

        field = Model._meta.get_field('field')
        self.assertEqual(field.check(), [
            Error(
                "FilePathFields must have either 'allow_files' or 'allow_folders' set to True.",
                obj=field,
                id='fields.E140',
            ),
        ])


</source>
<source file="django/tests/invalid_models_tests/test_ordinary_fields.py.pyindent" startline="260" endline="271" pcid="17911">
        class Model(models.Model):
            field = models.CharField(max_length=10, db_index='bad')

        field = Model._meta.get_field('field')
        self.assertEqual(field.check(), [
            Error(
                "'db_index' must be None, True or False.",
                obj=field,
                id='fields.E006',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_ordinary_fields.py.pyindent" startline="174" endline="185" pcid="17897">
        class Model(models.Model):
            field = models.CharField(max_length=10, choices=[(1, 2, 3), (1, 2, 3)])

        field = Model._meta.get_field('field')
        self.assertEqual(field.check(), [
            Error(
                "'choices' must be an iterable containing (actual value, human readable name) tuples.",
                obj=field,
                id='fields.E005',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_ordinary_fields.py.pyindent" startline="99" endline="110" pcid="17881">
        class Model(models.Model):
            field = models.CharField(max_length='20')

        field = Model._meta.get_field('field')
        self.assertEqual(field.check(), [
            Error(
                "'max_length' must be a positive integer.",
                obj=field,
                id='fields.E121',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_ordinary_fields.py.pyindent" startline="125" endline="136" pcid="17885">
        class Model(models.Model):
            field = models.CharField(max_length=10, choices='bad')

        field = Model._meta.get_field('field')
        self.assertEqual(field.check(), [
            Error(
                "'choices' must be an iterable (e.g., a list or tuple).",
                obj=field,
                id='fields.E004',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_ordinary_fields.py.pyindent" startline="138" endline="151" pcid="17887">
        """Two letters isn't a valid choice pair."""
        class Model(models.Model):
            field = models.CharField(max_length=10, choices=['ab'])

        field = Model._meta.get_field('field')
        self.assertEqual(field.check(), [
            Error(
                "'choices' must be an iterable containing (actual value, "
                "human readable name) tuples.",
                obj=field,
                id='fields.E005',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_ordinary_fields.py.pyindent" startline="567" endline="580" pcid="17955">
        class Model(models.Model):
            field = models.GenericIPAddressField(null=False, blank=True)

        field = Model._meta.get_field('field')
        self.assertEqual(field.check(), [
            Error(
                ('GenericIPAddressFields cannot have blank=True if null=False, '
                 'as blank values are stored as nulls.'),
                obj=field,
                id='fields.E150',
            ),
        ])


</source>
<source file="django/tests/invalid_models_tests/test_ordinary_fields.py.pyindent" startline="112" endline="123" pcid="17883">
        class Model(models.Model):
            field = models.CharField(max_length=True)

        field = Model._meta.get_field('field')
        self.assertEqual(field.check(), [
            Error(
                "'max_length' must be a positive integer.",
                obj=field,
                id='fields.E121'
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_ordinary_fields.py.pyindent" startline="211" endline="226" pcid="17905">
        class Model(models.Model):
            field = models.CharField(
                max_length=10,
                choices=[['knights', [['L', 'Lancelot', 'Du Lac']]]],
            )

        field = Model._meta.get_field('field')
        self.assertEqual(field.check(), [
            Error(
                "'choices' must be an iterable containing (actual value, "
                "human readable name) tuples.",
                obj=field,
                id='fields.E005',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_ordinary_fields.py.pyindent" startline="228" endline="247" pcid="17907">
        class Model(models.Model):
            field = models.CharField(
                max_length=10, choices=[
                    ['knights', [
                        ['Noble', [['G', 'Galahad']]],
                        ['Combative', [['L', 'Lancelot']]],
                    ]],
                ],
            )

        field = Model._meta.get_field('field')
        self.assertEqual(field.check(), [
            Error(
                "'choices' must be an iterable containing (actual value, "
                "human readable name) tuples.",
                obj=field,
                id='fields.E005',
            ),
        ])

</source>
</class>

<class classid="299" nclones="2" nlines="13" similarity="76">
<source file="django/tests/invalid_models_tests/test_ordinary_fields.py.pyindent" startline="199" endline="209" pcid="17903">
        class Model(models.Model):
            field = models.CharField(
                max_length=10, choices=[
                    ['knights', [['L', 'Lancelot'], ['G', 'Galahad']]],
                    ['wizards', [['T', 'Tim the Enchanter']]],
                    ['R', 'Random character'],
                ],
            )

        self.assertEqual(Model._meta.get_field('field').check(), [])

</source>
<source file="django/tests/invalid_models_tests/test_ordinary_fields.py.pyindent" startline="249" endline="258" pcid="17909">
        class Model(models.Model):
            field = models.CharField(
                max_length=10, choices=[
                    [_('knights'), [['L', _('Lancelot')], ['G', _('Galahad')]]],
                    ['R', _('Random character')],
                ],
            )

        self.assertEqual(Model._meta.get_field('field').check(), [])

</source>
</class>

<class classid="300" nclones="4" nlines="37" similarity="71">
<source file="django/tests/invalid_models_tests/test_ordinary_fields.py.pyindent" startline="334" endline="365" pcid="17921">
        class Model(models.Model):
            field_dt = models.DateField(default=now())
            field_d = models.DateField(default=now().date())
            field_now = models.DateField(default=now)

        field_dt = Model._meta.get_field('field_dt')
        field_d = Model._meta.get_field('field_d')
        field_now = Model._meta.get_field('field_now')
        errors = field_dt.check()
        errors.extend(field_d.check())
        errors.extend(field_now.check())  # doesn't raise a warning
        self.assertEqual(errors, [
            DjangoWarning(
                'Fixed default value provided.',
                hint='It seems you set a fixed date / time / datetime '
                     'value as default for this field. This may not be '
                     'what you want. If you want to have the current date '
                     'as default, use `django.utils.timezone.now`',
                obj=field_dt,
                id='fields.W161',
            ),
            DjangoWarning(
                'Fixed default value provided.',
                hint='It seems you set a fixed date / time / datetime '
                     'value as default for this field. This may not be '
                     'what you want. If you want to have the current date '
                     'as default, use `django.utils.timezone.now`',
                obj=field_d,
                id='fields.W161',
            )
        ])

</source>
<source file="django/tests/invalid_models_tests/test_ordinary_fields.py.pyindent" startline="373" endline="412" pcid="17924">
    maxDiff = None

    def test_fix_default_value(self):
        class Model(models.Model):
            field_dt = models.DateTimeField(default=now())
            field_d = models.DateTimeField(default=now().date())
            field_now = models.DateTimeField(default=now)

        field_dt = Model._meta.get_field('field_dt')
        field_d = Model._meta.get_field('field_d')
        field_now = Model._meta.get_field('field_now')
        errors = field_dt.check()
        errors.extend(field_d.check())
        errors.extend(field_now.check())  # doesn't raise a warning
        self.assertEqual(errors, [
            DjangoWarning(
                'Fixed default value provided.',
                hint='It seems you set a fixed date / time / datetime '
                     'value as default for this field. This may not be '
                     'what you want. If you want to have the current date '
                     'as default, use `django.utils.timezone.now`',
                obj=field_dt,
                id='fields.W161',
            ),
            DjangoWarning(
                'Fixed default value provided.',
                hint='It seems you set a fixed date / time / datetime '
                     'value as default for this field. This may not be '
                     'what you want. If you want to have the current date '
                     'as default, use `django.utils.timezone.now`',
                obj=field_d,
                id='fields.W161',
            )
        ])

    @override_settings(USE_TZ=True)
    def test_fix_default_value_tz(self):
        self.test_fix_default_value()


</source>
<source file="django/tests/invalid_models_tests/test_ordinary_fields.py.pyindent" startline="632" endline="663" pcid="17967">
        class Model(models.Model):
            field_dt = models.TimeField(default=now())
            field_t = models.TimeField(default=now().time())
            field_now = models.DateField(default=now)

        field_dt = Model._meta.get_field('field_dt')
        field_t = Model._meta.get_field('field_t')
        field_now = Model._meta.get_field('field_now')
        errors = field_dt.check()
        errors.extend(field_t.check())
        errors.extend(field_now.check())  # doesn't raise a warning
        self.assertEqual(errors, [
            DjangoWarning(
                'Fixed default value provided.',
                hint='It seems you set a fixed date / time / datetime '
                     'value as default for this field. This may not be '
                     'what you want. If you want to have the current date '
                     'as default, use `django.utils.timezone.now`',
                obj=field_dt,
                id='fields.W161',
            ),
            DjangoWarning(
                'Fixed default value provided.',
                hint='It seems you set a fixed date / time / datetime '
                     'value as default for this field. This may not be '
                     'what you want. If you want to have the current date '
                     'as default, use `django.utils.timezone.now`',
                obj=field_t,
                id='fields.W161',
            )
        ])

</source>
<source file="django/tests/invalid_models_tests/test_ordinary_fields.py.pyindent" startline="629" endline="668" pcid="17966">
    maxDiff = None

    def test_fix_default_value(self):
        class Model(models.Model):
            field_dt = models.TimeField(default=now())
            field_t = models.TimeField(default=now().time())
            field_now = models.DateField(default=now)

        field_dt = Model._meta.get_field('field_dt')
        field_t = Model._meta.get_field('field_t')
        field_now = Model._meta.get_field('field_now')
        errors = field_dt.check()
        errors.extend(field_t.check())
        errors.extend(field_now.check())  # doesn't raise a warning
        self.assertEqual(errors, [
            DjangoWarning(
                'Fixed default value provided.',
                hint='It seems you set a fixed date / time / datetime '
                     'value as default for this field. This may not be '
                     'what you want. If you want to have the current date '
                     'as default, use `django.utils.timezone.now`',
                obj=field_dt,
                id='fields.W161',
            ),
            DjangoWarning(
                'Fixed default value provided.',
                hint='It seems you set a fixed date / time / datetime '
                     'value as default for this field. This may not be '
                     'what you want. If you want to have the current date '
                     'as default, use `django.utils.timezone.now`',
                obj=field_t,
                id='fields.W161',
            )
        ])

    @override_settings(USE_TZ=True)
    def test_fix_default_value_tz(self):
        self.test_fix_default_value()


</source>
</class>

<class classid="301" nclones="3" nlines="19" similarity="73">
<source file="django/tests/invalid_models_tests/test_ordinary_fields.py.pyindent" startline="417" endline="433" pcid="17929">
        class Model(models.Model):
            field = models.DecimalField()

        field = Model._meta.get_field('field')
        self.assertEqual(field.check(), [
            Error(
                "DecimalFields must define a 'decimal_places' attribute.",
                obj=field,
                id='fields.E130',
            ),
            Error(
                "DecimalFields must define a 'max_digits' attribute.",
                obj=field,
                id='fields.E132',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_ordinary_fields.py.pyindent" startline="435" endline="451" pcid="17931">
        class Model(models.Model):
            field = models.DecimalField(max_digits=-1, decimal_places=-1)

        field = Model._meta.get_field('field')
        self.assertEqual(field.check(), [
            Error(
                "'decimal_places' must be a non-negative integer.",
                obj=field,
                id='fields.E131',
            ),
            Error(
                "'max_digits' must be a positive integer.",
                obj=field,
                id='fields.E133',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_ordinary_fields.py.pyindent" startline="453" endline="469" pcid="17933">
        class Model(models.Model):
            field = models.DecimalField(max_digits="bad", decimal_places="bad")

        field = Model._meta.get_field('field')
        self.assertEqual(field.check(), [
            Error(
                "'decimal_places' must be a non-negative integer.",
                obj=field,
                id='fields.E131',
            ),
            Error(
                "'max_digits' must be a positive integer.",
                obj=field,
                id='fields.E133',
            ),
        ])

</source>
</class>

<class classid="302" nclones="2" nlines="12" similarity="75">
<source file="django/tests/invalid_models_tests/test_ordinary_fields.py.pyindent" startline="536" endline="545" pcid="17948">
        def callable(instance, filename):
            return '/' + filename

        class Model(models.Model):
            field = models.FileField(upload_to=callable)

        field = Model._meta.get_field('field')
        self.assertEqual(field.check(), [])


</source>
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="12" endline="21" pcid="17974">
        class Target(models.Model):
            # There would be a clash if Model.field installed an accessor.
            model = models.IntegerField()

        class Model(models.Model):
            field = models.ForeignKey(Target, models.CASCADE, related_name='+')

        field = Model._meta.get_field('field')
        self.assertEqual(field.check(), [])

</source>
</class>

<class classid="303" nclones="2" nlines="18" similarity="72">
<source file="django/tests/invalid_models_tests/test_ordinary_fields.py.pyindent" startline="548" endline="562" pcid="17951">

    def test_forbidden_files_and_folders(self):
        class Model(models.Model):
            field = models.FilePathField(allow_files=False, allow_folders=False)

        field = Model._meta.get_field('field')
        self.assertEqual(field.check(), [
            Error(
                "FilePathFields must have either 'allow_files' or 'allow_folders' set to True.",
                obj=field,
                id='fields.E140',
            ),
        ])


</source>
<source file="django/tests/invalid_models_tests/test_ordinary_fields.py.pyindent" startline="565" endline="580" pcid="17954">

    def test_non_nullable_blank(self):
        class Model(models.Model):
            field = models.GenericIPAddressField(null=False, blank=True)

        field = Model._meta.get_field('field')
        self.assertEqual(field.check(), [
            Error(
                ('GenericIPAddressFields cannot have blank=True if null=False, '
                 'as blank values are stored as nulls.'),
                obj=field,
                id='fields.E150',
            ),
        ])


</source>
</class>

<class classid="304" nclones="2" nlines="15" similarity="73">
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="23" endline="38" pcid="17977">
        # Model names are resolved when a model is being created, so we cannot
        # test relative fields in isolation and we need to attach them to a
        # model.
        class Model(models.Model):
            foreign_key = models.ForeignKey('Rel1', models.CASCADE)

        field = Model._meta.get_field('foreign_key')
        self.assertEqual(field.check(), [
            Error(
                "Field defines a relation with model 'Rel1', "
                "which is either not installed, or is abstract.",
                obj=field,
                id='fields.E300',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="55" endline="67" pcid="17982">
        class Model(models.Model):
            m2m = models.ManyToManyField("Rel2")

        field = Model._meta.get_field('m2m')
        self.assertEqual(field.check(from_model=Model), [
            Error(
                "Field defines a relation with model 'Rel2', "
                "which is either not installed, or is abstract.",
                obj=field,
                id='fields.E300',
            ),
        ])

</source>
</class>

<class classid="305" nclones="2" nlines="12" similarity="83">
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="41" endline="53" pcid="17979">
        """
        #25723 - Referenced model registration lookup should be run against the
        field's model registry.
        """
        class OtherModel(models.Model):
            pass

        class Model(models.Model):
            foreign_key = models.ForeignKey('OtherModel', models.CASCADE)

        field = Model._meta.get_field('foreign_key')
        self.assertEqual(field.check(from_model=Model), [])

</source>
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="70" endline="82" pcid="17984">
        """
        #25723 - Referenced model registration lookup should be run against the
        field's model registry.
        """
        class OtherModel(models.Model):
            pass

        class Model(models.Model):
            m2m = models.ManyToManyField('OtherModel')

        field = Model._meta.get_field('m2m')
        self.assertEqual(field.check(from_model=Model), [])

</source>
</class>

<class classid="306" nclones="2" nlines="27" similarity="72">
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="162" endline="186" pcid="17998">
        class WrongModel(models.Model):
            pass

        class Person(models.Model):
            pass

        class Group(models.Model):
            members = models.ManyToManyField('Person', through="InvalidRelationship")

        class InvalidRelationship(models.Model):
            person = models.ForeignKey(Person, models.CASCADE)
            wrong_foreign_key = models.ForeignKey(WrongModel, models.CASCADE)
            # The last foreign key should point to Group model.

        field = Group._meta.get_field('members')
        self.assertEqual(field.check(from_model=Group), [
            Error(
                "The model is used as an intermediate model by "
                "'invalid_models_tests.Group.members', but it does not "
                "have a foreign key to 'Group' or 'Person'.",
                obj=InvalidRelationship,
                id='fields.E336',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="188" endline="208" pcid="18003">
        class Person(models.Model):
            pass

        class Group(models.Model):
            members = models.ManyToManyField('Person', through="InvalidRelationship")

        class InvalidRelationship(models.Model):
            group = models.ForeignKey(Group, models.CASCADE)
            # No foreign key to Person

        field = Group._meta.get_field('members')
        self.assertEqual(field.check(from_model=Group), [
            Error(
                "The model is used as an intermediate model by "
                "'invalid_models_tests.Group.members', but it does not have "
                "a foreign key to 'Group' or 'Person'.",
                obj=InvalidRelationship,
                id='fields.E336',
            ),
        ])

</source>
</class>

<class classid="307" nclones="3" nlines="19" similarity="73">
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="210" endline="225" pcid="18007">
        class Person(models.Model):
            pass

        class Group(models.Model):
            members = models.ManyToManyField('Person', through="MissingM2MModel")

        field = Group._meta.get_field('members')
        self.assertEqual(field.check(from_model=Group), [
            Error(
                "Field specifies a many-to-many relation through model "
                "'MissingM2MModel', which has not been installed.",
                obj=field,
                id='fields.E331',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="227" endline="241" pcid="18010">
        class Person(models.Model):
            pass

        class Group(models.Model):
            members = models.ManyToManyField('Person', through='MissingM2MModel')

        self.assertEqual(Group.check(), [
            Error(
                "Field specifies a many-to-many relation through model "
                "'MissingM2MModel', which has not been installed.",
                obj=Group._meta.get_field('members'),
                id='fields.E331',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="393" endline="407" pcid="18039">
        class Person(models.Model):
            name = models.CharField(max_length=5)

        class Group(models.Model):
            members = models.ManyToManyField('Person', unique=True)

        field = Group._meta.get_field('members')
        self.assertEqual(field.check(from_model=Group), [
            Error(
                'ManyToManyFields cannot be unique.',
                obj=field,
                id='fields.E330',
            ),
        ])

</source>
</class>

<class classid="308" nclones="3" nlines="21" similarity="72">
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="262" endline="278" pcid="18017">
        class Person(models.Model):
            # Implicit symmetrical=False.
            friends = models.ManyToManyField('self', through="Relationship")

        class Relationship(models.Model):
            first = models.ForeignKey(Person, models.CASCADE, related_name="rel_from_set")
            second = models.ForeignKey(Person, models.CASCADE, related_name="rel_to_set")

        field = Person._meta.get_field('friends')
        self.assertEqual(field.check(from_model=Person), [
            Error(
                'Many-to-many fields with intermediate tables must not be symmetrical.',
                obj=field,
                id='fields.E332',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="321" endline="347" pcid="18026">
        """
        Using through_fields in a m2m with an intermediate model shouldn't
        mask its incompatibility with symmetry.
        """
        class Person(models.Model):
            # Explicit symmetrical=True.
            friends = models.ManyToManyField(
                'self',
                symmetrical=True,
                through="Relationship",
                through_fields=('first', 'second'),
            )

        class Relationship(models.Model):
            first = models.ForeignKey(Person, models.CASCADE, related_name="rel_from_set")
            second = models.ForeignKey(Person, models.CASCADE, related_name="rel_to_set")
            referee = models.ForeignKey(Person, models.CASCADE, related_name="referred")

        field = Person._meta.get_field('friends')
        self.assertEqual(field.check(from_model=Person), [
            Error(
                'Many-to-many fields with intermediate tables must not be symmetrical.',
                obj=field,
                id='fields.E332',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="303" endline="319" pcid="18023">
        class Person(models.Model):
            # Explicit symmetrical=True.
            friends = models.ManyToManyField('self', through="Relationship", symmetrical=True)

        class Relationship(models.Model):
            first = models.ForeignKey(Person, models.CASCADE, related_name="rel_from_set")
            second = models.ForeignKey(Person, models.CASCADE, related_name="rel_to_set")

        field = Person._meta.get_field('friends')
        self.assertEqual(field.check(from_model=Person), [
            Error(
                'Many-to-many fields with intermediate tables must not be symmetrical.',
                obj=field,
                id='fields.E332',
            ),
        ])

</source>
</class>

<class classid="309" nclones="2" nlines="28" similarity="82">
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="349" endline="369" pcid="18029">
        class AbstractModel(models.Model):
            class Meta:
                abstract = True

        class Model(models.Model):
            rel_string_foreign_key = models.ForeignKey('AbstractModel', models.CASCADE)
            rel_class_foreign_key = models.ForeignKey(AbstractModel, models.CASCADE)

        fields = [
            Model._meta.get_field('rel_string_foreign_key'),
            Model._meta.get_field('rel_class_foreign_key'),
        ]
        expected_error = Error(
            "Field defines a relation with model 'AbstractModel', "
            "which is either not installed, or is abstract.",
            id='fields.E300',
        )
        for field in fields:
            expected_error.obj = field
            self.assertEqual(field.check(), [expected_error])

</source>
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="371" endline="391" pcid="18034">
        class AbstractModel(models.Model):
            class Meta:
                abstract = True

        class Model(models.Model):
            rel_string_m2m = models.ManyToManyField('AbstractModel')
            rel_class_m2m = models.ManyToManyField(AbstractModel)

        fields = [
            Model._meta.get_field('rel_string_m2m'),
            Model._meta.get_field('rel_class_m2m'),
        ]
        expected_error = Error(
            "Field defines a relation with model 'AbstractModel', "
            "which is either not installed, or is abstract.",
            id='fields.E300',
        )
        for field in fields:
            expected_error.obj = field
            self.assertEqual(field.check(from_model=Model), [expected_error])

</source>
</class>

<class classid="310" nclones="2" nlines="18" similarity="88">
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="409" endline="423" pcid="18042">
        class Target(models.Model):
            bad = models.IntegerField()  # No unique=True

        class Model(models.Model):
            foreign_key = models.ForeignKey('Target', models.CASCADE, to_field='bad')

        field = Model._meta.get_field('foreign_key')
        self.assertEqual(field.check(), [
            Error(
                "'Target.bad' must set unique=True because it is referenced by a foreign key.",
                obj=field,
                id='fields.E311',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="425" endline="439" pcid="18045">
        class Target(models.Model):
            bad = models.IntegerField()

        class Model(models.Model):
            field = models.ForeignKey(Target, models.CASCADE, to_field='bad')

        field = Model._meta.get_field('field')
        self.assertEqual(field.check(), [
            Error(
                "'Target.bad' must set unique=True because it is referenced by a foreign key.",
                obj=field,
                id='fields.E311',
            ),
        ])

</source>
</class>

<class classid="311" nclones="2" nlines="19" similarity="78">
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="471" endline="486" pcid="18051">
        class Person(models.Model):
            pass

        class Model(models.Model):
            foreign_key = models.ForeignKey('Person', models.SET_NULL)

        field = Model._meta.get_field('foreign_key')
        self.assertEqual(field.check(), [
            Error(
                'Field specifies on_delete=SET_NULL, but cannot be null.',
                hint='Set null=True argument on the field, or change the on_delete rule.',
                obj=field,
                id='fields.E320',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="488" endline="503" pcid="18054">
        class Person(models.Model):
            pass

        class Model(models.Model):
            foreign_key = models.ForeignKey('Person', models.SET_DEFAULT)

        field = Model._meta.get_field('foreign_key')
        self.assertEqual(field.check(), [
            Error(
                'Field specifies on_delete=SET_DEFAULT, but has no default value.',
                hint='Set a default value, or change the on_delete rule.',
                obj=field,
                id='fields.E321',
            ),
        ])

</source>
</class>

<class classid="312" nclones="2" nlines="17" similarity="76">
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="527" endline="542" pcid="18062">
            explicit_fk = models.ForeignKey(
                SwappableModel,
                models.CASCADE,
                related_name='explicit_fk',
            )
            implicit_fk = models.ForeignKey(
                'invalid_models_tests.SwappableModel',
                models.CASCADE,
                related_name='implicit_fk',
            )
            explicit_m2m = models.ManyToManyField(SwappableModel, related_name='explicit_m2m')
            implicit_m2m = models.ManyToManyField(
                'invalid_models_tests.SwappableModel',
                related_name='implicit_m2m',
            )

</source>
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="565" endline="580" pcid="18067">
            explicit_fk = models.ForeignKey(
                SwappedModel,
                models.CASCADE,
                related_name='explicit_fk',
            )
            implicit_fk = models.ForeignKey(
                'invalid_models_tests.SwappedModel',
                models.CASCADE,
                related_name='implicit_fk',
            )
            explicit_m2m = models.ManyToManyField(SwappedModel, related_name='explicit_m2m')
            implicit_m2m = models.ManyToManyField(
                'invalid_models_tests.SwappedModel',
                related_name='implicit_m2m',
            )

</source>
</class>

<class classid="313" nclones="4" nlines="25" similarity="75">
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="775" endline="794" pcid="18090">
        class Another(models.Model):
            pass

        class Target(models.Model):
            model_set = target

        class Model(models.Model):
            rel = relative

        self.assertEqual(Model.check(), [
            Error(
                "Reverse accessor for 'Model.rel' clashes with field name 'Target.model_set'.",
                hint=("Rename field 'Target.model_set', or add/change "
                      "a related_name argument to the definition "
                      "for field 'Model.rel'."),
                obj=Model._meta.get_field('rel'),
                id='fields.E302',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="1063" endline="1084" pcid="18141">
        class Another(models.Model):
            pass

        class Target(models.Model):
            clash = target

        class Model(models.Model):
            rel = relative

        self.assertEqual(Model.check(), [
            Error(
                "Reverse query name for 'Model.rel' clashes with field name 'Target.clash'.",
                hint=(
                    "Rename field 'Target.clash', or add/change a related_name "
                    "argument to the definition for field 'Model.rel'."
                ),
                obj=Model._meta.get_field('rel'),
                id='fields.E303',
            ),
        ])


</source>
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="901" endline="922" pcid="18113">
        class Another(models.Model):
            pass

        class Target(models.Model):
            model = target

        class Model(models.Model):
            rel = relative

        self.assertEqual(Model.check(), [
            Error(
                "Reverse query name for 'Model.rel' clashes with field name 'Target.model'.",
                hint=(
                    "Rename field 'Target.model', or add/change a related_name "
                    "argument to the definition for field 'Model.rel'."
                ),
                obj=Model._meta.get_field('rel'),
                id='fields.E303',
            ),
        ])


</source>
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="957" endline="987" pcid="18124">
        class Another(models.Model):
            pass

        class Target(models.Model):
            clash = target

        class Model(models.Model):
            rel = relative

        self.assertEqual(Model.check(), [
            Error(
                "Reverse accessor for 'Model.rel' clashes with field name 'Target.clash'.",
                hint=(
                    "Rename field 'Target.clash', or add/change a related_name "
                    "argument to the definition for field 'Model.rel'."
                ),
                obj=Model._meta.get_field('rel'),
                id='fields.E302',
            ),
            Error(
                "Reverse query name for 'Model.rel' clashes with field name 'Target.clash'.",
                hint=(
                    "Rename field 'Target.clash', or add/change a related_name "
                    "argument to the definition for field 'Model.rel'."
                ),
                obj=Model._meta.get_field('rel'),
                id='fields.E303',
            ),
        ])


</source>
</class>

<class classid="314" nclones="3" nlines="10" similarity="90">
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="992" endline="1001" pcid="18129">
        self._test_explicit_related_query_name_clash(
            target=models.IntegerField(),
            relative=models.ForeignKey(
                'Target',
                models.CASCADE,
                related_name=related_name,
                related_query_name='clash',
            )
        )

</source>
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="1020" endline="1029" pcid="18133">
        self._test_explicit_related_query_name_clash(
            target=models.ManyToManyField('Another'),
            relative=models.ForeignKey(
                'Target',
                models.CASCADE,
                related_name=related_name,
                related_query_name='clash',
            )
        )

</source>
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="1006" endline="1015" pcid="18131">
        self._test_explicit_related_query_name_clash(
            target=models.ForeignKey('Another', models.CASCADE),
            relative=models.ForeignKey(
                'Target',
                models.CASCADE,
                related_name=related_name,
                related_query_name='clash',
            )
        )

</source>
</class>

<class classid="315" nclones="2" nlines="17" similarity="76">
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="1115" endline="1129" pcid="18148">
        class Model(models.Model):
            model_set = models.ManyToManyField("self", symmetrical=False)

        self.assertEqual(Model.check(), [
            Error(
                "Reverse accessor for 'Model.model_set' clashes with field name 'Model.model_set'.",
                hint=(
                    "Rename field 'Model.model_set', or add/change a related_name "
                    "argument to the definition for field 'Model.model_set'."
                ),
                obj=Model._meta.get_field('model_set'),
                id='fields.E302',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="1184" endline="1199" pcid="18157">
        class Model(models.Model):
            model_set = models.ForeignKey("Model", models.CASCADE)

        self.assertEqual(Model.check(), [
            Error(
                "Reverse accessor for 'Model.model_set' clashes with field name 'Model.model_set'.",
                hint=(
                    "Rename field 'Model.model_set', or add/change "
                    "a related_name argument to the definition "
                    "for field 'Model.model_set'."
                ),
                obj=Model._meta.get_field('model_set'),
                id='fields.E302',
            ),
        ])

</source>
</class>

<class classid="316" nclones="2" nlines="16" similarity="93">
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="1131" endline="1145" pcid="18150">
        class Model(models.Model):
            model = models.ManyToManyField("self", symmetrical=False)

        self.assertEqual(Model.check(), [
            Error(
                "Reverse query name for 'Model.model' clashes with field name 'Model.model'.",
                hint=(
                    "Rename field 'Model.model', or add/change a related_name "
                    "argument to the definition for field 'Model.model'."
                ),
                obj=Model._meta.get_field('model'),
                id='fields.E303',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="1201" endline="1215" pcid="18159">
        class Model(models.Model):
            model = models.ForeignKey("Model", models.CASCADE)

        self.assertEqual(Model.check(), [
            Error(
                "Reverse query name for 'Model.model' clashes with field name 'Model.model'.",
                hint=(
                    "Rename field 'Model.model', or add/change a related_name "
                    "argument to the definition for field 'Model.model'."
                ),
                obj=Model._meta.get_field('model'),
                id='fields.E303',
            ),
        ])

</source>
</class>

<class classid="317" nclones="2" nlines="33" similarity="74">
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="1370" endline="1400" pcid="18171">
        """
        Mixing up the order of link fields to ManyToManyField.through_fields
        triggers validation errors.
        """
        class Fan(models.Model):
            pass

        class Event(models.Model):
            invitees = models.ManyToManyField(Fan, through='Invitation', through_fields=('invitee', 'event'))

        class Invitation(models.Model):
            event = models.ForeignKey(Event, models.CASCADE)
            invitee = models.ForeignKey(Fan, models.CASCADE)
            inviter = models.ForeignKey(Fan, models.CASCADE, related_name='+')

        field = Event._meta.get_field('invitees')
        self.assertEqual(field.check(from_model=Event), [
            Error(
                "'Invitation.invitee' is not a foreign key to 'Event'.",
                hint="Did you mean one of the following foreign keys to 'Event': event?",
                obj=field,
                id='fields.E339',
            ),
            Error(
                "'Invitation.event' is not a foreign key to 'Fan'.",
                hint="Did you mean one of the following foreign keys to 'Fan': invitee, inviter?",
                obj=field,
                id='fields.E339',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="1402" endline="1436" pcid="18175">
        """
        Providing invalid field names to ManyToManyField.through_fields
        triggers validation errors.
        """
        class Fan(models.Model):
            pass

        class Event(models.Model):
            invitees = models.ManyToManyField(
                Fan,
                through='Invitation',
                through_fields=('invalid_field_1', 'invalid_field_2'),
            )

        class Invitation(models.Model):
            event = models.ForeignKey(Event, models.CASCADE)
            invitee = models.ForeignKey(Fan, models.CASCADE)
            inviter = models.ForeignKey(Fan, models.CASCADE, related_name='+')

        field = Event._meta.get_field('invitees')
        self.assertEqual(field.check(from_model=Event), [
            Error(
                "The intermediary model 'invalid_models_tests.Invitation' has no field 'invalid_field_1'.",
                hint="Did you mean one of the following foreign keys to 'Event': event?",
                obj=field,
                id='fields.E338',
            ),
            Error(
                "The intermediary model 'invalid_models_tests.Invitation' has no field 'invalid_field_2'.",
                hint="Did you mean one of the following foreign keys to 'Fan': invitee, inviter?",
                obj=field,
                id='fields.E338',
            ),
        ])

</source>
</class>

<class classid="318" nclones="2" nlines="37" similarity="86">
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="1466" endline="1498" pcid="18183">
        class Parent(models.Model):
            a = models.PositiveIntegerField()
            b = models.PositiveIntegerField()
            c = models.PositiveIntegerField()

            class Meta:
                unique_together = (('a', 'b', 'c'),)

        class Child(models.Model):
            a = models.PositiveIntegerField()
            b = models.PositiveIntegerField()
            value = models.CharField(max_length=255)
            parent = ForeignObject(
                Parent,
                on_delete=models.SET_NULL,
                from_fields=('a', 'b'),
                to_fields=('a', 'b'),
                related_name='children',
            )

        field = Child._meta.get_field('parent')
        self.assertEqual(field.check(from_model=Child), [
            Error(
                "No subset of the fields 'a', 'b' on model 'Parent' is unique.",
                hint=(
                    "Add unique=True on any of those fields or add at least "
                    "a subset of them to a unique_together constraint."
                ),
                obj=field,
                id='fields.E310',
            ),
        ])

</source>
<source file="django/tests/invalid_models_tests/test_relative_fields.py.pyindent" startline="1500" endline="1533" pcid="18187">
        class Parent(models.Model):
            a = models.PositiveIntegerField()
            b = models.PositiveIntegerField()
            c = models.PositiveIntegerField()
            d = models.PositiveIntegerField()

            class Meta:
                unique_together = (('a', 'b', 'c'),)

        class Child(models.Model):
            a = models.PositiveIntegerField()
            b = models.PositiveIntegerField()
            d = models.PositiveIntegerField()
            value = models.CharField(max_length=255)
            parent = ForeignObject(
                Parent,
                on_delete=models.SET_NULL,
                from_fields=('a', 'b', 'd'),
                to_fields=('a', 'b', 'd'),
                related_name='children',
            )

        field = Child._meta.get_field('parent')
        self.assertEqual(field.check(from_model=Child), [
            Error(
                "No subset of the fields 'a', 'b', 'd' on model 'Parent' is unique.",
                hint=(
                    "Add unique=True on any of those fields or add at least "
                    "a subset of them to a unique_together constraint."
                ),
                obj=field,
                id='fields.E310',
            ),
        ])
</source>
</class>

<class classid="319" nclones="2" nlines="12" similarity="75">
<source file="django/tests/m2m_recursive/tests.py.pyindent" startline="126" endline="142" pcid="18279">
        # David is idolized by Anne and Chuck - add in reverse direction
        self.d.stalkers.add(self.a)

        # Who are Anne's idols?
        self.assertQuerysetEqual(
            self.a.idols.all(), [
                "David",
            ],
            attrgetter("name"),
            ordered=False
        )
        # Who is stalking Anne?
        self.assertQuerysetEqual(
            self.a.stalkers.all(), [],
            attrgetter("name")
        )

</source>
<source file="django/tests/m2m_recursive/tests.py.pyindent" startline="144" endline="162" pcid="18280">
        """Adding the same relation twice results in a single relation."""
        # Ann idolizes David
        self.a.idols.add(self.d)

        # David is idolized by Anne
        self.d.stalkers.add(self.a)

        # Who are Anne's idols?
        self.assertQuerysetEqual(
            self.a.idols.all(), [
                "David",
            ],
            attrgetter("name"),
            ordered=False
        )
        # As the assertQuerysetEqual uses a set for comparison,
        # check we've only got David listed once
        self.assertEqual(self.a.idols.all().count(), 1)

</source>
</class>

<class classid="320" nclones="2" nlines="36" similarity="80">
<source file="django/tests/m2m_signals/tests.py.pyindent" startline="71" endline="109" pcid="18329">
        expected_messages = []

        self._initialize_signal_car(add_default_parts_before_set_signal=True)

        self.vw.default_parts.add(self.wheelset, self.doors, self.engine)
        expected_messages.append({
            'instance': self.vw,
            'action': 'pre_add',
            'reverse': False,
            'model': Part,
            'objects': [self.doors, self.engine, self.wheelset],
        })
        expected_messages.append({
            'instance': self.vw,
            'action': 'post_add',
            'reverse': False,
            'model': Part,
            'objects': [self.doors, self.engine, self.wheelset],
        })
        self.assertEqual(self.m2m_changed_messages, expected_messages)

        # give the BMW and Toyota some doors as well
        self.doors.car_set.add(self.bmw, self.toyota)
        expected_messages.append({
            'instance': self.doors,
            'action': 'pre_add',
            'reverse': True,
            'model': Car,
            'objects': [self.bmw, self.toyota],
        })
        expected_messages.append({
            'instance': self.doors,
            'action': 'post_add',
            'reverse': True,
            'model': Car,
            'objects': [self.bmw, self.toyota],
        })
        self.assertEqual(self.m2m_changed_messages, expected_messages)

</source>
<source file="django/tests/m2m_signals/tests.py.pyindent" startline="132" endline="171" pcid="18331">
        expected_messages = []

        self._initialize_signal_car()

        # give the self.vw some optional parts (second relation to same model)
        self.vw.optional_parts.add(self.airbag, self.sunroof)
        expected_messages.append({
            'instance': self.vw,
            'action': 'pre_add',
            'reverse': False,
            'model': Part,
            'objects': [self.airbag, self.sunroof],
        })
        expected_messages.append({
            'instance': self.vw,
            'action': 'post_add',
            'reverse': False,
            'model': Part,
            'objects': [self.airbag, self.sunroof],
        })
        self.assertEqual(self.m2m_changed_messages, expected_messages)

        # add airbag to all the cars (even though the self.vw already has one)
        self.airbag.cars_optional.add(self.vw, self.bmw, self.toyota)
        expected_messages.append({
            'instance': self.airbag,
            'action': 'pre_add',
            'reverse': True,
            'model': Car,
            'objects': [self.bmw, self.toyota],
        })
        expected_messages.append({
            'instance': self.airbag,
            'action': 'post_add',
            'reverse': True,
            'model': Car,
            'objects': [self.bmw, self.toyota],
        })
        self.assertEqual(self.m2m_changed_messages, expected_messages)

</source>
</class>

<class classid="321" nclones="2" nlines="17" similarity="72">
<source file="django/tests/m2m_signals/tests.py.pyindent" startline="111" endline="130" pcid="18330">
        self._initialize_signal_car()
        # remove the engine from the self.vw and the airbag (which is not set
        # but is returned)
        self.vw.default_parts.remove(self.engine, self.airbag)
        self.assertEqual(self.m2m_changed_messages, [
            {
                'instance': self.vw,
                'action': 'pre_remove',
                'reverse': False,
                'model': Part,
                'objects': [self.airbag, self.engine],
            }, {
                'instance': self.vw,
                'action': 'post_remove',
                'reverse': False,
                'model': Part,
                'objects': [self.airbag, self.engine],
            }
        ])

</source>
<source file="django/tests/m2m_signals/tests.py.pyindent" startline="194" endline="210" pcid="18333">
        self._initialize_signal_car()
        # clear all parts of the self.vw
        self.vw.default_parts.clear()
        self.assertEqual(self.m2m_changed_messages, [
            {
                'instance': self.vw,
                'action': 'pre_clear',
                'reverse': False,
                'model': Part,
            }, {
                'instance': self.vw,
                'action': 'post_clear',
                'reverse': False,
                'model': Part,
            }
        ])

</source>
</class>

<class classid="322" nclones="3" nlines="16" similarity="72">
<source file="django/tests/m2m_signals/tests.py.pyindent" startline="173" endline="192" pcid="18332">
        self._initialize_signal_car()
        # remove airbag from the self.vw (reverse relation with custom
        # related_name)
        self.airbag.cars_optional.remove(self.vw)
        self.assertEqual(self.m2m_changed_messages, [
            {
                'instance': self.airbag,
                'action': 'pre_remove',
                'reverse': True,
                'model': Car,
                'objects': [self.vw],
            }, {
                'instance': self.airbag,
                'action': 'post_remove',
                'reverse': True,
                'model': Car,
                'objects': [self.vw],
            }
        ])

</source>
<source file="django/tests/m2m_signals/tests.py.pyindent" startline="230" endline="247" pcid="18335">
        self._initialize_signal_car()
        # take all the airbags off of cars (clear reverse relation with custom
        # related_name)
        self.airbag.cars_optional.clear()
        self.assertEqual(self.m2m_changed_messages, [
            {
                'instance': self.airbag,
                'action': 'pre_clear',
                'reverse': True,
                'model': Car,
            }, {
                'instance': self.airbag,
                'action': 'post_clear',
                'reverse': True,
                'model': Car,
            }
        ])

</source>
<source file="django/tests/m2m_signals/tests.py.pyindent" startline="212" endline="228" pcid="18334">
        self._initialize_signal_car()
        # take all the doors off of cars
        self.doors.car_set.clear()
        self.assertEqual(self.m2m_changed_messages, [
            {
                'instance': self.doors,
                'action': 'pre_clear',
                'reverse': True,
                'model': Car,
            }, {
                'instance': self.doors,
                'action': 'post_clear',
                'reverse': True,
                'model': Car,
            }
        ])

</source>
</class>

<class classid="323" nclones="2" nlines="18" similarity="83">
<source file="django/tests/m2m_signals/tests.py.pyindent" startline="409" endline="426" pcid="18340">
        self._initialize_signal_person()
        self.alice.friends.set([self.bob, self.chuck])
        self.assertEqual(self.m2m_changed_messages, [
            {
                'instance': self.alice,
                'action': 'pre_add',
                'reverse': False,
                'model': Person,
                'objects': [self.bob, self.chuck],
            }, {
                'instance': self.alice,
                'action': 'post_add',
                'reverse': False,
                'model': Person,
                'objects': [self.bob, self.chuck],
            }
        ])

</source>
<source file="django/tests/m2m_signals/tests.py.pyindent" startline="428" endline="445" pcid="18341">
        self._initialize_signal_person()
        self.alice.fans.set([self.daisy])
        self.assertEqual(self.m2m_changed_messages, [
            {
                'instance': self.alice,
                'action': 'pre_add',
                'reverse': False,
                'model': Person,
                'objects': [self.daisy],
            }, {
                'instance': self.alice,
                'action': 'post_add',
                'reverse': False,
                'model': Person,
                'objects': [self.daisy],
            }
        ])

</source>
</class>

<class classid="324" nclones="6" nlines="10" similarity="70">
<source file="django/tests/m2m_through/tests.py.pyindent" startline="60" endline="69" pcid="18376">
        msg = 'Cannot use add() on a ManyToManyField which specifies an intermediary model'

        with self.assertRaisesMessage(AttributeError, msg):
            self.rock.members.add(self.bob)

        self.assertQuerysetEqual(
            self.rock.members.all(),
            []
        )

</source>
<source file="django/tests/m2m_through/tests.py.pyindent" startline="140" endline="149" pcid="18388">
        msg = 'Cannot use create() on a ManyToManyField which specifies an intermediary model'

        with self.assertRaisesMessage(AttributeError, msg):
            self.bob.group_set.create(name='Funk')

        self.assertQuerysetEqual(
            self.bob.group_set.all(),
            []
        )

</source>
<source file="django/tests/m2m_through/tests.py.pyindent" startline="95" endline="105" pcid="18382">
        msg = 'Cannot set values on a ManyToManyField which specifies an intermediary model'
        members = list(Person.objects.filter(name__in=['Bob', 'Jim']))

        with self.assertRaisesMessage(AttributeError, msg):
            self.rock.members.set(members)

        self.assertQuerysetEqual(
            self.rock.members.all(),
            []
        )

</source>
<source file="django/tests/m2m_through/tests.py.pyindent" startline="71" endline="80" pcid="18378">
        msg = 'Cannot use create() on a ManyToManyField which specifies an intermediary model'

        with self.assertRaisesMessage(AttributeError, msg):
            self.rock.members.create(name='Annie')

        self.assertQuerysetEqual(
            self.rock.members.all(),
            []
        )

</source>
<source file="django/tests/m2m_through/tests.py.pyindent" startline="129" endline="138" pcid="18386">
        msg = 'Cannot use add() on a ManyToManyField which specifies an intermediary model'

        with self.assertRaisesMessage(AttributeError, msg):
            self.bob.group_set.add(self.bob)

        self.assertQuerysetEqual(
            self.bob.group_set.all(),
            []
        )

</source>
<source file="django/tests/m2m_through/tests.py.pyindent" startline="164" endline="174" pcid="18392">
        msg = 'Cannot set values on a ManyToManyField which specifies an intermediary model'
        members = list(Group.objects.filter(name__in=['Rock', 'Roll']))

        with self.assertRaisesMessage(AttributeError, msg):
            self.bob.group_set.set(members)

        self.assertQuerysetEqual(
            self.bob.group_set.all(),
            []
        )

</source>
</class>

<class classid="325" nclones="2" nlines="11" similarity="81">
<source file="django/tests/m2m_through/tests.py.pyindent" startline="187" endline="198" pcid="18395">
        Membership.objects.create(person=self.jim, group=self.rock)
        Membership.objects.create(person=self.jane, group=self.rock)
        Membership.objects.create(person=self.bob, group=self.roll)
        Membership.objects.create(person=self.jim, group=self.roll)
        Membership.objects.create(person=self.jane, group=self.roll)

        self.assertQuerysetEqual(
            Group.objects.filter(members__name='Bob'),
            ['Roll'],
            attrgetter("name")
        )

</source>
<source file="django/tests/m2m_through/tests.py.pyindent" startline="254" endline="265" pcid="18399">
        Membership.objects.create(person=self.jim, group=self.rock)
        Membership.objects.create(person=self.jane, group=self.rock)
        Membership.objects.create(person=self.bob, group=self.roll)
        Membership.objects.create(person=self.jim, group=self.roll)
        Membership.objects.create(person=self.jane, group=self.roll)

        self.assertQuerysetEqual(
            Person.objects.filter(group__name="Rock"),
            ['Jane', 'Jim'],
            attrgetter("name")
        )

</source>
</class>

<class classid="326" nclones="2" nlines="15" similarity="86">
<source file="django/tests/m2m_through/tests.py.pyindent" startline="214" endline="232" pcid="18397">
        Membership.objects.create(
            person=self.jane, group=self.roll,
            invite_reason="She was just awesome."
        )
        Membership.objects.create(
            person=self.jim, group=self.roll,
            invite_reason="He is good."
        )
        Membership.objects.create(person=self.bob, group=self.roll)

        qs = Group.objects.filter(
            membership__invite_reason="She was just awesome."
        )
        self.assertQuerysetEqual(
            qs,
            ['Roll'],
            attrgetter("name")
        )

</source>
<source file="django/tests/m2m_through/tests.py.pyindent" startline="234" endline="252" pcid="18398">
        Membership.objects.create(
            person=self.jane, group=self.roll,
            invite_reason="She was just awesome."
        )
        Membership.objects.create(
            person=self.jim, group=self.roll,
            invite_reason="He is good."
        )
        Membership.objects.create(person=self.bob, group=self.roll)

        qs = Person.objects.filter(
            membership__invite_reason="She was just awesome."
        )
        self.assertQuerysetEqual(
            qs,
            ['Jane'],
            attrgetter("name")
        )

</source>
</class>

<class classid="327" nclones="2" nlines="12" similarity="71">
<source file="django/tests/m2m_through/tests.py.pyindent" startline="363" endline="374" pcid="18410">
        tony = PersonSelfRefM2M.objects.create(name="Tony")
        chris = PersonSelfRefM2M.objects.create(name="Chris")
        Friendship.objects.create(
            first=tony, second=chris, date_friended=datetime.now()
        )

        self.assertQuerysetEqual(
            tony.friends.all(),
            ['Chris'],
            attrgetter("name")
        )

</source>
<source file="django/tests/m2m_through/tests.py.pyindent" startline="388" endline="407" pcid="18412">
        tony = PersonSelfRefM2M.objects.create(name="Tony")
        chris = PersonSelfRefM2M.objects.create(name="Chris")
        Friendship.objects.create(
            first=tony, second=chris, date_friended=datetime.now()
        )

        chris.friends.clear()

        self.assertQuerysetEqual(
            chris.friends.all(),
            []
        )

        # Since this isn't a symmetrical relation, Tony's friend link still exists.
        self.assertQuerysetEqual(
            tony.friends.all(),
            ['Chris'],
            attrgetter("name")
        )

</source>
</class>

<class classid="328" nclones="2" nlines="10" similarity="90">
<source file="django/tests/m2m_through_regress/tests.py.pyindent" startline="51" endline="58" pcid="18444">
        msg = (
            "Cannot set values on a ManyToManyField which specifies an "
            "intermediary model. Use m2m_through_regress.Membership's Manager "
            "instead."
        )
        with self.assertRaisesMessage(AttributeError, msg):
            self.bob.group_set.set([])

</source>
<source file="django/tests/m2m_through_regress/tests.py.pyindent" startline="60" endline="67" pcid="18446">
        msg = (
            "Cannot set values on a ManyToManyField which specifies an "
            "intermediary model. Use m2m_through_regress.Membership's Manager "
            "instead."
        )
        with self.assertRaisesMessage(AttributeError, msg):
            self.roll.members.set([])

</source>
</class>

<class classid="329" nclones="2" nlines="10" similarity="90">
<source file="django/tests/m2m_through_regress/tests.py.pyindent" startline="69" endline="76" pcid="18448">
        msg = (
            "Cannot use create() on a ManyToManyField which specifies an "
            "intermediary model. Use m2m_through_regress.Membership's "
            "Manager instead."
        )
        with self.assertRaisesMessage(AttributeError, msg):
            self.rock.members.create(name="Anne")

</source>
<source file="django/tests/m2m_through_regress/tests.py.pyindent" startline="78" endline="85" pcid="18450">
        msg = (
            "Cannot use create() on a ManyToManyField which specifies an "
            "intermediary model. Use m2m_through_regress.Membership's "
            "Manager instead."
        )
        with self.assertRaisesMessage(AttributeError, msg):
            self.bob.group_set.create(name="Funk")

</source>
</class>

<class classid="330" nclones="3" nlines="17" similarity="88">
<source file="django/tests/managers_regress/tests.py.pyindent" startline="86" endline="98" pcid="18548">
        class SwappableModel(models.Model):
            class Meta:
                swappable = 'TEST_SWAPPABLE_MODEL'

        # Accessing the manager on a swappable model should
        # raise an attribute error with a helpful message
        msg = (
            "Manager isn't available; 'managers_regress.SwappableModel' "
            "has been swapped for 'managers_regress.Parent'"
        )
        with self.assertRaisesMessage(AttributeError, msg):
            SwappableModel.objects.all()

</source>
<source file="django/tests/managers_regress/tests.py.pyindent" startline="102" endline="117" pcid="18552">
        class SwappableModel(models.Model):
            stuff = models.Manager()

            class Meta:
                swappable = 'TEST_SWAPPABLE_MODEL'

        # Accessing the manager on a swappable model with an
        # explicit manager should raise an attribute error with a
        # helpful message
        msg = (
            "Manager isn't available; 'managers_regress.SwappableModel' "
            "has been swapped for 'managers_regress.Parent'"
        )
        with self.assertRaisesMessage(AttributeError, msg):
            SwappableModel.stuff.all()

</source>
<source file="django/tests/managers_regress/tests.py.pyindent" startline="121" endline="136" pcid="18556">
        class SwappableModel(models.Model):
            objects = models.Manager()

            class Meta:
                swappable = 'TEST_SWAPPABLE_MODEL'

        # Accessing the manager on a swappable model with an
        # explicit manager should raise an attribute error with a
        # helpful message
        msg = (
            "Manager isn't available; 'managers_regress.SwappableModel' "
            "has been swapped for 'managers_regress.Parent'"
        )
        with self.assertRaisesMessage(AttributeError, msg):
            SwappableModel.objects.all()

</source>
</class>

<class classid="331" nclones="3" nlines="43" similarity="75">
<source file="django/tests/managers_regress/tests.py.pyindent" startline="165" endline="198" pcid="18563">
        class CustomManager(models.Manager):
            pass

        class AbstractModel(models.Model):
            custom_manager = CustomManager()

            class Meta:
                abstract = True

        class PlainModel(models.Model):
            custom_manager = CustomManager()

        self.assertIsInstance(PlainModel._base_manager, models.Manager)
        self.assertIsInstance(PlainModel._default_manager, CustomManager)

        class ModelWithAbstractParent(AbstractModel):
            pass

        self.assertIsInstance(ModelWithAbstractParent._base_manager, models.Manager)
        self.assertIsInstance(ModelWithAbstractParent._default_manager, CustomManager)

        class ProxyModel(PlainModel):
            class Meta:
                proxy = True

        self.assertIsInstance(ProxyModel._base_manager, models.Manager)
        self.assertIsInstance(ProxyModel._default_manager, CustomManager)

        class MTIModel(PlainModel):
            pass

        self.assertIsInstance(MTIModel._base_manager, models.Manager)
        self.assertIsInstance(MTIModel._default_manager, CustomManager)

</source>
<source file="django/tests/managers_regress/tests.py.pyindent" startline="200" endline="235" pcid="18572">
        class CustomManager(models.Manager):
            pass

        class AbstractModel(models.Model):
            another_manager = models.Manager()
            custom_manager = CustomManager()

            class Meta:
                default_manager_name = 'custom_manager'
                abstract = True

        class PlainModel(models.Model):
            another_manager = models.Manager()
            custom_manager = CustomManager()

            class Meta:
                default_manager_name = 'custom_manager'

        self.assertIsInstance(PlainModel._default_manager, CustomManager)

        class ModelWithAbstractParent(AbstractModel):
            pass

        self.assertIsInstance(ModelWithAbstractParent._default_manager, CustomManager)

        class ProxyModel(PlainModel):
            class Meta:
                proxy = True

        self.assertIsInstance(ProxyModel._default_manager, CustomManager)

        class MTIModel(PlainModel):
            pass

        self.assertIsInstance(MTIModel._default_manager, CustomManager)

</source>
<source file="django/tests/managers_regress/tests.py.pyindent" startline="237" endline="272" pcid="18582">
        class CustomManager(models.Manager):
            pass

        class AbstractModel(models.Model):
            another_manager = models.Manager()
            custom_manager = CustomManager()

            class Meta:
                base_manager_name = 'custom_manager'
                abstract = True

        class PlainModel(models.Model):
            another_manager = models.Manager()
            custom_manager = CustomManager()

            class Meta:
                base_manager_name = 'custom_manager'

        self.assertIsInstance(PlainModel._base_manager, CustomManager)

        class ModelWithAbstractParent(AbstractModel):
            pass

        self.assertIsInstance(ModelWithAbstractParent._base_manager, CustomManager)

        class ProxyModel(PlainModel):
            class Meta:
                proxy = True

        self.assertIsInstance(ProxyModel._base_manager, CustomManager)

        class MTIModel(PlainModel):
            pass

        self.assertIsInstance(MTIModel._base_manager, CustomManager)

</source>
</class>

<class classid="332" nclones="2" nlines="13" similarity="84">
<source file="django/tests/many_to_many/models.py.pyindent" startline="31" endline="44" pcid="18602">
    headline = models.CharField(max_length=100)
    # Assign a string as name to make sure the intermediary model is
    # correctly created. Refs #20207
    publications = models.ManyToManyField(Publication, name='publications')
    tags = models.ManyToManyField(Tag, related_name='tags')

    def __str__(self):
        return self.headline

    class Meta:
        ordering = ('headline',)


# Models to test correct related_name inheritance
</source>
<source file="django/tests/many_to_one/models.py.pyindent" startline="19" endline="29" pcid="18640">
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter, models.CASCADE)

    def __str__(self):
        return self.headline

    class Meta:
        ordering = ('headline',)


</source>
</class>

<class classid="333" nclones="2" nlines="20" similarity="75">
<source file="django/tests/messages_tests/base.py.pyindent" startline="151" endline="168" pcid="18716">
        """
        With the message middleware enabled, messages are properly stored and
        retrieved across the full request/redirect/response cycle.
        """
        data = {
            'messages': ['Test message %d' % x for x in range(5)],
        }
        show_url = reverse('show_message')
        for level in ('debug', 'info', 'success', 'warning', 'error'):
            add_url = reverse('add_message', args=(level,))
            response = self.client.post(add_url, data, follow=True)
            self.assertRedirects(response, show_url)
            self.assertIn('messages', response.context)
            messages = [Message(self.levels[level], msg) for msg in data['messages']]
            self.assertEqual(list(response.context['messages']), messages)
            for msg in data['messages']:
                self.assertContains(response, msg)

</source>
<source file="django/tests/messages_tests/base.py.pyindent" startline="197" endline="214" pcid="18724">
        """
        Messages persist properly when multiple POSTs are made before a GET.
        """
        data = {
            'messages': ['Test message %d' % x for x in range(5)],
        }
        show_url = reverse('show_message')
        messages = []
        for level in ('debug', 'info', 'success', 'warning', 'error'):
            messages.extend(Message(self.levels[level], msg) for msg in data['messages'])
            add_url = reverse('add_message', args=(level,))
            self.client.post(add_url, data)
        response = self.client.get(show_url)
        self.assertIn('messages', response.context)
        self.assertEqual(list(response.context['messages']), messages)
        for msg in data['messages']:
            self.assertContains(response, msg)

</source>
</class>

<class classid="334" nclones="3" nlines="14" similarity="71">
<source file="django/tests/messages_tests/test_cookie.py.pyindent" startline="99" endline="121" pcid="18775">
        """
        If the data exceeds what is allowed in a cookie, older messages are
        removed before saving (and returned by the ``update`` method).
        """
        storage = self.get_storage()
        response = self.get_response()

        # When storing as a cookie, the cookie has constant overhead of approx
        # 54 chars, and each message has a constant overhead of about 37 chars
        # and a variable overhead of zero in the best case. We aim for a message
        # size which will fit 4 messages into the cookie, but not 5.
        # See also FallbackTest.test_session_fallback
        msg_size = int((CookieStorage.max_cookie_size - 54) / 4.5 - 37)
        for i in range(5):
            storage.add(constants.INFO, str(i) * msg_size)
        unstored_messages = storage.update(response)

        cookie_storing = self.stored_messages_count(storage, response)
        self.assertEqual(cookie_storing, 4)

        self.assertEqual(len(unstored_messages), 1)
        self.assertEqual(unstored_messages[0].message, '0' * msg_size)

</source>
<source file="django/tests/messages_tests/test_fallback.py.pyindent" startline="123" endline="138" pcid="18796">
        """
        If the data exceeds what is allowed in a cookie, messages which did
        not fit are stored in the SessionBackend.
        """
        storage = self.get_storage()
        response = self.get_response()
        # see comment in CookieTests.test_cookie_max_length()
        msg_size = int((CookieStorage.max_cookie_size - 54) / 4.5 - 37)
        for i in range(5):
            storage.add(constants.INFO, str(i) * msg_size)
        storage.update(response)
        cookie_storing = self.stored_cookie_messages_count(storage, response)
        self.assertEqual(cookie_storing, 4)
        session_storing = self.stored_session_messages_count(storage, response)
        self.assertEqual(session_storing, 1)

</source>
<source file="django/tests/messages_tests/test_fallback.py.pyindent" startline="102" endline="121" pcid="18794">
        """
        (1) A short number of messages whose data size doesn't exceed what is
        allowed in a cookie will all be stored in the CookieBackend.

        (2) If the CookieBackend can store all messages, the SessionBackend
        won't be written to at all.
        """
        storage = self.get_storage()
        response = self.get_response()
        # Overwrite the _store method of the fallback storage to prove it isn't
        # used (it would cause a TypeError: 'NoneType' object is not callable).
        self.get_session_storage(storage)._store = None
        for i in range(5):
            storage.add(constants.INFO, str(i) * 100)
        storage.update(response)
        cookie_storing = self.stored_cookie_messages_count(storage, response)
        self.assertEqual(cookie_storing, 5)
        session_storing = self.stored_session_messages_count(storage, response)
        self.assertEqual(session_storing, 0)

</source>
</class>

<class classid="335" nclones="2" nlines="10" similarity="80">
<source file="django/tests/messages_tests/test_fallback.py.pyindent" startline="63" endline="73" pcid="18791">
        request = self.get_request()
        storage = self.storage_class(request)
        cookie_storage = self.get_cookie_storage(storage)
        session_storage = self.get_session_storage(storage)

        # Set initial cookie and session data.
        example_messages = [str(i) for i in range(5)]
        set_cookie_data(cookie_storage, example_messages[:4] + [CookieStorage.not_finished])
        set_session_data(session_storage, example_messages[4:])
        self.assertEqual(list(storage), example_messages)

</source>
<source file="django/tests/messages_tests/test_fallback.py.pyindent" startline="75" endline="84" pcid="18792">
        request = self.get_request()
        storage = self.storage_class(request)
        cookie_storage = self.get_cookie_storage(storage)
        session_storage = self.get_session_storage(storage)
        # Set initial cookie and session data.
        example_messages = [str(i) for i in range(5)]
        set_cookie_data(cookie_storage, [CookieStorage.not_finished], encode_empty=True)
        set_session_data(session_storage, example_messages)
        self.assertEqual(list(storage), example_messages)

</source>
</class>

<class classid="336" nclones="2" nlines="12" similarity="83">
<source file="django/tests/migrate_signals/tests.py.pyindent" startline="78" endline="87" pcid="19013">
            args = receiver.call_args
            self.assertEqual(receiver.call_counter, 1)
            self.assertEqual(set(args), set(SIGNAL_ARGS))
            self.assertEqual(args['app_config'], APP_CONFIG)
            self.assertEqual(args['verbosity'], MIGRATE_VERBOSITY)
            self.assertEqual(args['interactive'], MIGRATE_INTERACTIVE)
            self.assertEqual(args['using'], 'default')
            self.assertEqual(args['plan'], [])
            self.assertIsInstance(args['apps'], migrations.state.StateApps)

</source>
<source file="django/tests/migrate_signals/tests.py.pyindent" startline="101" endline="111" pcid="19015">
            args = receiver.call_args
            self.assertEqual(receiver.call_counter, 1)
            self.assertEqual(set(args), set(SIGNAL_ARGS))
            self.assertEqual(args['app_config'], APP_CONFIG)
            self.assertEqual(args['verbosity'], MIGRATE_VERBOSITY)
            self.assertEqual(args['interactive'], MIGRATE_INTERACTIVE)
            self.assertEqual(args['using'], 'default')
            self.assertIsInstance(args['plan'][0][0], migrations.Migration)
            # The migration isn't applied backward.
            self.assertFalse(args['plan'][0][1])
            self.assertIsInstance(args['apps'], migrations.state.StateApps)
</source>
</class>

<class classid="337" nclones="9" nlines="21" similarity="71">
<source file="django/tests/migrations/migrations_test_apps/conflicting_app_with_dependencies/migrations/0001_initial.py.pyindent" startline="5" endline="24" pcid="19021">

    operations = [
        migrations.CreateModel(
            "Author",
            [
                ("id", models.AutoField(primary_key=True)),
                ("name", models.CharField(max_length=255)),
                ("slug", models.SlugField(null=True)),
                ("age", models.IntegerField(default=0)),
                ("silly_field", models.BooleanField(default=False)),
            ],
        ),
        migrations.CreateModel(
            "Tribble",
            [
                ("id", models.AutoField(primary_key=True)),
                ("fluffy", models.BooleanField(default=True)),
            ],
        )
    ]
</source>
<source file="django/tests/migrations/test_migrations_no_changes/0001_initial.py.pyindent" startline="5" endline="27" pcid="19370">

    operations = [

        migrations.CreateModel(
            "Author",
            [
                ("id", models.AutoField(primary_key=True)),
                ("name", models.CharField(max_length=255)),
                ("slug", models.SlugField(null=True)),
                ("age", models.IntegerField(default=0)),
                ("silly_field", models.BooleanField(default=False)),
            ],
        ),

        migrations.CreateModel(
            "Tribble",
            [
                ("id", models.AutoField(primary_key=True)),
                ("fluffy", models.BooleanField(default=True)),
            ],
        )

    ]
</source>
<source file="django/tests/migrations/migrations_test_apps/unspecified_app_with_conflict/migrations/0001_initial.py.pyindent" startline="5" endline="27" pcid="19054">

    operations = [

        migrations.CreateModel(
            "Author",
            [
                ("id", models.AutoField(primary_key=True)),
                ("name", models.CharField(max_length=255)),
                ("slug", models.SlugField(null=True)),
                ("age", models.IntegerField(default=0)),
                ("silly_field", models.BooleanField(default=False)),
            ],
        ),

        migrations.CreateModel(
            "Tribble",
            [
                ("id", models.AutoField(primary_key=True)),
                ("fluffy", models.BooleanField(default=True)),
            ],
        )

    ]
</source>
<source file="django/tests/migrations/test_migrations_custom_user/0001_initial.py.pyindent" startline="6" endline="28" pcid="19361">
    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [

        migrations.CreateModel(
            "Author",
            [
                ("id", models.AutoField(primary_key=True)),
                ("name", models.CharField(max_length=255)),
            ],
        ),

        migrations.CreateModel(
            "Tribble",
            [
                ("id", models.AutoField(primary_key=True)),
                ("author", models.ForeignKey(settings.AUTH_USER_MODEL, models.CASCADE, to_field="id")),
            ],
        )

    ]
</source>
<source file="django/tests/migrations/test_migrations_no_ancestor/0001_initial.py.pyindent" startline="5" endline="27" pcid="19367">

    operations = [

        migrations.CreateModel(
            "Author",
            [
                ("id", models.AutoField(primary_key=True)),
                ("name", models.CharField(max_length=255)),
                ("slug", models.SlugField(null=True)),
                ("age", models.IntegerField(default=0)),
                ("silly_field", models.BooleanField(default=False)),
            ],
        ),

        migrations.CreateModel(
            "Tribble",
            [
                ("id", models.AutoField(primary_key=True)),
                ("fluffy", models.BooleanField(default=True)),
            ],
        )

    ]
</source>
<source file="django/tests/migrations/test_migrations_conflict/0001_initial.py.pyindent" startline="5" endline="27" pcid="19358">

    operations = [

        migrations.CreateModel(
            "Author",
            [
                ("id", models.AutoField(primary_key=True)),
                ("name", models.CharField(max_length=255)),
                ("slug", models.SlugField(null=True)),
                ("age", models.IntegerField(default=0)),
                ("silly_field", models.BooleanField(default=False)),
            ],
        ),

        migrations.CreateModel(
            "Tribble",
            [
                ("id", models.AutoField(primary_key=True)),
                ("fluffy", models.BooleanField(default=True)),
            ],
        )

    ]
</source>
<source file="django/tests/migrations/migrations_test_apps/migrated_app/migrations/0001_initial.py.pyindent" startline="5" endline="27" pcid="19044">

    operations = [

        migrations.CreateModel(
            "Author",
            [
                ("id", models.AutoField(primary_key=True)),
                ("name", models.CharField(max_length=255)),
                ("slug", models.SlugField(null=True)),
                ("age", models.IntegerField(default=0)),
                ("silly_field", models.BooleanField(default=False)),
            ],
        ),

        migrations.CreateModel(
            "Tribble",
            [
                ("id", models.AutoField(primary_key=True)),
                ("fluffy", models.BooleanField(default=True)),
            ],
        )

    ]
</source>
<source file="django/tests/migrations/test_migrations_first/thefirst.py.pyindent" startline="5" endline="27" pcid="19364">

    operations = [

        migrations.CreateModel(
            "Author",
            [
                ("id", models.AutoField(primary_key=True)),
                ("name", models.CharField(max_length=255)),
                ("slug", models.SlugField(null=True)),
                ("age", models.IntegerField(default=0)),
                ("silly_field", models.BooleanField(default=False)),
            ],
        ),

        migrations.CreateModel(
            "Tribble",
            [
                ("id", models.AutoField(primary_key=True)),
                ("fluffy", models.BooleanField(default=True)),
            ],
        )

    ]
</source>
<source file="django/tests/migrations/test_migrations_squashed/0001_initial.py.pyindent" startline="5" endline="27" pcid="19384">

    operations = [

        migrations.CreateModel(
            "Author",
            [
                ("id", models.AutoField(primary_key=True)),
                ("name", models.CharField(max_length=255)),
                ("slug", models.SlugField(null=True)),
                ("age", models.IntegerField(default=0)),
                ("silly_field", models.BooleanField(default=False)),
            ],
        ),

        migrations.CreateModel(
            "Tribble",
            [
                ("id", models.AutoField(primary_key=True)),
                ("fluffy", models.BooleanField(default=True)),
            ],
        )

    ]
</source>
</class>

<class classid="338" nclones="2" nlines="15" similarity="80">
<source file="django/tests/migrations/migrations_test_apps/lookuperror_b/migrations/0002_b2.py.pyindent" startline="5" endline="19" pcid="19033">

    dependencies = [
        ('lookuperror_a', '0002_a2'),
        ('lookuperror_b', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='B2',
            fields=[
                ('id', models.AutoField(primary_key=True, verbose_name='ID', auto_created=True, serialize=False)),
                ('a1', models.ForeignKey('lookuperror_a.A1', models.CASCADE)),
            ],
        ),
    ]
</source>
<source file="django/tests/migrations/migrations_test_apps/lookuperror_c/migrations/0002_c2.py.pyindent" startline="5" endline="19" pcid="19039">

    dependencies = [
        ('lookuperror_a', '0002_a2'),
        ('lookuperror_c', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='C2',
            fields=[
                ('id', models.AutoField(auto_created=True, verbose_name='ID', primary_key=True, serialize=False)),
                ('a1', models.ForeignKey('lookuperror_a.A1', models.CASCADE)),
            ],
        ),
    ]
</source>
</class>

<class classid="339" nclones="2" nlines="12" similarity="91">
<source file="django/tests/migrations/test_base.py.pyindent" startline="57" endline="66" pcid="19079">
        with connections[using].cursor() as cursor:
            self.assertEqual(
                value,
                any(
                    c["index"]
                    for c in connections[using].introspection.get_constraints(cursor, table).values()
                    if c['columns'] == list(columns)
                ),
            )

</source>
<source file="django/tests/migrations/test_base.py.pyindent" startline="82" endline="91" pcid="19085">
        with connections[using].cursor() as cursor:
            self.assertEqual(
                value,
                any(
                    c["foreign_key"] == to
                    for c in connections[using].introspection.get_constraints(cursor, table).values()
                    if c['columns'] == list(columns)
                ),
            )

</source>
</class>

<class classid="340" nclones="2" nlines="12" similarity="76">
<source file="django/tests/migrations/test_commands.py.pyindent" startline="981" endline="990" pcid="19195">
        """
        makemigrations enters and exits interactive mode properly.
        """
        # Monkeypatch interactive questioner to auto reject
        with mock.patch('builtins.input', mock.Mock(return_value='N')):
            with self.temporary_migration_module(module="migrations.test_migrations_conflict") as migration_dir:
                call_command("makemigrations", "migrations", name="merge", merge=True, interactive=True, verbosity=0)
                merge_file = os.path.join(migration_dir, '0003_merge.py')
                self.assertFalse(os.path.exists(merge_file))

</source>
<source file="django/tests/migrations/test_commands.py.pyindent" startline="1226" endline="1240" pcid="19241">
        """
        The user is prompted to merge by default if there are conflicts and
        merge is True. Answer negative to differentiate it from behavior when
        --noinput is specified.
        """
        # Monkeypatch interactive questioner to auto reject
        out = io.StringIO()
        with mock.patch('builtins.input', mock.Mock(return_value='N')):
            with self.temporary_migration_module(module="migrations.test_migrations_conflict") as migration_dir:
                call_command("makemigrations", "migrations", name="merge", merge=True, stdout=out)
                merge_file = os.path.join(migration_dir, '0003_merge.py')
                # This will fail if interactive is False by default
                self.assertFalse(os.path.exists(merge_file))
            self.assertNotIn("Created new merge migration", out.getvalue())

</source>
</class>

<class classid="341" nclones="2" nlines="14" similarity="78">
<source file="django/tests/migrations/test_commands.py.pyindent" startline="992" endline="1003" pcid="19198">
        """
        makemigrations enters interactive mode and merges properly.
        """
        # Monkeypatch interactive questioner to auto accept
        with mock.patch('builtins.input', mock.Mock(return_value='y')):
            out = io.StringIO()
            with self.temporary_migration_module(module="migrations.test_migrations_conflict") as migration_dir:
                call_command("makemigrations", "migrations", name="merge", merge=True, interactive=True, stdout=out)
                merge_file = os.path.join(migration_dir, '0003_merge.py')
                self.assertTrue(os.path.exists(merge_file))
            self.assertIn("Created new merge migration", out.getvalue())

</source>
<source file="django/tests/migrations/test_commands.py.pyindent" startline="1006" endline="1014" pcid="19201">
        mock_datetime.datetime.now.return_value = datetime.datetime(2016, 1, 2, 3, 4)
        with mock.patch('builtins.input', mock.Mock(return_value='y')):
            out = io.StringIO()
            with self.temporary_migration_module(module="migrations.test_migrations_conflict") as migration_dir:
                call_command("makemigrations", "migrations", merge=True, interactive=True, stdout=out)
                merge_file = os.path.join(migration_dir, '0003_merge_20160102_0304.py')
                self.assertTrue(os.path.exists(merge_file))
            self.assertIn("Created new merge migration", out.getvalue())

</source>
</class>

<class classid="342" nclones="4" nlines="18" similarity="73">
<source file="django/tests/migrations/test_commands.py.pyindent" startline="1016" endline="1031" pcid="19204">
        """
        Non-interactive makemigrations fails when a default is missing on a
        new not-null field.
        """
        class SillyModel(models.Model):
            silly_field = models.BooleanField(default=False)
            silly_int = models.IntegerField()

            class Meta:
                app_label = "migrations"

        out = io.StringIO()
        with self.assertRaises(SystemExit):
            with self.temporary_migration_module(module="migrations.test_migrations_no_default"):
                call_command("makemigrations", "migrations", interactive=False, stdout=out)

</source>
<source file="django/tests/migrations/test_commands.py.pyindent" startline="1147" endline="1162" pcid="19227">
        """
        `makemigrations --dry-run` should not ask for defaults.
        """
        class SillyModel(models.Model):
            silly_field = models.BooleanField(default=False)
            silly_date = models.DateField()  # Added field without a default

            class Meta:
                app_label = "migrations"

        out = io.StringIO()
        with self.temporary_migration_module(module="migrations.test_migrations_no_default"):
            call_command("makemigrations", "migrations", dry_run=True, stdout=out)
        # Output the expected changes directly, without asking for defaults
        self.assertIn("Add field silly_date to sillymodel", out.getvalue())

</source>
<source file="django/tests/migrations/test_commands.py.pyindent" startline="1051" endline="1066" pcid="19213">
        """
        makemigrations adds and removes a possible model rename in
        non-interactive mode.
        """
        class RenamedModel(models.Model):
            silly_field = models.BooleanField(default=False)

            class Meta:
                app_label = "migrations"

        out = io.StringIO()
        with self.temporary_migration_module(module="migrations.test_migrations_no_default"):
            call_command("makemigrations", "migrations", interactive=False, stdout=out)
        self.assertIn("Delete model SillyModel", out.getvalue())
        self.assertIn("Create model RenamedModel", out.getvalue())

</source>
<source file="django/tests/migrations/test_commands.py.pyindent" startline="1068" endline="1083" pcid="19217">
        """
        makemigrations adds and removes a possible field rename in
        non-interactive mode.
        """
        class SillyModel(models.Model):
            silly_rename = models.BooleanField(default=False)

            class Meta:
                app_label = "migrations"

        out = io.StringIO()
        with self.temporary_migration_module(module="migrations.test_migrations_no_default"):
            call_command("makemigrations", "migrations", interactive=False, stdout=out)
        self.assertIn("Remove field silly_field from sillymodel", out.getvalue())
        self.assertIn("Add field silly_rename to sillymodel", out.getvalue())

</source>
</class>

<class classid="343" nclones="2" nlines="12" similarity="83">
<source file="django/tests/migrations/test_commands.py.pyindent" startline="1485" endline="1494" pcid="19290">
        """--squashed-name specifies the new migration's name."""
        squashed_name = 'squashed_name'
        with self.temporary_migration_module(module='migrations.test_migrations') as migration_dir:
            call_command(
                'squashmigrations', 'migrations', '0001', '0002',
                squashed_name=squashed_name, interactive=False, verbosity=0,
            )
            squashed_migration_file = os.path.join(migration_dir, '0001_%s.py' % squashed_name)
            self.assertTrue(os.path.exists(squashed_migration_file))

</source>
<source file="django/tests/migrations/test_commands.py.pyindent" startline="1496" endline="1506" pcid="19292">
        """--squashed-name also works if a start migration is omitted."""
        squashed_name = 'squashed_name'
        with self.temporary_migration_module(module="migrations.test_migrations") as migration_dir:
            call_command(
                'squashmigrations', 'migrations', '0001',
                squashed_name=squashed_name, interactive=False, verbosity=0,
            )
            squashed_migration_file = os.path.join(migration_dir, '0001_%s.py' % squashed_name)
            self.assertTrue(os.path.exists(squashed_migration_file))


</source>
</class>

<class classid="344" nclones="2" nlines="22" similarity="72">
<source file="django/tests/migrations/test_graph.py.pyindent" startline="163" endline="180" pcid="19322">
        graph = MigrationGraph()
        root = ("app_a", "1")
        graph.add_node(root, None)
        expected = [root]
        for i in range(2, 750):
            parent = ("app_a", str(i - 1))
            child = ("app_a", str(i))
            graph.add_node(child, None)
            graph.add_dependency(str(i), child, parent)
            expected.append(child)
        leaf = expected[-1]

        forwards_plan = graph.forwards_plan(leaf)
        self.assertEqual(expected, forwards_plan)

        backwards_plan = graph.backwards_plan(root)
        self.assertEqual(expected[::-1], backwards_plan)

</source>
<source file="django/tests/migrations/test_graph.py.pyindent" startline="182" endline="203" pcid="19324">
        graph = MigrationGraph()
        root = ("app_a", "1")
        graph.add_node(root, None)
        expected = [root]
        for i in range(2, 1000):
            parent = ("app_a", str(i - 1))
            child = ("app_a", str(i))
            graph.add_node(child, None)
            graph.add_dependency(str(i), child, parent)
            expected.append(child)
        leaf = expected[-1]

        with self.assertWarnsMessage(RuntimeWarning, RECURSION_DEPTH_WARNING):
            forwards_plan = graph.forwards_plan(leaf)

        self.assertEqual(expected, forwards_plan)

        with self.assertWarnsMessage(RuntimeWarning, RECURSION_DEPTH_WARNING):
            backwards_plan = graph.backwards_plan(root)

        self.assertEqual(expected[::-1], backwards_plan)

</source>
</class>

<class classid="345" nclones="4" nlines="16" similarity="73">
<source file="django/tests/migrations/test_migrations_no_default/0001_initial.py.pyindent" startline="5" endline="20" pcid="19373">

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='SillyModel',
            fields=[
                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),
                ('silly_field', models.BooleanField(default=False)),
            ],
            options={
            },
            bases=(models.Model,),
        ),
    ]
</source>
<source file="django/tests/migration_test_data_persistence/migrations/0001_initial.py.pyindent" startline="5" endline="20" pcid="19467">

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Book',
            fields=[
                ('id', models.AutoField(verbose_name='ID', primary_key=True, serialize=False, auto_created=True)),
                ('title', models.CharField(max_length=100)),
            ],
            options={
            },
            bases=(models.Model,),
        ),
    ]
</source>
<source file="django/tests/postgres_tests/array_index_migrations/0001_initial.py.pyindent" startline="6" endline="25" pcid="21371">

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='CharTextArrayIndexModel',
            fields=[
                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),
                ('char', django.contrib.postgres.fields.ArrayField(
                    models.CharField(max_length=10), db_index=True, size=100)
                 ),
                ('char2', models.CharField(max_length=11, db_index=True)),
                ('text', django.contrib.postgres.fields.ArrayField(models.TextField(), db_index=True)),
            ],
            options={
            },
            bases=(models.Model,),
        ),
    ]
</source>
<source file="django/tests/postgres_tests/array_default_migrations/0001_initial.py.pyindent" startline="6" endline="21" pcid="21369">

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='IntegerArrayDefaultModel',
            fields=[
                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),
                ('field', django.contrib.postgres.fields.ArrayField(models.IntegerField(), size=None)),
            ],
            options={
            },
            bases=(models.Model,),
        ),
    ]
</source>
</class>

<class classid="346" nclones="2" nlines="14" similarity="71">
<source file="django/tests/migrations/test_migrations_plan/0002_second.py.pyindent" startline="5" endline="20" pcid="19378">

    dependencies = [
        ('migrations', '0001_initial'),
    ]

    operations = [

        migrations.CreateModel(
            'Book',
            [
                ('id', models.AutoField(primary_key=True)),
            ],
        ),
        migrations.RunSQL('SELECT * FROM migrations_book', 'SELECT * FROM migrations_salamander')

    ]
</source>
<source file="django/tests/migrations/test_migrations_plan/0003_third.py.pyindent" startline="5" endline="19" pcid="19379">

    dependencies = [
        ('migrations', '0002_second'),
    ]

    operations = [

        migrations.CreateModel(
            'Author',
            [
                ('id', models.AutoField(primary_key=True)),
            ],
        ),
        migrations.RunSQL('SELECT * FROM migrations_author', 'SELECT * FROM migrations_book')
    ]
</source>
</class>

<class classid="347" nclones="2" nlines="10" similarity="100">
<source file="django/tests/migrations/test_migrations_squashed_complex/3_squashed_5.py.pyindent" startline="5" endline="16" pcid="19390">

    replaces = [
        ("migrations", "3_auto"),
        ("migrations", "4_auto"),
        ("migrations", "5_auto"),
    ]

    dependencies = [("migrations", "2_auto")]

    operations = [
        migrations.RunPython(migrations.RunPython.noop)
    ]
</source>
<source file="django/tests/migrations/test_migrations_squashed_erroneous/3_squashed_5.py.pyindent" startline="5" endline="16" pcid="19405">

    replaces = [
        ("migrations", "3_auto"),
        ("migrations", "4_auto"),
        ("migrations", "5_auto"),
    ]

    dependencies = [("migrations", "2_auto")]

    operations = [
        migrations.RunPython(migrations.RunPython.noop)
    ]
</source>
</class>

<class classid="348" nclones="2" nlines="29" similarity="76">
<source file="django/tests/migrations/test_multidb.py.pyindent" startline="108" endline="130" pcid="19444">
        with override_settings(DATABASE_ROUTERS=[MigrateEverythingRouter()]):
            project_state = self.set_up_test_model(app_label)

        sql = """
        INSERT INTO {0}_pony (pink, weight) VALUES (1, 3.55);
        INSERT INTO {0}_pony (pink, weight) VALUES (3, 5.0);
        """.format(app_label)

        operation = migrations.RunSQL(sql, hints=hints or {})
        # Test the state alteration does nothing
        new_state = project_state.clone()
        operation.state_forwards(app_label, new_state)
        self.assertEqual(new_state, project_state)
        # Test the database alteration
        self.assertEqual(project_state.apps.get_model(app_label, "Pony").objects.count(), 0)
        with connection.schema_editor() as editor:
            operation.database_forwards(app_label, editor, project_state, new_state)
        Pony = project_state.apps.get_model(app_label, "Pony")
        if should_run:
            self.assertEqual(Pony.objects.count(), 2)
        else:
            self.assertEqual(Pony.objects.count(), 0)

</source>
<source file="django/tests/migrations/test_multidb.py.pyindent" startline="143" endline="166" pcid="19451">
        with override_settings(DATABASE_ROUTERS=[MigrateEverythingRouter()]):
            project_state = self.set_up_test_model(app_label)

        # Create the operation
        def inner_method(models, schema_editor):
            Pony = models.get_model(app_label, "Pony")
            Pony.objects.create(pink=1, weight=3.55)
            Pony.objects.create(weight=5)

        operation = migrations.RunPython(inner_method, hints=hints or {})
        # Test the state alteration does nothing
        new_state = project_state.clone()
        operation.state_forwards(app_label, new_state)
        self.assertEqual(new_state, project_state)
        # Test the database alteration
        self.assertEqual(project_state.apps.get_model(app_label, "Pony").objects.count(), 0)
        with connection.schema_editor() as editor:
            operation.database_forwards(app_label, editor, project_state, new_state)
        Pony = project_state.apps.get_model(app_label, "Pony")
        if should_run:
            self.assertEqual(Pony.objects.count(), 2)
        else:
            self.assertEqual(Pony.objects.count(), 0)

</source>
</class>

<class classid="349" nclones="3" nlines="45" similarity="75">
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="47" endline="86" pcid="19505">

    def test_not_iterable(self):
        class TestModelAdmin(ModelAdmin):
            raw_id_fields = 10

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'raw_id_fields' must be a list or tuple.",
            'admin.E001'
        )

    def test_missing_field(self):
        class TestModelAdmin(ModelAdmin):
            raw_id_fields = ('non_existent_field',)

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'raw_id_fields[0]' refers to 'non_existent_field', "
            "which is not an attribute of 'modeladmin.ValidationTestModel'.",
            'admin.E002'
        )

    def test_invalid_field_type(self):
        class TestModelAdmin(ModelAdmin):
            raw_id_fields = ('name',)

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'raw_id_fields[0]' must be a foreign key or a "
            "many-to-many field.",
            'admin.E003'
        )

    def test_valid_case(self):
        class TestModelAdmin(ModelAdmin):
            raw_id_fields = ('users',)

        self.assertIsValid(TestModelAdmin, ValidationTestModel)


</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="297" endline="335" pcid="19560">

    def test_not_iterable(self):
        class TestModelAdmin(ModelAdmin):
            filter_horizontal = 10

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'filter_horizontal' must be a list or tuple.",
            'admin.E018'
        )

    def test_missing_field(self):
        class TestModelAdmin(ModelAdmin):
            filter_horizontal = ('non_existent_field',)

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'filter_horizontal[0]' refers to 'non_existent_field', "
            "which is not an attribute of 'modeladmin.ValidationTestModel'.",
            'admin.E019'
        )

    def test_invalid_field_type(self):
        class TestModelAdmin(ModelAdmin):
            filter_horizontal = ('name',)

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'filter_horizontal[0]' must be a many-to-many field.",
            'admin.E020'
        )

    def test_valid_case(self):
        class TestModelAdmin(ModelAdmin):
            filter_horizontal = ('users',)

        self.assertIsValid(TestModelAdmin, ValidationTestModel)


</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="257" endline="295" pcid="19551">

    def test_not_iterable(self):
        class TestModelAdmin(ModelAdmin):
            filter_vertical = 10

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'filter_vertical' must be a list or tuple.",
            'admin.E017'
        )

    def test_missing_field(self):
        class TestModelAdmin(ModelAdmin):
            filter_vertical = ('non_existent_field',)

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'filter_vertical[0]' refers to 'non_existent_field', "
            "which is not an attribute of 'modeladmin.ValidationTestModel'.",
            'admin.E019'
        )

    def test_invalid_field_type(self):
        class TestModelAdmin(ModelAdmin):
            filter_vertical = ('name',)

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'filter_vertical[0]' must be a many-to-many field.",
            'admin.E020'
        )

    def test_valid_case(self):
        class TestModelAdmin(ModelAdmin):
            filter_vertical = ('users',)

        self.assertIsValid(TestModelAdmin, ValidationTestModel)


</source>
</class>

<class classid="350" nclones="29" nlines="10" similarity="70">
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="49" endline="57" pcid="19506">
        class TestModelAdmin(ModelAdmin):
            raw_id_fields = 10

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'raw_id_fields' must be a list or tuple.",
            'admin.E001'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="912" endline="920" pcid="19706">
        class TestModelAdmin(ModelAdmin):
            inlines = 10

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'inlines' must be a list or tuple.",
            'admin.E103'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="96" endline="104" pcid="19517">
        class TestModelAdmin(ModelAdmin):
            fieldsets = 10

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'fieldsets' must be a list or tuple.",
            'admin.E007'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="106" endline="114" pcid="19519">
        class TestModelAdmin(ModelAdmin):
            fieldsets = ({},)

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'fieldsets[0]' must be a list or tuple.",
            'admin.E008'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="116" endline="124" pcid="19521">
        class TestModelAdmin(ModelAdmin):
            fieldsets = ((),)

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'fieldsets[0]' must be of length 2.",
            'admin.E009'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="126" endline="134" pcid="19523">
        class TestModelAdmin(ModelAdmin):
            fieldsets = (('General', ()),)

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'fieldsets[0][1]' must be a dictionary.",
            'admin.E010'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="162" endline="170" pcid="19530">
        class TestModelAdmin(ModelAdmin):
            fieldsets = [(None, {'fields': ['name', 'name']})]

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "There are duplicate field(s) in 'fieldsets[0][1]'.",
            'admin.E012'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="194" endline="202" pcid="19537">
        class TestModelAdmin(ModelAdmin):
            fields = ['name', 'name']

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'fields' contains duplicate field(s).",
            'admin.E006'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="874" endline="882" pcid="19696">
        class TestModelAdmin(ModelAdmin):
            save_as = 1

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'save_as' must be a boolean.",
            'admin.E101'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="511" endline="519" pcid="19607">
        class TestModelAdmin(ModelAdmin):
            list_display_links = 10

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'list_display_links' must be a list, a tuple, or None.",
            'admin.E110'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="532" endline="540" pcid="19611">
        class TestModelAdmin(ModelAdmin):
            list_display_links = ('name',)

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'list_display_links[0]' refers to 'name', which is not defined in 'list_display'.",
            'admin.E111'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="855" endline="863" pcid="19691">
        class TestModelAdmin(ModelAdmin):
            list_select_related = 1

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'list_select_related' must be a boolean, tuple or list.",
            'admin.E117'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="893" endline="901" pcid="19701">
        class TestModelAdmin(ModelAdmin):
            save_on_top = 1

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'save_on_top' must be a boolean.",
            'admin.E102'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="772" endline="781" pcid="19672">
        class TestModelAdmin(ModelAdmin):
            date_hierarchy = 'band__name'

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'date_hierarchy' must be a DateField or DateTimeField.",
            'admin.E128'
        )


</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="592" endline="600" pcid="19626">
        class TestModelAdmin(ModelAdmin):
            list_filter = 10

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'list_filter' must be a list or tuple.",
            'admin.E112'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="750" endline="758" pcid="19666">
        class TestModelAdmin(ModelAdmin):
            date_hierarchy = 'name'

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'date_hierarchy' must be a DateField or DateTimeField.",
            'admin.E128'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="402" endline="410" pcid="19583">
        class TestModelAdmin(ModelAdmin):
            prepopulated_fields = ()

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'prepopulated_fields' must be a dictionary.",
            'admin.E026'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="726" endline="735" pcid="19661">
        class TestModelAdmin(ModelAdmin):
            search_fields = 10

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'search_fields' must be a list or tuple.",
            'admin.E126'
        )


</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="465" endline="473" pcid="19596">
        class TestModelAdmin(ModelAdmin):
            list_display = 10

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'list_display' must be a list or tuple.",
            'admin.E107'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="659" endline="667" pcid="19642">
        class TestModelAdmin(ModelAdmin):
            list_filter = (BooleanFieldListFilter,)

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'list_filter[0]' must not inherit from 'FieldListFilter'.",
            'admin.E114'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="707" endline="715" pcid="19656">
        class TestModelAdmin(ModelAdmin):
            list_max_show_all = 'hello'

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'list_max_show_all' must be an integer.",
            'admin.E119'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="688" endline="696" pcid="19651">
        class TestModelAdmin(ModelAdmin):
            list_per_page = 'hello'

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'list_per_page' must be an integer.",
            'admin.E118'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="372" endline="380" pcid="19576">
        class TestModelAdmin(ModelAdmin):
            radio_fields = {'state': None}

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'radio_fields[\"state\"]' must be either admin.HORIZONTAL or admin.VERTICAL.",
            'admin.E024'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="339" endline="348" pcid="19570">

        class TestModelAdmin(ModelAdmin):
            radio_fields = ()

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'radio_fields' must be a dictionary.",
            'admin.E021'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="487" endline="495" pcid="19600">
        class TestModelAdmin(ModelAdmin):
            list_display = ('users',)

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'list_display[0]' must not be a ManyToManyField.",
            'admin.E109'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="320" endline="328" pcid="19565">
        class TestModelAdmin(ModelAdmin):
            filter_horizontal = ('name',)

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'filter_horizontal[0]' must be a many-to-many field.",
            'admin.E020'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="299" endline="307" pcid="19561">
        class TestModelAdmin(ModelAdmin):
            filter_horizontal = 10

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'filter_horizontal' must be a list or tuple.",
            'admin.E018'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="280" endline="288" pcid="19556">
        class TestModelAdmin(ModelAdmin):
            filter_vertical = ('name',)

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'filter_vertical[0]' must be a many-to-many field.",
            'admin.E020'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="259" endline="267" pcid="19552">
        class TestModelAdmin(ModelAdmin):
            filter_vertical = 10

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'filter_vertical' must be a list or tuple.",
            'admin.E017'
        )

</source>
</class>

<class classid="351" nclones="6" nlines="11" similarity="72">
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="59" endline="68" pcid="19508">
        class TestModelAdmin(ModelAdmin):
            raw_id_fields = ('non_existent_field',)

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'raw_id_fields[0]' refers to 'non_existent_field', "
            "which is not an attribute of 'modeladmin.ValidationTestModel'.",
            'admin.E002'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="350" endline="359" pcid="19572">
        class TestModelAdmin(ModelAdmin):
            radio_fields = {'non_existent_field': VERTICAL}

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'radio_fields' refers to 'non_existent_field', "
            "which is not an attribute of 'modeladmin.ValidationTestModel'.",
            'admin.E022'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="412" endline="421" pcid="19585">
        class TestModelAdmin(ModelAdmin):
            prepopulated_fields = {'non_existent_field': ('slug',)}

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'prepopulated_fields' refers to 'non_existent_field', "
            "which is not an attribute of 'modeladmin.ValidationTestModel'.",
            'admin.E027'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="423" endline="432" pcid="19587">
        class TestModelAdmin(ModelAdmin):
            prepopulated_fields = {'slug': ('non_existent_field',)}

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'prepopulated_fields[\"slug\"][0]' refers to 'non_existent_field', "
            "which is not an attribute of 'modeladmin.ValidationTestModel'.",
            'admin.E030'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="269" endline="278" pcid="19554">
        class TestModelAdmin(ModelAdmin):
            filter_vertical = ('non_existent_field',)

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'filter_vertical[0]' refers to 'non_existent_field', "
            "which is not an attribute of 'modeladmin.ValidationTestModel'.",
            'admin.E019'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="309" endline="318" pcid="19563">
        class TestModelAdmin(ModelAdmin):
            filter_horizontal = ('non_existent_field',)

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'filter_horizontal[0]' refers to 'non_existent_field', "
            "which is not an attribute of 'modeladmin.ValidationTestModel'.",
            'admin.E019'
        )

</source>
</class>

<class classid="352" nclones="5" nlines="16" similarity="81">
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="204" endline="218" pcid="19539">
        class ValidationTestInline(TabularInline):
            model = ValidationTestInlineModel
            fields = 10

        class TestModelAdmin(ModelAdmin):
            inlines = [ValidationTestInline]

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'fields' must be a list or tuple.",
            'admin.E004',
            invalid_obj=ValidationTestInline
        )


</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="1032" endline="1045" pcid="19736">
        class ValidationTestInline(TabularInline):
            model = ValidationTestInlineModel
            max_num = 'hello'

        class TestModelAdmin(ModelAdmin):
            inlines = [ValidationTestInline]

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'max_num' must be an integer.",
            'admin.E204',
            invalid_obj=ValidationTestInline
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="1004" endline="1017" pcid="19729">
        class ValidationTestInline(TabularInline):
            model = ValidationTestInlineModel
            extra = 'hello'

        class TestModelAdmin(ModelAdmin):
            inlines = [ValidationTestInline]

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'extra' must be an integer.",
            'admin.E203',
            invalid_obj=ValidationTestInline
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="1060" endline="1073" pcid="19743">
        class ValidationTestInline(TabularInline):
            model = ValidationTestInlineModel
            min_num = 'hello'

        class TestModelAdmin(ModelAdmin):
            inlines = [ValidationTestInline]

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'min_num' must be an integer.",
            'admin.E205',
            invalid_obj=ValidationTestInline
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="976" endline="989" pcid="19722">
        class ValidationTestInline(TabularInline):
            model = ValidationTestInlineModel
            fk_name = 'non_existent_field'

        class TestModelAdmin(ModelAdmin):
            inlines = [ValidationTestInline]

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "'modeladmin.ValidationTestInlineModel' has no field named 'non_existent_field'.",
            'admin.E202',
            invalid_obj=ValidationTestInline
        )

</source>
</class>

<class classid="353" nclones="3" nlines="14" similarity="71">
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="222" endline="233" pcid="19543">
        class FakeForm:
            pass

        class TestModelAdmin(ModelAdmin):
            form = FakeForm

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'form' must inherit from 'BaseModelForm'.",
            'admin.E016'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="626" endline="637" pcid="19633">
        class RandomClass:
            pass

        class TestModelAdmin(ModelAdmin):
            list_filter = (('is_active', RandomClass),)

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'list_filter[0][1]' must inherit from 'FieldListFilter'.",
            'admin.E115'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="613" endline="624" pcid="19630">
        class RandomClass:
            pass

        class TestModelAdmin(ModelAdmin):
            list_filter = (RandomClass,)

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'list_filter[0]' must inherit from 'ListFilter'.",
            'admin.E113'
        )

</source>
</class>

<class classid="354" nclones="2" nlines="11" similarity="81">
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="434" endline="443" pcid="19589">
        class TestModelAdmin(ModelAdmin):
            prepopulated_fields = {'users': ('name',)}

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'prepopulated_fields' refers to 'users', which must not be "
            "a DateTimeField, a ForeignKey, a OneToOneField, or a ManyToManyField.",
            'admin.E028'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="451" endline="461" pcid="19593">
        class TestModelAdmin(ModelAdmin):
            prepopulated_fields = {'best_friend': ('name',)}

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'prepopulated_fields' refers to 'best_friend', which must not be "
            "a DateTimeField, a ForeignKey, a OneToOneField, or a ManyToManyField.",
            'admin.E028'
        )


</source>
</class>

<class classid="355" nclones="2" nlines="16" similarity="93">
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="497" endline="507" pcid="19602">
        def a_callable(obj):
            pass

        class TestModelAdmin(ModelAdmin):
            def a_method(self, obj):
                pass
            list_display = ('name', 'decade_published_in', 'a_method', a_callable)

        self.assertIsValid(TestModelAdmin, ValidationTestModel)


</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="542" endline="552" pcid="19613">
        def a_callable(obj):
            pass

        class TestModelAdmin(ModelAdmin):
            def a_method(self, obj):
                pass
            list_display = ('name', 'decade_published_in', 'a_method', a_callable)
            list_display_links = ('name', 'decade_published_in', 'a_method', a_callable)

        self.assertIsValid(TestModelAdmin, ValidationTestModel)

</source>
</class>

<class classid="356" nclones="2" nlines="11" similarity="72">
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="602" endline="611" pcid="19628">
        class TestModelAdmin(ModelAdmin):
            list_filter = ('non_existent_field',)

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'list_filter[0]' refers to 'non_existent_field', "
            "which does not refer to a Field.",
            'admin.E116'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="739" endline="748" pcid="19664">
        class TestModelAdmin(ModelAdmin):
            date_hierarchy = 'non_existent_field'

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'date_hierarchy' refers to 'non_existent_field', "
            "which does not refer to a Field.",
            'admin.E127'
        )

</source>
</class>

<class classid="357" nclones="2" nlines="24" similarity="80">
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="639" endline="657" pcid="19636">
        class AwesomeFilter(SimpleListFilter):
            def get_title(self):
                return 'awesomeness'

            def get_choices(self, request):
                return (('bit', 'A bit awesome'), ('very', 'Very awesome'))

            def get_queryset(self, cl, qs):
                return qs

        class TestModelAdmin(ModelAdmin):
            list_filter = (('is_active', AwesomeFilter),)

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'list_filter[0][1]' must inherit from 'FieldListFilter'.",
            'admin.E115'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="669" endline="684" pcid="19644">
        class AwesomeFilter(SimpleListFilter):
            def get_title(self):
                return 'awesomeness'

            def get_choices(self, request):
                return (('bit', 'A bit awesome'), ('very', 'Very awesome'))

            def get_queryset(self, cl, qs):
                return qs

        class TestModelAdmin(ModelAdmin):
            list_filter = ('is_active', AwesomeFilter, ('is_active', BooleanFieldListFilter), 'no')

        self.assertIsValid(TestModelAdmin, ValidationTestModel)


</source>
</class>

<class classid="358" nclones="5" nlines="21" similarity="76">
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="686" endline="703" pcid="19650">

    def test_not_integer(self):
        class TestModelAdmin(ModelAdmin):
            list_per_page = 'hello'

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'list_per_page' must be an integer.",
            'admin.E118'
        )

    def test_valid_case(self):
        class TestModelAdmin(ModelAdmin):
            list_per_page = 100

        self.assertIsValid(TestModelAdmin, ValidationTestModel)


</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="891" endline="908" pcid="19700">

    def test_not_boolean(self):
        class TestModelAdmin(ModelAdmin):
            save_on_top = 1

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'save_on_top' must be a boolean.",
            'admin.E102'
        )

    def test_valid_case(self):
        class TestModelAdmin(ModelAdmin):
            save_on_top = True

        self.assertIsValid(TestModelAdmin, ValidationTestModel)


</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="872" endline="889" pcid="19695">

    def test_not_boolean(self):
        class TestModelAdmin(ModelAdmin):
            save_as = 1

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'save_as' must be a boolean.",
            'admin.E101'
        )

    def test_valid_case(self):
        class TestModelAdmin(ModelAdmin):
            save_as = True

        self.assertIsValid(TestModelAdmin, ValidationTestModel)


</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="705" endline="722" pcid="19655">

    def test_not_integer(self):
        class TestModelAdmin(ModelAdmin):
            list_max_show_all = 'hello'

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'list_max_show_all' must be an integer.",
            'admin.E119'
        )

    def test_valid_case(self):
        class TestModelAdmin(ModelAdmin):
            list_max_show_all = 200

        self.assertIsValid(TestModelAdmin, ValidationTestModel)


</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="853" endline="870" pcid="19690">

    def test_invalid_type(self):
        class TestModelAdmin(ModelAdmin):
            list_select_related = 1

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'list_select_related' must be a boolean, tuple or list.",
            'admin.E117'
        )

    def test_valid_case(self):
        class TestModelAdmin(ModelAdmin):
            list_select_related = False

        self.assertIsValid(TestModelAdmin, ValidationTestModel)


</source>
</class>

<class classid="359" nclones="2" nlines="14" similarity="78">
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="922" endline="933" pcid="19708">
        class ValidationTestInline:
            pass

        class TestModelAdmin(ModelAdmin):
            inlines = [ValidationTestInline]

        self.assertIsInvalidRegexp(
            TestModelAdmin, ValidationTestModel,
            r"'.*\.ValidationTestInline' must inherit from 'InlineModelAdmin'\.",
            'admin.E104'
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="935" endline="946" pcid="19711">
        class ValidationTestInline(TabularInline):
            pass

        class TestModelAdmin(ModelAdmin):
            inlines = [ValidationTestInline]

        self.assertIsInvalidRegexp(
            TestModelAdmin, ValidationTestModel,
            r"'.*\.ValidationTestInline' must have a 'model' attribute\.",
            'admin.E105'
        )

</source>
</class>

<class classid="360" nclones="5" nlines="12" similarity="91">
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="964" endline="972" pcid="19718">
        class ValidationTestInline(TabularInline):
            model = ValidationTestInlineModel

        class TestModelAdmin(ModelAdmin):
            inlines = [ValidationTestInline]

        self.assertIsValid(TestModelAdmin, ValidationTestModel)


</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="1075" endline="1084" pcid="19746">
        class ValidationTestInline(TabularInline):
            model = ValidationTestInlineModel
            min_num = 2

        class TestModelAdmin(ModelAdmin):
            inlines = [ValidationTestInline]

        self.assertIsValid(TestModelAdmin, ValidationTestModel)


</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="1047" endline="1056" pcid="19739">
        class ValidationTestInline(TabularInline):
            model = ValidationTestInlineModel
            max_num = 2

        class TestModelAdmin(ModelAdmin):
            inlines = [ValidationTestInline]

        self.assertIsValid(TestModelAdmin, ValidationTestModel)


</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="1019" endline="1028" pcid="19732">
        class ValidationTestInline(TabularInline):
            model = ValidationTestInlineModel
            extra = 2

        class TestModelAdmin(ModelAdmin):
            inlines = [ValidationTestInline]

        self.assertIsValid(TestModelAdmin, ValidationTestModel)


</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="991" endline="1000" pcid="19725">
        class ValidationTestInline(TabularInline):
            model = ValidationTestInlineModel
            fk_name = 'parent'

        class TestModelAdmin(ModelAdmin):
            inlines = [ValidationTestInline]

        self.assertIsValid(TestModelAdmin, ValidationTestModel)


</source>
</class>

<class classid="361" nclones="4" nlines="32" similarity="84">
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="974" endline="1000" pcid="19721">

    def test_missing_field(self):
        class ValidationTestInline(TabularInline):
            model = ValidationTestInlineModel
            fk_name = 'non_existent_field'

        class TestModelAdmin(ModelAdmin):
            inlines = [ValidationTestInline]

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "'modeladmin.ValidationTestInlineModel' has no field named 'non_existent_field'.",
            'admin.E202',
            invalid_obj=ValidationTestInline
        )

    def test_valid_case(self):
        class ValidationTestInline(TabularInline):
            model = ValidationTestInlineModel
            fk_name = 'parent'

        class TestModelAdmin(ModelAdmin):
            inlines = [ValidationTestInline]

        self.assertIsValid(TestModelAdmin, ValidationTestModel)


</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="1002" endline="1028" pcid="19728">

    def test_not_integer(self):
        class ValidationTestInline(TabularInline):
            model = ValidationTestInlineModel
            extra = 'hello'

        class TestModelAdmin(ModelAdmin):
            inlines = [ValidationTestInline]

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'extra' must be an integer.",
            'admin.E203',
            invalid_obj=ValidationTestInline
        )

    def test_valid_case(self):
        class ValidationTestInline(TabularInline):
            model = ValidationTestInlineModel
            extra = 2

        class TestModelAdmin(ModelAdmin):
            inlines = [ValidationTestInline]

        self.assertIsValid(TestModelAdmin, ValidationTestModel)


</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="1058" endline="1084" pcid="19742">

    def test_not_integer(self):
        class ValidationTestInline(TabularInline):
            model = ValidationTestInlineModel
            min_num = 'hello'

        class TestModelAdmin(ModelAdmin):
            inlines = [ValidationTestInline]

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'min_num' must be an integer.",
            'admin.E205',
            invalid_obj=ValidationTestInline
        )

    def test_valid_case(self):
        class ValidationTestInline(TabularInline):
            model = ValidationTestInlineModel
            min_num = 2

        class TestModelAdmin(ModelAdmin):
            inlines = [ValidationTestInline]

        self.assertIsValid(TestModelAdmin, ValidationTestModel)


</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="1030" endline="1056" pcid="19735">

    def test_not_integer(self):
        class ValidationTestInline(TabularInline):
            model = ValidationTestInlineModel
            max_num = 'hello'

        class TestModelAdmin(ModelAdmin):
            inlines = [ValidationTestInline]

        self.assertIsInvalid(
            TestModelAdmin, ValidationTestModel,
            "The value of 'max_num' must be an integer.",
            'admin.E204',
            invalid_obj=ValidationTestInline
        )

    def test_valid_case(self):
        class ValidationTestInline(TabularInline):
            model = ValidationTestInlineModel
            max_num = 2

        class TestModelAdmin(ModelAdmin):
            inlines = [ValidationTestInline]

        self.assertIsValid(TestModelAdmin, ValidationTestModel)


</source>
</class>

<class classid="362" nclones="2" nlines="14" similarity="78">
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="1154" endline="1168" pcid="19765">
        """
        The first item in list_display cannot be the same as the first item
        in list_editable if list_display_links is not defined.
        """
        class ProductAdmin(ModelAdmin):
            list_display = ['name']
            list_editable = ['name']
        self.assertIsInvalid(
            ProductAdmin, ValidationTestModel,
            "The value of 'list_editable[0]' refers to the first field "
            "in 'list_display' ('name'), which cannot be used unless "
            "'list_display_links' is set.",
            id='admin.E124',
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="1170" endline="1184" pcid="19767">
        """
        The first item in list_display cannot be in list_editable if
        list_display_links isn't defined.
        """
        class ProductAdmin(ModelAdmin):
            list_display = ['name', 'slug', 'pub_date']
            list_editable = ['slug', 'name']
        self.assertIsInvalid(
            ProductAdmin, ValidationTestModel,
            "The value of 'list_editable[1]' refers to the first field "
            "in 'list_display' ('name'), which cannot be used unless "
            "'list_display_links' is set.",
            id='admin.E124',
        )

</source>
</class>

<class classid="363" nclones="2" nlines="14" similarity="71">
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="1211" endline="1223" pcid="19774">
        class Admin(ModelAdmin):
            autocomplete_fields = ('nonexistent',)

        self.assertIsInvalid(
            Admin, ValidationTestModel,
            msg=(
                "The value of 'autocomplete_fields[0]' refers to 'nonexistent', "
                "which is not an attribute of 'modeladmin.ValidationTestModel'."
            ),
            id='admin.E037',
            invalid_obj=Admin,
        )

</source>
<source file="django/tests/modeladmin/test_checks.py.pyindent" startline="1225" endline="1237" pcid="19776">
        class Admin(ModelAdmin):
            autocomplete_fields = ('name',)

        self.assertIsInvalid(
            Admin, ValidationTestModel,
            msg=(
                "The value of 'autocomplete_fields[0]' must be a foreign "
                "key or a many-to-many field."
            ),
            id='admin.E038',
            invalid_obj=Admin,
        )

</source>
</class>

<class classid="364" nclones="2" nlines="13" similarity="73">
<source file="django/tests/modeladmin/test_has_add_permission_obj_deprecation.py.pyindent" startline="23" endline="30" pcid="19799">
        class SongInlineAdmin(TabularInline):
            model = Song

        class BandAdmin(ModelAdmin):
            inlines = [SongInlineAdmin]

        self.assertIsValid(BandAdmin, Band)

</source>
<source file="django/tests/modeladmin/test_has_add_permission_obj_deprecation.py.pyindent" startline="32" endline="42" pcid="19802">
        class SongInlineAdmin(TabularInline):
            model = Song

            def has_add_permission(self, request, obj):
                return super().has_add_permission(request, obj)

        class BandAdmin(ModelAdmin):
            inlines = [SongInlineAdmin]

        self.assertIsValid(BandAdmin, Band)

</source>
</class>

<class classid="365" nclones="2" nlines="15" similarity="73">
<source file="django/tests/model_fields/test_durationfield.py.pyindent" startline="56" endline="67" pcid="19959">
    test_data = '[{"fields": {"field": "1 01:00:00"}, "model": "model_fields.durationmodel", "pk": null}]'

    def test_dumping(self):
        instance = DurationModel(field=datetime.timedelta(days=1, hours=1))
        data = serializers.serialize('json', [instance])
        self.assertEqual(json.loads(data), json.loads(self.test_data))

    def test_loading(self):
        instance = list(serializers.deserialize('json', self.test_data))[0].object
        self.assertEqual(instance.field, datetime.timedelta(days=1, hours=1))


</source>
<source file="django/tests/postgres_tests/test_array.py.pyindent" startline="593" endline="606" pcid="21584">
    test_data = (
        '[{"fields": {"field": "[\\"1\\", \\"2\\", null]"}, "model": "postgres_tests.integerarraymodel", "pk": null}]'
    )

    def test_dumping(self):
        instance = IntegerArrayModel(field=[1, 2, None])
        data = serializers.serialize('json', [instance])
        self.assertEqual(json.loads(data), json.loads(self.test_data))

    def test_loading(self):
        instance = list(serializers.deserialize('json', self.test_data))[0].object
        self.assertEqual(instance.field, [1, 2, None])


</source>
</class>

<class classid="366" nclones="2" nlines="16" similarity="81">
<source file="django/tests/model_fields/test_foreignkey.py.pyindent" startline="55" endline="73" pcid="19993">
        """
        Foreign key fields declared on abstract models should not add lazy
        relations to resolve relationship declared as string (#24215).
        """
        pending_ops_before = list(apps._pending_operations.items())

        class AbstractForeignKeyModel(models.Model):
            fk = models.ForeignKey('missing.FK', models.CASCADE)

            class Meta:
                abstract = True

        self.assertIs(AbstractForeignKeyModel._meta.apps, apps)
        self.assertEqual(
            pending_ops_before,
            list(apps._pending_operations.items()),
            'Pending lookup added for a foreign key on an abstract model'
        )

</source>
<source file="django/tests/model_fields/test_manytomanyfield.py.pyindent" startline="12" endline="30" pcid="20095">
        """
        Many-to-many fields declared on abstract models should not add lazy
        relations to resolve relationship declared as string (#24215).
        """
        pending_ops_before = list(apps._pending_operations.items())

        class AbstractManyToManyModel(models.Model):
            fk = models.ForeignKey('missing.FK', models.CASCADE)

            class Meta:
                abstract = True

        self.assertIs(AbstractManyToManyModel._meta.apps, apps)
        self.assertEqual(
            pending_ops_before,
            list(apps._pending_operations.items()),
            'Pending lookup added for a many-to-many field on an abstract model'
        )

</source>
</class>

<class classid="367" nclones="2" nlines="36" similarity="73">
<source file="django/tests/model_fields/test_foreignkey.py.pyindent" startline="76" endline="96" pcid="19996">
        class AbstractReferent(models.Model):
            reference = models.ForeignKey('Referred', on_delete=models.CASCADE)

            class Meta:
                app_label = 'model_fields'
                abstract = True

        def assert_app_model_resolved(label):
            class Referred(models.Model):
                class Meta:
                    app_label = label

            class ConcreteReferent(AbstractReferent):
                class Meta:
                    app_label = label

            self.assertEqual(ConcreteReferent._meta.get_field('reference').related_model, Referred)

        assert_app_model_resolved('model_fields')
        assert_app_model_resolved('tests')

</source>
<source file="django/tests/model_fields/test_manytomanyfield.py.pyindent" startline="33" endline="62" pcid="20098">
        class AbstractReferent(models.Model):
            reference = models.ManyToManyField('Referred', through='Through')

            class Meta:
                app_label = 'model_fields'
                abstract = True

        def assert_app_model_resolved(label):
            class Referred(models.Model):
                class Meta:
                    app_label = label

            class Through(models.Model):
                referred = models.ForeignKey('Referred', on_delete=models.CASCADE)
                referent = models.ForeignKey('ConcreteReferent', on_delete=models.CASCADE)

                class Meta:
                    app_label = label

            class ConcreteReferent(AbstractReferent):
                class Meta:
                    app_label = label

            self.assertEqual(ConcreteReferent._meta.get_field('reference').related_model, Referred)
            self.assertEqual(ConcreteReferent.reference.through, Through)

        assert_app_model_resolved('model_fields')
        assert_app_model_resolved('tests')


</source>
</class>

<class classid="368" nclones="7" nlines="11" similarity="72">
<source file="django/tests/model_fields/test_imagefield.py.pyindent" startline="188" endline="194" pcid="20036">
        self.PersonModel.objects.create(name='Joe', mugshot=self.file1)
        with self.assertNumQueries(1):
            qs = list(self.PersonModel.objects.defer('mugshot'))
        with self.assertNumQueries(0):
            self.assertEqual(qs[0].name, 'Joe')


</source>
<source file="django/tests/prefetch_related/test_prefetch_related_objects.py.pyindent" startline="41" endline="47" pcid="22105">
        book1 = Book.objects.get(id=self.book1.id)
        with self.assertNumQueries(1):
            prefetch_related_objects([book1], 'authors')

        with self.assertNumQueries(0):
            self.assertCountEqual(book1.authors.all(), [self.author1, self.author2, self.author3])

</source>
<source file="django/tests/prefetch_related/test_prefetch_related_objects.py.pyindent" startline="57" endline="63" pcid="22111">
        authors = list(Author.objects.all())
        with self.assertNumQueries(1):
            prefetch_related_objects(authors, 'first_book')

        with self.assertNumQueries(0):
            [author.first_book for author in authors]

</source>
<source file="django/tests/prefetch_related/test_prefetch_related_objects.py.pyindent" startline="49" endline="55" pcid="22108">
        author1 = Author.objects.get(id=self.author1.id)
        with self.assertNumQueries(1):
            prefetch_related_objects([author1], 'books')

        with self.assertNumQueries(0):
            self.assertCountEqual(author1.books.all(), [self.book1, self.book2])

</source>
<source file="django/tests/prefetch_related/test_prefetch_related_objects.py.pyindent" startline="65" endline="71" pcid="22114">
        books = list(Book.objects.all())
        with self.assertNumQueries(1):
            prefetch_related_objects(books, 'first_time_authors')

        with self.assertNumQueries(0):
            [list(book.first_time_authors.all()) for book in books]

</source>
<source file="django/tests/prefetch_related/test_prefetch_related_objects.py.pyindent" startline="101" endline="107" pcid="22123">
        book1 = Book.objects.get(id=self.book1.id)
        with self.assertNumQueries(1):
            prefetch_related_objects([book1], Prefetch('authors', to_attr='the_authors'))

        with self.assertNumQueries(0):
            self.assertCountEqual(book1.the_authors, [self.author1, self.author2, self.author3])

</source>
<source file="django/tests/prefetch_related/test_prefetch_related_objects.py.pyindent" startline="93" endline="99" pcid="22120">
        book1 = Book.objects.get(id=self.book1.id)
        with self.assertNumQueries(1):
            prefetch_related_objects([book1], Prefetch('authors'))

        with self.assertNumQueries(0):
            self.assertCountEqual(book1.authors.all(), [self.author1, self.author2, self.author3])

</source>
</class>

<class classid="369" nclones="2" nlines="10" similarity="80">
<source file="django/tests/model_fields/test_uuid.py.pyindent" startline="43" endline="48" pcid="20150">
        with self.assertRaisesMessage(exceptions.ValidationError, 'is not a valid UUID'):
            PrimaryKeyUUIDModel.objects.get(pk={})

        with self.assertRaisesMessage(exceptions.ValidationError, 'is not a valid UUID'):
            PrimaryKeyUUIDModel.objects.get(pk=[])

</source>
<source file="django/tests/model_fields/test_uuid.py.pyindent" startline="50" endline="56" pcid="20153">
        with self.assertRaisesMessage(exceptions.ValidationError, 'is not a valid UUID'):
            UUIDModel.objects.get(field='not-a-uuid')

        with self.assertRaisesMessage(exceptions.ValidationError, 'is not a valid UUID'):
            UUIDModel.objects.create(field='not-a-uuid')


</source>
</class>

<class classid="370" nclones="2" nlines="10" similarity="70">
<source file="django/tests/model_forms/test_modelchoicefield.py.pyindent" startline="130" endline="139" pcid="20197">
        class ModelChoiceForm(forms.Form):
            category = forms.ModelChoiceField(Category.objects.all())

        form1 = ModelChoiceForm()
        field1 = form1.fields['category']
        # To allow the widget to change the queryset of field1.widget.choices
        # without affecting other forms, the following must hold (#11183):
        self.assertIsNot(field1, ModelChoiceForm.base_fields['category'])
        self.assertIs(field1.widget.choices.field, field1)

</source>
<source file="django/tests/model_forms/test_modelchoicefield.py.pyindent" startline="141" endline="148" pcid="20199">
        class ModelChoiceForm(forms.Form):
            category = forms.ModelChoiceField(Category.objects.all())

        form1 = ModelChoiceForm()
        self.assertCountEqual(form1.fields['category'].queryset, [self.c1, self.c2, self.c3])
        form2 = ModelChoiceForm()
        self.assertIsNone(form2.fields['category'].queryset._result_cache)

</source>
</class>

<class classid="371" nclones="2" nlines="10" similarity="90">
<source file="django/tests/model_formsets/models.py.pyindent" startline="217" endline="226" pcid="20290">
    title = models.CharField(max_length=50, unique_for_date='posted', blank=True)
    slug = models.CharField(max_length=50, unique_for_year='posted', blank=True)
    subtitle = models.CharField(max_length=50, unique_for_month='posted', blank=True)
    posted = models.DateField()

    def __str__(self):
        return self.title


# Models for testing UUID primary keys
</source>
<source file="django/tests/validation/models.py.pyindent" startline="92" endline="100" pcid="28190">
    title = models.CharField(max_length=50, unique_for_date='posted', blank=True)
    slug = models.CharField(max_length=50, unique_for_year='posted', blank=True)
    subtitle = models.CharField(max_length=50, unique_for_month='posted', blank=True)
    posted = models.DateField()

    def __str__(self):
        return self.name


</source>
</class>

<class classid="372" nclones="2" nlines="12" similarity="91">
<source file="django/tests/model_formsets/tests.py.pyindent" startline="870" endline="877" pcid="20333">
            def save(self, commit=True):
                # change the name to "Brooklyn Bridge" just to be a jerk.
                poem = super().save(commit=False)
                poem.name = "Brooklyn Bridge"
                if commit:
                    poem.save()
                return poem

</source>
<source file="django/tests/model_formsets/tests.py.pyindent" startline="1002" endline="1008" pcid="20337">
            def save(self, commit=True):
                poem = super().save(commit=False)
                poem.name = "%s by %s" % (poem.name, poem.poet.name)
                if commit:
                    poem.save()
                return poem

</source>
</class>

<class classid="373" nclones="4" nlines="15" similarity="73">
<source file="django/tests/model_formsets/tests.py.pyindent" startline="1686" endline="1698" pcid="20364">
        AuthorFormSet = modelformset_factory(Author, fields='__all__')
        data = {
            'form-TOTAL_FORMS': '1',
            'form-INITIAL_FORMS': '1',
            'form-MAX_NUM_FORMS': '',
            'form-0-name': 'Charles',
        }
        formset = AuthorFormSet(data)
        self.assertEqual(
            formset.errors,
            [{'id': ['This field is required.']}],
        )

</source>
<source file="django/tests/model_formsets/tests.py.pyindent" startline="1730" endline="1744" pcid="20367">
        AuthorFormSet = modelformset_factory(Author, fields='__all__')
        data = {
            'form-TOTAL_FORMS': '1',
            'form-INITIAL_FORMS': '1',
            'form-MAX_NUM_FORMS': '',
            'form-0-id': '12345',
            'form-0-name': 'Charles',
        }
        formset = AuthorFormSet(data)
        self.assertEqual(
            formset.errors,
            [{'id': ['Select a valid choice. That choice is not one of the available choices.']}],
        )


</source>
<source file="django/tests/model_formsets/tests.py.pyindent" startline="1700" endline="1713" pcid="20365">
        BetterAuthorFormSet = modelformset_factory(BetterAuthor, fields='__all__')
        data = {
            'form-TOTAL_FORMS': '1',
            'form-INITIAL_FORMS': '1',
            'form-MAX_NUM_FORMS': '',
            'form-0-name': 'Charles',
            'form-0-write_speed': '10',
        }
        formset = BetterAuthorFormSet(data)
        self.assertEqual(
            formset.errors,
            [{'author_ptr': ['This field is required.']}],
        )

</source>
<source file="django/tests/model_formsets/tests.py.pyindent" startline="1715" endline="1728" pcid="20366">
        AuthorFormSet = modelformset_factory(Author, fields='__all__')
        data = {
            'form-TOTAL_FORMS': '1',
            'form-INITIAL_FORMS': '1',
            'form-MAX_NUM_FORMS': '',
            'form-0-id': 'abc',
            'form-0-name': 'Charles',
        }
        formset = AuthorFormSet(data)
        self.assertEqual(
            formset.errors,
            [{'id': ['Select a valid choice. That choice is not one of the available choices.']}],
        )

</source>
</class>

<class classid="374" nclones="2" nlines="11" similarity="72">
<source file="django/tests/model_meta/tests.py.pyindent" startline="81" endline="87" pcid="20704">
        for model, expected_result in TEST_RESULTS['local_concrete_fields'].items():
            fields = model._meta.local_concrete_fields
            self.assertEqual([f.attname for f in fields], expected_result)
            for f in fields:
                self.assertIsNotNone(f.column)


</source>
<source file="django/tests/model_meta/tests.py.pyindent" startline="91" endline="96" pcid="20708">
        for model, expected_result in TEST_RESULTS['many_to_many'].items():
            fields = model._meta.many_to_many
            self.assertEqual([f.attname for f in fields], expected_result)
            for f in fields:
                self.assertTrue(f.many_to_many and f.is_relation)

</source>
</class>

<class classid="375" nclones="2" nlines="14" similarity="85">
<source file="django/tests/model_meta/tests.py.pyindent" startline="108" endline="119" pcid="20715">
        result_key = 'get_all_related_objects_with_model'
        for model, expected in TEST_RESULTS[result_key].items():
            objects = [
                (field, self._model(model, field))
                for field in model._meta.get_fields()
                if field.auto_created and not field.concrete
            ]
            self.assertEqual(
                sorted(self._map_related_query_names(objects), key=self.key_name),
                sorted(expected, key=self.key_name),
            )

</source>
<source file="django/tests/model_meta/tests.py.pyindent" startline="121" endline="132" pcid="20717">
        result_key = 'get_all_related_objects_with_model_local'
        for model, expected in TEST_RESULTS[result_key].items():
            objects = [
                (field, self._model(model, field))
                for field in model._meta.get_fields(include_parents=False)
                if field.auto_created and not field.concrete
            ]
            self.assertEqual(
                sorted(self._map_related_query_names(objects), key=self.key_name),
                sorted(expected, key=self.key_name),
            )

</source>
</class>

<class classid="376" nclones="2" nlines="13" similarity="84">
<source file="django/tests/model_meta/tests.py.pyindent" startline="134" endline="145" pcid="20719">
        result_key = 'get_all_related_objects_with_model_hidden'
        for model, expected in TEST_RESULTS[result_key].items():
            objects = [
                (field, self._model(model, field))
                for field in model._meta.get_fields(include_hidden=True)
                if field.auto_created and not field.concrete
            ]
            self.assertEqual(
                sorted(self._map_names(objects), key=self.key_name),
                sorted(expected, key=self.key_name)
            )

</source>
<source file="django/tests/model_meta/tests.py.pyindent" startline="147" endline="159" pcid="20721">
        result_key = 'get_all_related_objects_with_model_hidden_local'
        for model, expected in TEST_RESULTS[result_key].items():
            objects = [
                (field, self._model(model, field))
                for field in model._meta.get_fields(include_hidden=True, include_parents=False)
                if field.auto_created and not field.concrete
            ]
            self.assertEqual(
                sorted(self._map_names(objects), key=self.key_name),
                sorted(expected, key=self.key_name)
            )


</source>
</class>

<class classid="377" nclones="2" nlines="19" similarity="78">
<source file="django/tests/model_regress/test_pickle.py.pyindent" startline="10" endline="27" pcid="20846">
        """
        #21430 -- Verifies a warning is raised for models that are
        unpickled without a Django version
        """
        class MissingDjangoVersion(models.Model):
            title = models.CharField(max_length=10)

            def __reduce__(self):
                reduce_list = super().__reduce__()
                data = reduce_list[-1]
                del data[DJANGO_VERSION_PICKLE_KEY]
                return reduce_list

        p = MissingDjangoVersion(title="FooBar")
        msg = "Pickled model instance's Django version is not specified."
        with self.assertRaisesMessage(RuntimeWarning, msg):
            pickle.loads(pickle.dumps(p))

</source>
<source file="django/tests/model_regress/test_pickle.py.pyindent" startline="29" endline="46" pcid="20850">
        """
        #21430 -- Verifies a warning is raised for models that are
        unpickled with a different Django version than the current
        """
        class DifferentDjangoVersion(models.Model):
            title = models.CharField(max_length=10)

            def __reduce__(self):
                reduce_list = super().__reduce__()
                data = reduce_list[-1]
                data[DJANGO_VERSION_PICKLE_KEY] = '1.0'
                return reduce_list

        p = DifferentDjangoVersion(title="FooBar")
        msg = "Pickled model instance's Django version 1.0 does not match the current version %s." % get_version()
        with self.assertRaisesMessage(RuntimeWarning, msg):
            pickle.loads(pickle.dumps(p))

</source>
</class>

<class classid="378" nclones="3" nlines="13" similarity="73">
<source file="django/tests/multiple_database/tests.py.pyindent" startline="1764" endline="1770" pcid="21003">
        "The AttributeError from AttributeErrorRouter bubbles up"
        b = Book.objects.create(title="Pro Django",
                                published=datetime.date(2008, 12, 16))
        with self.override_router():
            with self.assertRaises(AttributeError):
                Book.objects.get(pk=b.pk)

</source>
<source file="django/tests/multiple_database/tests.py.pyindent" startline="1792" endline="1800" pcid="21012">
        "The AttributeError from AttributeErrorRouter bubbles up"
        b = Book.objects.create(title="Pro Django",
                                published=datetime.date(2008, 12, 16))
        p = Person.objects.create(name="Marty Alchin")
        with self.override_router():
            with self.assertRaises(AttributeError):
                b.authors.set([p])


</source>
<source file="django/tests/multiple_database/tests.py.pyindent" startline="1781" endline="1790" pcid="21009">
        "The AttributeError from AttributeErrorRouter bubbles up"
        b = Book.objects.create(title="Pro Django",
                                published=datetime.date(2008, 12, 16))
        p = Person.objects.create(name="Marty Alchin")
        b.authors.set([p])
        b.editor = p
        with self.override_router():
            with self.assertRaises(AttributeError):
                b.delete()

</source>
</class>

<class classid="379" nclones="4" nlines="15" similarity="80">
<source file="django/tests/multiple_database/tests.py.pyindent" startline="1892" endline="1901" pcid="21033">
        owner = Person.objects.create(name='Someone')
        pet = Pet.objects.create(name='fido', owner=owner)
        with self.assertRaises(RouterUsed) as cm:
            with self.override_router():
                pet.owner.delete()
        e = cm.exception
        self.assertEqual(e.mode, RouterUsed.WRITE)
        self.assertEqual(e.model, Person)
        self.assertEqual(e.hints, {'instance': owner})

</source>
<source file="django/tests/multiple_database/tests.py.pyindent" startline="1924" endline="1933" pcid="21042">
        owner = Person.objects.create(name='Someone')
        Pet.objects.create(name='fido', owner=owner)
        with self.assertRaises(RouterUsed) as cm:
            with self.override_router():
                owner.pet_set.update(name='max')
        e = cm.exception
        self.assertEqual(e.mode, RouterUsed.WRITE)
        self.assertEqual(e.model, Pet)
        self.assertEqual(e.hints, {'instance': owner})

</source>
<source file="django/tests/multiple_database/tests.py.pyindent" startline="1903" endline="1912" pcid="21036">
        owner = Person.objects.create(name='Someone')
        to_del_qs = owner.pet_set.all()
        with self.assertRaises(RouterUsed) as cm:
            with self.override_router():
                to_del_qs.delete()
        e = cm.exception
        self.assertEqual(e.mode, RouterUsed.WRITE)
        self.assertEqual(e.model, Pet)
        self.assertEqual(e.hints, {'instance': owner})

</source>
<source file="django/tests/multiple_database/tests.py.pyindent" startline="1914" endline="1922" pcid="21039">
        owner = Person.objects.create(name='Someone')
        with self.assertRaises(RouterUsed) as cm:
            with self.override_router():
                owner.pet_set.get_or_create(name='fido')
        e = cm.exception
        self.assertEqual(e.mode, RouterUsed.WRITE)
        self.assertEqual(e.model, Pet)
        self.assertEqual(e.hints, {'instance': owner})

</source>
</class>

<class classid="380" nclones="12" nlines="16" similarity="75">
<source file="django/tests/multiple_database/tests.py.pyindent" startline="1935" endline="1945" pcid="21045">
        auth = Person.objects.create(name='Someone')
        book = Book.objects.create(title="Pro Django",
                                   published=datetime.date(2008, 12, 16))
        with self.assertRaises(RouterUsed) as cm:
            with self.override_router():
                book.authors.add(auth)
        e = cm.exception
        self.assertEqual(e.mode, RouterUsed.WRITE)
        self.assertEqual(e.model, Book.authors.through)
        self.assertEqual(e.hints, {'instance': book})

</source>
<source file="django/tests/multiple_database/tests.py.pyindent" startline="2049" endline="2059" pcid="21072">
        auth = Person.objects.create(name='Someone')
        Book.objects.create(title="Pro Django",
                            published=datetime.date(2008, 12, 16))
        with self.assertRaises(RouterUsed) as cm:
            with self.override_router():
                auth.book_set.get_or_create(title="New Book", published=datetime.datetime.now())
        e = cm.exception
        self.assertEqual(e.mode, RouterUsed.WRITE)
        self.assertEqual(e.model, Person)
        self.assertEqual(e.hints, {'instance': auth})

</source>
<source file="django/tests/multiple_database/tests.py.pyindent" startline="1960" endline="1971" pcid="21051">
        auth = Person.objects.create(name='Someone')
        book = Book.objects.create(title="Pro Django",
                                   published=datetime.date(2008, 12, 16))
        book.authors.add(auth)
        with self.assertRaises(RouterUsed) as cm:
            with self.override_router():
                book.authors.all().delete()
        e = cm.exception
        self.assertEqual(e.mode, RouterUsed.WRITE)
        self.assertEqual(e.model, Person)
        self.assertEqual(e.hints, {'instance': book})

</source>
<source file="django/tests/multiple_database/tests.py.pyindent" startline="1985" endline="1996" pcid="21057">
        auth = Person.objects.create(name='Someone')
        book = Book.objects.create(title="Pro Django",
                                   published=datetime.date(2008, 12, 16))
        book.authors.add(auth)
        with self.assertRaises(RouterUsed) as cm:
            with self.override_router():
                book.authors.remove(auth)
        e = cm.exception
        self.assertEqual(e.mode, RouterUsed.WRITE)
        self.assertEqual(e.model, Book.authors.through)
        self.assertEqual(e.hints, {'instance': book})

</source>
<source file="django/tests/multiple_database/tests.py.pyindent" startline="1947" endline="1958" pcid="21048">
        auth = Person.objects.create(name='Someone')
        book = Book.objects.create(title="Pro Django",
                                   published=datetime.date(2008, 12, 16))
        book.authors.add(auth)
        with self.assertRaises(RouterUsed) as cm:
            with self.override_router():
                book.authors.clear()
        e = cm.exception
        self.assertEqual(e.mode, RouterUsed.WRITE)
        self.assertEqual(e.model, Book.authors.through)
        self.assertEqual(e.hints, {'instance': book})

</source>
<source file="django/tests/multiple_database/tests.py.pyindent" startline="2036" endline="2047" pcid="21069">
        auth = Person.objects.create(name='Someone')
        book = Book.objects.create(title="Pro Django",
                                   published=datetime.date(2008, 12, 16))
        book.authors.add(auth)
        with self.assertRaises(RouterUsed) as cm:
            with self.override_router():
                auth.book_set.all().delete()
        e = cm.exception
        self.assertEqual(e.mode, RouterUsed.WRITE)
        self.assertEqual(e.model, Book)
        self.assertEqual(e.hints, {'instance': auth})

</source>
<source file="django/tests/multiple_database/tests.py.pyindent" startline="1998" endline="2009" pcid="21060">
        auth = Person.objects.create(name='Someone')
        book = Book.objects.create(title="Pro Django",
                                   published=datetime.date(2008, 12, 16))
        book.authors.add(auth)
        with self.assertRaises(RouterUsed) as cm:
            with self.override_router():
                book.authors.all().update(name='Different')
        e = cm.exception
        self.assertEqual(e.mode, RouterUsed.WRITE)
        self.assertEqual(e.model, Person)
        self.assertEqual(e.hints, {'instance': book})

</source>
<source file="django/tests/multiple_database/tests.py.pyindent" startline="2011" endline="2021" pcid="21063">
        auth = Person.objects.create(name='Someone')
        book = Book.objects.create(title="Pro Django",
                                   published=datetime.date(2008, 12, 16))
        with self.assertRaises(RouterUsed) as cm:
            with self.override_router():
                auth.book_set.add(book)
        e = cm.exception
        self.assertEqual(e.mode, RouterUsed.WRITE)
        self.assertEqual(e.model, Book.authors.through)
        self.assertEqual(e.hints, {'instance': auth})

</source>
<source file="django/tests/multiple_database/tests.py.pyindent" startline="1973" endline="1983" pcid="21054">
        Person.objects.create(name='Someone')
        book = Book.objects.create(title="Pro Django",
                                   published=datetime.date(2008, 12, 16))
        with self.assertRaises(RouterUsed) as cm:
            with self.override_router():
                book.authors.get_or_create(name='Someone else')
        e = cm.exception
        self.assertEqual(e.mode, RouterUsed.WRITE)
        self.assertEqual(e.model, Book)
        self.assertEqual(e.hints, {'instance': book})

</source>
<source file="django/tests/multiple_database/tests.py.pyindent" startline="2074" endline="2086" pcid="21078">
        auth = Person.objects.create(name='Someone')
        book = Book.objects.create(title="Pro Django",
                                   published=datetime.date(2008, 12, 16))
        book.authors.add(auth)
        with self.assertRaises(RouterUsed) as cm:
            with self.override_router():
                auth.book_set.all().update(title='Different')
        e = cm.exception
        self.assertEqual(e.mode, RouterUsed.WRITE)
        self.assertEqual(e.model, Book)
        self.assertEqual(e.hints, {'instance': auth})


</source>
<source file="django/tests/multiple_database/tests.py.pyindent" startline="2061" endline="2072" pcid="21075">
        auth = Person.objects.create(name='Someone')
        book = Book.objects.create(title="Pro Django",
                                   published=datetime.date(2008, 12, 16))
        book.authors.add(auth)
        with self.assertRaises(RouterUsed) as cm:
            with self.override_router():
                auth.book_set.remove(book)
        e = cm.exception
        self.assertEqual(e.mode, RouterUsed.WRITE)
        self.assertEqual(e.model, Book.authors.through)
        self.assertEqual(e.hints, {'instance': auth})

</source>
<source file="django/tests/multiple_database/tests.py.pyindent" startline="2023" endline="2034" pcid="21066">
        auth = Person.objects.create(name='Someone')
        book = Book.objects.create(title="Pro Django",
                                   published=datetime.date(2008, 12, 16))
        book.authors.add(auth)
        with self.assertRaises(RouterUsed) as cm:
            with self.override_router():
                auth.book_set.clear()
        e = cm.exception
        self.assertEqual(e.mode, RouterUsed.WRITE)
        self.assertEqual(e.model, Book.authors.through)
        self.assertEqual(e.hints, {'instance': auth})

</source>
</class>

<class classid="381" nclones="2" nlines="12" similarity="91">
<source file="django/tests/null_fk/models.py.pyindent" startline="31" endline="42" pcid="21117">
    post = models.ForeignKey(Post, models.SET_NULL, null=True)
    comment_text = models.CharField(max_length=250)

    class Meta:
        ordering = ('comment_text',)

    def __str__(self):
        return self.comment_text

# Ticket 15823


</source>
<source file="django/tests/null_fk_ordering/models.py.pyindent" startline="46" endline="53" pcid="21134">
    post = models.ForeignKey(Post, models.SET_NULL, null=True)
    comment_text = models.CharField(max_length=250)

    class Meta:
        ordering = ['post__forum__system_info__system_name', 'comment_text']

    def __str__(self):
        return self.comment_text
</source>
</class>

<class classid="382" nclones="5" nlines="12" similarity="75">
<source file="django/tests/order_with_respect_to/models.py.pyindent" startline="24" endline="34" pcid="21269">
    title = models.CharField(max_length=200)
    parent = models.ForeignKey("self", models.SET_NULL, related_name="children", null=True)

    class Meta:
        order_with_respect_to = "parent"

    def __str__(self):
        return self.title


# order_with_respect_to points to a model with a OneToOneField primary key.
</source>
<source file="django/tests/queries/models.py.pyindent" startline="134" endline="143" pcid="22325">
    title = models.CharField(max_length=50)
    item = models.ForeignKey(Item, models.CASCADE)

    class Meta:
        ordering = ['item']

    def __str__(self):
        return self.title


</source>
<source file="django/tests/sites_framework/models.py.pyindent" startline="7" endline="18" pcid="23978">
    title = models.CharField(max_length=50)

    objects = models.Manager()
    on_site = CurrentSiteManager()

    class Meta:
        abstract = True

    def __str__(self):
        return self.title


</source>
<source file="django/tests/serializers/models/base.py.pyindent" startline="88" endline="98" pcid="23136">
    actor = models.ForeignKey(Actor, models.CASCADE)
    title = models.CharField(max_length=50)
    price = models.DecimalField(max_digits=6, decimal_places=2, default=Decimal('0.00'))

    class Meta:
        ordering = ('title',)

    def __str__(self):
        return self.title


</source>
<source file="django/tests/view_tests/models.py.pyindent" startline="19" endline="33" pcid="28264">
    """
    An abstract article Model so that we can create article models with and
    without a get_absolute_url method (for create_update generic views tests).
    """
    title = models.CharField(max_length=100)
    slug = models.SlugField()
    author = models.ForeignKey(Author, models.CASCADE)

    class Meta:
        abstract = True

    def __str__(self):
        return self.title


</source>
</class>

<class classid="383" nclones="3" nlines="11" similarity="72">
<source file="django/tests/postgres_tests/test_array.py.pyindent" startline="446" endline="455" pcid="21559">
        class MyModel(PostgreSQLModel):
            field = ArrayField(models.CharField())

        model = MyModel()
        errors = model.check()
        self.assertEqual(len(errors), 1)
        # The inner CharField is missing a max_length.
        self.assertEqual(errors[0].id, 'postgres.E001')
        self.assertIn('max_length', errors[0].msg)

</source>
<source file="django/tests/postgres_tests/test_array.py.pyindent" startline="498" endline="511" pcid="21569">
        """
        Nested ArrayFields are permitted.
        """
        class MyModel(PostgreSQLModel):
            field = ArrayField(ArrayField(models.CharField()))

        model = MyModel()
        errors = model.check()
        self.assertEqual(len(errors), 1)
        # The inner CharField is missing a max_length.
        self.assertEqual(errors[0].id, 'postgres.E001')
        self.assertIn('max_length', errors[0].msg)


</source>
<source file="django/tests/postgres_tests/test_array.py.pyindent" startline="457" endline="464" pcid="21561">
        class MyModel(PostgreSQLModel):
            field = ArrayField(models.ManyToManyField('postgres_tests.IntegerArrayModel'))

        model = MyModel()
        errors = model.check()
        self.assertEqual(len(errors), 1)
        self.assertEqual(errors[0].id, 'postgres.E002')

</source>
</class>

<class classid="384" nclones="3" nlines="17" similarity="82">
<source file="django/tests/postgres_tests/test_array.py.pyindent" startline="466" endline="482" pcid="21563">
        class MyModel(PostgreSQLModel):
            field = ArrayField(models.IntegerField(), default=[])

        model = MyModel()
        self.assertEqual(model.check(), [
            checks.Warning(
                msg=(
                    "ArrayField default should be a callable instead of an "
                    "instance so that it's not shared between all field "
                    "instances."
                ),
                hint='Use a callable instead, e.g., use `list` instead of `[]`.',
                obj=MyModel._meta.get_field('field'),
                id='postgres.E003',
            )
        ])

</source>
<source file="django/tests/postgres_tests/test_hstore.py.pyindent" startline="197" endline="213" pcid="21697">
        class MyModel(PostgreSQLModel):
            field = HStoreField(default={})

        model = MyModel()
        self.assertEqual(model.check(), [
            checks.Warning(
                msg=(
                    "HStoreField default should be a callable instead of an "
                    "instance so that it's not shared between all field "
                    "instances."
                ),
                hint='Use a callable instead, e.g., use `dict` instead of `{}`.',
                obj=MyModel._meta.get_field('field'),
                id='postgres.E003',
            )
        ])

</source>
<source file="django/tests/postgres_tests/test_json.py.pyindent" startline="307" endline="323" pcid="21859">
        class MyModel(PostgreSQLModel):
            field = JSONField(default={})

        model = MyModel()
        self.assertEqual(model.check(), [
            checks.Warning(
                msg=(
                    "JSONField default should be a callable instead of an "
                    "instance so that it's not shared between all field "
                    "instances."
                ),
                hint='Use a callable instead, e.g., use `dict` instead of `{}`.',
                obj=MyModel._meta.get_field('field'),
                id='postgres.E003',
            )
        ])

</source>
</class>

<class classid="385" nclones="3" nlines="10" similarity="70">
<source file="django/tests/postgres_tests/test_array.py.pyindent" startline="788" endline="795" pcid="21625">
        class SplitForm(forms.Form):
            array = SplitArrayField(forms.CharField(), size=3)

        data = {'array_0': 'a', 'array_1': 'b', 'array_2': 'c'}
        form = SplitForm(data)
        self.assertTrue(form.is_valid())
        self.assertEqual(form.cleaned_data, {'array': ['a', 'b', 'c']})

</source>
<source file="django/tests/postgres_tests/test_array.py.pyindent" startline="829" endline="836" pcid="21633">
        class SplitForm(forms.Form):
            array = SplitArrayField(forms.CharField(), size=3)

        data = {'array_0': 'a', 'array_1': 'b', 'array_2': ''}
        form = SplitForm(data)
        self.assertFalse(form.is_valid())
        self.assertEqual(form.errors, {'array': ['Item 3 in the array did not validate: This field is required.']})

</source>
<source file="django/tests/postgres_tests/test_array.py.pyindent" startline="797" endline="804" pcid="21627">
        class SplitForm(forms.Form):
            array = SplitArrayField(forms.CharField(), required=True, size=3)

        data = {'array_0': '', 'array_1': '', 'array_2': ''}
        form = SplitForm(data)
        self.assertFalse(form.is_valid())
        self.assertEqual(form.errors, {'array': ['This field is required.']})

</source>
</class>

<class classid="386" nclones="3" nlines="10" similarity="70">
<source file="django/tests/postgres_tests/test_citext.py.pyindent" startline="48" endline="52" pcid="21655">
        for lookup in self.case_sensitive_lookups:
            with self.subTest(lookup=lookup):
                query = {'name__{}'.format(lookup): 'john'}
                self.assertSequenceEqual(CITestModel.objects.filter(**query), [self.john])

</source>
<source file="django/tests/postgres_tests/test_citext.py.pyindent" startline="60" endline="63" pcid="21661">
        for lookup, string in zip(self.case_sensitive_lookups, ('john', 'john', 'john.com', 'john.com')):
            with self.subTest(lookup=lookup, string=string):
                query = {'email__{}'.format(lookup): string}
                self.assertSequenceEqual(CITestModel.objects.filter(**query), [self.john])
</source>
<source file="django/tests/postgres_tests/test_citext.py.pyindent" startline="54" endline="58" pcid="21658">
        for lookup, string in zip(self.case_sensitive_lookups, ('average', 'average joe', 'john', 'Joe.named')):
            with self.subTest(lookup=lookup, string=string):
                query = {'description__{}'.format(lookup): string}
                self.assertSequenceEqual(CITestModel.objects.filter(**query), [self.john])

</source>
</class>

<class classid="387" nclones="3" nlines="16" similarity="75">
<source file="django/tests/postgres_tests/test_indexes.py.pyindent" startline="148" endline="162" pcid="21758">
        # Ensure the table is there and doesn't have an index.
        self.assertNotIn('field', self.get_constraints(IntegerArrayModel._meta.db_table))
        # Add the index
        index_name = 'integer_array_model_field_gin'
        index = GinIndex(fields=['field'], name=index_name)
        with connection.schema_editor() as editor:
            editor.add_index(IntegerArrayModel, index)
        constraints = self.get_constraints(IntegerArrayModel._meta.db_table)
        # Check gin index was added
        self.assertEqual(constraints[index_name]['type'], GinIndex.suffix)
        # Drop the index
        with connection.schema_editor() as editor:
            editor.remove_index(IntegerArrayModel, index)
        self.assertNotIn(index_name, self.get_constraints(IntegerArrayModel._meta.db_table))

</source>
<source file="django/tests/postgres_tests/test_indexes.py.pyindent" startline="177" endline="187" pcid="21764">
        index_name = 'integer_array_gin_params'
        index = GinIndex(fields=['field'], name=index_name, fastupdate=True, gin_pending_list_limit=64)
        with connection.schema_editor() as editor:
            editor.add_index(IntegerArrayModel, index)
        constraints = self.get_constraints(IntegerArrayModel._meta.db_table)
        self.assertEqual(constraints[index_name]['type'], 'gin')
        self.assertEqual(constraints[index_name]['options'], ['gin_pending_list_limit=64', 'fastupdate=on'])
        with connection.schema_editor() as editor:
            editor.remove_index(IntegerArrayModel, index)
        self.assertNotIn(index_name, self.get_constraints(IntegerArrayModel._meta.db_table))

</source>
<source file="django/tests/postgres_tests/test_indexes.py.pyindent" startline="164" endline="174" pcid="21761">
        index_name = 'integer_array_gin_fastupdate'
        index = GinIndex(fields=['field'], name=index_name, fastupdate=False)
        with connection.schema_editor() as editor:
            editor.add_index(IntegerArrayModel, index)
        constraints = self.get_constraints(IntegerArrayModel._meta.db_table)
        self.assertEqual(constraints[index_name]['type'], 'gin')
        self.assertEqual(constraints[index_name]['options'], ['fastupdate=off'])
        with connection.schema_editor() as editor:
            editor.remove_index(IntegerArrayModel, index)
        self.assertNotIn(index_name, self.get_constraints(IntegerArrayModel._meta.db_table))

</source>
</class>

<class classid="388" nclones="10" nlines="16" similarity="75">
<source file="django/tests/postgres_tests/test_indexes.py.pyindent" startline="200" endline="210" pcid="21771">
        index_name = 'char_field_model_field_brin'
        index = BrinIndex(fields=['field'], name=index_name, pages_per_range=4)
        with connection.schema_editor() as editor:
            editor.add_index(CharFieldModel, index)
        constraints = self.get_constraints(CharFieldModel._meta.db_table)
        self.assertEqual(constraints[index_name]['type'], BrinIndex.suffix)
        self.assertEqual(constraints[index_name]['options'], ['pages_per_range=4'])
        with connection.schema_editor() as editor:
            editor.remove_index(CharFieldModel, index)
        self.assertNotIn(index_name, self.get_constraints(CharFieldModel._meta.db_table))

</source>
<source file="django/tests/postgres_tests/test_indexes.py.pyindent" startline="244" endline="258" pcid="21785">
        # Ensure the table is there and doesn't have an index.
        self.assertNotIn('field', self.get_constraints(CharFieldModel._meta.db_table))
        # Add the index.
        index_name = 'char_field_model_field_btree'
        index = BTreeIndex(fields=['field'], name=index_name)
        with connection.schema_editor() as editor:
            editor.add_index(CharFieldModel, index)
        constraints = self.get_constraints(CharFieldModel._meta.db_table)
        # The index was added.
        self.assertEqual(constraints[index_name]['type'], BTreeIndex.suffix)
        # Drop the index.
        with connection.schema_editor() as editor:
            editor.remove_index(CharFieldModel, index)
        self.assertNotIn(index_name, self.get_constraints(CharFieldModel._meta.db_table))

</source>
<source file="django/tests/postgres_tests/test_indexes.py.pyindent" startline="288" endline="298" pcid="21794">
        index_name = 'integer_array_gist_buffering'
        index = GistIndex(fields=['field'], name=index_name, buffering=True, fillfactor=80)
        with connection.schema_editor() as editor:
            editor.add_index(CharFieldModel, index)
        constraints = self.get_constraints(CharFieldModel._meta.db_table)
        self.assertEqual(constraints[index_name]['type'], GistIndex.suffix)
        self.assertEqual(constraints[index_name]['options'], ['buffering=on', 'fillfactor=80'])
        with connection.schema_editor() as editor:
            editor.remove_index(CharFieldModel, index)
        self.assertNotIn(index_name, self.get_constraints(CharFieldModel._meta.db_table))

</source>
<source file="django/tests/postgres_tests/test_indexes.py.pyindent" startline="328" endline="342" pcid="21803">
        # Ensure the table is there and doesn't have an index.
        self.assertNotIn('field', self.get_constraints(CharFieldModel._meta.db_table))
        # Add the index.
        index_name = 'char_field_model_field_spgist'
        index = SpGistIndex(fields=['field'], name=index_name)
        with connection.schema_editor() as editor:
            editor.add_index(CharFieldModel, index)
        constraints = self.get_constraints(CharFieldModel._meta.db_table)
        # The index was added.
        self.assertEqual(constraints[index_name]['type'], SpGistIndex.suffix)
        # Drop the index.
        with connection.schema_editor() as editor:
            editor.remove_index(CharFieldModel, index)
        self.assertNotIn(index_name, self.get_constraints(CharFieldModel._meta.db_table))

</source>
<source file="django/tests/postgres_tests/test_indexes.py.pyindent" startline="260" endline="270" pcid="21788">
        index_name = 'integer_array_btree_fillfactor'
        index = BTreeIndex(fields=['field'], name=index_name, fillfactor=80)
        with connection.schema_editor() as editor:
            editor.add_index(CharFieldModel, index)
        constraints = self.get_constraints(CharFieldModel._meta.db_table)
        self.assertEqual(constraints[index_name]['type'], BTreeIndex.suffix)
        self.assertEqual(constraints[index_name]['options'], ['fillfactor=80'])
        with connection.schema_editor() as editor:
            editor.remove_index(CharFieldModel, index)
        self.assertNotIn(index_name, self.get_constraints(CharFieldModel._meta.db_table))

</source>
<source file="django/tests/postgres_tests/test_indexes.py.pyindent" startline="213" endline="223" pcid="21774">
        index_name = 'char_field_brin_params'
        index = BrinIndex(fields=['field'], name=index_name, autosummarize=True)
        with connection.schema_editor() as editor:
            editor.add_index(CharFieldModel, index)
        constraints = self.get_constraints(CharFieldModel._meta.db_table)
        self.assertEqual(constraints[index_name]['type'], BrinIndex.suffix)
        self.assertEqual(constraints[index_name]['options'], ['autosummarize=on'])
        with connection.schema_editor() as editor:
            editor.remove_index(CharFieldModel, index)
        self.assertNotIn(index_name, self.get_constraints(CharFieldModel._meta.db_table))

</source>
<source file="django/tests/postgres_tests/test_indexes.py.pyindent" startline="300" endline="314" pcid="21797">
        # Ensure the table is there and doesn't have an index.
        self.assertNotIn('field', self.get_constraints(CharFieldModel._meta.db_table))
        # Add the index.
        index_name = 'char_field_model_field_hash'
        index = HashIndex(fields=['field'], name=index_name)
        with connection.schema_editor() as editor:
            editor.add_index(CharFieldModel, index)
        constraints = self.get_constraints(CharFieldModel._meta.db_table)
        # The index was added.
        self.assertEqual(constraints[index_name]['type'], HashIndex.suffix)
        # Drop the index.
        with connection.schema_editor() as editor:
            editor.remove_index(CharFieldModel, index)
        self.assertNotIn(index_name, self.get_constraints(CharFieldModel._meta.db_table))

</source>
<source file="django/tests/postgres_tests/test_indexes.py.pyindent" startline="344" endline="353" pcid="21806">
        index_name = 'integer_array_spgist_fillfactor'
        index = SpGistIndex(fields=['field'], name=index_name, fillfactor=80)
        with connection.schema_editor() as editor:
            editor.add_index(CharFieldModel, index)
        constraints = self.get_constraints(CharFieldModel._meta.db_table)
        self.assertEqual(constraints[index_name]['type'], SpGistIndex.suffix)
        self.assertEqual(constraints[index_name]['options'], ['fillfactor=80'])
        with connection.schema_editor() as editor:
            editor.remove_index(CharFieldModel, index)
        self.assertNotIn(index_name, self.get_constraints(CharFieldModel._meta.db_table))
</source>
<source file="django/tests/postgres_tests/test_indexes.py.pyindent" startline="272" endline="286" pcid="21791">
        # Ensure the table is there and doesn't have an index.
        self.assertNotIn('field', self.get_constraints(CharFieldModel._meta.db_table))
        # Add the index.
        index_name = 'char_field_model_field_gist'
        index = GistIndex(fields=['field'], name=index_name)
        with connection.schema_editor() as editor:
            editor.add_index(CharFieldModel, index)
        constraints = self.get_constraints(CharFieldModel._meta.db_table)
        # The index was added.
        self.assertEqual(constraints[index_name]['type'], GistIndex.suffix)
        # Drop the index.
        with connection.schema_editor() as editor:
            editor.remove_index(CharFieldModel, index)
        self.assertNotIn(index_name, self.get_constraints(CharFieldModel._meta.db_table))

</source>
<source file="django/tests/postgres_tests/test_indexes.py.pyindent" startline="316" endline="326" pcid="21800">
        index_name = 'integer_array_hash_fillfactor'
        index = HashIndex(fields=['field'], name=index_name, fillfactor=80)
        with connection.schema_editor() as editor:
            editor.add_index(CharFieldModel, index)
        constraints = self.get_constraints(CharFieldModel._meta.db_table)
        self.assertEqual(constraints[index_name]['type'], HashIndex.suffix)
        self.assertEqual(constraints[index_name]['options'], ['fillfactor=80'])
        with connection.schema_editor() as editor:
            editor.remove_index(CharFieldModel, index)
        self.assertNotIn(index_name, self.get_constraints(CharFieldModel._meta.db_table))

</source>
</class>

<class classid="389" nclones="2" nlines="15" similarity="73">
<source file="django/tests/postgres_tests/test_indexes.py.pyindent" startline="225" endline="232" pcid="21777">
        index_name = 'brin_index_exception'
        index = BrinIndex(fields=['field'], name=index_name)
        with self.assertRaisesMessage(NotSupportedError, 'BRIN indexes require PostgreSQL 9.5+.'):
            with mock.patch('django.db.connection.features.has_brin_index_support', False):
                with connection.schema_editor() as editor:
                    editor.add_index(CharFieldModel, index)
        self.assertNotIn(index_name, self.get_constraints(CharFieldModel._meta.db_table))

</source>
<source file="django/tests/postgres_tests/test_indexes.py.pyindent" startline="235" endline="242" pcid="21781">
        index_name = 'brin_options_exception'
        index = BrinIndex(fields=['field'], name=index_name, autosummarize=True)
        with self.assertRaisesMessage(NotSupportedError, 'BRIN option autosummarize requires PostgreSQL 10+.'):
            with mock.patch('django.db.connection.features.has_brin_autosummarize', False):
                with connection.schema_editor() as editor:
                    editor.add_index(CharFieldModel, index)
        self.assertNotIn(index_name, self.get_constraints(CharFieldModel._meta.db_table))

</source>
</class>

<class classid="390" nclones="3" nlines="10" similarity="70">
<source file="django/tests/postgres_tests/test_json.py.pyindent" startline="352" endline="357" pcid="21866">
        for value, serialized in self.test_values:
            with self.subTest(value=value):
                instance = JSONModel(field=value)
                data = serializers.serialize('json', [instance])
                self.assertJSONEqual(data, self.test_data % serialized)

</source>
<source file="django/tests/postgres_tests/test_json.py.pyindent" startline="359" endline="364" pcid="21869">
        for value, serialized in self.test_values:
            with self.subTest(value=value):
                instance = list(serializers.deserialize('json', self.test_data % serialized))[0].object
                self.assertEqual(instance.field, value)


</source>
<source file="django/tests/template_tests/filter_tests/test_pluralize.py.pyindent" startline="12" endline="16" pcid="24743">
        for value, expected in tests:
            with self.subTest(value=value):
                output = self.engine.render_to_string('t', {'value': value})
                self.assertEqual(output, expected)

</source>
</class>

<class classid="391" nclones="2" nlines="19" similarity="70">
<source file="django/tests/postgres_tests/test_ranges.py.pyindent" startline="134" endline="148" pcid="21909">
        filter_args = (
            self.timestamps[1],
            self.aware_timestamps[1],
            (self.timestamps[1], self.timestamps[2]),
            (self.aware_timestamps[1], self.aware_timestamps[2]),
            Value(self.dates[0], output_field=DateTimeField()),
            Func(F('dates'), function='lower', output_field=DateTimeField()),
        )
        for filter_arg in filter_args:
            with self.subTest(filter_arg=filter_arg):
                self.assertCountEqual(
                    RangesModel.objects.filter(**{'timestamps__contains': filter_arg}),
                    [self.obj, self.aware_obj],
                )

</source>
<source file="django/tests/postgres_tests/test_ranges.py.pyindent" startline="150" endline="163" pcid="21912">
        filter_args = (
            self.timestamps[1],
            (self.dates[1], self.dates[2]),
            Value(self.dates[0], output_field=DateField()),
            Func(F('timestamps'), function='lower', output_field=DateField()),
        )
        for filter_arg in filter_args:
            with self.subTest(filter_arg=filter_arg):
                self.assertCountEqual(
                    RangesModel.objects.filter(**{'dates__contains': filter_arg}),
                    [self.obj, self.aware_obj],
                )


</source>
</class>

<class classid="392" nclones="2" nlines="10" similarity="70">
<source file="django/tests/postgres_tests/test_ranges.py.pyindent" startline="269" endline="277" pcid="21933">
        objs = [
            RangeLookupsModel.objects.create(date='2015-01-01'),
            RangeLookupsModel.objects.create(date='2015-05-05'),
        ]
        self.assertSequenceEqual(
            RangeLookupsModel.objects.filter(date__contained_by=DateRange('2015-01-01', '2015-05-04')),
            [objs[0]],
        )

</source>
<source file="django/tests/postgres_tests/test_ranges.py.pyindent" startline="279" endline="287" pcid="21934">
        objs = [
            RangeLookupsModel.objects.create(timestamp='2015-01-01'),
            RangeLookupsModel.objects.create(timestamp='2015-05-05'),
        ]
        self.assertSequenceEqual(
            RangeLookupsModel.objects.filter(timestamp__date__contained_by=DateRange('2015-01-01', '2015-05-04')),
            [objs[0]],
        )

</source>
</class>

<class classid="393" nclones="2" nlines="10" similarity="80">
<source file="django/tests/postgres_tests/test_ranges.py.pyindent" startline="323" endline="332" pcid="21938">
        objs = [
            RangeLookupsModel.objects.create(float=5),
            RangeLookupsModel.objects.create(float=99),
            RangeLookupsModel.objects.create(float=-1),
        ]
        self.assertSequenceEqual(
            RangeLookupsModel.objects.filter(float__contained_by=NumericRange(1, 98)),
            [objs[0]]
        )

</source>
<source file="django/tests/postgres_tests/test_ranges.py.pyindent" startline="345" endline="355" pcid="21940">
        objs = [
            RangeLookupsModel.objects.create(float=5),
            RangeLookupsModel.objects.create(float=99),
            RangeLookupsModel.objects.create(float=-1),
        ]
        self.assertSequenceEqual(
            RangeLookupsModel.objects.exclude(float__contained_by=NumericRange(0, 100)),
            [objs[2]]
        )


</source>
</class>

<class classid="394" nclones="4" nlines="10" similarity="70">
<source file="django/tests/postgres_tests/test_ranges.py.pyindent" startline="540" endline="546" pcid="21974">
        field = pg_forms.IntegerRangeField(required=True)
        with self.assertRaises(exceptions.ValidationError) as cm:
            field.clean(['', ''])
        self.assertEqual(cm.exception.messages[0], 'This field is required.')
        value = field.clean([1, ''])
        self.assertEqual(value, NumericRange(1, None))

</source>
<source file="django/tests/postgres_tests/test_ranges.py.pyindent" startline="657" endline="663" pcid="22007">
        field = pg_forms.DateTimeRangeField(required=True)
        with self.assertRaises(exceptions.ValidationError) as cm:
            field.clean(['', ''])
        self.assertEqual(cm.exception.messages[0], 'This field is required.')
        value = field.clean(['2013-04-09 11:45', ''])
        self.assertEqual(value, DateTimeTZRange(datetime.datetime(2013, 4, 9, 11, 45), None))

</source>
<source file="django/tests/postgres_tests/test_ranges.py.pyindent" startline="618" endline="624" pcid="21996">
        field = pg_forms.DateRangeField(required=True)
        with self.assertRaises(exceptions.ValidationError) as cm:
            field.clean(['', ''])
        self.assertEqual(cm.exception.messages[0], 'This field is required.')
        value = field.clean(['1976-04-16', ''])
        self.assertEqual(value, DateRange(datetime.date(1976, 4, 16), None))

</source>
<source file="django/tests/postgres_tests/test_ranges.py.pyindent" startline="579" endline="585" pcid="21985">
        field = pg_forms.FloatRangeField(required=True)
        with self.assertRaises(exceptions.ValidationError) as cm:
            field.clean(['', ''])
        self.assertEqual(cm.exception.messages[0], 'This field is required.')
        value = field.clean(['1.61803399', ''])
        self.assertEqual(value, NumericRange(1.61803399, None))

</source>
</class>

<class classid="395" nclones="5" nlines="10" similarity="70">
<source file="django/tests/prefetch_related/test_uuid.py.pyindent" startline="72" endline="77" pcid="22144">
        # From uuid-pk model, prefetch <uuid-pk model>.<integer-pk model>:
        with self.assertNumQueries(4):
            spooky = Pet.objects.prefetch_related('fleas_hosted__current_room__house').get(name='Spooky')
        with self.assertNumQueries(0):
            self.assertEqual('Racoon', spooky.fleas_hosted.all()[0].current_room.name)

</source>
<source file="django/tests/prefetch_related/test_uuid.py.pyindent" startline="93" endline="98" pcid="22153">
        # From integer-pk model, prefetch <integer-pk model>.<uuid-pk model>:
        with self.assertNumQueries(3):
            redwood = House.objects.prefetch_related('rooms__fleas').get(name='Redwood')
        with self.assertNumQueries(0):
            self.assertEqual(3, len(redwood.rooms.all()[0].fleas.all()))

</source>
<source file="django/tests/prefetch_related/test_uuid.py.pyindent" startline="79" endline="84" pcid="22147">
        # From uuid-pk model, prefetch <integer-pk model>.<integer-pk model>.<uuid-pk model>.<uuid-pk model>:
        with self.assertNumQueries(5):
            spooky = Pet.objects.prefetch_related('people__houses__rooms__fleas').get(name='Spooky')
        with self.assertNumQueries(0):
            self.assertEqual(3, len(spooky.people.all()[0].houses.all()[0].rooms.all()[0].fleas.all()))

</source>
<source file="django/tests/prefetch_related/test_uuid.py.pyindent" startline="100" endline="104" pcid="22156">
        # From integer-pk model, prefetch <integer-pk model>.<uuid-pk model>.<uuid-pk model>:
        with self.assertNumQueries(4):
            redwood = House.objects.prefetch_related('rooms__fleas__pets_visited').get(name='Redwood')
        with self.assertNumQueries(0):
            self.assertEqual('Spooky', redwood.rooms.all()[0].fleas.all()[0].pets_visited.all()[0].name)
</source>
<source file="django/tests/prefetch_related/test_uuid.py.pyindent" startline="86" endline="91" pcid="22150">
        # From integer-pk model, prefetch <uuid-pk model>.<integer-pk model>:
        with self.assertNumQueries(3):
            racoon = Room.objects.prefetch_related('fleas__people_visited').get(name='Racoon')
        with self.assertNumQueries(0):
            self.assertEqual('Bob', racoon.fleas.all()[0].people_visited.all()[0].name)

</source>
</class>

<class classid="396" nclones="3" nlines="13" similarity="84">
<source file="django/tests/proxy_models/tests.py.pyindent" startline="107" endline="112" pcid="22235">
        msg = "Abstract base class containing model fields not permitted for proxy model 'NoAbstract'."
        with self.assertRaisesMessage(TypeError, msg):
            class NoAbstract(Abstract):
                class Meta:
                    proxy = True

</source>
<source file="django/tests/proxy_models/tests.py.pyindent" startline="114" endline="119" pcid="22239">
        msg = "Proxy model 'TooManyBases' has more than one non-abstract model base class."
        with self.assertRaisesMessage(TypeError, msg):
            class TooManyBases(User, Person):
                class Meta:
                    proxy = True

</source>
<source file="django/tests/proxy_models/tests.py.pyindent" startline="121" endline="126" pcid="22243">
        msg = "Proxy model 'NoBaseClasses' has no non-abstract model base class."
        with self.assertRaisesMessage(TypeError, msg):
            class NoBaseClasses(models.Model):
                class Meta:
                    proxy = True

</source>
</class>

<class classid="397" nclones="2" nlines="11" similarity="72">
<source file="django/tests/queries/test_iterator.py.pyindent" startline="26" endline="32" pcid="22468">
        qs = Article.objects.iterator()
        with mock.patch('django.db.models.sql.compiler.cursor_iter', side_effect=cursor_iter) as cursor_iter_mock:
            next(qs)
        self.assertEqual(cursor_iter_mock.call_count, 1)
        mock_args, _mock_kwargs = cursor_iter_mock.call_args
        self.assertEqual(mock_args[self.itersize_index_in_mock_args], 2000)

</source>
<source file="django/tests/queries/test_iterator.py.pyindent" startline="34" endline="41" pcid="22470">
        batch_size = 3
        qs = Article.objects.iterator(chunk_size=batch_size)
        with mock.patch('django.db.models.sql.compiler.cursor_iter', side_effect=cursor_iter) as cursor_iter_mock:
            next(qs)
        self.assertEqual(cursor_iter_mock.call_count, 1)
        mock_args, _mock_kwargs = cursor_iter_mock.call_args
        self.assertEqual(mock_args[self.itersize_index_in_mock_args], batch_size)

</source>
</class>

<class classid="398" nclones="2" nlines="11" similarity="81">
<source file="django/tests/queries/test_q.py.pyindent" startline="47" endline="56" pcid="22484">
        q1 = Q(price__gt=F('discounted_price'))
        q2 = Q(price=F('discounted_price'))
        q = q1 | q2
        path, args, kwargs = q.deconstruct()
        self.assertEqual(args, (
            ('price__gt', F('discounted_price')),
            ('price', F('discounted_price')),
        ))
        self.assertEqual(kwargs, {'_connector': 'OR'})

</source>
<source file="django/tests/queries/test_q.py.pyindent" startline="58" endline="67" pcid="22485">
        q1 = Q(price__gt=F('discounted_price'))
        q2 = Q(price=F('discounted_price'))
        q = q1 & q2
        path, args, kwargs = q.deconstruct()
        self.assertEqual(args, (
            ('price__gt', F('discounted_price')),
            ('price', F('discounted_price')),
        ))
        self.assertEqual(kwargs, {})

</source>
</class>

<class classid="399" nclones="2" nlines="14" similarity="92">
<source file="django/tests/queryset_pickle/tests.py.pyindent" startline="209" endline="224" pcid="22587">
        """
        Neither pickling nor unpickling a QuerySet.query with an __in=inner_qs
        lookup should evaluate inner_qs.
        """
        events = Event.objects.filter(group__in=Group.objects.all())

        with self.assertNumQueries(0):
            dumped = pickle.dumps(events.query)

        with self.assertNumQueries(0):
            reloaded = pickle.loads(dumped)
            reloaded_events = Event.objects.none()
            reloaded_events.query = reloaded

        self.assertSequenceEqual(reloaded_events, [self.e1])

</source>
<source file="django/tests/queryset_pickle/tests.py.pyindent" startline="226" endline="236" pcid="22590">
        events = Event.objects.filter(group__in=Group.objects.values('id').query)

        with self.assertNumQueries(0):
            dumped = pickle.dumps(events.query)

        with self.assertNumQueries(0):
            reloaded = pickle.loads(dumped)
            reloaded_events = Event.objects.none()
            reloaded_events.query = reloaded

        self.assertSequenceEqual(reloaded_events, [self.e1])
</source>
</class>

<class classid="400" nclones="2" nlines="36" similarity="80">
<source file="django/tests/requests/test_data_upload_settings.py.pyindent" startline="13" endline="35" pcid="22618">
    def setUp(self):
        payload = FakePayload('a=1&a=2;a=3\r\n')
        self.request = WSGIRequest({
            'REQUEST_METHOD': 'POST',
            'CONTENT_TYPE': 'application/x-www-form-urlencoded',
            'CONTENT_LENGTH': len(payload),
            'wsgi.input': payload,
        })

    def test_size_exceeded(self):
        with self.settings(DATA_UPLOAD_MAX_MEMORY_SIZE=12):
            with self.assertRaisesMessage(RequestDataTooBig, TOO_MUCH_DATA_MSG):
                self.request._load_post_and_files()

    def test_size_not_exceeded(self):
        with self.settings(DATA_UPLOAD_MAX_MEMORY_SIZE=13):
            self.request._load_post_and_files()

    def test_no_limit(self):
        with self.settings(DATA_UPLOAD_MAX_MEMORY_SIZE=None):
            self.request._load_post_and_files()


</source>
<source file="django/tests/requests/test_data_upload_settings.py.pyindent" startline="170" endline="190" pcid="22663">
    def setUp(self):
        payload = FakePayload("\r\n".join(['a=1&a=2;a=3', '']))
        self.request = WSGIRequest({
            'REQUEST_METHOD': 'POST',
            'CONTENT_TYPE': 'application/x-www-form-urlencoded',
            'CONTENT_LENGTH': len(payload),
            'wsgi.input': payload,
        })

    def test_number_exceeded(self):
        with self.settings(DATA_UPLOAD_MAX_NUMBER_FIELDS=2):
            with self.assertRaisesMessage(TooManyFieldsSent, TOO_MANY_FIELDS_MSG):
                self.request._load_post_and_files()

    def test_number_not_exceeded(self):
        with self.settings(DATA_UPLOAD_MAX_NUMBER_FIELDS=3):
            self.request._load_post_and_files()

    def test_no_limit(self):
        with self.settings(DATA_UPLOAD_MAX_NUMBER_FIELDS=None):
            self.request._load_post_and_files()
</source>
</class>

<class classid="401" nclones="2" nlines="13" similarity="71">
<source file="django/tests/requests/test_data_upload_settings.py.pyindent" startline="115" endline="123" pcid="22649">
        with self.settings(DATA_UPLOAD_MAX_NUMBER_FIELDS=1):
            with self.assertRaisesMessage(TooManyFieldsSent, TOO_MANY_FIELDS_MSG):
                request = WSGIRequest({
                    'REQUEST_METHOD': 'GET',
                    'wsgi.input': BytesIO(b''),
                    'QUERY_STRING': 'a=1&a=2;a=3',
                })
                request.GET['a']

</source>
<source file="django/tests/requests/test_data_upload_settings.py.pyindent" startline="125" endline="133" pcid="22652">
        with self.settings(DATA_UPLOAD_MAX_NUMBER_FIELDS=3):
            request = WSGIRequest({
                'REQUEST_METHOD': 'GET',
                'wsgi.input': BytesIO(b''),
                'QUERY_STRING': 'a=1&a=2;a=3',
            })
            request.GET['a']


</source>
</class>

<class classid="402" nclones="2" nlines="11" similarity="81">
<source file="django/tests/schema/models.py.pyindent" startline="88" endline="96" pcid="22870">
    author = models.OneToOneField(Author, models.CASCADE)
    title = models.CharField(max_length=100, db_index=True)
    pub_date = models.DateTimeField()

    class Meta:
        apps = new_apps
        db_table = "schema_book"


</source>
<source file="django/tests/schema/models.py.pyindent" startline="98" endline="107" pcid="22872">
    author = models.ForeignKey(Author, models.CASCADE)
    title = models.CharField(max_length=100, db_index=True)
    pub_date = models.DateTimeField()
    slug = models.CharField(max_length=20, unique=True)

    class Meta:
        apps = new_apps
        db_table = "schema_book"


</source>
</class>

<class classid="403" nclones="2" nlines="13" similarity="84">
<source file="django/tests/select_related/tests.py.pyindent" startline="63" endline="76" pcid="22943">
        """
        select_related() also of course applies to entire lists, not just
        items. This test verifies the expected behavior without select_related.
        """
        with self.assertNumQueries(9):
            world = Species.objects.all()
            families = [o.genus.family.name for o in world]
            self.assertEqual(sorted(families), [
                'Amanitacae',
                'Drosophilidae',
                'Fabaceae',
                'Hominidae',
            ])

</source>
<source file="django/tests/select_related/tests.py.pyindent" startline="78" endline="91" pcid="22945">
        """
        select_related() also of course applies to entire lists, not just
        items. This test verifies the expected behavior with select_related.
        """
        with self.assertNumQueries(1):
            world = Species.objects.all().select_related()
            families = [o.genus.family.name for o in world]
            self.assertEqual(sorted(families), [
                'Amanitacae',
                'Drosophilidae',
                'Fabaceae',
                'Hominidae',
            ])

</source>
</class>

<class classid="404" nclones="2" nlines="16" similarity="75">
<source file="django/tests/serializers/test_json.py.pyindent" startline="96" endline="111" pcid="23353">
        """
        If there is an invalid primary key, the error message should contain
        the model associated with it.
        """
        test_string = """[{
            "pk": "badpk",
            "model": "serializers.player",
            "fields": {
                "name": "Bob",
                "rank": 1,
                "team": "Team"
            }
        }]"""
        with self.assertRaisesMessage(DeserializationError, "(serializers.player:pk=badpk)"):
            list(serializers.deserialize('json', test_string))

</source>
<source file="django/tests/serializers/test_json.py.pyindent" startline="113" endline="129" pcid="23355">
        """
        If there is an invalid field value, the error message should contain
        the model associated with it.
        """
        test_string = """[{
            "pk": "1",
            "model": "serializers.player",
            "fields": {
                "name": "Bob",
                "rank": "invalidint",
                "team": "Team"
            }
        }]"""
        expected = "(serializers.player:pk=1) field_value was 'invalidint'"
        with self.assertRaisesMessage(DeserializationError, expected):
            list(serializers.deserialize('json', test_string))

</source>
</class>

<class classid="405" nclones="4" nlines="27" similarity="75">
<source file="django/tests/serializers/test_natural.py.pyindent" startline="97" endline="118" pcid="23381">
    t1 = NaturalKeyThing.objects.create(key='t1')
    t2 = NaturalKeyThing.objects.create(key='t2', other_thing=t1)
    t1.other_thing = t2
    t1.save()
    string_data = serializers.serialize(
        format, [t1, t2], use_natural_primary_keys=True,
        use_natural_foreign_keys=True,
    )
    NaturalKeyThing.objects.all().delete()
    objs_with_deferred_fields = []
    for obj in serializers.deserialize(format, string_data, handle_forward_references=True):
        obj.save()
        if obj.deferred_fields:
            objs_with_deferred_fields.append(obj)
    for obj in objs_with_deferred_fields:
        obj.save_deferred_fields()
    t1 = NaturalKeyThing.objects.get(key='t1')
    t2 = NaturalKeyThing.objects.get(key='t2')
    self.assertEqual(t1.other_thing, t2)
    self.assertEqual(t2.other_thing, t1)


</source>
<source file="django/tests/serializers/test_natural.py.pyindent" startline="120" endline="139" pcid="23385">
    t1 = NaturalKeyThing.objects.create(key='t1')
    t2 = NaturalKeyThing.objects.create(key='t2', other_thing=t1)
    t1.other_thing = t2
    t1.save()
    string_data = serializers.serialize(
        format, [t1], use_natural_primary_keys=True,
        use_natural_foreign_keys=True,
    )
    NaturalKeyThing.objects.all().delete()
    objs_with_deferred_fields = []
    for obj in serializers.deserialize(format, string_data, handle_forward_references=True):
        obj.save()
        if obj.deferred_fields:
            objs_with_deferred_fields.append(obj)
    obj = objs_with_deferred_fields[0]
    msg = 'NaturalKeyThing matching query does not exist'
    with self.assertRaisesMessage(serializers.base.DeserializationError, msg):
        obj.save_deferred_fields()


</source>
<source file="django/tests/serializers/test_natural.py.pyindent" startline="164" endline="185" pcid="23393">
    t1 = NaturalKeyThing.objects.create(key='t1')
    t2 = NaturalKeyThing.objects.create(key='t2')
    t3 = NaturalKeyThing.objects.create(key='t3')
    t1.other_things.set([t2, t3])
    t1.save()
    string_data = serializers.serialize(
        format, [t1, t2], use_natural_primary_keys=True,
        use_natural_foreign_keys=True,
    )
    NaturalKeyThing.objects.all().delete()
    objs_with_deferred_fields = []
    for obj in serializers.deserialize(format, string_data, handle_forward_references=True):
        obj.save()
        if obj.deferred_fields:
            objs_with_deferred_fields.append(obj)
    obj = objs_with_deferred_fields[0]
    msg = 'NaturalKeyThing matching query does not exist'
    with self.assertRaisesMessage(serializers.base.DeserializationError, msg):
        obj.save_deferred_fields()


# Dynamically register tests for each serializer
</source>
<source file="django/tests/serializers/test_natural.py.pyindent" startline="141" endline="162" pcid="23389">
    t1 = NaturalKeyThing.objects.create(key='t1')
    t2 = NaturalKeyThing.objects.create(key='t2')
    t3 = NaturalKeyThing.objects.create(key='t3')
    t1.other_things.set([t2, t3])
    string_data = serializers.serialize(
        format, [t1, t2, t3], use_natural_primary_keys=True,
        use_natural_foreign_keys=True,
    )
    NaturalKeyThing.objects.all().delete()
    objs_with_deferred_fields = []
    for obj in serializers.deserialize(format, string_data, handle_forward_references=True):
        obj.save()
        if obj.deferred_fields:
            objs_with_deferred_fields.append(obj)
    for obj in objs_with_deferred_fields:
        obj.save_deferred_fields()
    t1 = NaturalKeyThing.objects.get(key='t1')
    t2 = NaturalKeyThing.objects.get(key='t2')
    t3 = NaturalKeyThing.objects.get(key='t3')
    self.assertCountEqual(t1.other_things.all(), [t2, t3])


</source>
</class>

<class classid="406" nclones="2" nlines="12" similarity="83">
<source file="django/tests/sessions_tests/tests.py.pyindent" startline="645" endline="660" pcid="23627">
        request = RequestFactory().get('/')
        response = HttpResponse('Session test')
        middleware = SessionMiddleware()

        # Simulate a request the modifies the session
        middleware.process_request(request)
        request.session['hello'] = 'world'

        # Handle the response through the middleware
        response = middleware.process_response(request, response)
        self.assertIs(response.cookies[settings.SESSION_COOKIE_NAME]['httponly'], True)
        self.assertIn(
            cookies.Morsel._reserved['httponly'],
            str(response.cookies[settings.SESSION_COOKIE_NAME])
        )

</source>
<source file="django/tests/sessions_tests/tests.py.pyindent" startline="673" endline="688" pcid="23629">
        request = RequestFactory().get('/')
        response = HttpResponse('Session test')
        middleware = SessionMiddleware()

        # Simulate a request the modifies the session
        middleware.process_request(request)
        request.session['hello'] = 'world'

        # Handle the response through the middleware
        response = middleware.process_response(request, response)
        self.assertEqual(response.cookies[settings.SESSION_COOKIE_NAME]['httponly'], '')
        self.assertNotIn(
            cookies.Morsel._reserved['httponly'],
            str(response.cookies[settings.SESSION_COOKIE_NAME])
        )

</source>
</class>

<class classid="407" nclones="2" nlines="15" similarity="86">
<source file="django/tests/sessions_tests/tests.py.pyindent" startline="726" endline="750" pcid="23633">
        request = RequestFactory().get('/')
        response = HttpResponse('Session test')
        middleware = SessionMiddleware()

        # Before deleting, there has to be an existing cookie
        request.COOKIES[settings.SESSION_COOKIE_NAME] = 'abc'

        # Simulate a request that ends the session
        middleware.process_request(request)
        request.session.flush()

        # Handle the response through the middleware
        response = middleware.process_response(request, response)

        # The cookie was deleted, not recreated.
        # A deleted cookie header looks like:
        #  Set-Cookie: sessionid=; expires=Thu, 01 Jan 1970 00:00:00 GMT; Max-Age=0; Path=/
        self.assertEqual(
            'Set-Cookie: {}=""; expires=Thu, 01 Jan 1970 00:00:00 GMT; '
            'Max-Age=0; Path=/'.format(
                settings.SESSION_COOKIE_NAME,
            ),
            str(response.cookies[settings.SESSION_COOKIE_NAME])
        )

</source>
<source file="django/tests/sessions_tests/tests.py.pyindent" startline="753" endline="779" pcid="23634">
        request = RequestFactory().get('/')
        response = HttpResponse('Session test')
        middleware = SessionMiddleware()

        # Before deleting, there has to be an existing cookie
        request.COOKIES[settings.SESSION_COOKIE_NAME] = 'abc'

        # Simulate a request that ends the session
        middleware.process_request(request)
        request.session.flush()

        # Handle the response through the middleware
        response = middleware.process_response(request, response)

        # The cookie was deleted, not recreated.
        # A deleted cookie header with a custom domain and path looks like:
        #  Set-Cookie: sessionid=; Domain=.example.local;
        #              expires=Thu, 01 Jan 1970 00:00:00 GMT; Max-Age=0;
        #              Path=/example/
        self.assertEqual(
            'Set-Cookie: {}=""; Domain=.example.local; expires=Thu, '
            '01 Jan 1970 00:00:00 GMT; Max-Age=0; Path=/example/'.format(
                settings.SESSION_COOKIE_NAME,
            ),
            str(response.cookies[settings.SESSION_COOKIE_NAME])
        )

</source>
</class>

<class classid="408" nclones="2" nlines="11" similarity="90">
<source file="django/tests/settings_tests/tests.py.pyindent" startline="161" endline="167" pcid="23672">
        settings.TEST = 'test'
        self.assertEqual('test', settings.TEST)
        with self.settings(TEST='override'):
            self.assertEqual('override', settings.TEST)
        self.assertEqual('test', settings.TEST)
        del settings.TEST

</source>
<source file="django/tests/settings_tests/tests.py.pyindent" startline="169" endline="176" pcid="23674">
        settings.TEST = 'test'
        self.assertEqual('test', settings.TEST)
        with self.settings(TEST='override'):
            self.assertEqual('override', settings.TEST)
            settings.TEST = 'test2'
        self.assertEqual('test', settings.TEST)
        del settings.TEST

</source>
</class>

<class classid="409" nclones="3" nlines="16" similarity="81">
<source file="django/tests/settings_tests/tests.py.pyindent" startline="292" endline="300" pcid="23709">
        settings_module = ModuleType('fake_settings_module')
        sys.modules['fake_settings_module'] = settings_module
        msg = 'The SECRET_KEY setting must not be empty.'
        try:
            with self.assertRaisesMessage(ImproperlyConfigured, msg):
                Settings('fake_settings_module')
        finally:
            del sys.modules['fake_settings_module']

</source>
<source file="django/tests/settings_tests/tests.py.pyindent" startline="436" endline="445" pcid="23746">
            setattr(settings_module, setting, ('non_list_or_tuple_value'))
            sys.modules['fake_settings_module'] = settings_module
            try:
                with self.assertRaises(ImproperlyConfigured):
                    Settings('fake_settings_module')
            finally:
                del sys.modules['fake_settings_module']
                delattr(settings_module, setting)


</source>
<source file="django/tests/view_tests/tests/test_default_content_type.py.pyindent" startline="36" endline="44" pcid="28292">
        settings_module = ModuleType('fake_settings_module')
        settings_module.DEFAULT_CONTENT_TYPE = 'text/xml'
        settings_module.SECRET_KEY = 'abc'
        sys.modules['fake_settings_module'] = settings_module
        try:
            with self.assertRaisesMessage(RemovedInDjango30Warning, self.msg):
                Settings('fake_settings_module')
        finally:
            del sys.modules['fake_settings_module']
</source>
</class>

<class classid="410" nclones="3" nlines="11" similarity="81">
<source file="django/tests/settings_tests/tests.py.pyindent" startline="504" endline="512" pcid="23759">
        """Receiver fails on both enter and exit."""
        with self.assertRaises(SettingChangeEnterException):
            with override_settings(SETTING_PASS='BOTH', SETTING_BOTH='BOTH'):
                pass

        self.check_settings()
        # Two settings were touched, so expect two calls of `spy_receiver`.
        self.check_spy_receiver_exit_calls(call_count=2)

</source>
<source file="django/tests/settings_tests/tests.py.pyindent" startline="514" endline="522" pcid="23762">
        """Receiver fails on enter only."""
        with self.assertRaises(SettingChangeEnterException):
            with override_settings(SETTING_PASS='ENTER', SETTING_ENTER='ENTER'):
                pass

        self.check_settings()
        # Two settings were touched, so expect two calls of `spy_receiver`.
        self.check_spy_receiver_exit_calls(call_count=2)

</source>
<source file="django/tests/settings_tests/tests.py.pyindent" startline="524" endline="532" pcid="23765">
        """Receiver fails on exit only."""
        with self.assertRaises(SettingChangeExitException):
            with override_settings(SETTING_PASS='EXIT', SETTING_EXIT='EXIT'):
                pass

        self.check_settings()
        # Two settings were touched, so expect two calls of `spy_receiver`.
        self.check_spy_receiver_exit_calls(call_count=2)

</source>
</class>

<class classid="411" nclones="4" nlines="10" similarity="70">
<source file="django/tests/sitemaps_tests/test_http.py.pyindent" startline="25" endline="33" pcid="23912">
        "A simple sitemap index can be rendered"
        response = self.client.get('/simple/index.xml')
        expected_content = """<?xml version="1.0" encoding="UTF-8"?>
<sitemapindex xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
<sitemap><loc>%s/simple/sitemap-simple.xml</loc></sitemap>
</sitemapindex>
""" % self.base_url
        self.assertXMLEqual(response.content.decode(), expected_content)

</source>
<source file="django/tests/sitemaps_tests/test_https.py.pyindent" startline="38" endline="46" pcid="23948">
        "A sitemap index requested in HTTPS is rendered with HTTPS links"
        response = self.client.get('/simple/index.xml', **self.extra)
        expected_content = """<?xml version="1.0" encoding="UTF-8"?>
<sitemapindex xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
<sitemap><loc>%s/simple/sitemap-simple.xml</loc></sitemap>
</sitemapindex>
""" % self.base_url.replace('http://', 'https://')
        self.assertXMLEqual(response.content.decode(), expected_content)

</source>
<source file="django/tests/sitemaps_tests/test_https.py.pyindent" startline="13" endline="21" pcid="23945">
        "A secure sitemap index can be rendered"
        response = self.client.get('/secure/index.xml')
        expected_content = """<?xml version="1.0" encoding="UTF-8"?>
<sitemapindex xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
<sitemap><loc>%s/secure/sitemap-simple.xml</loc></sitemap>
</sitemapindex>
""" % self.base_url
        self.assertXMLEqual(response.content.decode(), expected_content)

</source>
<source file="django/tests/sitemaps_tests/test_http.py.pyindent" startline="59" endline="68" pcid="23915">
        "A simple sitemap index can be rendered with a custom template"
        response = self.client.get('/simple/custom-index.xml')
        expected_content = """<?xml version="1.0" encoding="UTF-8"?>
<!-- This is a customised template -->
<sitemapindex xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
<sitemap><loc>%s/simple/sitemap-simple.xml</loc></sitemap>
</sitemapindex>
""" % self.base_url
        self.assertXMLEqual(response.content.decode(), expected_content)

</source>
</class>

<class classid="412" nclones="5" nlines="10" similarity="70">
<source file="django/tests/sitemaps_tests/test_http.py.pyindent" startline="70" endline="78" pcid="23916">
        "A simple sitemap section can be rendered"
        response = self.client.get('/simple/sitemap-simple.xml')
        expected_content = """<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
<url><loc>%s/location/</loc><lastmod>%s</lastmod><changefreq>never</changefreq><priority>0.5</priority></url>
</urlset>
""" % (self.base_url, date.today())
        self.assertXMLEqual(response.content.decode(), expected_content)

</source>
<source file="django/tests/sitemaps_tests/test_https.py.pyindent" startline="48" endline="55" pcid="23949">
        "A sitemap section requested in HTTPS is rendered with HTTPS links"
        response = self.client.get('/simple/sitemap-simple.xml', **self.extra)
        expected_content = """<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
<url><loc>%s/location/</loc><lastmod>%s</lastmod><changefreq>never</changefreq><priority>0.5</priority></url>
</urlset>
""" % (self.base_url.replace('http://', 'https://'), date.today())
        self.assertXMLEqual(response.content.decode(), expected_content)
</source>
<source file="django/tests/sitemaps_tests/test_https.py.pyindent" startline="23" endline="32" pcid="23946">
        "A secure sitemap section can be rendered"
        response = self.client.get('/secure/sitemap-simple.xml')
        expected_content = """<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
<url><loc>%s/location/</loc><lastmod>%s</lastmod><changefreq>never</changefreq><priority>0.5</priority></url>
</urlset>
""" % (self.base_url, date.today())
        self.assertXMLEqual(response.content.decode(), expected_content)


</source>
<source file="django/tests/sitemaps_tests/test_http.py.pyindent" startline="95" endline="103" pcid="23920">
        "A simple sitemap can be rendered"
        response = self.client.get('/simple/sitemap.xml')
        expected_content = """<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
<url><loc>%s/location/</loc><lastmod>%s</lastmod><changefreq>never</changefreq><priority>0.5</priority></url>
</urlset>
""" % (self.base_url, date.today())
        self.assertXMLEqual(response.content.decode(), expected_content)

</source>
<source file="django/tests/sitemaps_tests/test_http.py.pyindent" startline="109" endline="118" pcid="23921">
        "A simple sitemap can be rendered with a custom template"
        response = self.client.get('/simple/custom-sitemap.xml')
        expected_content = """<?xml version="1.0" encoding="UTF-8"?>
<!-- This is a customised template -->
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
<url><loc>%s/location/</loc><lastmod>%s</lastmod><changefreq>never</changefreq><priority>0.5</priority></url>
</urlset>
""" % (self.base_url, date.today())
        self.assertXMLEqual(response.content.decode(), expected_content)

</source>
</class>

<class classid="413" nclones="2" nlines="11" similarity="72">
<source file="django/tests/staticfiles_tests/test_management.py.pyindent" startline="253" endline="261" pcid="24171">
        stdout = StringIO()
        self.run_collectstatic()
        with mock.patch('builtins.input', side_effect=self.mock_input(stdout)):
            call_command('collectstatic', interactive=True, clear=True, stdout=stdout)

        output = stdout.getvalue()
        self.assertNotIn(self.overwrite_warning_msg, output)
        self.assertIn(self.delete_warning_msg, output)

</source>
<source file="django/tests/staticfiles_tests/test_management.py.pyindent" startline="263" endline="270" pcid="24173">
        stdout = StringIO()
        self.run_collectstatic()
        with mock.patch('builtins.input', side_effect=self.mock_input(stdout)):
            call_command('collectstatic', interactive=True, stdout=stdout)
        output = stdout.getvalue()
        self.assertIn(self.overwrite_warning_msg, output)
        self.assertNotIn(self.delete_warning_msg, output)

</source>
</class>

<class classid="414" nclones="5" nlines="11" similarity="72">
<source file="django/tests/staticfiles_tests/test_storage.py.pyindent" startline="58" endline="65" pcid="24223">
        relpath = self.hashed_file_path("cached/styles.css")
        self.assertEqual(relpath, "cached/styles.5e0040571e1a.css")
        with storage.staticfiles_storage.open(relpath) as relfile:
            content = relfile.read()
            self.assertNotIn(b"cached/other.css", content)
            self.assertIn(b"other.d41d8cd98f00.css", content)
        self.assertPostCondition()

</source>
<source file="django/tests/staticfiles_tests/test_storage.py.pyindent" startline="80" endline="87" pcid="24227">
        relpath = self.hashed_file_path("cached/styles.css?spam=eggs")
        self.assertEqual(relpath, "cached/styles.5e0040571e1a.css?spam=eggs")
        with storage.staticfiles_storage.open("cached/styles.5e0040571e1a.css") as relfile:
            content = relfile.read()
            self.assertNotIn(b"cached/other.css", content)
            self.assertIn(b"other.d41d8cd98f00.css", content)
        self.assertPostCondition()

</source>
<source file="django/tests/staticfiles_tests/test_storage.py.pyindent" startline="89" endline="96" pcid="24229">
        relpath = self.hashed_file_path("cached/styles.css#eggs")
        self.assertEqual(relpath, "cached/styles.5e0040571e1a.css#eggs")
        with storage.staticfiles_storage.open("cached/styles.5e0040571e1a.css") as relfile:
            content = relfile.read()
            self.assertNotIn(b"cached/other.css", content)
            self.assertIn(b"other.d41d8cd98f00.css", content)
        self.assertPostCondition()

</source>
<source file="django/tests/staticfiles_tests/test_storage.py.pyindent" startline="211" endline="218" pcid="24248">
        relpath = self.hashed_file_path("cached/styles_insensitive.css")
        self.assertEqual(relpath, "cached/styles_insensitive.3fa427592a53.css")
        with storage.staticfiles_storage.open(relpath) as relfile:
            content = relfile.read()
            self.assertNotIn(b"cached/other.css", content)
            self.assertIn(b"other.d41d8cd98f00.css", content)
        self.assertPostCondition()

</source>
<source file="django/tests/staticfiles_tests/test_storage.py.pyindent" startline="464" endline="471" pcid="24280">
        relpath = self.hashed_file_path("cached/styles.css")
        self.assertEqual(relpath, "cached/styles.deploy12345.css")
        with storage.staticfiles_storage.open(relpath) as relfile:
            content = relfile.read()
            self.assertNotIn(b"cached/other.css", content)
            self.assertIn(b"other.deploy12345.css", content)


</source>
</class>

<class classid="415" nclones="2" nlines="10" similarity="80">
<source file="django/tests/staticfiles_tests/test_storage.py.pyindent" startline="174" endline="180" pcid="24245">
        finders.get_finder.cache_clear()
        err = StringIO()
        with self.assertRaisesMessage(RuntimeError, 'Max post-process passes exceeded'):
            call_command('collectstatic', interactive=False, verbosity=0, stderr=err)
        self.assertEqual("Post-processing 'All' failed!\n\n", err.getvalue())
        self.assertPostCondition()

</source>
<source file="django/tests/staticfiles_tests/test_storage.py.pyindent" startline="224" endline="234" pcid="24250">
        """
        post_processing indicates the origin of the error when it fails.
        """
        finders.get_finder.cache_clear()
        err = StringIO()
        with self.assertRaises(Exception):
            call_command('collectstatic', interactive=False, verbosity=0, stderr=err)
        self.assertEqual("Post-processing 'faulty.css' failed!\n\n", err.getvalue())
        self.assertPostCondition()


</source>
</class>

<class classid="416" nclones="2" nlines="14" similarity="100">
<source file="django/tests/syndication_tests/feeds.py.pyindent" startline="90" endline="102" pcid="24366">
    """
    A feed to test that RSS feeds work with a single enclosure.
    """
    def item_enclosure_url(self, item):
        return 'http://example.com'

    def item_enclosure_size(self, item):
        return 0

    def item_mime_type(self, item):
        return 'image/png'


</source>
<source file="django/tests/syndication_tests/feeds.py.pyindent" startline="190" endline="202" pcid="24387">
    """
    A feed to test that Atom feeds work with a single enclosure.
    """
    def item_enclosure_url(self, item):
        return 'http://example.com'

    def item_enclosure_size(self, item):
        return 0

    def item_mime_type(self, item):
        return 'image/png'


</source>
</class>

<class classid="417" nclones="2" nlines="11" similarity="72">
<source file="django/tests/template_backends/test_utils.py.pyindent" startline="10" endline="18" pcid="24443">
        """
        Failing to import a backend keeps raising the original import error
        (#24265).
        """
        with self.assertRaisesMessage(ImportError, "No module named 'raise"):
            engines.all()
        with self.assertRaisesMessage(ImportError, "No module named 'raise"):
            engines.all()

</source>
<source file="django/tests/template_backends/test_utils.py.pyindent" startline="26" endline="35" pcid="24446">
        """
        Failing to initialize a backend keeps raising the original exception
        (#24265).
        """
        msg = 'app_dirs must not be set when loaders is defined.'
        with self.assertRaisesMessage(ImproperlyConfigured, msg):
            engines.all()
        with self.assertRaisesMessage(ImproperlyConfigured, msg):
            engines.all()

</source>
</class>

<class classid="418" nclones="2" nlines="11" similarity="90">
<source file="django/tests/template_loader/tests.py.pyindent" startline="39" endline="46" pcid="24455">
        with self.assertRaises(TemplateDoesNotExist) as e:
            get_template("template_loader/unknown.html")
        self.assertEqual(
            e.exception.chain[-1].tried[0][0].template_name,
            'template_loader/unknown.html',
        )
        self.assertEqual(e.exception.chain[-1].backend.name, 'django')

</source>
<source file="django/tests/template_loader/tests.py.pyindent" startline="113" endline="120" pcid="24471">
        with self.assertRaises(TemplateDoesNotExist) as e:
            render_to_string("template_loader/unknown.html")
        self.assertEqual(
            e.exception.chain[-1].tried[0][0].template_name,
            'template_loader/unknown.html',
        )
        self.assertEqual(e.exception.chain[-1].backend.name, 'django')

</source>
</class>

<class classid="419" nclones="2" nlines="10" similarity="70">
<source file="django/tests/template_tests/filter_tests/test_center.py.pyindent" startline="22" endline="27" pcid="24511">

    def test_center(self):
        self.assertEqual(center('test', 6), ' test ')

    def test_non_string_input(self):
        self.assertEqual(center(123, 5), ' 123 ')
</source>
<source file="django/tests/template_tests/filter_tests/test_urlencode.py.pyindent" startline="21" endline="26" pcid="24904">

    def test_urlencode(self):
        self.assertEqual(urlencode('fran\xe7ois & jill'), 'fran%C3%A7ois%20%26%20jill')

    def test_non_string_input(self):
        self.assertEqual(urlencode(1), '1')
</source>
</class>

<class classid="420" nclones="2" nlines="14" similarity="78">
<source file="django/tests/template_tests/filter_tests/test_default.py.pyindent" startline="52" endline="60" pcid="24565">

    def test_value(self):
        self.assertEqual(default('val', 'default'), 'val')

    def test_none(self):
        self.assertEqual(default(None, 'default'), 'default')

    def test_empty_string(self):
        self.assertEqual(default('', 'default'), 'default')
</source>
<source file="django/tests/template_tests/filter_tests/test_default_if_none.py.pyindent" startline="6" endline="14" pcid="24569">

    def test_value(self):
        self.assertEqual(default_if_none("val", 'default'), 'val')

    def test_none(self):
        self.assertEqual(default_if_none(None, 'default'), 'default')

    def test_empty_string(self):
        self.assertEqual(default_if_none('', 'default'), '')
</source>
</class>

<class classid="421" nclones="2" nlines="14" similarity="78">
<source file="django/tests/template_tests/filter_tests/test_dictsort.py.pyindent" startline="8" endline="21" pcid="24574">
        sorted_dicts = dictsort(
            [{'age': 23, 'name': 'Barbara-Ann'},
             {'age': 63, 'name': 'Ra Ra Rasputin'},
             {'name': 'Jonny B Goode', 'age': 18}],
            'age',
        )

        self.assertEqual(
            [sorted(dict.items()) for dict in sorted_dicts],
            [[('age', 18), ('name', 'Jonny B Goode')],
             [('age', 23), ('name', 'Barbara-Ann')],
             [('age', 63), ('name', 'Ra Ra Rasputin')]],
        )

</source>
<source file="django/tests/template_tests/filter_tests/test_dictsortreversed.py.pyindent" startline="8" endline="21" pcid="24580">
        sorted_dicts = dictsortreversed(
            [{'age': 23, 'name': 'Barbara-Ann'},
             {'age': 63, 'name': 'Ra Ra Rasputin'},
             {'name': 'Jonny B Goode', 'age': 18}],
            'age',
        )

        self.assertEqual(
            [sorted(dict.items()) for dict in sorted_dicts],
            [[('age', 63), ('name', 'Ra Ra Rasputin')],
             [('age', 23), ('name', 'Barbara-Ann')],
             [('age', 18), ('name', 'Jonny B Goode')]],
        )

</source>
</class>

<class classid="422" nclones="2" nlines="13" similarity="76">
<source file="django/tests/template_tests/filter_tests/test_dictsort.py.pyindent" startline="42" endline="53" pcid="24577">
        data = [
            {'0': 'a', '1': '42'},
            {'0': 'c', '1': 'string'},
            {'0': 'b', '1': 'foo'},
        ]
        expected = [
            {'0': 'a', '1': '42'},
            {'0': 'b', '1': 'foo'},
            {'0': 'c', '1': 'string'},
        ]
        self.assertEqual(dictsort(data, '0'), expected)

</source>
<source file="django/tests/template_tests/filter_tests/test_dictsortreversed.py.pyindent" startline="28" endline="39" pcid="24582">
        data = [
            {'0': 'a', '1': '42'},
            {'0': 'c', '1': 'string'},
            {'0': 'b', '1': 'foo'},
        ]
        expected = [
            {'0': 'c', '1': 'string'},
            {'0': 'b', '1': 'foo'},
            {'0': 'a', '1': '42'},
        ]
        self.assertEqual(dictsortreversed(data, '0'), expected)

</source>
</class>

<class classid="423" nclones="3" nlines="14" similarity="71">
<source file="django/tests/template_tests/filter_tests/test_lower.py.pyindent" startline="22" endline="31" pcid="24724">

    def test_lower(self):
        self.assertEqual(lower('TEST'), 'test')

    def test_unicode(self):
        # uppercase E umlaut
        self.assertEqual(lower('\xcb'), '\xeb')

    def test_non_string_input(self):
        self.assertEqual(lower(123), '123')
</source>
<source file="django/tests/template_tests/filter_tests/test_title.py.pyindent" startline="21" endline="29" pcid="24860">

    def test_title(self):
        self.assertEqual(title('a nice title, isn\'t it?'), "A Nice Title, Isn't It?")

    def test_unicode(self):
        self.assertEqual(title('discoth\xe8que'), 'Discoth\xe8que')

    def test_non_string_input(self):
        self.assertEqual(title(123), '123')
</source>
<source file="django/tests/template_tests/filter_tests/test_upper.py.pyindent" startline="26" endline="35" pcid="24897">

    def test_upper(self):
        self.assertEqual(upper('Mixed case input'), 'MIXED CASE INPUT')

    def test_unicode(self):
        # lowercase e umlaut
        self.assertEqual(upper('\xeb'), '\xcb')

    def test_non_string_input(self):
        self.assertEqual(upper(123), '123')
</source>
</class>

<class classid="424" nclones="2" nlines="10" similarity="90">
<source file="django/tests/template_tests/filter_tests/test_striptags.py.pyindent" startline="13" endline="21" pcid="24794">
        output = self.engine.render_to_string(
            'striptags01',
            {
                'a': '<a>x</a> <p><b>y</b></p>',
                'b': mark_safe('<a>x</a> <p><b>y</b></p>'),
            },
        )
        self.assertEqual(output, 'x y x y')

</source>
<source file="django/tests/template_tests/filter_tests/test_striptags.py.pyindent" startline="24" endline="33" pcid="24795">
        output = self.engine.render_to_string(
            'striptags02',
            {
                'a': '<a>x</a> <p><b>y</b></p>',
                'b': mark_safe('<a>x</a> <p><b>y</b></p>'),
            },
        )
        self.assertEqual(output, 'x y x y')


</source>
</class>

<class classid="425" nclones="2" nlines="14" similarity="71">
<source file="django/tests/template_tests/filter_tests/test_timesince.py.pyindent" startline="130" endline="138" pcid="24832">

    def test_since_now(self):
        self.assertEqual(timesince_filter(datetime.now() - timedelta(1)), '1\xa0day')

    def test_no_args(self):
        self.assertEqual(timesince_filter(None), '')

    def test_explicit_date(self):
        self.assertEqual(timesince_filter(datetime(2005, 12, 29), datetime(2005, 12, 30)), '1\xa0day')
</source>
<source file="django/tests/template_tests/filter_tests/test_timeuntil.py.pyindent" startline="112" endline="120" pcid="24853">

    def test_until_now(self):
        self.assertEqual(timeuntil_filter(datetime.now() + timedelta(1, 1)), '1\xa0day')

    def test_no_args(self):
        self.assertEqual(timeuntil_filter(None), '')

    def test_explicit_date(self):
        self.assertEqual(timeuntil_filter(datetime(2005, 12, 30), datetime(2005, 12, 29)), '1\xa0day')
</source>
</class>

<class classid="426" nclones="2" nlines="13" similarity="84">
<source file="django/tests/template_tests/filter_tests/test_urlizetrunc.py.pyindent" startline="14" endline="26" pcid="24946">
        output = self.engine.render_to_string(
            'urlizetrunc01',
            {
                'a': '"Unsafe" http://example.com/x=&y=',
                'b': mark_safe('&quot;Safe&quot; http://example.com?x=&amp;y='),
            },
        )
        self.assertEqual(
            output,
            '"Unsafe" <a href="http://example.com/x=&amp;y=" rel="nofollow">http:...</a> '
            '&quot;Safe&quot; <a href="http://example.com?x=&amp;y=" rel="nofollow">http:...</a>'
        )

</source>
<source file="django/tests/template_tests/filter_tests/test_urlizetrunc.py.pyindent" startline="29" endline="42" pcid="24947">
        output = self.engine.render_to_string(
            'urlizetrunc02',
            {
                'a': '"Unsafe" http://example.com/x=&y=',
                'b': mark_safe('&quot;Safe&quot; http://example.com?x=&amp;y='),
            },
        )
        self.assertEqual(
            output,
            '&quot;Unsafe&quot; <a href="http://example.com/x=&amp;y=" rel="nofollow">http:...</a> '
            '&quot;Safe&quot; <a href="http://example.com?x=&amp;y=" rel="nofollow">http:...</a>'
        )


</source>
</class>

<class classid="427" nclones="2" nlines="10" similarity="100">
<source file="django/tests/template_tests/syntax_tests/i18n/test_filters.py.pyindent" startline="41" endline="47" pcid="24993">
        with translation.override('cs'):
            output = self.engine.render_to_string('i18n38_2', {'langcodes': ['it', 'fr']})
        self.assertEqual(
            output,
            'it: Italian/italiano/italsky bidi=False; '
            'fr: French/français/francouzsky bidi=False; '
        )
</source>
<source file="django/tests/template_tests/syntax_tests/i18n/test_get_language_info_list.py.pyindent" startline="40" endline="47" pcid="25015">
        with translation.override('cs'):
            output = self.engine.render_to_string('i18n38_2', {'langcodes': ['it', 'fr']})
        self.assertEqual(
            output,
            'it: Italian/italiano/italsky bidi=False; '
            'fr: French/français/francouzsky bidi=False; '
        )

</source>
</class>

<class classid="428" nclones="2" nlines="12" similarity="83">
<source file="django/tests/template_tests/syntax_tests/i18n/test_get_current_language.py.pyindent" startline="8" endline="14" pcid="24999">
    libraries = {'i18n': 'django.templatetags.i18n'}

    @setup({'template': '{% load i18n %} {% get_current_language %}'})
    def test_no_as_var(self):
        msg = "'get_current_language' requires 'as variable' (got ['get_current_language'])"
        with self.assertRaisesMessage(TemplateSyntaxError, msg):
            self.engine.render_to_string('template')
</source>
<source file="django/tests/template_tests/syntax_tests/i18n/test_get_current_language_bidi.py.pyindent" startline="8" endline="14" pcid="25002">
    libraries = {'i18n': 'django.templatetags.i18n'}

    @setup({'template': '{% load i18n %} {% get_current_language_bidi %}'})
    def test_no_as_var(self):
        msg = "'get_current_language_bidi' requires 'as variable' (got ['get_current_language_bidi'])"
        with self.assertRaisesMessage(TemplateSyntaxError, msg):
            self.engine.render_to_string('template')
</source>
</class>

<class classid="429" nclones="25" nlines="11" similarity="71">
<source file="django/tests/template_tests/syntax_tests/test_basic.py.pyindent" startline="42" endline="50" pcid="25049">
        """
        Fail silently when a variable is not found in the current context
        """
        output = self.engine.render_to_string('basic-syntax04')
        if self.engine.string_if_invalid:
            self.assertEqual(output, 'asINVALIDdf')
        else:
            self.assertEqual(output, 'asdf')

</source>
<source file="django/tests/template_tests/syntax_tests/test_basic.py.pyindent" startline="93" endline="102" pcid="25060">
        """
        Fail silently when a variable's attribute isn't found.
        """
        output = self.engine.render_to_string('basic-syntax11', {'var': SomeClass()})

        if self.engine.string_if_invalid:
            self.assertEqual(output, 'INVALID')
        else:
            self.assertEqual(output, '')

</source>
<source file="django/tests/template_tests/syntax_tests/test_list_index.py.pyindent" startline="30" endline="38" pcid="25673">
        """
        Fail silently when the list index is out of range.
        """
        output = self.engine.render_to_string('list-index03', {'var': None})
        if self.engine.string_if_invalid:
            self.assertEqual(output, 'INVALID')
        else:
            self.assertEqual(output, '')

</source>
<source file="django/tests/template_tests/syntax_tests/test_with.py.pyindent" startline="35" endline="40" pcid="25921">
        output = self.engine.render_to_string('legacywith02', {'dict': {'key': 50}})
        if self.engine.string_if_invalid:
            self.assertEqual(output, 'INVALID50-50-50INVALID')
        else:
            self.assertEqual(output, '50-50-50')

</source>
<source file="django/tests/template_tests/syntax_tests/test_filter_syntax.py.pyindent" startline="183" endline="192" pcid="25287">
        """
        Fail silently for non-callable attribute and dict lookups which
        raise an exception with a "silent_variable_failure" attribute
        """
        output = self.engine.render_to_string('filter-syntax21', {"var": SomeClass()})
        if self.engine.string_if_invalid:
            self.assertEqual(output, "1INVALID2")
        else:
            self.assertEqual(output, "12")

</source>
<source file="django/tests/template_tests/syntax_tests/test_include.py.pyindent" startline="72" endline="77" pcid="25595">
        output = self.engine.render_to_string('include10', {'first': '1'})
        if self.engine.string_if_invalid:
            self.assertEqual(output, 'INVALID --- INVALID')
        else:
            self.assertEqual(output, ' --- ')

</source>
<source file="django/tests/template_tests/syntax_tests/test_filter_syntax.py.pyindent" startline="114" endline="123" pcid="25276">
        """
        Fail silently for methods that raise an exception with a
        `silent_variable_failure` attribute
        """
        output = self.engine.render_to_string('filter-syntax13', {"var": SomeClass()})
        if self.engine.string_if_invalid:
            self.assertEqual(output, "1INVALID2")
        else:
            self.assertEqual(output, "12")

</source>
<source file="django/tests/template_tests/syntax_tests/test_with.py.pyindent" startline="25" endline="30" pcid="25918">
        output = self.engine.render_to_string('with02', {'dict': {'key': 50}})
        if self.engine.string_if_invalid:
            self.assertEqual(output, 'INVALID50-50-50INVALID')
        else:
            self.assertEqual(output, '50-50-50')

</source>
<source file="django/tests/template_tests/syntax_tests/test_list_index.py.pyindent" startline="41" endline="49" pcid="25676">
        """
        Fail silently when variable is a dict without the specified key.
        """
        output = self.engine.render_to_string('list-index04', {'var': {}})
        if self.engine.string_if_invalid:
            self.assertEqual(output, 'INVALID')
        else:
            self.assertEqual(output, '')

</source>
<source file="django/tests/template_tests/syntax_tests/test_filter_syntax.py.pyindent" startline="195" endline="204" pcid="25290">
        """
        Fail silently for non-callable attribute and dict lookups which
        raise an exception with a `silent_variable_failure` attribute
        """
        output = self.engine.render_to_string('filter-syntax22', {"var": SomeClass()})
        if self.engine.string_if_invalid:
            self.assertEqual(output, "1INVALID2")
        else:
            self.assertEqual(output, "12")

</source>
<source file="django/tests/template_tests/syntax_tests/test_basic.py.pyindent" startline="232" endline="237" pcid="25092">
        output = self.engine.render_to_string('basic-syntax28', {'a': SilentGetItemClass()})
        if self.engine.string_if_invalid:
            self.assertEqual(output, 'INVALID')
        else:
            self.assertEqual(output, '')

</source>
<source file="django/tests/template_tests/syntax_tests/test_basic.py.pyindent" startline="150" endline="159" pcid="25076">
        """
        Fail silently when a variable's dictionary key isn't found.
        """
        output = self.engine.render_to_string('basic-syntax19', {"foo": {"bar": "baz"}})

        if self.engine.string_if_invalid:
            self.assertEqual(output, 'INVALID')
        else:
            self.assertEqual(output, '')

</source>
<source file="django/tests/template_tests/syntax_tests/test_basic.py.pyindent" startline="162" endline="171" pcid="25079">
        """
        Fail silently when accessing a non-simple method
        """
        output = self.engine.render_to_string('basic-syntax20', {'var': SomeClass()})

        if self.engine.string_if_invalid:
            self.assertEqual(output, 'INVALID')
        else:
            self.assertEqual(output, '')

</source>
<source file="django/tests/template_tests/syntax_tests/test_include.py.pyindent" startline="80" endline="85" pcid="25598">
        output = self.engine.render_to_string('include11', {'first': '1'})
        if self.engine.string_if_invalid:
            self.assertEqual(output, 'INVALID --- 2')
        else:
            self.assertEqual(output, ' --- 2')

</source>
<source file="django/tests/template_tests/syntax_tests/test_include.py.pyindent" startline="88" endline="93" pcid="25601">
        output = self.engine.render_to_string('include12', {'second': '2'})
        if self.engine.string_if_invalid:
            self.assertEqual(output, '1 --- INVALID')
        else:
            self.assertEqual(output, '1 --- ')

</source>
<source file="django/tests/template_tests/syntax_tests/test_include.py.pyindent" startline="99" endline="104" pcid="25604">
        output = self.engine.render_to_string('include13', {'first': '&'})
        if self.engine.string_if_invalid:
            self.assertEqual(output, '& --- INVALID')
        else:
            self.assertEqual(output, '& --- ')

</source>
<source file="django/tests/template_tests/syntax_tests/test_list_index.py.pyindent" startline="19" endline="27" pcid="25670">
        """
        Fail silently when the list index is out of range.
        """
        output = self.engine.render_to_string('list-index02', {'var': ['first item', 'second item']})
        if self.engine.string_if_invalid:
            self.assertEqual(output, 'INVALID')
        else:
            self.assertEqual(output, '')

</source>
<source file="django/tests/template_tests/syntax_tests/test_include.py.pyindent" startline="112" endline="118" pcid="25607">
        output = self.engine.render_to_string('include14', {'var1': '&'})
        if self.engine.string_if_invalid:
            self.assertEqual(output, '& --- INVALID')
        else:
            self.assertEqual(output, '& --- ')

    # Include syntax errors
</source>
<source file="django/tests/template_tests/syntax_tests/test_invalid_string.py.pyindent" startline="11" endline="16" pcid="25650">
        output = self.engine.render_to_string('invalidstr01')
        if self.engine.string_if_invalid:
            self.assertEqual(output, 'INVALID')
        else:
            self.assertEqual(output, 'Foo')

</source>
<source file="django/tests/template_tests/syntax_tests/test_invalid_string.py.pyindent" startline="19" endline="24" pcid="25653">
        output = self.engine.render_to_string('invalidstr02')
        if self.engine.string_if_invalid:
            self.assertEqual(output, 'INVALID')
        else:
            self.assertEqual(output, '')

</source>
<source file="django/tests/template_tests/syntax_tests/test_invalid_string.py.pyindent" startline="42" endline="47" pcid="25659">
        output = self.engine.render_to_string('invalidstr05')
        if self.engine.string_if_invalid:
            self.assertEqual(output, 'INVALID')
        else:
            self.assertEqual(output, '')

</source>
<source file="django/tests/template_tests/syntax_tests/test_invalid_string.py.pyindent" startline="50" endline="55" pcid="25662">
        output = self.engine.render_to_string('invalidstr06')
        if self.engine.string_if_invalid:
            self.assertEqual(output, 'INVALID')
        else:
            self.assertEqual(output, '')

</source>
<source file="django/tests/template_tests/syntax_tests/test_basic.py.pyindent" startline="240" endline="247" pcid="25095">
        output = self.engine.render_to_string('basic-syntax29', {'a': SilentAttrClass()})
        if self.engine.string_if_invalid:
            self.assertEqual(output, 'INVALID')
        else:
            self.assertEqual(output, '')

    # Something that starts like a number but has an extra lookup works
    # as a lookup.
</source>
<source file="django/tests/template_tests/syntax_tests/test_invalid_string.py.pyindent" startline="58" endline="62" pcid="25665">
        output = self.engine.render_to_string('invalidstr07')
        if self.engine.string_if_invalid:
            self.assertEqual(output, 'INVALID')
        else:
            self.assertEqual(output, '')
</source>
<source file="django/tests/template_tests/syntax_tests/test_numpy.py.pyindent" startline="30" endline="40" pcid="25731">
        """
        Fail silently when the array index is out of range.
        """
        output = self.engine.render_to_string(
            'numpy-array-index02',
            {'var': numpy.array(["first item", "second item"])},
        )
        if self.engine.string_if_invalid:
            self.assertEqual(output, 'INVALID')
        else:
            self.assertEqual(output, '')
</source>
</class>

<class classid="430" nclones="2" nlines="10" similarity="80">
<source file="django/tests/template_tests/syntax_tests/test_if_changed.py.pyindent" startline="203" endline="215" pcid="25536">
        """
        #23516 -- This works as a regression test only if the cached loader
        isn't used. Hence we don't use the @setup decorator.
        """
        engine = Engine(loaders=[
            ('django.template.loaders.locmem.Loader', {
                'template': '{% for x in vars %}{% include "include" %}{% endfor %}',
                'include': '{% ifchanged %}{{ x }}{% endifchanged %}',
            }),
        ])
        output = engine.render_to_string('template', {'vars': [1, 1, 2, 2, 3, 3]})
        self.assertEqual(output, "123")

</source>
<source file="django/tests/template_tests/syntax_tests/test_if_changed.py.pyindent" startline="217" endline="225" pcid="25537">
        """Tests the node state for different IncludeNodes (#27974)."""
        engine = Engine(loaders=[
            ('django.template.loaders.locmem.Loader', {
                'template': '{% for x in vars %}{% include "include" %}{% include "include" %}{% endfor %}',
                'include': '{% ifchanged %}{{ x }}{% endifchanged %}',
            }),
        ])
        output = engine.render_to_string('template', {'vars': [1, 1, 2, 2, 3, 3]})
        self.assertEqual(output, '112233')
</source>
</class>

<class classid="431" nclones="4" nlines="23" similarity="79">
<source file="django/tests/template_tests/test_callables.py.pyindent" startline="14" endline="41" pcid="25977">

        class Doodad:
            def __init__(self, value):
                self.num_calls = 0
                self.value = value

            def __call__(self):
                self.num_calls += 1
                return {"the_value": self.value}

        my_doodad = Doodad(42)
        c = Context({"my_doodad": my_doodad})

        # We can't access ``my_doodad.value`` in the template, because
        # ``my_doodad.__call__`` will be invoked first, yielding a dictionary
        # without a key ``value``.
        t = self.engine.from_string('{{ my_doodad.value }}')
        self.assertEqual(t.render(c), '')

        # We can confirm that the doodad has been called
        self.assertEqual(my_doodad.num_calls, 1)

        # But we can access keys on the dict that's returned
        # by ``__call__``, instead.
        t = self.engine.from_string('{{ my_doodad.the_value }}')
        self.assertEqual(t.render(c), '42')
        self.assertEqual(my_doodad.num_calls, 2)

</source>
<source file="django/tests/template_tests/test_callables.py.pyindent" startline="43" endline="68" pcid="25981">

        class Doodad:
            alters_data = True

            def __init__(self, value):
                self.num_calls = 0
                self.value = value

            def __call__(self):
                self.num_calls += 1
                return {"the_value": self.value}

        my_doodad = Doodad(42)
        c = Context({"my_doodad": my_doodad})

        # Since ``my_doodad.alters_data`` is True, the template system will not
        # try to call our doodad but will use string_if_invalid
        t = self.engine.from_string('{{ my_doodad.value }}')
        self.assertEqual(t.render(c), '')
        t = self.engine.from_string('{{ my_doodad.the_value }}')
        self.assertEqual(t.render(c), '')

        # Double-check that the object was really never called during the
        # template rendering.
        self.assertEqual(my_doodad.num_calls, 0)

</source>
<source file="django/tests/template_tests/test_callables.py.pyindent" startline="70" endline="97" pcid="25985">

        class Doodad:
            do_not_call_in_templates = True

            def __init__(self, value):
                self.num_calls = 0
                self.value = value

            def __call__(self):
                self.num_calls += 1
                return {"the_value": self.value}

        my_doodad = Doodad(42)
        c = Context({"my_doodad": my_doodad})

        # Since ``my_doodad.do_not_call_in_templates`` is True, the template
        # system will not try to call our doodad.  We can access its attributes
        # as normal, and we don't have access to the dict that it returns when
        # called.
        t = self.engine.from_string('{{ my_doodad.value }}')
        self.assertEqual(t.render(c), '42')
        t = self.engine.from_string('{{ my_doodad.the_value }}')
        self.assertEqual(t.render(c), '')

        # Double-check that the object was really never called during the
        # template rendering.
        self.assertEqual(my_doodad.num_calls, 0)

</source>
<source file="django/tests/template_tests/test_callables.py.pyindent" startline="99" endline="125" pcid="25989">
        # If we combine ``alters_data`` and ``do_not_call_in_templates``, the
        # ``alters_data`` attribute will not make any difference in the
        # template system's behavior.

        class Doodad:
            do_not_call_in_templates = True
            alters_data = True

            def __init__(self, value):
                self.num_calls = 0
                self.value = value

            def __call__(self):
                self.num_calls += 1
                return {"the_value": self.value}

        my_doodad = Doodad(42)
        c = Context({"my_doodad": my_doodad})

        t = self.engine.from_string('{{ my_doodad.value }}')
        self.assertEqual(t.render(c), '42')
        t = self.engine.from_string('{{ my_doodad.the_value }}')
        self.assertEqual(t.render(c), '')

        # Double-check that the object was really never called during the
        # template rendering.
        self.assertEqual(my_doodad.num_calls, 0)
</source>
</class>

<class classid="432" nclones="2" nlines="14" similarity="85">
<source file="django/tests/template_tests/test_context.py.pyindent" startline="23" endline="32" pcid="25995">
        c = Context({"a": 1})
        with c.push():
            c['a'] = 2
            self.assertEqual(c['a'], 2)
        self.assertEqual(c['a'], 1)

        with c.push(a=3):
            self.assertEqual(c['a'], 3)
        self.assertEqual(c['a'], 1)

</source>
<source file="django/tests/template_tests/test_context.py.pyindent" startline="34" endline="43" pcid="25998">
        c = Context({"a": 1})
        with c.update({}):
            c['a'] = 2
            self.assertEqual(c['a'], 2)
        self.assertEqual(c['a'], 1)

        with c.update({'a': 3}):
            self.assertEqual(c['a'], 3)
        self.assertEqual(c['a'], 1)

</source>
</class>

<class classid="433" nclones="2" nlines="13" similarity="84">
<source file="django/tests/template_tests/test_context.py.pyindent" startline="57" endline="69" pcid="26005">
        c = Context({'a': 1})
        c.push(Context({'b': 2}))
        c.push(Context({'c': 3, 'd': {'z': '26'}}))
        self.assertEqual(
            c.dicts,
            [
                {'False': False, 'None': None, 'True': True},
                {'a': 1},
                {'b': 2},
                {'c': 3, 'd': {'z': '26'}},
            ]
        )

</source>
<source file="django/tests/template_tests/test_context.py.pyindent" startline="71" endline="83" pcid="26006">
        c = Context({'a': 1})
        c.update(Context({'b': 2}))
        c.update(Context({'c': 3, 'd': {'z': '26'}}))
        self.assertEqual(
            c.dicts,
            [
                {'False': False, 'None': None, 'True': True},
                {'a': 1},
                {'b': 2},
                {'c': 3, 'd': {'z': '26'}},
            ]
        )

</source>
</class>

<class classid="434" nclones="2" nlines="10" similarity="70">
<source file="django/tests/template_tests/test_extends_relative.py.pyindent" startline="50" endline="58" pcid="26102">
        engine = Engine(dirs=[RELATIVE])
        msg = (
            "The relative path '\"./../two.html\"' points outside the file "
            "hierarchy that template 'error_extends.html' is in."
        )
        with self.assertRaisesMessage(TemplateSyntaxError, msg):
            engine.render_to_string('error_extends.html')


</source>
<source file="django/tests/template_tests/test_extends_relative.py.pyindent" startline="74" endline="82" pcid="26107">
        engine = Engine(dirs=[RELATIVE])
        msg = (
            "The relative path '\"./../three.html\"' points outside the file "
            "hierarchy that template 'error_include.html' is in."
        )
        with self.assertRaisesMessage(TemplateSyntaxError, msg):
            engine.render_to_string('error_include.html')


</source>
</class>

<class classid="435" nclones="2" nlines="32" similarity="74">
<source file="django/tests/template_tests/test_response.py.pyindent" startline="162" endline="190" pcid="26282">
        # Create a template response. The context is
        # known to be unpicklable (e.g., a function).
        response = SimpleTemplateResponse('first/test.html', {
            'value': 123,
            'fn': datetime.now,
        })
        with self.assertRaises(ContentNotRenderedError):
            pickle.dumps(response)

        # But if we render the response, we can pickle it.
        response.render()
        pickled_response = pickle.dumps(response)
        unpickled_response = pickle.loads(pickled_response)

        self.assertEqual(unpickled_response.content, response.content)
        self.assertEqual(unpickled_response['content-type'], response['content-type'])
        self.assertEqual(unpickled_response.status_code, response.status_code)

        # ...and the unpickled response doesn't have the
        # template-related attributes, so it can't be re-rendered
        template_attrs = ('template_name', 'context_data', '_post_render_callbacks')
        for attr in template_attrs:
            self.assertFalse(hasattr(unpickled_response, attr))

        # ...and requesting any of those attributes raises an exception
        for attr in template_attrs:
            with self.assertRaises(AttributeError):
                getattr(unpickled_response, attr)

</source>
<source file="django/tests/template_tests/test_response.py.pyindent" startline="273" endline="309" pcid="26299">
        # Create a template response. The context is
        # known to be unpicklable (e.g., a function).
        response = TemplateResponse(
            self.factory.get('/'),
            'first/test.html', {
                'value': 123,
                'fn': datetime.now,
            }
        )
        with self.assertRaises(ContentNotRenderedError):
            pickle.dumps(response)

        # But if we render the response, we can pickle it.
        response.render()
        pickled_response = pickle.dumps(response)
        unpickled_response = pickle.loads(pickled_response)

        self.assertEqual(unpickled_response.content, response.content)
        self.assertEqual(unpickled_response['content-type'], response['content-type'])
        self.assertEqual(unpickled_response.status_code, response.status_code)

        # ...and the unpickled response doesn't have the
        # template-related attributes, so it can't be re-rendered
        template_attrs = (
            'template_name',
            'context_data',
            '_post_render_callbacks',
            '_request',
        )
        for attr in template_attrs:
            self.assertFalse(hasattr(unpickled_response, attr))

        # ...and requesting any of those attributes raises an exception
        for attr in template_attrs:
            with self.assertRaises(AttributeError):
                getattr(unpickled_response, attr)

</source>
</class>

<class classid="436" nclones="2" nlines="14" similarity="100">
<source file="django/tests/template_tests/test_response.py.pyindent" startline="192" endline="203" pcid="26287">
        response = SimpleTemplateResponse('first/test.html', {
            'value': 123,
            'fn': datetime.now,
        })
        with self.assertRaises(ContentNotRenderedError):
            pickle.dumps(response)

        response.render()
        pickled_response = pickle.dumps(response)
        unpickled_response = pickle.loads(pickled_response)
        pickle.dumps(unpickled_response)

</source>
<source file="django/tests/template_tests/test_response.py.pyindent" startline="311" endline="323" pcid="26304">
        response = SimpleTemplateResponse('first/test.html', {
            'value': 123,
            'fn': datetime.now,
        })
        with self.assertRaises(ContentNotRenderedError):
            pickle.dumps(response)

        response.render()
        pickled_response = pickle.dumps(response)
        unpickled_response = pickle.loads(pickled_response)
        pickle.dumps(unpickled_response)


</source>
</class>

<class classid="437" nclones="5" nlines="10" similarity="70">
<source file="django/tests/test_client/tests.py.pyindent" startline="264" endline="268" pcid="26397">
        for code in (307, 308):
            with self.subTest(code=code):
                response = self.client.post('/redirect_view_%s/' % code, data={'value': 'test'}, follow=True)
                self.assertContains(response, 'test is the value')

</source>
<source file="django/tests/test_client/tests.py.pyindent" startline="276" endline="281" pcid="26403">
        data = {'var': 30, 'to': '/get_view/'}
        for code in (307, 308):
            with self.subTest(code=code):
                response = self.client.get('/redirect_view_%s/' % code, data=data, follow=True)
                self.assertContains(response, '30 is the value')

</source>
<source file="django/tests/urlpatterns_reverse/tests.py.pyindent" startline="1054" endline="1059" pcid="27489">
        handler = (empty_view, {})
        for code in [400, 404, 500]:
            with self.subTest(code=code):
                self.assertEqual(self.callable_resolver.resolve_error_handler(code), handler)


</source>
<source file="django/tests/test_client/tests.py.pyindent" startline="270" endline="274" pcid="26400">
        for code in (307, 308):
            with self.subTest(code=code):
                response = self.client.put('/redirect_view_%s/?to=/put_view/' % code, data='a=b', follow=True)
                self.assertContains(response, 'a=b is the body')

</source>
<source file="django/tests/urlpatterns_reverse/tests.py.pyindent" startline="1048" endline="1052" pcid="27486">
        handler = (empty_view, {})
        for code in [400, 404, 500]:
            with self.subTest(code=code):
                self.assertEqual(self.resolver.resolve_error_handler(code), handler)

</source>
</class>

<class classid="438" nclones="2" nlines="10" similarity="90">
<source file="django/tests/test_client/tests.py.pyindent" startline="552" endline="567" pcid="26429">
        "Request a logout after logging in"
        # Log in
        self.client.login(username='testclient', password='password')

        # Request a page that requires a login
        response = self.client.get('/login_protected_view/')
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.context['user'].username, 'testclient')

        # Log out
        self.client.logout()

        # Request a page that requires a login
        response = self.client.get('/login_protected_view/')
        self.assertRedirects(response, '/accounts/login/?next=/login_protected_view/')

</source>
<source file="django/tests/test_client/tests.py.pyindent" startline="569" endline="584" pcid="26430">
        "Request a logout after logging in"
        # Log in
        self.client.force_login(self.u1)

        # Request a page that requires a login
        response = self.client.get('/login_protected_view/')
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.context['user'].username, 'testclient')

        # Log out
        self.client.logout()

        # Request a page that requires a login
        response = self.client.get('/login_protected_view/')
        self.assertRedirects(response, '/accounts/login/?next=/login_protected_view/')

</source>
</class>

<class classid="439" nclones="3" nlines="20" similarity="70">
<source file="django/tests/test_runner/tests.py.pyindent" startline="26" endline="44" pcid="26601">
        raw = [
            ('s1', ('s1_db', ['alpha'])),
            ('s2', ('s2_db', ['bravo'])),
            ('s3', ('s3_db', ['charlie'])),
        ]
        dependencies = {
            'alpha': ['charlie'],
            'bravo': ['charlie'],
        }

        ordered = dependency_ordered(raw, dependencies=dependencies)
        ordered_sigs = [sig for sig, value in ordered]

        self.assertIn('s1', ordered_sigs)
        self.assertIn('s2', ordered_sigs)
        self.assertIn('s3', ordered_sigs)
        self.assertLess(ordered_sigs.index('s3'), ordered_sigs.index('s1'))
        self.assertLess(ordered_sigs.index('s3'), ordered_sigs.index('s2'))

</source>
<source file="django/tests/test_runner/tests.py.pyindent" startline="46" endline="69" pcid="26602">
        raw = [
            ('s1', ('s1_db', ['alpha'])),
            ('s2', ('s2_db', ['bravo'])),
            ('s3', ('s3_db', ['charlie'])),
        ]
        dependencies = {
            'alpha': ['bravo'],
            'bravo': ['charlie'],
        }

        ordered = dependency_ordered(raw, dependencies=dependencies)
        ordered_sigs = [sig for sig, value in ordered]

        self.assertIn('s1', ordered_sigs)
        self.assertIn('s2', ordered_sigs)
        self.assertIn('s3', ordered_sigs)

        # Explicit dependencies
        self.assertLess(ordered_sigs.index('s2'), ordered_sigs.index('s1'))
        self.assertLess(ordered_sigs.index('s3'), ordered_sigs.index('s2'))

        # Implied dependencies
        self.assertLess(ordered_sigs.index('s3'), ordered_sigs.index('s1'))

</source>
<source file="django/tests/test_runner/tests.py.pyindent" startline="71" endline="99" pcid="26603">
        raw = [
            ('s1', ('s1_db', ['alpha'])),
            ('s2', ('s2_db', ['bravo'])),
            ('s3', ('s3_db', ['charlie'])),
            ('s4', ('s4_db', ['delta'])),
        ]
        dependencies = {
            'alpha': ['bravo', 'delta'],
            'bravo': ['charlie'],
            'delta': ['charlie'],
        }

        ordered = dependency_ordered(raw, dependencies=dependencies)
        ordered_sigs = [sig for sig, aliases in ordered]

        self.assertIn('s1', ordered_sigs)
        self.assertIn('s2', ordered_sigs)
        self.assertIn('s3', ordered_sigs)
        self.assertIn('s4', ordered_sigs)

        # Explicit dependencies
        self.assertLess(ordered_sigs.index('s2'), ordered_sigs.index('s1'))
        self.assertLess(ordered_sigs.index('s4'), ordered_sigs.index('s1'))
        self.assertLess(ordered_sigs.index('s3'), ordered_sigs.index('s2'))
        self.assertLess(ordered_sigs.index('s3'), ordered_sigs.index('s4'))

        # Implicit dependencies
        self.assertLess(ordered_sigs.index('s3'), ordered_sigs.index('s1'))

</source>
</class>

<class classid="440" nclones="2" nlines="17" similarity="88">
<source file="django/tests/test_runner/tests.py.pyindent" startline="303" endline="314" pcid="26644">
        tested_connections = db.ConnectionHandler({
            'default': {
                'ENGINE': 'django.db.backends.dummy',
            },
        })
        with mock.patch('django.db.backends.dummy.base.DatabaseWrapper.creation_class') as mocked_db_creation:
            with mock.patch('django.test.utils.connections', new=tested_connections):
                self.runner_instance.setup_databases()
        mocked_db_creation.return_value.create_test_db.assert_called_once_with(
            verbosity=0, autoclobber=False, serialize=True, keepdb=False
        )

</source>
<source file="django/tests/test_runner/tests.py.pyindent" startline="316" endline="329" pcid="26647">
        tested_connections = db.ConnectionHandler({
            'default': {
                'ENGINE': 'django.db.backends.dummy',
                'TEST': {'SERIALIZE': False},
            },
        })
        with mock.patch('django.db.backends.dummy.base.DatabaseWrapper.creation_class') as mocked_db_creation:
            with mock.patch('django.test.utils.connections', new=tested_connections):
                self.runner_instance.setup_databases()
        mocked_db_creation.return_value.create_test_db.assert_called_once_with(
            verbosity=0, autoclobber=False, serialize=False, keepdb=False
        )


</source>
</class>

<class classid="441" nclones="2" nlines="10" similarity="80">
<source file="django/tests/test_runner/test_debug_sql.py.pyindent" startline="34" endline="38" pcid="26666">
        def runTest(self):
            with self.subTest():
                Person.objects.filter(first_name='subtest-fail').count()
                self.fail()

</source>
<source file="django/tests/test_runner/test_debug_sql.py.pyindent" startline="40" endline="44" pcid="26669">
        def runTest(self):
            with self.subTest():
                Person.objects.filter(first_name='subtest-error').count()
                raise Exception

</source>
</class>

<class classid="442" nclones="2" nlines="11" similarity="81">
<source file="django/tests/test_runner/test_debug_sql.py.pyindent" startline="67" endline="72" pcid="26673">
        full_output = self._test_output(1)
        for output in self.expected_outputs:
            self.assertIn(output, full_output)
        for output in self.verbose_expected_outputs:
            self.assertNotIn(output, full_output)

</source>
<source file="django/tests/test_runner/test_debug_sql.py.pyindent" startline="74" endline="79" pcid="26676">
        full_output = self._test_output(2)
        for output in self.expected_outputs:
            self.assertIn(output, full_output)
        for output in self.verbose_expected_outputs:
            self.assertIn(output, full_output)

</source>
</class>

<class classid="443" nclones="2" nlines="12" similarity="75">
<source file="django/tests/test_runner/test_parallel.py.pyindent" startline="23" endline="39" pcid="26718">
    """
    End-to-end tests of the parallel test runner.

    These tests are only meaningful when running tests in parallel using
    the --parallel option, though it doesn't hurt to run them not in
    parallel.
    """

    def test_subtest(self):
        """
        Passing subtests work.
        """
        for i in range(2):
            with self.subTest(index=i):
                self.assertEqual(i, i)


</source>
<source file="django/tests/test_runner/test_parallel.py.pyindent" startline="41" endline="52" pcid="26722">

    # This method name doesn't begin with "test" to prevent test discovery
    # from seeing it.
    def dummy_test(self):
        """
        A dummy test for testing subTest failures.
        """
        for i in range(3):
            with self.subTest(index=i):
                self.assertEqual(i, 1)


</source>
</class>

<class classid="444" nclones="2" nlines="11" similarity="90">
<source file="django/tests/timezones/tests.py.pyindent" startline="109" endline="118" pcid="26815">
        now = datetime.datetime.now()
        past = now - datetime.timedelta(seconds=2)
        future = now + datetime.timedelta(seconds=2)
        Timestamp.objects.create()
        ts = Timestamp.objects.get()
        self.assertLess(past, ts.created)
        self.assertLess(past, ts.updated)
        self.assertGreater(future, ts.updated)
        self.assertGreater(future, ts.updated)

</source>
<source file="django/tests/timezones/tests.py.pyindent" startline="282" endline="291" pcid="26838">
        now = timezone.now()
        past = now - datetime.timedelta(seconds=2)
        future = now + datetime.timedelta(seconds=2)
        Timestamp.objects.create()
        ts = Timestamp.objects.get()
        self.assertLess(past, ts.created)
        self.assertLess(past, ts.updated)
        self.assertGreater(future, ts.updated)
        self.assertGreater(future, ts.updated)

</source>
</class>

<class classid="445" nclones="2" nlines="10" similarity="80">
<source file="django/tests/timezones/tests.py.pyindent" startline="120" endline="128" pcid="26816">
        dt1 = datetime.datetime(2011, 9, 1, 12, 20, 30)
        dt2 = datetime.datetime(2011, 9, 1, 14, 20, 30)
        Event.objects.create(dt=dt1)
        Event.objects.create(dt=dt2)
        self.assertEqual(Event.objects.filter(dt__gte=dt1).count(), 2)
        self.assertEqual(Event.objects.filter(dt__gt=dt1).count(), 1)
        self.assertEqual(Event.objects.filter(dt__gte=dt2).count(), 1)
        self.assertEqual(Event.objects.filter(dt__gt=dt2).count(), 0)

</source>
<source file="django/tests/timezones/tests.py.pyindent" startline="293" endline="301" pcid="26839">
        dt1 = datetime.datetime(2011, 9, 1, 12, 20, 30, tzinfo=EAT)
        dt2 = datetime.datetime(2011, 9, 1, 14, 20, 30, tzinfo=EAT)
        Event.objects.create(dt=dt1)
        Event.objects.create(dt=dt2)
        self.assertEqual(Event.objects.filter(dt__gte=dt1).count(), 2)
        self.assertEqual(Event.objects.filter(dt__gt=dt1).count(), 1)
        self.assertEqual(Event.objects.filter(dt__gte=dt2).count(), 1)
        self.assertEqual(Event.objects.filter(dt__gt=dt2).count(), 0)

</source>
</class>

<class classid="446" nclones="2" nlines="11" similarity="81">
<source file="django/tests/timezones/tests.py.pyindent" startline="130" endline="139" pcid="26817">
        Event.objects.create(dt=datetime.datetime(2011, 1, 1, 1, 30, 0))
        Event.objects.create(dt=datetime.datetime(2011, 1, 1, 4, 30, 0))
        self.assertEqual(Event.objects.filter(dt__year=2011).count(), 2)
        self.assertEqual(Event.objects.filter(dt__month=1).count(), 2)
        self.assertEqual(Event.objects.filter(dt__day=1).count(), 2)
        self.assertEqual(Event.objects.filter(dt__week_day=7).count(), 2)
        self.assertEqual(Event.objects.filter(dt__hour=1).count(), 1)
        self.assertEqual(Event.objects.filter(dt__minute=30).count(), 2)
        self.assertEqual(Event.objects.filter(dt__second=0).count(), 2)

</source>
<source file="django/tests/timezones/tests.py.pyindent" startline="329" endline="338" pcid="26845">
        Event.objects.create(dt=datetime.datetime(2011, 1, 1, 1, 30, 0, tzinfo=EAT))
        Event.objects.create(dt=datetime.datetime(2011, 1, 1, 4, 30, 0, tzinfo=EAT))
        self.assertEqual(Event.objects.filter(dt__year=2011).count(), 2)
        self.assertEqual(Event.objects.filter(dt__month=1).count(), 2)
        self.assertEqual(Event.objects.filter(dt__day=1).count(), 2)
        self.assertEqual(Event.objects.filter(dt__week_day=7).count(), 2)
        self.assertEqual(Event.objects.filter(dt__hour=1).count(), 1)
        self.assertEqual(Event.objects.filter(dt__minute=30).count(), 2)
        self.assertEqual(Event.objects.filter(dt__second=0).count(), 2)

</source>
</class>

<class classid="447" nclones="2" nlines="24" similarity="79">
<source file="django/tests/timezones/tests.py.pyindent" startline="152" endline="175" pcid="26819">
        # Only min and max make sense for datetimes.
        morning = Session.objects.create(name='morning')
        afternoon = Session.objects.create(name='afternoon')
        SessionEvent.objects.create(dt=datetime.datetime(2011, 9, 1, 23, 20, 20), session=afternoon)
        SessionEvent.objects.create(dt=datetime.datetime(2011, 9, 1, 13, 20, 30), session=afternoon)
        SessionEvent.objects.create(dt=datetime.datetime(2011, 9, 1, 3, 20, 40), session=morning)
        morning_min_dt = datetime.datetime(2011, 9, 1, 3, 20, 40)
        afternoon_min_dt = datetime.datetime(2011, 9, 1, 13, 20, 30)
        self.assertQuerysetEqual(
            Session.objects.annotate(dt=Min('events__dt')).order_by('dt'),
            [morning_min_dt, afternoon_min_dt],
            transform=lambda d: d.dt,
        )
        self.assertQuerysetEqual(
            Session.objects.annotate(dt=Min('events__dt')).filter(dt__lt=afternoon_min_dt),
            [morning_min_dt],
            transform=lambda d: d.dt,
        )
        self.assertQuerysetEqual(
            Session.objects.annotate(dt=Min('events__dt')).filter(dt__gte=afternoon_min_dt),
            [afternoon_min_dt],
            transform=lambda d: d.dt,
        )

</source>
<source file="django/tests/timezones/tests.py.pyindent" startline="366" endline="389" pcid="26849">
        # Only min and max make sense for datetimes.
        morning = Session.objects.create(name='morning')
        afternoon = Session.objects.create(name='afternoon')
        SessionEvent.objects.create(dt=datetime.datetime(2011, 9, 1, 23, 20, 20, tzinfo=EAT), session=afternoon)
        SessionEvent.objects.create(dt=datetime.datetime(2011, 9, 1, 13, 20, 30, tzinfo=EAT), session=afternoon)
        SessionEvent.objects.create(dt=datetime.datetime(2011, 9, 1, 3, 20, 40, tzinfo=EAT), session=morning)
        morning_min_dt = datetime.datetime(2011, 9, 1, 3, 20, 40, tzinfo=EAT)
        afternoon_min_dt = datetime.datetime(2011, 9, 1, 13, 20, 30, tzinfo=EAT)
        self.assertQuerysetEqual(
            Session.objects.annotate(dt=Min('events__dt')).order_by('dt'),
            [morning_min_dt, afternoon_min_dt],
            transform=lambda d: d.dt,
        )
        self.assertQuerysetEqual(
            Session.objects.annotate(dt=Min('events__dt')).filter(dt__lt=afternoon_min_dt),
            [morning_min_dt],
            transform=lambda d: d.dt,
        )
        self.assertQuerysetEqual(
            Session.objects.annotate(dt=Min('events__dt')).filter(dt__gte=afternoon_min_dt),
            [afternoon_min_dt],
            transform=lambda d: d.dt,
        )

</source>
</class>

<class classid="448" nclones="2" nlines="10" similarity="70">
<source file="django/tests/timezones/tests.py.pyindent" startline="474" endline="480" pcid="26856">
        dt = datetime.datetime(2011, 9, 1, 13, 20, 30, tzinfo=EAT)
        utc_naive_dt = timezone.make_naive(dt, timezone.utc)
        with connection.cursor() as cursor:
            cursor.execute('INSERT INTO timezones_event (dt) VALUES (%s)', [utc_naive_dt])
        event = Event.objects.get()
        self.assertEqual(event.dt, dt)

</source>
<source file="django/tests/timezones/tests.py.pyindent" startline="491" endline="497" pcid="26860">
        dt = datetime.datetime(2011, 9, 1, 13, 20, 30, tzinfo=EAT)
        utc_naive_dt = timezone.make_naive(dt, timezone.utc)
        Event.objects.create(dt=dt)
        with connection.cursor() as cursor:
            cursor.execute('SELECT dt FROM timezones_event WHERE dt = %s', [utc_naive_dt])
            self.assertEqual(cursor.fetchall()[0][0], utc_naive_dt)

</source>
</class>

<class classid="449" nclones="6" nlines="22" similarity="72">
<source file="django/tests/timezones/tests.py.pyindent" startline="628" endline="650" pcid="26886">
        dt = datetime.datetime(2011, 9, 1, 13, 20, 30)

        data = serializers.serialize('python', [Event(dt=dt)])
        self.assert_python_contains_datetime(data, dt)
        obj = next(serializers.deserialize('python', data)).object
        self.assertEqual(obj.dt, dt)

        data = serializers.serialize('json', [Event(dt=dt)])
        self.assert_json_contains_datetime(data, "2011-09-01T13:20:30")
        obj = next(serializers.deserialize('json', data)).object
        self.assertEqual(obj.dt, dt)

        data = serializers.serialize('xml', [Event(dt=dt)])
        self.assert_xml_contains_datetime(data, "2011-09-01T13:20:30")
        obj = next(serializers.deserialize('xml', data)).object
        self.assertEqual(obj.dt, dt)

        if not isinstance(serializers.get_serializer('yaml'), serializers.BadSerializer):
            data = serializers.serialize('yaml', [Event(dt=dt)])
            self.assert_yaml_contains_datetime(data, "2011-09-01 13:20:30")
            obj = next(serializers.deserialize('yaml', data)).object
            self.assertEqual(obj.dt, dt)

</source>
<source file="django/tests/timezones/tests.py.pyindent" startline="724" endline="746" pcid="26894">
        dt = datetime.datetime(2011, 9, 1, 13, 20, 30, tzinfo=EAT)

        data = serializers.serialize('python', [Event(dt=dt)])
        self.assert_python_contains_datetime(data, dt)
        obj = next(serializers.deserialize('python', data)).object
        self.assertEqual(obj.dt, dt)

        data = serializers.serialize('json', [Event(dt=dt)])
        self.assert_json_contains_datetime(data, "2011-09-01T13:20:30+03:00")
        obj = next(serializers.deserialize('json', data)).object
        self.assertEqual(obj.dt, dt)

        data = serializers.serialize('xml', [Event(dt=dt)])
        self.assert_xml_contains_datetime(data, "2011-09-01T13:20:30+03:00")
        obj = next(serializers.deserialize('xml', data)).object
        self.assertEqual(obj.dt, dt)

        if not isinstance(serializers.get_serializer('yaml'), serializers.BadSerializer):
            data = serializers.serialize('yaml', [Event(dt=dt)])
            self.assert_yaml_contains_datetime(data, "2011-09-01 13:20:30+03:00")
            obj = next(serializers.deserialize('yaml', data)).object
            self.assertEqual(obj.dt.replace(tzinfo=UTC), dt)

</source>
<source file="django/tests/timezones/tests.py.pyindent" startline="748" endline="771" pcid="26896">
        dt = datetime.datetime(2011, 9, 1, 17, 20, 30, tzinfo=ICT)

        data = serializers.serialize('python', [Event(dt=dt)])
        self.assert_python_contains_datetime(data, dt)
        obj = next(serializers.deserialize('python', data)).object
        self.assertEqual(obj.dt, dt)

        data = serializers.serialize('json', [Event(dt=dt)])
        self.assert_json_contains_datetime(data, "2011-09-01T17:20:30+07:00")
        obj = next(serializers.deserialize('json', data)).object
        self.assertEqual(obj.dt, dt)

        data = serializers.serialize('xml', [Event(dt=dt)])
        self.assert_xml_contains_datetime(data, "2011-09-01T17:20:30+07:00")
        obj = next(serializers.deserialize('xml', data)).object
        self.assertEqual(obj.dt, dt)

        if not isinstance(serializers.get_serializer('yaml'), serializers.BadSerializer):
            data = serializers.serialize('yaml', [Event(dt=dt)])
            self.assert_yaml_contains_datetime(data, "2011-09-01 17:20:30+07:00")
            obj = next(serializers.deserialize('yaml', data)).object
            self.assertEqual(obj.dt.replace(tzinfo=UTC), dt)


</source>
<source file="django/tests/timezones/tests.py.pyindent" startline="676" endline="698" pcid="26890">
        dt = datetime.datetime(2011, 9, 1, 17, 20, 30, 405060, tzinfo=ICT)

        data = serializers.serialize('python', [Event(dt=dt)])
        self.assert_python_contains_datetime(data, dt)
        obj = next(serializers.deserialize('python', data)).object
        self.assertEqual(obj.dt, dt)

        data = serializers.serialize('json', [Event(dt=dt)])
        self.assert_json_contains_datetime(data, "2011-09-01T17:20:30.405+07:00")
        obj = next(serializers.deserialize('json', data)).object
        self.assertEqual(obj.dt, dt.replace(microsecond=405000))

        data = serializers.serialize('xml', [Event(dt=dt)])
        self.assert_xml_contains_datetime(data, "2011-09-01T17:20:30.405060+07:00")
        obj = next(serializers.deserialize('xml', data)).object
        self.assertEqual(obj.dt, dt)

        if not isinstance(serializers.get_serializer('yaml'), serializers.BadSerializer):
            data = serializers.serialize('yaml', [Event(dt=dt)])
            self.assert_yaml_contains_datetime(data, "2011-09-01 17:20:30.405060+07:00")
            obj = next(serializers.deserialize('yaml', data)).object
            self.assertEqual(obj.dt.replace(tzinfo=UTC), dt)

</source>
<source file="django/tests/timezones/tests.py.pyindent" startline="652" endline="674" pcid="26888">
        dt = datetime.datetime(2011, 9, 1, 13, 20, 30, 405060)

        data = serializers.serialize('python', [Event(dt=dt)])
        self.assert_python_contains_datetime(data, dt)
        obj = next(serializers.deserialize('python', data)).object
        self.assertEqual(obj.dt, dt)

        data = serializers.serialize('json', [Event(dt=dt)])
        self.assert_json_contains_datetime(data, "2011-09-01T13:20:30.405")
        obj = next(serializers.deserialize('json', data)).object
        self.assertEqual(obj.dt, dt.replace(microsecond=405000))

        data = serializers.serialize('xml', [Event(dt=dt)])
        self.assert_xml_contains_datetime(data, "2011-09-01T13:20:30.405060")
        obj = next(serializers.deserialize('xml', data)).object
        self.assertEqual(obj.dt, dt)

        if not isinstance(serializers.get_serializer('yaml'), serializers.BadSerializer):
            data = serializers.serialize('yaml', [Event(dt=dt)])
            self.assert_yaml_contains_datetime(data, "2011-09-01 13:20:30.405060")
            obj = next(serializers.deserialize('yaml', data)).object
            self.assertEqual(obj.dt, dt)

</source>
<source file="django/tests/timezones/tests.py.pyindent" startline="700" endline="722" pcid="26892">
        dt = datetime.datetime(2011, 9, 1, 10, 20, 30, tzinfo=UTC)

        data = serializers.serialize('python', [Event(dt=dt)])
        self.assert_python_contains_datetime(data, dt)
        obj = next(serializers.deserialize('python', data)).object
        self.assertEqual(obj.dt, dt)

        data = serializers.serialize('json', [Event(dt=dt)])
        self.assert_json_contains_datetime(data, "2011-09-01T10:20:30Z")
        obj = next(serializers.deserialize('json', data)).object
        self.assertEqual(obj.dt, dt)

        data = serializers.serialize('xml', [Event(dt=dt)])
        self.assert_xml_contains_datetime(data, "2011-09-01T10:20:30+00:00")
        obj = next(serializers.deserialize('xml', data)).object
        self.assertEqual(obj.dt, dt)

        if not isinstance(serializers.get_serializer('yaml'), serializers.BadSerializer):
            data = serializers.serialize('yaml', [Event(dt=dt)])
            self.assert_yaml_contains_datetime(data, "2011-09-01 10:20:30+00:00")
            obj = next(serializers.deserialize('yaml', data)).object
            self.assertEqual(obj.dt.replace(tzinfo=UTC), dt)

</source>
</class>

<class classid="450" nclones="2" nlines="11" similarity="81">
<source file="django/tests/timezones/tests.py.pyindent" startline="1077" endline="1086" pcid="26944">
        with timezone.override(pytz.timezone('Europe/Paris')):
            form = EventForm({'dt': '2011-03-27 02:30:00'})
            self.assertFalse(form.is_valid())
            self.assertEqual(
                form.errors['dt'], [
                    "2011-03-27 02:30:00 couldn't be interpreted in time zone "
                    "Europe/Paris; it may be ambiguous or it may not exist."
                ]
            )

</source>
<source file="django/tests/timezones/tests.py.pyindent" startline="1088" endline="1097" pcid="26946">
        with timezone.override(pytz.timezone('Europe/Paris')):
            form = EventForm({'dt': '2011-10-30 02:30:00'})
            self.assertFalse(form.is_valid())
            self.assertEqual(
                form.errors['dt'], [
                    "2011-10-30 02:30:00 couldn't be interpreted in time zone "
                    "Europe/Paris; it may be ambiguous or it may not exist."
                ]
            )

</source>
</class>

<class classid="451" nclones="2" nlines="13" similarity="92">
<source file="django/tests/transactions/tests.py.pyindent" startline="40" endline="47" pcid="26972">
        @transaction.atomic
        def make_reporter():
            Reporter.objects.create(first_name="Haddock")
            raise Exception("Oops, that's his last name")
        with self.assertRaisesMessage(Exception, "Oops"):
            make_reporter()
        self.assertQuerysetEqual(Reporter.objects.all(), [])

</source>
<source file="django/tests/transactions/tests.py.pyindent" startline="56" endline="63" pcid="26977">
        @transaction.atomic()
        def make_reporter():
            Reporter.objects.create(first_name="Haddock")
            raise Exception("Oops, that's his last name")
        with self.assertRaisesMessage(Exception, "Oops"):
            make_reporter()
        self.assertQuerysetEqual(Reporter.objects.all(), [])

</source>
</class>

<class classid="452" nclones="6" nlines="11" similarity="72">
<source file="django/tests/transactions/tests.py.pyindent" startline="70" endline="75" pcid="26982">
        with self.assertRaisesMessage(Exception, "Oops"):
            with transaction.atomic():
                Reporter.objects.create(first_name="Haddock")
                raise Exception("Oops, that's his last name")
        self.assertQuerysetEqual(Reporter.objects.all(), [])

</source>
<source file="django/tests/transactions/tests.py.pyindent" startline="127" endline="132" pcid="27005">
            Reporter.objects.create(first_name="Tintin")
            with self.assertRaisesMessage(Exception, "Oops"):
                with transaction.atomic(savepoint=False):
                    Reporter.objects.create(first_name="Haddock")
                    raise Exception("Oops, that's his last name")
        # Writes in the outer block are rolled back too.
</source>
<source file="django/tests/transactions/tests.py.pyindent" startline="166" endline="170" pcid="27021">
            Reporter.objects.create(first_name="Tintin")
            with self.assertRaisesMessage(Exception, "Oops"):
                with atomic:
                    Reporter.objects.create(first_name="Haddock")
                    raise Exception("Oops, that's his last name")
</source>
<source file="django/tests/transactions/tests.py.pyindent" startline="427" endline="439" pcid="27090">

                # Swallow the intentional error raised in the sub-transaction.
                with self.assertRaisesMessage(Exception, "Oops"):

                    # Start a sub-transaction with a savepoint.
                    with transaction.atomic():
                        sid = connection.savepoint_ids[-1]
                        raise Exception("Oops")

                # This is expected to fail because the savepoint no longer exists.
                connection.savepoint_rollback(sid)


</source>
<source file="django/tests/transactions/tests.py.pyindent" startline="107" endline="112" pcid="26998">
                Reporter.objects.create(last_name="Tintin")
                with self.assertRaisesMessage(Exception, "Oops"):
                    with transaction.atomic():
                        Reporter.objects.create(first_name="Haddock")
                    raise Exception("Oops, that's his last name")
                raise Exception("Oops, that's his first name")
</source>
<source file="django/tests/transactions/tests.py.pyindent" startline="88" endline="92" pcid="26989">
            Reporter.objects.create(first_name="Tintin")
            with self.assertRaisesMessage(Exception, "Oops"):
                with transaction.atomic():
                    Reporter.objects.create(first_name="Haddock")
                    raise Exception("Oops, that's his last name")
</source>
</class>

<class classid="453" nclones="2" nlines="13" similarity="92">
<source file="django/tests/transactions/tests.py.pyindent" startline="77" endline="85" pcid="26985">
        with transaction.atomic():
            Reporter.objects.create(first_name="Tintin")
            with transaction.atomic():
                Reporter.objects.create(first_name="Archibald", last_name="Haddock")
        self.assertQuerysetEqual(
            Reporter.objects.all(),
            ['<Reporter: Archibald Haddock>', '<Reporter: Tintin>']
        )

</source>
<source file="django/tests/transactions/tests.py.pyindent" startline="116" endline="124" pcid="27001">
        with transaction.atomic():
            Reporter.objects.create(first_name="Tintin")
            with transaction.atomic(savepoint=False):
                Reporter.objects.create(first_name="Archibald", last_name="Haddock")
        self.assertQuerysetEqual(
            Reporter.objects.all(),
            ['<Reporter: Archibald Haddock>', '<Reporter: Tintin>']
        )

</source>
</class>

<class classid="454" nclones="12" nlines="16" similarity="70">
<source file="django/tests/transactions/tests.py.pyindent" startline="87" endline="94" pcid="26988">
        with transaction.atomic():
            Reporter.objects.create(first_name="Tintin")
            with self.assertRaisesMessage(Exception, "Oops"):
                with transaction.atomic():
                    Reporter.objects.create(first_name="Haddock")
                    raise Exception("Oops, that's his last name")
        self.assertQuerysetEqual(Reporter.objects.all(), ['<Reporter: Tintin>'])

</source>
<source file="django/tests/transactions/tests.py.pyindent" startline="424" endline="439" pcid="27089">

            # Start a plain transaction.
            with transaction.atomic():

                # Swallow the intentional error raised in the sub-transaction.
                with self.assertRaisesMessage(Exception, "Oops"):

                    # Start a sub-transaction with a savepoint.
                    with transaction.atomic():
                        sid = connection.savepoint_ids[-1]
                        raise Exception("Oops")

                # This is expected to fail because the savepoint no longer exists.
                connection.savepoint_rollback(sid)


</source>
<source file="django/tests/transactions/tests.py.pyindent" startline="164" endline="172" pcid="27020">
        atomic = transaction.atomic()
        with atomic:
            Reporter.objects.create(first_name="Tintin")
            with self.assertRaisesMessage(Exception, "Oops"):
                with atomic:
                    Reporter.objects.create(first_name="Haddock")
                    raise Exception("Oops, that's his last name")
        self.assertQuerysetEqual(Reporter.objects.all(), ['<Reporter: Tintin>'])

</source>
<source file="django/tests/transactions/tests.py.pyindent" startline="126" endline="134" pcid="27004">
        with transaction.atomic():
            Reporter.objects.create(first_name="Tintin")
            with self.assertRaisesMessage(Exception, "Oops"):
                with transaction.atomic(savepoint=False):
                    Reporter.objects.create(first_name="Haddock")
                    raise Exception("Oops, that's his last name")
        # Writes in the outer block are rolled back too.
        self.assertQuerysetEqual(Reporter.objects.all(), [])

</source>
<source file="django/tests/transactions/tests.py.pyindent" startline="106" endline="112" pcid="26997">
            with transaction.atomic():
                Reporter.objects.create(last_name="Tintin")
                with self.assertRaisesMessage(Exception, "Oops"):
                    with transaction.atomic():
                        Reporter.objects.create(first_name="Haddock")
                    raise Exception("Oops, that's his last name")
                raise Exception("Oops, that's his first name")
</source>
<source file="django/tests/transactions/tests.py.pyindent" startline="146" endline="152" pcid="27013">
            with transaction.atomic():
                Reporter.objects.create(last_name="Tintin")
                with self.assertRaisesMessage(Exception, "Oops"):
                    with transaction.atomic(savepoint=False):
                        Reporter.objects.create(first_name="Haddock")
                    raise Exception("Oops, that's his last name")
                raise Exception("Oops, that's his first name")
</source>
<source file="django/tests/transactions/tests.py.pyindent" startline="184" endline="194" pcid="27028">
        atomic = transaction.atomic()
        with self.assertRaisesMessage(Exception, "Oops"):
            with atomic:
                Reporter.objects.create(last_name="Tintin")
                with self.assertRaisesMessage(Exception, "Oops"):
                    with atomic:
                        Reporter.objects.create(first_name="Haddock")
                    raise Exception("Oops, that's his last name")
                raise Exception("Oops, that's his first name")
        self.assertQuerysetEqual(Reporter.objects.all(), [])

</source>
<source file="django/tests/transactions/tests.py.pyindent" startline="145" endline="154" pcid="27012">
        with self.assertRaisesMessage(Exception, "Oops"):
            with transaction.atomic():
                Reporter.objects.create(last_name="Tintin")
                with self.assertRaisesMessage(Exception, "Oops"):
                    with transaction.atomic(savepoint=False):
                        Reporter.objects.create(first_name="Haddock")
                    raise Exception("Oops, that's his last name")
                raise Exception("Oops, that's his first name")
        self.assertQuerysetEqual(Reporter.objects.all(), [])

</source>
<source file="django/tests/transactions/tests.py.pyindent" startline="174" endline="182" pcid="27024">
        atomic = transaction.atomic()
        with self.assertRaisesMessage(Exception, "Oops"):
            with atomic:
                Reporter.objects.create(last_name="Tintin")
                with atomic:
                    Reporter.objects.create(last_name="Haddock")
                raise Exception("Oops, that's his first name")
        self.assertQuerysetEqual(Reporter.objects.all(), [])

</source>
<source file="django/tests/transactions/tests.py.pyindent" startline="105" endline="114" pcid="26996">
        with self.assertRaisesMessage(Exception, "Oops"):
            with transaction.atomic():
                Reporter.objects.create(last_name="Tintin")
                with self.assertRaisesMessage(Exception, "Oops"):
                    with transaction.atomic():
                        Reporter.objects.create(first_name="Haddock")
                    raise Exception("Oops, that's his last name")
                raise Exception("Oops, that's his first name")
        self.assertQuerysetEqual(Reporter.objects.all(), [])

</source>
<source file="django/tests/transactions/tests.py.pyindent" startline="136" endline="143" pcid="27008">
        with self.assertRaisesMessage(Exception, "Oops"):
            with transaction.atomic():
                Reporter.objects.create(last_name="Tintin")
                with transaction.atomic(savepoint=False):
                    Reporter.objects.create(last_name="Haddock")
                raise Exception("Oops, that's his first name")
        self.assertQuerysetEqual(Reporter.objects.all(), [])

</source>
<source file="django/tests/transactions/tests.py.pyindent" startline="96" endline="103" pcid="26992">
        with self.assertRaisesMessage(Exception, "Oops"):
            with transaction.atomic():
                Reporter.objects.create(last_name="Tintin")
                with transaction.atomic():
                    Reporter.objects.create(last_name="Haddock")
                raise Exception("Oops, that's his first name")
        self.assertQuerysetEqual(Reporter.objects.all(), [])

</source>
</class>

<class classid="455" nclones="4" nlines="11" similarity="72">
<source file="django/tests/transactions/tests.py.pyindent" startline="97" endline="101" pcid="26993">
            with transaction.atomic():
                Reporter.objects.create(last_name="Tintin")
                with transaction.atomic():
                    Reporter.objects.create(last_name="Haddock")
                raise Exception("Oops, that's his first name")
</source>
<source file="django/tests/transaction_hooks/tests.py.pyindent" startline="90" endline="93" pcid="27127">
            with transaction.atomic():
                with transaction.atomic():
                    self.do(1)
                raise ForcedError()
</source>
<source file="django/tests/transaction_hooks/tests.py.pyindent" startline="102" endline="105" pcid="27133">
                with transaction.atomic():
                    with transaction.atomic():
                        self.do(1)
                    raise ForcedError()
</source>
<source file="django/tests/transaction_hooks/tests.py.pyindent" startline="61" endline="67" pcid="27116">
        with transaction.atomic():
            with transaction.atomic():
                self.do(1)
                self.assertNotified([])
            self.assertNotified([])
        self.assertDone([1])

</source>
</class>

<class classid="456" nclones="2" nlines="26" similarity="77">
<source file="django/tests/transactions/tests.py.pyindent" startline="255" endline="277" pcid="27047">
        with transaction.atomic():
            Reporter.objects.create(first_name="Tintin")
            with transaction.atomic(savepoint=False):
                Reporter.objects.create(first_name="Archibald", last_name="Haddock")
                with self.assertRaisesMessage(Exception, "Oops"):
                    with transaction.atomic(savepoint=False):
                        Reporter.objects.create(first_name="Calculus")
                        raise Exception("Oops, that's his last name")
                # The third insert couldn't be roll back. Temporarily mark the
                # connection as not needing rollback to check it.
                self.assertTrue(transaction.get_rollback())
                transaction.set_rollback(False)
                self.assertEqual(Reporter.objects.count(), 3)
                transaction.set_rollback(True)
            # The second insert couldn't be roll back. Temporarily mark the
            # connection as not needing rollback to check it.
            self.assertTrue(transaction.get_rollback())
            transaction.set_rollback(False)
            self.assertEqual(Reporter.objects.count(), 3)
            transaction.set_rollback(True)
        # The first block has a savepoint and must roll back.
        self.assertQuerysetEqual(Reporter.objects.all(), [])

</source>
<source file="django/tests/transactions/tests.py.pyindent" startline="279" endline="297" pcid="27052">
        with transaction.atomic():
            Reporter.objects.create(first_name="Tintin")
            with transaction.atomic():
                Reporter.objects.create(first_name="Archibald", last_name="Haddock")
                with self.assertRaisesMessage(Exception, "Oops"):
                    with transaction.atomic(savepoint=False):
                        Reporter.objects.create(first_name="Calculus")
                        raise Exception("Oops, that's his last name")
                # The third insert couldn't be roll back. Temporarily mark the
                # connection as not needing rollback to check it.
                self.assertTrue(transaction.get_rollback())
                transaction.set_rollback(False)
                self.assertEqual(Reporter.objects.count(), 3)
                transaction.set_rollback(True)
            # The second block has a savepoint and must roll back.
            self.assertEqual(Reporter.objects.count(), 1)
        self.assertQuerysetEqual(Reporter.objects.all(), ['<Reporter: Tintin>'])


</source>
</class>

<class classid="457" nclones="12" nlines="18" similarity="70">
<source file="django/tests/transaction_hooks/tests.py.pyindent" startline="51" endline="59" pcid="27112">
        try:
            with transaction.atomic():
                self.do(1)
                raise ForcedError()
        except ForcedError:
            pass

        self.assertDone([])

</source>
<source file="django/tests/transaction_hooks/tests.py.pyindent" startline="126" endline="133" pcid="27144">
            with transaction.atomic():
                self.do(1)
                try:
                    with transaction.atomic():
                        raise ForcedError()
                except ForcedError:
                    pass

</source>
<source file="django/tests/transaction_hooks/tests.py.pyindent" startline="88" endline="98" pcid="27126">
        """If outer transaction fails, no hooks from within it run."""
        try:
            with transaction.atomic():
                with transaction.atomic():
                    self.do(1)
                raise ForcedError()
        except ForcedError:
            pass

        self.assertDone([])

</source>
<source file="django/tests/transaction_hooks/tests.py.pyindent" startline="101" endline="109" pcid="27132">
            try:
                with transaction.atomic():
                    with transaction.atomic():
                        self.do(1)
                    raise ForcedError()
            except ForcedError:
                pass
            self.do(2)

</source>
<source file="django/tests/transaction_hooks/tests.py.pyindent" startline="154" endline="165" pcid="27155">
        try:
            with transaction.atomic():
                self.do(1)
                raise ForcedError()
        except ForcedError:
            pass

        with transaction.atomic():
            self.do(2)

        self.assertDone([2])

</source>
<source file="django/tests/transaction_hooks/tests.py.pyindent" startline="114" endline="121" pcid="27138">
            with transaction.atomic():
                self.do(1)
                try:
                    with transaction.atomic(savepoint=False):
                        raise ForcedError()
                except ForcedError:
                    pass

</source>
<source file="django/tests/transaction_hooks/tests.py.pyindent" startline="180" endline="190" pcid="27163">
        try:
            with transaction.atomic():
                transaction.on_commit(lambda: self.notify('error'))
        except ForcedError:
            pass

        with transaction.atomic():
            self.do(1)

        self.assertDone([1])

</source>
<source file="django/tests/transaction_hooks/tests.py.pyindent" startline="100" endline="111" pcid="27131">
        with transaction.atomic():
            try:
                with transaction.atomic():
                    with transaction.atomic():
                        self.do(1)
                    raise ForcedError()
            except ForcedError:
                pass
            self.do(2)

        self.assertDone([2])

</source>
<source file="django/tests/transaction_hooks/tests.py.pyindent" startline="113" endline="123" pcid="27137">
        with transaction.atomic():
            with transaction.atomic():
                self.do(1)
                try:
                    with transaction.atomic(savepoint=False):
                        raise ForcedError()
                except ForcedError:
                    pass

        self.assertDone([])

</source>
<source file="django/tests/transaction_hooks/tests.py.pyindent" startline="70" endline="84" pcid="27120">
            # one successful savepoint
            with transaction.atomic():
                self.do(1)
            # one failed savepoint
            try:
                with transaction.atomic():
                    self.do(2)
                    raise ForcedError()
            except ForcedError:
                pass
            # another successful savepoint
            with transaction.atomic():
                self.do(3)

        # only hooks registered during successful savepoints execute
</source>
<source file="django/tests/transaction_hooks/tests.py.pyindent" startline="125" endline="135" pcid="27143">
        with transaction.atomic():
            with transaction.atomic():
                self.do(1)
                try:
                    with transaction.atomic():
                        raise ForcedError()
                except ForcedError:
                    pass

        self.assertDone([1])

</source>
<source file="django/tests/transaction_hooks/tests.py.pyindent" startline="69" endline="86" pcid="27119">
        with transaction.atomic():
            # one successful savepoint
            with transaction.atomic():
                self.do(1)
            # one failed savepoint
            try:
                with transaction.atomic():
                    self.do(2)
                    raise ForcedError()
            except ForcedError:
                pass
            # another successful savepoint
            with transaction.atomic():
                self.do(3)

        # only hooks registered during successful savepoints execute
        self.assertDone([1, 3])

</source>
</class>

<class classid="458" nclones="3" nlines="12" similarity="75">
<source file="django/tests/transaction_hooks/tests.py.pyindent" startline="137" endline="144" pcid="27149">
        with transaction.atomic():
            self.do(1)
            with transaction.atomic():
                self.do(2)
            self.do(3)

        self.assertDone([1, 2, 3])

</source>
<source file="django/tests/transaction_hooks/tests.py.pyindent" startline="146" endline="152" pcid="27152">
        with transaction.atomic():
            self.do(1)
        with transaction.atomic():
            self.do(2)

        self.assertDone([1, 2])  # not [1, 1, 2]

</source>
<source file="django/tests/transaction_hooks/tests.py.pyindent" startline="168" endline="178" pcid="27160">
        with transaction.atomic():
            self.do(1)
            connection.close()

        connection.connect()

        with transaction.atomic():
            self.do(2)

        self.assertDone([2])

</source>
</class>

<class classid="459" nclones="6" nlines="12" similarity="71">
<source file="django/tests/unmanaged_models/models.py.pyindent" startline="12" endline="21" pcid="27184">
    f_a = models.CharField(max_length=10, db_index=True)
    f_b = models.IntegerField()

    class Meta:
        db_table = 'a01'

    def __str__(self):
        return self.f_a


</source>
<source file="django/tests/unmanaged_models/models.py.pyindent" startline="53" endline="62" pcid="27193">
    f_a = models.CharField(max_length=10, db_index=True)

    class Meta:
        db_table = 'a01'
        managed = False

    def __str__(self):
        return self.f_a


</source>
<source file="django/tests/unmanaged_models/models.py.pyindent" startline="23" endline="35" pcid="27187">
    fk_a = models.ForeignKey(A01, models.CASCADE)
    f_a = models.CharField(max_length=10, db_index=True)
    f_b = models.IntegerField()

    class Meta:
        db_table = 'b01'
        # 'managed' is True by default. This tests we can set it explicitly.
        managed = True

    def __str__(self):
        return self.f_a


</source>
<source file="django/tests/unmanaged_models/models.py.pyindent" startline="37" endline="51" pcid="27190">
    mm_a = models.ManyToManyField(A01, db_table='d01')
    f_a = models.CharField(max_length=10, db_index=True)
    f_b = models.IntegerField()

    class Meta:
        db_table = 'c01'

    def __str__(self):
        return self.f_a

# All of these models use the same tables as the previous set (they are shadows
# of possibly a subset of the columns). There should be no creation errors,
# since we have told Django they aren't managed by Django.


</source>
<source file="django/tests/unmanaged_models/models.py.pyindent" startline="79" endline="90" pcid="27199">
    mm_a = models.ManyToManyField(A02, through="Intermediate")
    f_a = models.CharField(max_length=10, db_index=True)
    f_b = models.IntegerField()

    class Meta:
        db_table = 'c01'
        managed = False

    def __str__(self):
        return self.f_a


</source>
<source file="django/tests/unmanaged_models/models.py.pyindent" startline="64" endline="77" pcid="27196">
    class Meta:
        db_table = 'b01'
        managed = False

    fk_a = models.ForeignKey(A02, models.CASCADE)
    f_a = models.CharField(max_length=10, db_index=True)
    f_b = models.IntegerField()

    def __str__(self):
        return self.f_a


# To re-use the many-to-many intermediate table, we need to manually set up
# things up.
</source>
</class>

<class classid="460" nclones="2" nlines="14" similarity="85">
<source file="django/tests/update_only_fields/tests.py.pyindent" startline="23" endline="36" pcid="27262">
        s = Person.objects.create(name='Sara', gender='F', pid=22)
        self.assertEqual(s.gender, 'F')

        s1 = Person.objects.defer("gender", "pid").get(pk=s.pk)
        s1.name = "Emily"
        s1.gender = "M"

        with self.assertNumQueries(1):
            s1.save()

        s2 = Person.objects.get(pk=s1.pk)
        self.assertEqual(s2.name, "Emily")
        self.assertEqual(s2.gender, "M")

</source>
<source file="django/tests/update_only_fields/tests.py.pyindent" startline="38" endline="51" pcid="27264">
        s = Person.objects.create(name='Sara', gender='F')
        self.assertEqual(s.gender, 'F')

        s1 = Person.objects.only('name').get(pk=s.pk)
        s1.name = "Emily"
        s1.gender = "M"

        with self.assertNumQueries(1):
            s1.save()

        s2 = Person.objects.get(pk=s1.pk)
        self.assertEqual(s2.name, "Emily")
        self.assertEqual(s2.gender, "M")

</source>
</class>

<class classid="461" nclones="2" nlines="10" similarity="90">
<source file="django/tests/urlpatterns_reverse/middleware.py.pyindent" startline="29" endline="34" pcid="27323">
    def process_view(self, *args, **kwargs):
        def stream():
            yield reverse('inner')
        return StreamingHttpResponse(stream())


</source>
<source file="django/tests/urlpatterns_reverse/middleware.py.pyindent" startline="36" endline="39" pcid="27326">
    def process_view(self, *args, **kwargs):
        def stream():
            yield reverse('outer')
        return StreamingHttpResponse(stream())
</source>
</class>

<class classid="462" nclones="2" nlines="17" similarity="82">
<source file="django/tests/urlpatterns_reverse/tests.py.pyindent" startline="614" endline="627" pcid="27408">
        """
        Names deployed via dynamic URL objects that require namespaces can't
        be resolved.
        """
        test_urls = [
            ('urlobject-view', [], {}),
            ('urlobject-view', [37, 42], {}),
            ('urlobject-view', [], {'arg1': 42, 'arg2': 37}),
        ]
        for name, args, kwargs in test_urls:
            with self.subTest(name=name, args=args, kwargs=kwargs):
                with self.assertRaises(NoReverseMatch):
                    reverse(name, args=args, kwargs=kwargs)

</source>
<source file="django/tests/urlpatterns_reverse/tests.py.pyindent" startline="629" endline="642" pcid="27412">
        """
        Names deployed via dynamic URL objects that require namespaces can't
        be resolved.
        """
        test_urls = [
            ('inner-nothing', [], {}),
            ('inner-nothing', [37, 42], {}),
            ('inner-nothing', [], {'arg1': 42, 'arg2': 37}),
        ]
        for name, args, kwargs in test_urls:
            with self.subTest(name=name, args=args, kwargs=kwargs):
                with self.assertRaises(NoReverseMatch):
                    reverse(name, args=args, kwargs=kwargs)

</source>
</class>

<class classid="463" nclones="9" nlines="15" similarity="73">
<source file="django/tests/urlpatterns_reverse/tests.py.pyindent" startline="655" endline="665" pcid="27420">
        """Normal lookups work as expected."""
        test_urls = [
            ('normal-view', [], {}, '/normal/'),
            ('normal-view', [37, 42], {}, '/normal/37/42/'),
            ('normal-view', [], {'arg1': 42, 'arg2': 37}, '/normal/42/37/'),
            ('special-view', [], {}, '/+%5C$*/'),
        ]
        for name, args, kwargs, expected in test_urls:
            with self.subTest(name=name, args=args, kwargs=kwargs):
                self.assertEqual(reverse(name, args=args, kwargs=kwargs), expected)

</source>
<source file="django/tests/urlpatterns_reverse/tests.py.pyindent" startline="736" endline="746" pcid="27438">
        """Namespaces can be applied to include()'d urlpatterns."""
        test_urls = [
            ('inc-ns1:inc-normal-view', [], {}, '/ns-included1/normal/'),
            ('inc-ns1:inc-normal-view', [37, 42], {}, '/ns-included1/normal/37/42/'),
            ('inc-ns1:inc-normal-view', [], {'arg1': 42, 'arg2': 37}, '/ns-included1/normal/42/37/'),
            ('inc-ns1:inc-special-view', [], {}, '/ns-included1/+%5C$*/'),
        ]
        for name, args, kwargs, expected in test_urls:
            with self.subTest(name=name, args=args, kwargs=kwargs):
                self.assertEqual(reverse(name, args=args, kwargs=kwargs), expected)

</source>
<source file="django/tests/urlpatterns_reverse/tests.py.pyindent" startline="748" endline="761" pcid="27441">
        """
        Namespaces can be applied to include()'d urlpatterns that set an
        app_name attribute.
        """
        test_urls = [
            ('app-ns1:inc-normal-view', [], {}, '/app-included1/normal/'),
            ('app-ns1:inc-normal-view', [37, 42], {}, '/app-included1/normal/37/42/'),
            ('app-ns1:inc-normal-view', [], {'arg1': 42, 'arg2': 37}, '/app-included1/normal/42/37/'),
            ('app-ns1:inc-special-view', [], {}, '/app-included1/+%5C$*/'),
        ]
        for name, args, kwargs, expected in test_urls:
            with self.subTest(name=name, args=args, kwargs=kwargs):
                self.assertEqual(reverse(name, args=args, kwargs=kwargs), expected)

</source>
<source file="django/tests/urlpatterns_reverse/tests.py.pyindent" startline="876" endline="886" pcid="27465">
        """Namespace prefixes can capture variables."""
        test_urls = [
            ('inc-ns5:inner-nothing', [], {'outer': '70'}, '/inc70/'),
            ('inc-ns5:inner-extra', [], {'extra': 'foobar', 'outer': '78'}, '/inc78/extra/foobar/'),
            ('inc-ns5:inner-nothing', ['70'], {}, '/inc70/'),
            ('inc-ns5:inner-extra', ['78', 'foobar'], {}, '/inc78/extra/foobar/'),
        ]
        for name, args, kwargs, expected in test_urls:
            with self.subTest(name=name, args=args, kwargs=kwargs):
                self.assertEqual(reverse(name, args=args, kwargs=kwargs), expected)

</source>
<source file="django/tests/urlpatterns_reverse/tests.py.pyindent" startline="819" endline="829" pcid="27453">
        """A default application namespace can be used for lookup."""
        test_urls = [
            ('testapp:urlobject-view', [], {}, '/default/inner/'),
            ('testapp:urlobject-view', [37, 42], {}, '/default/inner/37/42/'),
            ('testapp:urlobject-view', [], {'arg1': 42, 'arg2': 37}, '/default/inner/42/37/'),
            ('testapp:urlobject-special-view', [], {}, '/default/inner/+%5C$*/'),
        ]
        for name, args, kwargs, expected in test_urls:
            with self.subTest(name=name, args=args, kwargs=kwargs):
                self.assertEqual(reverse(name, args=args, kwargs=kwargs), expected)

</source>
<source file="django/tests/urlpatterns_reverse/tests.py.pyindent" startline="706" endline="719" pcid="27432">
        """
        Namespace defaults to app_name when including a (pattern, app_name)
        2-tuple.
        """
        test_urls = [
            ('newapp:urlobject-view', [], {}, '/new-default/inner/'),
            ('newapp:urlobject-view', [37, 42], {}, '/new-default/inner/37/42/'),
            ('newapp:urlobject-view', [], {'arg1': 42, 'arg2': 37}, '/new-default/inner/42/37/'),
            ('newapp:urlobject-special-view', [], {}, '/new-default/inner/+%5C$*/'),
        ]
        for name, args, kwargs, expected in test_urls:
            with self.subTest(name=name, args=args, kwargs=kwargs):
                self.assertEqual(reverse(name, args=args, kwargs=kwargs), expected)

</source>
<source file="django/tests/urlpatterns_reverse/tests.py.pyindent" startline="691" endline="704" pcid="27429">
        """
        Dynamic URL objects can return a (pattern, app_name) 2-tuple, and
        include() can set the namespace.
        """
        test_urls = [
            ('new-ns1:urlobject-view', [], {}, '/newapp1/inner/'),
            ('new-ns1:urlobject-view', [37, 42], {}, '/newapp1/inner/37/42/'),
            ('new-ns1:urlobject-view', [], {'arg1': 42, 'arg2': 37}, '/newapp1/inner/42/37/'),
            ('new-ns1:urlobject-special-view', [], {}, '/newapp1/inner/+%5C$*/'),
        ]
        for name, args, kwargs, expected in test_urls:
            with self.subTest(name=name, args=args, kwargs=kwargs):
                self.assertEqual(reverse(name, args=args, kwargs=kwargs), expected)

</source>
<source file="django/tests/urlpatterns_reverse/tests.py.pyindent" startline="667" endline="677" pcid="27423">
        """Normal lookups work on names included from other patterns."""
        test_urls = [
            ('included_namespace_urls:inc-normal-view', [], {}, '/included/normal/'),
            ('included_namespace_urls:inc-normal-view', [37, 42], {}, '/included/normal/37/42/'),
            ('included_namespace_urls:inc-normal-view', [], {'arg1': 42, 'arg2': 37}, '/included/normal/42/37/'),
            ('included_namespace_urls:inc-special-view', [], {}, '/included/+%5C$*/'),
        ]
        for name, args, kwargs, expected in test_urls:
            with self.subTest(name=name, args=args, kwargs=kwargs):
                self.assertEqual(reverse(name, args=args, kwargs=kwargs), expected)

</source>
<source file="django/tests/urlpatterns_reverse/tests.py.pyindent" startline="679" endline="689" pcid="27426">
        """Dynamic URL objects can be found using a namespace."""
        test_urls = [
            ('test-ns1:urlobject-view', [], {}, '/test1/inner/'),
            ('test-ns1:urlobject-view', [37, 42], {}, '/test1/inner/37/42/'),
            ('test-ns1:urlobject-view', [], {'arg1': 42, 'arg2': 37}, '/test1/inner/42/37/'),
            ('test-ns1:urlobject-special-view', [], {}, '/test1/inner/+%5C$*/'),
        ]
        for name, args, kwargs, expected in test_urls:
            with self.subTest(name=name, args=args, kwargs=kwargs):
                self.assertEqual(reverse(name, args=args, kwargs=kwargs), expected)

</source>
</class>

<class classid="464" nclones="3" nlines="18" similarity="72">
<source file="django/tests/urlpatterns_reverse/tests.py.pyindent" startline="721" endline="734" pcid="27435">
        """Namespaces can be installed anywhere in the URL pattern tree."""
        test_urls = [
            ('included_namespace_urls:test-ns3:urlobject-view', [], {}, '/included/test3/inner/'),
            ('included_namespace_urls:test-ns3:urlobject-view', [37, 42], {}, '/included/test3/inner/37/42/'),
            (
                'included_namespace_urls:test-ns3:urlobject-view', [], {'arg1': 42, 'arg2': 37},
                '/included/test3/inner/42/37/',
            ),
            ('included_namespace_urls:test-ns3:urlobject-special-view', [], {}, '/included/test3/inner/+%5C$*/'),
        ]
        for name, args, kwargs, expected in test_urls:
            with self.subTest(name=name, args=args, kwargs=kwargs):
                self.assertEqual(reverse(name, args=args, kwargs=kwargs), expected)

</source>
<source file="django/tests/urlpatterns_reverse/tests.py.pyindent" startline="862" endline="874" pcid="27462">
        test_urls = [
            ('special:included_namespace_urls:inc-normal-view', [], {}, '/+%5C$*/included/normal/'),
            ('special:included_namespace_urls:inc-normal-view', [37, 42], {}, '/+%5C$*/included/normal/37/42/'),
            (
                'special:included_namespace_urls:inc-normal-view', [], {'arg1': 42, 'arg2': 37},
                '/+%5C$*/included/normal/42/37/',
            ),
            ('special:included_namespace_urls:inc-special-view', [], {}, '/+%5C$*/included/+%5C$*/'),
        ]
        for name, args, kwargs, expected in test_urls:
            with self.subTest(name=name, args=args, kwargs=kwargs):
                self.assertEqual(reverse(name, args=args, kwargs=kwargs), expected)

</source>
<source file="django/tests/urlpatterns_reverse/tests.py.pyindent" startline="780" endline="793" pcid="27447">
        """Namespaces can be embedded."""
        test_urls = [
            ('inc-ns1:test-ns3:urlobject-view', [], {}, '/ns-included1/test3/inner/'),
            ('inc-ns1:test-ns3:urlobject-view', [37, 42], {}, '/ns-included1/test3/inner/37/42/'),
            (
                'inc-ns1:test-ns3:urlobject-view', [], {'arg1': 42, 'arg2': 37},
                '/ns-included1/test3/inner/42/37/',
            ),
            ('inc-ns1:test-ns3:urlobject-special-view', [], {}, '/ns-included1/test3/inner/+%5C$*/'),
        ]
        for name, args, kwargs, expected in test_urls:
            with self.subTest(name=name, args=args, kwargs=kwargs):
                self.assertEqual(reverse(name, args=args, kwargs=kwargs), expected)

</source>
</class>

<class classid="465" nclones="4" nlines="22" similarity="77">
<source file="django/tests/utils_tests/test_duration.py.pyindent" startline="11" endline="28" pcid="27762">

    def test_simple(self):
        duration = datetime.timedelta(hours=1, minutes=3, seconds=5)
        self.assertEqual(duration_string(duration), '01:03:05')

    def test_days(self):
        duration = datetime.timedelta(days=1, hours=1, minutes=3, seconds=5)
        self.assertEqual(duration_string(duration), '1 01:03:05')

    def test_microseconds(self):
        duration = datetime.timedelta(hours=1, minutes=3, seconds=5, microseconds=12345)
        self.assertEqual(duration_string(duration), '01:03:05.012345')

    def test_negative(self):
        duration = datetime.timedelta(days=-1, hours=1, minutes=3, seconds=5)
        self.assertEqual(duration_string(duration), '-1 01:03:05')


</source>
<source file="django/tests/utils_tests/test_duration.py.pyindent" startline="30" endline="47" pcid="27767">

    def test_simple(self):
        duration = datetime.timedelta(hours=1, minutes=3, seconds=5)
        self.assertEqual(parse_duration(duration_string(duration)), duration)

    def test_days(self):
        duration = datetime.timedelta(days=1, hours=1, minutes=3, seconds=5)
        self.assertEqual(parse_duration(duration_string(duration)), duration)

    def test_microseconds(self):
        duration = datetime.timedelta(hours=1, minutes=3, seconds=5, microseconds=12345)
        self.assertEqual(parse_duration(duration_string(duration)), duration)

    def test_negative(self):
        duration = datetime.timedelta(days=-1, hours=1, minutes=3, seconds=5)
        self.assertEqual(parse_duration(duration_string(duration)), duration)


</source>
<source file="django/tests/utils_tests/test_duration.py.pyindent" startline="49" endline="66" pcid="27772">

    def test_simple(self):
        duration = datetime.timedelta(hours=1, minutes=3, seconds=5)
        self.assertEqual(duration_iso_string(duration), 'P0DT01H03M05S')

    def test_days(self):
        duration = datetime.timedelta(days=1, hours=1, minutes=3, seconds=5)
        self.assertEqual(duration_iso_string(duration), 'P1DT01H03M05S')

    def test_microseconds(self):
        duration = datetime.timedelta(hours=1, minutes=3, seconds=5, microseconds=12345)
        self.assertEqual(duration_iso_string(duration), 'P0DT01H03M05.012345S')

    def test_negative(self):
        duration = -1 * datetime.timedelta(days=1, hours=1, minutes=3, seconds=5)
        self.assertEqual(duration_iso_string(duration), '-P1DT01H03M05S')


</source>
<source file="django/tests/utils_tests/test_duration.py.pyindent" startline="68" endline="85" pcid="27777">

    def test_simple(self):
        duration = datetime.timedelta(hours=1, minutes=3, seconds=5)
        self.assertEqual(parse_duration(duration_iso_string(duration)), duration)

    def test_days(self):
        duration = datetime.timedelta(days=1, hours=1, minutes=3, seconds=5)
        self.assertEqual(parse_duration(duration_iso_string(duration)), duration)

    def test_microseconds(self):
        duration = datetime.timedelta(hours=1, minutes=3, seconds=5, microseconds=12345)
        self.assertEqual(parse_duration(duration_iso_string(duration)), duration)

    def test_negative(self):
        duration = datetime.timedelta(days=-1, hours=1, minutes=3, seconds=5)
        self.assertEqual(parse_duration(duration_iso_string(duration)).total_seconds(), duration.total_seconds())


</source>
</class>

<class classid="466" nclones="2" nlines="14" similarity="71">
<source file="django/tests/utils_tests/test_encoding.py.pyindent" startline="68" endline="77" pcid="27798">
        class Test:
            def __str__(self):
                return 'ŠĐĆŽćžšđ'

        lazy_func = gettext_lazy('x')
        self.assertIs(smart_bytes(lazy_func), lazy_func)
        self.assertEqual(smart_bytes(Test()), b'\xc5\xa0\xc4\x90\xc4\x86\xc5\xbd\xc4\x87\xc5\xbe\xc5\xa1\xc4\x91')
        self.assertEqual(smart_bytes(1), b'1')
        self.assertEqual(smart_bytes('foo'), b'foo')

</source>
<source file="django/tests/utils_tests/test_encoding.py.pyindent" startline="79" endline="88" pcid="27801">
        class Test:
            def __str__(self):
                return 'ŠĐĆŽćžšđ'

        lazy_func = gettext_lazy('x')
        self.assertIs(smart_text(lazy_func), lazy_func)
        self.assertEqual(smart_text(Test()), '\u0160\u0110\u0106\u017d\u0107\u017e\u0161\u0111')
        self.assertEqual(smart_text(1), '1')
        self.assertEqual(smart_text('foo'), 'foo')

</source>
</class>

<class classid="467" nclones="2" nlines="10" similarity="70">
<source file="django/tests/utils_tests/test_html.py.pyindent" startline="230" endline="234" pcid="27902">
            @html_safe
            class HtmlClass:
                def __html__(self):
                    return "<h1>I'm a html class!</h1>"

</source>
<source file="django/tests/utils_tests/test_safestring.py.pyindent" startline="83" endline="91" pcid="28042">
        """
        mark_safe doesn't affect a callable that has an __html__() method.
        """
        class SafeStringContainer:
            def __html__(self):
                return '<html></html>'

        self.assertIs(mark_safe(SafeStringContainer), SafeStringContainer)

</source>
</class>

<class classid="468" nclones="2" nlines="21" similarity="71">
<source file="django/tests/utils_tests/test_module_loading.py.pyindent" startline="80" endline="99" pcid="27966">
        "Module existence can be tested inside eggs"
        egg_name = '%s/test_egg.egg' % self.egg_dir
        with extend_sys_path(egg_name):
            egg_module = import_module('egg_module')

            # An importable child
            self.assertTrue(module_has_submodule(egg_module, 'good_module'))
            mod = import_module('egg_module.good_module')
            self.assertEqual(mod.content, 'Good Module')

            # A child that exists, but will generate an import error if loaded
            self.assertTrue(module_has_submodule(egg_module, 'bad_module'))
            with self.assertRaises(ImportError):
                import_module('egg_module.bad_module')

            # A child that doesn't exist
            self.assertFalse(module_has_submodule(egg_module, 'no_such_module'))
            with self.assertRaises(ImportError):
                import_module('egg_module.no_such_module')

</source>
<source file="django/tests/utils_tests/test_module_loading.py.pyindent" startline="101" endline="121" pcid="27970">
        "Modules deep inside an egg can still be tested for existence"
        egg_name = '%s/test_egg.egg' % self.egg_dir
        with extend_sys_path(egg_name):
            egg_module = import_module('egg_module.sub1.sub2')

            # An importable child
            self.assertTrue(module_has_submodule(egg_module, 'good_module'))
            mod = import_module('egg_module.sub1.sub2.good_module')
            self.assertEqual(mod.content, 'Deep Good Module')

            # A child that exists, but will generate an import error if loaded
            self.assertTrue(module_has_submodule(egg_module, 'bad_module'))
            with self.assertRaises(ImportError):
                import_module('egg_module.sub1.sub2.bad_module')

            # A child that doesn't exist
            self.assertFalse(module_has_submodule(egg_module, 'no_such_module'))
            with self.assertRaises(ImportError):
                import_module('egg_module.sub1.sub2.no_such_module')


</source>
</class>

<class classid="469" nclones="2" nlines="12" similarity="91">
<source file="django/tests/view_tests/tests/test_static.py.pyindent" startline="78" endline="91" pcid="28312">
        """Handle bogus If-Modified-Since values gracefully

        Assume that a file is modified since an invalid timestamp as per RFC
        2616, section 14.25.
        """
        file_name = 'file.txt'
        invalid_date = 'Mon, 28 May 999999999999 28:25:26 GMT'
        response = self.client.get('/%s/%s' % (self.prefix, file_name),
                                   HTTP_IF_MODIFIED_SINCE=invalid_date)
        response_content = b''.join(response)
        with open(path.join(media_dir, file_name), 'rb') as fp:
            self.assertEqual(fp.read(), response_content)
        self.assertEqual(len(response_content), int(response['Content-Length']))

</source>
<source file="django/tests/view_tests/tests/test_static.py.pyindent" startline="93" endline="106" pcid="28314">
        """Handle even more bogus If-Modified-Since values gracefully

        Assume that a file is modified since an invalid timestamp as per RFC
        2616, section 14.25.
        """
        file_name = 'file.txt'
        invalid_date = ': 1291108438, Wed, 20 Oct 2010 14:05:00 GMT'
        response = self.client.get('/%s/%s' % (self.prefix, file_name),
                                   HTTP_IF_MODIFIED_SINCE=invalid_date)
        response_content = b''.join(response)
        with open(path.join(media_dir, file_name), 'rb') as fp:
            self.assertEqual(fp.read(), response_content)
        self.assertEqual(len(response_content), int(response['Content-Length']))

</source>
</class>

<class classid="470" nclones="9" nlines="14" similarity="77">
<source file="django/tests/view_tests/views.py.pyindent" startline="120" endline="132" pcid="28352">
    # Do not just use plain strings for the variables' values in the code
    # so that the tests don't return false positives when the function's source
    # is displayed in the exception report.
    cooked_eggs = ''.join(['s', 'c', 'r', 'a', 'm', 'b', 'l', 'e', 'd'])  # NOQA
    sauce = ''.join(['w', 'o', 'r', 'c', 'e', 's', 't', 'e', 'r', 's', 'h', 'i', 'r', 'e'])  # NOQA
    try:
        raise Exception
    except Exception:
        exc_info = sys.exc_info()
        send_log(request, exc_info)
        return technical_500_response(request, *exc_info)


</source>
<source file="django/tests/view_tests/views.py.pyindent" startline="152" endline="164" pcid="28358">
    # Do not just use plain strings for the variables' values in the code
    # so that the tests don't return false positives when the function's source
    # is displayed in the exception report.
    cooked_eggs = ''.join(['s', 'c', 'r', 'a', 'm', 'b', 'l', 'e', 'd'])  # NOQA
    sauce = ''.join(['w', 'o', 'r', 'c', 'e', 's', 't', 'e', 'r', 's', 'h', 'i', 'r', 'e'])  # NOQA
    try:
        raise Exception
    except Exception:
        exc_info = sys.exc_info()
        send_log(request, exc_info)
        return technical_500_response(request, *exc_info)


</source>
<source file="django/tests/view_tests/views.py.pyindent" startline="231" endline="246" pcid="28375">

    @sensitive_variables('sauce')
    def method(self, request):
        # Do not just use plain strings for the variables' values in the code
        # so that the tests don't return false positives when the function's
        # source is displayed in the exception report.
        cooked_eggs = ''.join(['s', 'c', 'r', 'a', 'm', 'b', 'l', 'e', 'd'])  # NOQA
        sauce = ''.join(['w', 'o', 'r', 'c', 'e', 's', 't', 'e', 'r', 's', 'h', 'i', 'r', 'e'])  # NOQA
        try:
            raise Exception
        except Exception:
            exc_info = sys.exc_info()
            send_log(request, exc_info)
            return technical_500_response(request, *exc_info)


</source>
<source file="django/tests/view_tests/views.py.pyindent" startline="136" endline="148" pcid="28355">
    # Do not just use plain strings for the variables' values in the code
    # so that the tests don't return false positives when the function's source
    # is displayed in the exception report.
    cooked_eggs = ''.join(['s', 'c', 'r', 'a', 'm', 'b', 'l', 'e', 'd'])  # NOQA
    sauce = ''.join(['w', 'o', 'r', 'c', 'e', 's', 't', 'e', 'r', 's', 'h', 'i', 'r', 'e'])  # NOQA
    try:
        raise Exception
    except Exception:
        exc_info = sys.exc_info()
        send_log(request, exc_info)
        return technical_500_response(request, *exc_info)


</source>
<source file="django/tests/view_tests/views.py.pyindent" startline="166" endline="173" pcid="28361">
    try:
        sensitive_args_function(''.join(['w', 'o', 'r', 'c', 'e', 's', 't', 'e', 'r', 's', 'h', 'i', 'r', 'e']))
    except Exception:
        exc_info = sys.exc_info()
        send_log(request, exc_info)
        return technical_500_response(request, *exc_info)


</source>
<source file="django/tests/view_tests/views.py.pyindent" startline="216" endline="229" pcid="28372">
    # Do not just use plain strings for the variables' values in the code
    # so that the tests don't return false positives when the function's source
    # is displayed in the exception report.
    cooked_eggs = ''.join(['s', 'c', 'r', 'a', 'm', 'b', 'l', 'e', 'd'])  # NOQA
    sauce = ''.join(['w', 'o', 'r', 'c', 'e', 's', 't', 'e', 'r', 's', 'h', 'i', 'r', 'e'])  # NOQA
    request.exception_reporter_filter = UnsafeExceptionReporterFilter()
    try:
        raise Exception
    except Exception:
        exc_info = sys.exc_info()
        send_log(request, exc_info)
        return technical_500_response(request, *exc_info)


</source>
<source file="django/tests/view_tests/views.py.pyindent" startline="184" endline="191" pcid="28365">
    try:
        sensitive_kwargs_function(''.join(['w', 'o', 'r', 'c', 'e', 's', 't', 'e', 'r', 's', 'h', 'i', 'r', 'e']))
    except Exception:
        exc_info = sys.exc_info()
        send_log(request, exc_info)
        return technical_500_response(request, *exc_info)


</source>
<source file="django/tests/view_tests/views.py.pyindent" startline="254" endline="263" pcid="28380">
    cooked_eggs = ''.join(['s', 'c', 'r', 'a', 'm', 'b', 'l', 'e', 'd'])  # NOQA
    sauce = ''.join(['w', 'o', 'r', 'c', 'e', 's', 't', 'e', 'r', 's', 'h', 'i', 'r', 'e'])  # NOQA
    try:
        request.POST['bar']
    except Exception:
        exc_info = sys.exc_info()
        send_log(request, exc_info)
        return technical_500_response(request, *exc_info)


</source>
<source file="django/tests/view_tests/views.py.pyindent" startline="234" endline="246" pcid="28376">
        # Do not just use plain strings for the variables' values in the code
        # so that the tests don't return false positives when the function's
        # source is displayed in the exception report.
        cooked_eggs = ''.join(['s', 'c', 'r', 'a', 'm', 'b', 'l', 'e', 'd'])  # NOQA
        sauce = ''.join(['w', 'o', 'r', 'c', 'e', 's', 't', 'e', 'r', 's', 'h', 'i', 'r', 'e'])  # NOQA
        try:
            raise Exception
        except Exception:
            exc_info = sys.exc_info()
            send_log(request, exc_info)
            return technical_500_response(request, *exc_info)


</source>
</class>

</clones>
