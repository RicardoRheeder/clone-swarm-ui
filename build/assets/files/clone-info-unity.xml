<clones>
<systeminfo processor="nicad3" system="UnityCsReference" granularity="blocks" threshold="30%" minlines="10" maxlines="2500"/>
<cloneinfo npcs="39755" npairs="427"/>
<runinfo ncompares="13413004" cputime="5045938"/>
<classinfo nclasses="207"/>

<class classid="1" nclones="5" nlines="21" similarity="72">
<source file="UnityCsReference/Runtime/Export/UnityEvent_2.cs.ifdefed" startline="55" endline="77" pcid="1000">
        {
            List<BaseInvokableCall> calls = PrepareInvoke();
            for (var i = 0; i < calls.Count; i++)
            {
                var curCall = calls[i] as InvokableCall<T0, T1>;
                if (curCall != null)
                    curCall.Invoke(arg0, arg1);
                else
                {
                    var staticCurCall = calls[i] as InvokableCall;
                    if (staticCurCall != null)
                        staticCurCall.Invoke();
                    else
                    {
                        var cachedCurCall = calls[i];
                        if (m_InvokeArray == null)
                            m_InvokeArray = new object[2];
                        m_InvokeArray[0] = arg0; m_InvokeArray[1] = arg1;
                        cachedCurCall.Invoke(m_InvokeArray);
                    }
                }
            }
        }
</source>
<source file="UnityCsReference/Runtime/Export/UnityEvent_3.cs.ifdefed" startline="55" endline="77" pcid="3031">
        {
            List<BaseInvokableCall> calls = PrepareInvoke();
            for (var i = 0; i < calls.Count; i++)
            {
                var curCall = calls[i] as InvokableCall<T0, T1, T2>;
                if (curCall != null)
                    curCall.Invoke(arg0, arg1, arg2);
                else
                {
                    var staticCurCall = calls[i] as InvokableCall;
                    if (staticCurCall != null)
                        staticCurCall.Invoke();
                    else
                    {
                        var cachedCurCall = calls[i];
                        if (m_InvokeArray == null)
                            m_InvokeArray = new object[3];
                        m_InvokeArray[0] = arg0; m_InvokeArray[1] = arg1; m_InvokeArray[2] = arg2;
                        cachedCurCall.Invoke(m_InvokeArray);
                    }
                }
            }
        }
</source>
<source file="UnityCsReference/Runtime/Export/UnityEvent_1.cs.ifdefed" startline="55" endline="77" pcid="2338">
        {
            List<BaseInvokableCall> calls = PrepareInvoke();
            for (var i = 0; i < calls.Count; i++)
            {
                var curCall = calls[i] as InvokableCall<T0>;
                if (curCall != null)
                    curCall.Invoke(arg0);
                else
                {
                    var staticCurCall = calls[i] as InvokableCall;
                    if (staticCurCall != null)
                        staticCurCall.Invoke();
                    else
                    {
                        var cachedCurCall = calls[i];
                        if (m_InvokeArray == null)
                            m_InvokeArray = new object[1];
                        m_InvokeArray[0] = arg0;
                        cachedCurCall.Invoke(m_InvokeArray);
                    }
                }
            }
        }
</source>
<source file="UnityCsReference/Runtime/Export/UnityEvent_4.cs.ifdefed" startline="55" endline="77" pcid="2810">
        {
            List<BaseInvokableCall> calls = PrepareInvoke();
            for (var i = 0; i < calls.Count; i++)
            {
                var curCall = calls[i] as InvokableCall<T0, T1, T2, T3>;
                if (curCall != null)
                    curCall.Invoke(arg0, arg1, arg2, arg3);
                else
                {
                    var staticCurCall = calls[i] as InvokableCall;
                    if (staticCurCall != null)
                        staticCurCall.Invoke();
                    else
                    {
                        var cachedCurCall = calls[i];
                        if (m_InvokeArray == null)
                            m_InvokeArray = new object[4];
                        m_InvokeArray[0] = arg0; m_InvokeArray[1] = arg1; m_InvokeArray[2] = arg2; m_InvokeArray[3] = arg3;
                        cachedCurCall.Invoke(m_InvokeArray);
                    }
                }
            }
        }
</source>
<source file="UnityCsReference/Runtime/Export/UnityEvent_0.cs.ifdefed" startline="55" endline="77" pcid="1484">
        {
            List<BaseInvokableCall> calls = PrepareInvoke();
            for (var i = 0; i < calls.Count; i++)
            {
                var curCall = calls[i] as InvokableCall;
                if (curCall != null)
                    curCall.Invoke();
                else
                {
                    var staticCurCall = calls[i] as InvokableCall;
                    if (staticCurCall != null)
                        staticCurCall.Invoke();
                    else
                    {
                        var cachedCurCall = calls[i];
                        if (m_InvokeArray == null)
                            m_InvokeArray = new object[0];

                        cachedCurCall.Invoke(m_InvokeArray);
                    }
                }
            }
        }
</source>
</class>

<class classid="2" nclones="4" nlines="11" similarity="81">
<source file="UnityCsReference/Runtime/Export/Mathf.cs.ifdefed" startline="59" endline="70" pcid="1049">
        {
            int len = values.Length;
            if (len == 0)
                return 0;
            float m = values[0];
            for (int i = 1; i < len; i++)
            {
                if (values[i] < m)
                    m = values[i];
            }
            return m;
        }
</source>
<source file="UnityCsReference/Runtime/Export/Mathf.cs.ifdefed" startline="76" endline="87" pcid="1052">
        {
            int len = values.Length;
            if (len == 0)
                return 0;
            int m = values[0];
            for (int i = 1; i < len; i++)
            {
                if (values[i] < m)
                    m = values[i];
            }
            return m;
        }
</source>
<source file="UnityCsReference/Runtime/Export/Mathf.cs.ifdefed" startline="110" endline="121" pcid="1058">
        {
            int len = values.Length;
            if (len == 0)
                return 0;
            int m = values[0];
            for (int i = 1; i < len; i++)
            {
                if (values[i] > m)
                    m = values[i];
            }
            return m;
        }
</source>
<source file="UnityCsReference/Runtime/Export/Mathf.cs.ifdefed" startline="93" endline="104" pcid="1055">
        {
            int len = values.Length;
            if (len == 0)
                return 0;
            float m = values[0];
            for (int i = 1; i < len; i++)
            {
                if (values[i] > m)
                    m = values[i];
            }
            return m;
        }
</source>
</class>

<class classid="3" nclones="5" nlines="10" similarity="80">
<source file="UnityCsReference/Runtime/Export/UnityEvent.cs.ifdefed" startline="940" endline="951" pcid="1283">
        {
            if (call == null)
            {
                Debug.LogWarning("Registering a Listener requires an action");
                return;
            }
            if (!ValidateRegistration(call.Method, call.Target, PersistentListenerMode.Void))
                return;

            m_PersistentCalls.RegisterVoidPersistentListener(index, call.Target as Object, call.Method.Name);
            DirtyPersistentCalls();
        }
</source>
<source file="UnityCsReference/Runtime/Export/UnityEvent.cs.ifdefed" startline="1024" endline="1035" pcid="1295">
        {
            if (call == null)
            {
                Debug.LogWarning("Registering a Listener requires an action");
                return;
            }
            if (!ValidateRegistration(call.Method, call.Target, PersistentListenerMode.String))
                return;

            m_PersistentCalls.RegisterStringPersistentListener(index, call.Target as Object, argument, call.Method.Name);
            DirtyPersistentCalls();
        }
</source>
<source file="UnityCsReference/Runtime/Export/UnityEvent.cs.ifdefed" startline="961" endline="972" pcid="1286">
        {
            if (call == null)
            {
                Debug.LogWarning("Registering a Listener requires an action");
                return;
            }
            if (!ValidateRegistration(call.Method, call.Target, PersistentListenerMode.Int))
                return;

            m_PersistentCalls.RegisterIntPersistentListener(index, call.Target as Object, argument, call.Method.Name);
            DirtyPersistentCalls();
        }
</source>
<source file="UnityCsReference/Runtime/Export/UnityEvent.cs.ifdefed" startline="982" endline="993" pcid="1289">
        {
            if (call == null)
            {
                Debug.LogWarning("Registering a Listener requires an action");
                return;
            }
            if (!ValidateRegistration(call.Method, call.Target, PersistentListenerMode.Float))
                return;

            m_PersistentCalls.RegisterFloatPersistentListener(index, call.Target as Object, argument, call.Method.Name);
            DirtyPersistentCalls();
        }
</source>
<source file="UnityCsReference/Runtime/Export/UnityEvent.cs.ifdefed" startline="1003" endline="1014" pcid="1292">
        {
            if (call == null)
            {
                Debug.LogWarning("Registering a Listener requires an action");
                return;
            }
            if (!ValidateRegistration(call.Method, call.Target, PersistentListenerMode.Bool))
                return;

            m_PersistentCalls.RegisterBoolPersistentListener(index, call.Target as Object, argument, call.Method.Name);
            DirtyPersistentCalls();
        }
</source>
</class>

<class classid="4" nclones="10" nlines="10" similarity="80">
<source file="UnityCsReference/Runtime/Export/Shader.cs.ifdefed" startline="49" endline="60" pcid="1754">
        {
            if (values == null)
                throw new ArgumentNullException("values");
            values.Clear();

            int count = GetFloatArrayCountImpl(name);
            if (count > 0)
            {
                NoAllocHelpers.EnsureListElemCount(values, count);
                ExtractFloatArrayImpl(name, (float[])NoAllocHelpers.ExtractArrayFromList(values));
            }
        }
</source>
<source file="UnityCsReference/Runtime/Export/Shader.cs.ifdefed" startline="291" endline="302" pcid="1827">
        {
            if (values == null)
                throw new ArgumentNullException("values");
            values.Clear();

            int count = GetGlobalVectorArrayCountImpl(name);
            if (count > 0)
            {
                NoAllocHelpers.EnsureListElemCount(values, count);
                ExtractGlobalVectorArrayImpl(name, (Vector4[])NoAllocHelpers.ExtractArrayFromList(values));
            }
        }
</source>
<source file="UnityCsReference/Runtime/Export/Shader.cs.ifdefed" startline="305" endline="316" pcid="1829">
        {
            if (values == null)
                throw new ArgumentNullException("values");
            values.Clear();

            int count = GetGlobalMatrixArrayCountImpl(name);
            if (count > 0)
            {
                NoAllocHelpers.EnsureListElemCount(values, count);
                ExtractGlobalMatrixArrayImpl(name, (Matrix4x4[])NoAllocHelpers.ExtractArrayFromList(values));
            }
        }
</source>
<source file="UnityCsReference/Runtime/Export/Shader.cs.ifdefed" startline="429" endline="440" pcid="1886">
        {
            if (values == null)
                throw new ArgumentNullException("values");
            values.Clear();

            int count = GetFloatArrayCountImpl(name);
            if (count > 0)
            {
                NoAllocHelpers.EnsureListElemCount(values, count);
                ExtractFloatArrayImpl(name, (float[])NoAllocHelpers.ExtractArrayFromList(values));
            }
        }
</source>
<source file="UnityCsReference/Runtime/Export/Shader.cs.ifdefed" startline="277" endline="288" pcid="1825">
        {
            if (values == null)
                throw new ArgumentNullException("values");
            values.Clear();

            int count = GetGlobalFloatArrayCountImpl(name);
            if (count > 0)
            {
                NoAllocHelpers.EnsureListElemCount(values, count);
                ExtractGlobalFloatArrayImpl(name, (float[])NoAllocHelpers.ExtractArrayFromList(values));
            }
        }
</source>
<source file="UnityCsReference/Runtime/Export/Shader.cs.ifdefed" startline="443" endline="454" pcid="1888">
        {
            if (values == null)
                throw new ArgumentNullException("values");
            values.Clear();

            int count = GetVectorArrayCountImpl(name);
            if (count > 0)
            {
                NoAllocHelpers.EnsureListElemCount(values, count);
                ExtractVectorArrayImpl(name, (Vector4[])NoAllocHelpers.ExtractArrayFromList(values));
            }
        }
</source>
<source file="UnityCsReference/Runtime/Export/Shader.cs.ifdefed" startline="63" endline="74" pcid="1756">
        {
            if (values == null)
                throw new ArgumentNullException("values");
            values.Clear();

            int count = GetVectorArrayCountImpl(name);
            if (count > 0)
            {
                NoAllocHelpers.EnsureListElemCount(values, count);
                ExtractVectorArrayImpl(name, (Vector4[])NoAllocHelpers.ExtractArrayFromList(values));
            }
        }
</source>
<source file="UnityCsReference/Runtime/Export/Shader.cs.ifdefed" startline="457" endline="468" pcid="1890">
        {
            if (values == null)
                throw new ArgumentNullException("values");
            values.Clear();

            int count = GetColorArrayCountImpl(name);
            if (count > 0)
            {
                NoAllocHelpers.EnsureListElemCount(values, count);
                ExtractColorArrayImpl(name, (Color[])NoAllocHelpers.ExtractArrayFromList(values));
            }
        }
</source>
<source file="UnityCsReference/Runtime/Export/Shader.cs.ifdefed" startline="77" endline="88" pcid="1758">
        {
            if (values == null)
                throw new ArgumentNullException("values");
            values.Clear();

            int count = GetMatrixArrayCountImpl(name);
            if (count > 0)
            {
                NoAllocHelpers.EnsureListElemCount(values, count);
                ExtractMatrixArrayImpl(name, (Matrix4x4[])NoAllocHelpers.ExtractArrayFromList(values));
            }
        }
</source>
<source file="UnityCsReference/Runtime/Export/Shader.cs.ifdefed" startline="471" endline="482" pcid="1892">
        {
            if (values == null)
                throw new ArgumentNullException("values");
            values.Clear();

            int count = GetMatrixArrayCountImpl(name);
            if (count > 0)
            {
                NoAllocHelpers.EnsureListElemCount(values, count);
                ExtractMatrixArrayImpl(name, (Matrix4x4[])NoAllocHelpers.ExtractArrayFromList(values));
            }
        }
</source>
</class>

<class classid="5" nclones="2" nlines="16" similarity="75">
<source file="UnityCsReference/Runtime/Export/GI/Lightmapping.cs.ifdefed" startline="237" endline="252" pcid="2316">
            {
                instanceID     = light.instanceID;
                color          = light.color;
                indirectColor  = light.indirectColor;
                orientation    = Quaternion.identity;
                position       = light.position;
                range          = light.range;
                coneAngle      = 0.0f;
                innerConeAngle = 0.0f;
                shape0         = light.sphereRadius;
                shape1         = 0.0f;
                type           = LightType.Point;
                mode           = light.mode;
                shadow         = (byte)(light.shadow ? 1 : 0);
                falloff        = light.falloff;
            }
</source>
<source file="UnityCsReference/Runtime/Export/GI/Lightmapping.cs.ifdefed" startline="255" endline="270" pcid="2317">
            {
                instanceID     = light.instanceID;
                color          = light.color;
                indirectColor  = light.indirectColor;
                orientation    = light.orientation;
                position       = light.position;
                range          = light.range;
                coneAngle      = light.coneAngle;
                innerConeAngle = light.innerConeAngle;
                shape0         = light.sphereRadius;
                shape1         = 0.0f;
                type           = LightType.Spot;
                mode           = light.mode;
                shadow         = (byte)(light.shadow ? 1 : 0);
                falloff        = light.falloff;
            }
</source>
</class>

<class classid="6" nclones="3" nlines="10" similarity="70">
<source file="UnityCsReference/Runtime/Export/AnimationCurve.bindings.cs.ifdefed" startline="42" endline="51" pcid="2367">
        {
            m_Time = time;
            m_Value = value;
            m_InTangent = 0;
            m_OutTangent = 0;
            m_WeightedMode = 0;
            m_InWeight = 0f;
            m_OutWeight = 0f;
            m_TangentMode = 0;
        }
</source>
<source file="UnityCsReference/Runtime/Export/AnimationCurve.bindings.cs.ifdefed" startline="55" endline="64" pcid="2368">
        {
            m_Time = time;
            m_Value = value;
            m_InTangent = inTangent;
            m_OutTangent = outTangent;
            m_WeightedMode = 0;
            m_InWeight = 0f;
            m_OutWeight = 0f;
            m_TangentMode = 0;
        }
</source>
<source file="UnityCsReference/Runtime/Export/AnimationCurve.bindings.cs.ifdefed" startline="68" endline="77" pcid="2369">
        {
            m_Time = time;
            m_Value = value;
            m_InTangent = inTangent;
            m_OutTangent = outTangent;
            m_WeightedMode = (int)WeightedMode.Both;
            m_InWeight = inWeight;
            m_OutWeight = outWeight;
            m_TangentMode = 0;
        }
</source>
</class>

<class classid="7" nclones="2" nlines="13" similarity="92">
<source file="UnityCsReference/Runtime/VR/HoloLens/ScriptBindings/VideoCapture.bindings.cs.ifdefed" startline="66" endline="83" pcid="3738">
        {
            VideoCaptureResult result = new VideoCaptureResult();

            CaptureResultType resultType;
            if (hResult == HR_SUCCESS)
            {
                resultType = CaptureResultType.Success;
            }
            else
            {
                resultType = CaptureResultType.UnknownError;
            }

            result.resultType = resultType;
            result.hResult = hResult;

            return result;
        }
</source>
<source file="UnityCsReference/Runtime/VR/HoloLens/ScriptBindings/PhotoCapture.bindings.cs.ifdefed" startline="64" endline="81" pcid="3792">
        {
            PhotoCaptureResult result = new PhotoCaptureResult();

            CaptureResultType resultType;
            if (hResult == HR_SUCCESS)
            {
                resultType = CaptureResultType.Success;
            }
            else
            {
                resultType = CaptureResultType.UnknownError;
            }

            result.resultType = resultType;
            result.hResult = hResult;

            return result;
        }
</source>
</class>

<class classid="8" nclones="2" nlines="18" similarity="83">
<source file="UnityCsReference/Runtime/VR/HoloLens/ScriptBindings/VideoCapture.bindings.cs.ifdefed" startline="204" endline="232" pcid="3754">
        {
            if (onStartedRecordingVideoCallback == null)
            {
                throw new ArgumentNullException("onStartedRecordingVideoCallback");
            }

            if (string.IsNullOrEmpty(filename))
            {
                throw new ArgumentNullException("filename");
            }

            // Make sure we don't have any forward slashes.
            // WinRT Apis do not like forward slashes.
            filename = filename.Replace("/", @"\");

            string directory = System.IO.Path.GetDirectoryName(filename);
            if (!string.IsNullOrEmpty(directory) && !System.IO.Directory.Exists(directory))
            {
                throw new ArgumentException("The specified directory does not exist.", "filename");
            }

            System.IO.FileInfo fileInfo = new System.IO.FileInfo(filename);
            if (fileInfo.Exists && fileInfo.IsReadOnly)
            {
                throw new ArgumentException("Cannot write to the file because it is read-only.", "filename");
            }

            StartRecordingVideoToDisk_Internal(filename, onStartedRecordingVideoCallback);
        }
</source>
<source file="UnityCsReference/Runtime/VR/HoloLens/ScriptBindings/PhotoCapture.bindings.cs.ifdefed" startline="184" endline="212" pcid="3808">
        {
            if (onCapturedPhotoToDiskCallback == null)
            {
                throw new ArgumentNullException("onCapturedPhotoToDiskCallback");
            }

            if (string.IsNullOrEmpty(filename))
            {
                throw new ArgumentNullException("filename");
            }

            // Make sure we don't have any forward slashes.
            // WinRT Apis do not like forward slashes.
            filename = filename.Replace("/", @"\");

            string directory = System.IO.Path.GetDirectoryName(filename);
            if (!string.IsNullOrEmpty(directory) && !System.IO.Directory.Exists(directory))
            {
                throw new ArgumentException("The specified directory does not exist.", "filename");
            }

            System.IO.FileInfo fileInfo = new System.IO.FileInfo(filename);
            if (fileInfo.Exists && fileInfo.IsReadOnly)
            {
                throw new ArgumentException("Cannot write to the file because it is read-only.", "filename");
            }

            CapturePhotoToDisk_Internal(filename, fileOutputFormat, onCapturedPhotoToDiskCallback);
        }
</source>
</class>

<class classid="9" nclones="5" nlines="10" similarity="70">
<source file="UnityCsReference/Runtime/Dynamics/ScriptBindings/Dynamics.bindings.cs.ifdefed" startline="294" endline="305" pcid="4262">
        {
            float dirLength = direction.magnitude;
            if (dirLength > float.Epsilon)
            {
                Vector3 normalizedDirection = direction / dirLength;
                return Internal_SweepTestAll(normalizedDirection, maxDistance, queryTriggerInteraction);
            }
            else
            {
                return new RaycastHit[0];
            }
        }
</source>
<source file="UnityCsReference/Runtime/Dynamics/ScriptBindings/Dynamics.bindings.cs.ifdefed" startline="1131" endline="1143" pcid="4369">
        {
            float dirLength = direction.magnitude;
            if (dirLength > float.Epsilon)
            {
                Vector3 normalizedDirection = direction / dirLength;

                return Query_CapsuleCastAll(point1, point2, radius, normalizedDirection, maxDistance, layerMask, queryTriggerInteraction);
            }
            else
            {
                return new RaycastHit[0];
            }
        }
</source>
<source file="UnityCsReference/Runtime/Dynamics/ScriptBindings/Dynamics.bindings.cs.ifdefed" startline="1067" endline="1079" pcid="4359">
        {
            float dirLength = direction.magnitude;
            if (dirLength > float.Epsilon)
            {
                Vector3 normalizedDirection = direction / dirLength;
                Ray ray = new Ray(origin, normalizedDirection);
                return Internal_RaycastAll(ray, maxDistance, layerMask, queryTriggerInteraction);
            }
            else
            {
                return new RaycastHit[0];
            }
        }
</source>
<source file="UnityCsReference/Runtime/Dynamics/ScriptBindings/Dynamics.bindings.cs.ifdefed" startline="1314" endline="1327" pcid="4395">
        {
            float dirLength = direction.magnitude;

            if (dirLength > float.Epsilon)
            {
                Ray ray = new Ray(origin, direction.normalized);

                return Internal_RaycastNonAlloc(ray, results, maxDistance, layerMask, queryTriggerInteraction);
            }
            else
            {
                return 0;
            }
        }
</source>
<source file="UnityCsReference/Runtime/Dynamics/ScriptBindings/Dynamics.bindings.cs.ifdefed" startline="1587" endline="1599" pcid="4437">
        {
            float dirLength = direction.magnitude;
            if (dirLength > float.Epsilon)
            {
                Vector3 normalizedDirection = direction / dirLength;

                return Internal_BoxCastAll(center, halfExtents, normalizedDirection, orientation, maxDistance, layerMask, queryTriggerInteraction);
            }
            else
            {
                return new RaycastHit[0];
            }
        }
</source>
</class>

<class classid="10" nclones="4" nlines="10" similarity="80">
<source file="UnityCsReference/Runtime/Dynamics/ScriptBindings/Dynamics.bindings.cs.ifdefed" startline="691" endline="701" pcid="4300">
        {
            float dirLength = direction.magnitude;
            if (dirLength > float.Epsilon)
            {
                Vector3 normalizedDirection = direction / dirLength;
                Ray ray = new Ray(origin, normalizedDirection);
                return Query_RaycastTest(ray, maxDistance, layerMask, queryTriggerInteraction);
            }
            else
                return false;
        }
</source>
<source file="UnityCsReference/Runtime/Dynamics/ScriptBindings/Dynamics.bindings.cs.ifdefed" startline="990" endline="1001" pcid="4347">
        {
            float dirLength = direction.magnitude;
            hitInfo = new RaycastHit();
            if (dirLength > float.Epsilon)
            {
                Vector3 normalizedDirection = direction / dirLength;

                return Query_BoxCast(center, halfExtents, normalizedDirection, orientation, maxDistance, ref hitInfo, layerMask, queryTriggerInteraction);
            }
            else
                return false;
        }
</source>
<source file="UnityCsReference/Runtime/Dynamics/ScriptBindings/Dynamics.bindings.cs.ifdefed" startline="731" endline="744" pcid="4306">
        {
            hitInfo = new RaycastHit();

            float dirLength = direction.magnitude;
            if (dirLength > float.Epsilon)
            {
                Vector3 normalizedDirection = direction / dirLength;
                Ray ray = new Ray(origin, normalizedDirection);

                return Internal_Raycast(ray, maxDistance, ref hitInfo, layerMask, queryTriggerInteraction);
            }
            else
                return false;
        }
</source>
<source file="UnityCsReference/Runtime/Dynamics/ScriptBindings/Dynamics.bindings.cs.ifdefed" startline="855" endline="866" pcid="4325">
        {
            float dirLength = direction.magnitude;
            hitInfo = new RaycastHit();
            if (dirLength > float.Epsilon)
            {
                Vector3 normalizedDirection = direction / dirLength;

                return Query_CapsuleCast(point1, point2, radius, normalizedDirection, maxDistance, ref hitInfo, layerMask, queryTriggerInteraction);
            }
            else
                return false;
        }
</source>
</class>

<class classid="11" nclones="2" nlines="23" similarity="70">
<source file="UnityCsReference/Runtime/Networking/Managed/MatchMakingClient.cs.ifdefed" startline="146" endline="176" pcid="4621">
        {
            if (callback == null)
            {
                Debug.Log("callback supplied is null, aborting CreateMatch Request.");
                return null;
            }

            Uri uri = new Uri(baseUri, "/json/reply/CreateMatchRequest");
            Debug.Log("MatchMakingClient Create :" + uri);

            var data = new WWWForm();

            data.AddField("version", UnityEngine.Networking.Match.Request.currentVersion);
            data.AddField("projectId", Application.cloudProjectId);
            data.AddField("sourceId", Utility.GetSourceID().ToString());
            data.AddField("accessTokenString", 0); // Set the access token to 0 for any new match request
            data.AddField("domain", req.domain);

            data.AddField("name", req.name);
            data.AddField("size", req.size.ToString());
            data.AddField("advertise", req.advertise.ToString());
            data.AddField("password", req.password);
            data.AddField("publicAddress", req.publicAddress);
            data.AddField("privateAddress", req.privateAddress);
            data.AddField("eloScore", req.eloScore.ToString());

            data.headers["Accept"] = "application/json";

            var client = UnityWebRequest.Post(uri.ToString(), data);
            return StartCoroutine(ProcessMatchResponse<CreateMatchResponse, DataResponseDelegate<MatchInfo>>(client, OnMatchCreate, callback));
        }
</source>
<source file="UnityCsReference/Runtime/Networking/Managed/MatchMakingClient.cs.ifdefed" startline="193" endline="221" pcid="4625">
        {
            if (callback == null)
            {
                Debug.Log("callback supplied is null, aborting JoinMatch Request.");
                return null;
            }

            Uri uri = new Uri(baseUri, "/json/reply/JoinMatchRequest");
            Debug.Log("MatchMakingClient Join :" + uri);

            var data = new WWWForm();

            data.AddField("version", UnityEngine.Networking.Match.Request.currentVersion);
            data.AddField("projectId", Application.cloudProjectId);
            data.AddField("sourceId", Utility.GetSourceID().ToString());
            data.AddField("accessTokenString", 0);
            data.AddField("domain", req.domain);

            data.AddField("networkId", req.networkId.ToString());
            data.AddField("password", req.password);
            data.AddField("publicAddress", req.publicAddress);
            data.AddField("privateAddress", req.privateAddress);
            data.AddField("eloScore", req.eloScore.ToString());

            data.headers["Accept"] = "application/json";

            var client = UnityWebRequest.Post(uri.ToString(), data);
            return StartCoroutine(ProcessMatchResponse<JoinMatchResponse, DataResponseDelegate<MatchInfo>>(client, OnMatchJoined, callback));
        }
</source>
</class>

<class classid="12" nclones="3" nlines="19" similarity="73">
<source file="UnityCsReference/Runtime/Networking/Managed/MatchMakingClient.cs.ifdefed" startline="238" endline="262" pcid="4629">
        {
            if (callback == null)
            {
                Debug.Log("callback supplied is null, aborting DestroyMatch Request.");
                return null;
            }

            Uri uri = new Uri(baseUri, "/json/reply/DestroyMatchRequest");
            Debug.Log("MatchMakingClient Destroy :" + uri.ToString());

            var data = new WWWForm();

            data.AddField("version", UnityEngine.Networking.Match.Request.currentVersion);
            data.AddField("projectId", Application.cloudProjectId);
            data.AddField("sourceId", Utility.GetSourceID().ToString());
            data.AddField("accessTokenString", Utility.GetAccessTokenForNetwork(req.networkId).GetByteString());
            data.AddField("domain", req.domain);

            data.AddField("networkId", req.networkId.ToString());

            data.headers["Accept"] = "application/json";

            var client = UnityWebRequest.Post(uri.ToString(), data);
            return StartCoroutine(ProcessMatchResponse<BasicResponse, BasicResponseDelegate>(client, OnMatchDestroyed, callback));
        }
</source>
<source file="UnityCsReference/Runtime/Networking/Managed/MatchMakingClient.cs.ifdefed" startline="276" endline="301" pcid="4633">
        {
            if (callback == null)
            {
                Debug.Log("callback supplied is null, aborting DropConnection Request.");
                return null;
            }

            Uri uri = new Uri(baseUri, "/json/reply/DropConnectionRequest");
            Debug.Log("MatchMakingClient DropConnection :" + uri);

            var data = new WWWForm();

            data.AddField("version", UnityEngine.Networking.Match.Request.currentVersion);
            data.AddField("projectId", Application.cloudProjectId);
            data.AddField("sourceId", Utility.GetSourceID().ToString());
            data.AddField("accessTokenString", Utility.GetAccessTokenForNetwork(req.networkId).GetByteString());
            data.AddField("domain", req.domain);

            data.AddField("networkId", req.networkId.ToString());
            data.AddField("nodeId", req.nodeId.ToString());

            data.headers["Accept"] = "application/json";

            var client = UnityWebRequest.Post(uri.ToString(), data);
            return StartCoroutine(ProcessMatchResponse<DropConnectionResponse, BasicResponseDelegate>(client, OnDropConnection, callback));
        }
</source>
<source file="UnityCsReference/Runtime/Networking/Managed/MatchMakingClient.cs.ifdefed" startline="369" endline="394" pcid="4643">
        {
            if (callback == null)
            {
                Debug.Log("callback supplied is null, aborting SetMatchAttributes Request.");
                return null;
            }

            Uri uri = new Uri(baseUri, "/json/reply/SetMatchAttributesRequest");
            Debug.Log("MatchMakingClient SetMatchAttributes :" + uri);

            var data = new WWWForm();

            data.AddField("version", UnityEngine.Networking.Match.Request.currentVersion);
            data.AddField("projectId", Application.cloudProjectId);
            data.AddField("sourceId", Utility.GetSourceID().ToString());
            data.AddField("accessTokenString", Utility.GetAccessTokenForNetwork(req.networkId).GetByteString());
            data.AddField("domain", req.domain);

            data.AddField("networkId", req.networkId.ToString());
            data.AddField("isListed", req.isListed.ToString());

            data.headers["Accept"] = "application/json";

            var client = UnityWebRequest.Post(uri.ToString(), data);
            return StartCoroutine(ProcessMatchResponse<BasicResponse, BasicResponseDelegate>(client, OnSetMatchAttributes, callback));
        }
</source>
</class>

<class classid="13" nclones="2" nlines="17" similarity="82">
<source file="UnityCsReference/Extensions/Networking/Weaver/UNetWeaver.cs.ifdefed" startline="968" endline="987" pcid="4811">
        {
            if (!IsNetworkBehaviour(td))
            {
                Log.Error("[Server] guard on non-NetworkBehaviour script at [" + md.FullName + "]");
                return;
            }
            ILProcessor worker = md.Body.GetILProcessor();
            Instruction top = md.Body.Instructions[0];

            worker.InsertBefore(top, worker.Create(OpCodes.Call, NetworkServerGetActive));
            worker.InsertBefore(top, worker.Create(OpCodes.Brtrue, top));
            if (logWarning)
            {
                worker.InsertBefore(top, worker.Create(OpCodes.Ldstr, "[Server] function '" + md.FullName + "' called on client"));
                worker.InsertBefore(top, worker.Create(OpCodes.Call, logWarningReference));
            }
            InjectGuardParameters(md, worker, top);
            InjectGuardReturnValue(md, worker, top);
            worker.InsertBefore(top, worker.Create(OpCodes.Ret));
        }
</source>
<source file="UnityCsReference/Extensions/Networking/Weaver/UNetWeaver.cs.ifdefed" startline="990" endline="1010" pcid="4814">
        {
            if (!IsNetworkBehaviour(td))
            {
                Log.Error("[Client] guard on non-NetworkBehaviour script at [" + md.FullName + "]");
                return;
            }
            ILProcessor worker = md.Body.GetILProcessor();
            Instruction top = md.Body.Instructions[0];

            worker.InsertBefore(top, worker.Create(OpCodes.Call, NetworkClientGetActive));
            worker.InsertBefore(top, worker.Create(OpCodes.Brtrue, top));
            if (logWarning)
            {
                worker.InsertBefore(top, worker.Create(OpCodes.Ldstr, "[Client] function '" + md.FullName + "' called on server"));
                worker.InsertBefore(top, worker.Create(OpCodes.Call, logWarningReference));
            }

            InjectGuardParameters(md, worker, top);
            InjectGuardReturnValue(md, worker, top);
            worker.InsertBefore(top, worker.Create(OpCodes.Ret));
        }
</source>
</class>

<class classid="14" nclones="2" nlines="20" similarity="72">
<source file="UnityCsReference/Extensions/Networking/Weaver/UNetWeaver.cs.ifdefed" startline="1558" endline="1582" pcid="4872">
        {
            if (!td.IsClass)
                return false;

            // are ANY parent clasess unetbehaviours
            TypeReference parent = td.BaseType;
            while (parent != null)
            {
                if (parent.FullName == NetworkBehaviourType.FullName)
                {
                    return true;
                }
                try
                {
                    parent = parent.Resolve().BaseType;
                }
                catch (AssemblyResolutionException)
                {
                    // this can happen for pluins.
                    //Console.WriteLine("AssemblyResolutionException: "+ ex.ToString());
                    break;
                }
            }
            return false;
        }
</source>
<source file="UnityCsReference/Extensions/Networking/Weaver/UNetWeaver.cs.ifdefed" startline="1585" endline="1618" pcid="4877">
        {
            if (!td.IsClass)
                return false;

            // are ANY parent clasess unetbehaviours
            TypeReference parent = td.BaseType;
            while (parent != null)
            {
                var parentName = parent.FullName;

                // strip generic parameters
                int index = parentName.IndexOf('<');
                if (index != -1)
                {
                    parentName = parentName.Substring(0, index);
                }

                if (parentName == baseClass.FullName)
                {
                    return true;
                }
                try
                {
                    parent = parent.Resolve().BaseType;
                }
                catch (AssemblyResolutionException)
                {
                    // this can happen for pluins.
                    //Console.WriteLine("AssemblyResolutionException: "+ ex.ToString());
                    break;
                }
            }
            return false;
        }
</source>
</class>

<class classid="15" nclones="4" nlines="12" similarity="75">
<source file="UnityCsReference/Extensions/Networking/Weaver/UNetWeaver.cs.ifdefed" startline="1565" endline="1580" pcid="4873">
            {
                if (parent.FullName == NetworkBehaviourType.FullName)
                {
                    return true;
                }
                try
                {
                    parent = parent.Resolve().BaseType;
                }
                catch (AssemblyResolutionException)
                {
                    // this can happen for pluins.
                    //Console.WriteLine("AssemblyResolutionException: "+ ex.ToString());
                    break;
                }
            }
</source>
<source file="UnityCsReference/Extensions/Networking/Weaver/UNetWeaver.cs.ifdefed" startline="1664" endline="1680" pcid="4889">
            {
                if (parent.FullName == NetworkBehaviourType.FullName)
                {
                    break;
                }
                try
                {
                    behClasses.Insert(0, parent);
                    parent = parent.BaseType.Resolve();
                }
                catch (AssemblyResolutionException)
                {
                    // this can happen for pluins.
                    //Console.WriteLine("AssemblyResolutionException: "+ ex.ToString());
                    break;
                }
            }
</source>
<source file="UnityCsReference/Extensions/Networking/Weaver/UNetWeaver.cs.ifdefed" startline="1700" endline="1716" pcid="4895">
            {
                if (parent.FullName == MessageBaseType.FullName)
                {
                    didWork |= ProcessMessageType(td);
                    break;
                }
                try
                {
                    parent = parent.Resolve().BaseType;
                }
                catch (AssemblyResolutionException)
                {
                    // this can happen for pluins.
                    //Console.WriteLine("AssemblyResolutionException: "+ ex.ToString());
                    break;
                }
            }
</source>
<source file="UnityCsReference/Extensions/Networking/Weaver/UNetWeaver.cs.ifdefed" startline="1737" endline="1753" pcid="4901">
            {
                if (parent.FullName.Contains("SyncListStruct"))
                {
                    didWork |= ProcessSyncListStructType(td);
                    break;
                }
                try
                {
                    parent = parent.Resolve().BaseType;
                }
                catch (AssemblyResolutionException)
                {
                    // this can happen for pluins.
                    //Console.WriteLine("AssemblyResolutionException: "+ ex.ToString());
                    break;
                }
            }
</source>
</class>

<class classid="16" nclones="2" nlines="22" similarity="86">
<source file="UnityCsReference/Extensions/Networking/Weaver/UNetWeaver.cs.ifdefed" startline="1691" endline="1725" pcid="4894">
        {
            if (!td.IsClass)
                return false;

            bool didWork = false;

            // are ANY parent clasess MessageBase
            TypeReference parent = td.BaseType;
            while (parent != null)
            {
                if (parent.FullName == MessageBaseType.FullName)
                {
                    didWork |= ProcessMessageType(td);
                    break;
                }
                try
                {
                    parent = parent.Resolve().BaseType;
                }
                catch (AssemblyResolutionException)
                {
                    // this can happen for pluins.
                    //Console.WriteLine("AssemblyResolutionException: "+ ex.ToString());
                    break;
                }
            }

            // check for embedded types
            foreach (var embedded in td.NestedTypes)
            {
                didWork |= CheckMessageBase(embedded);
            }

            return didWork;
        }
</source>
<source file="UnityCsReference/Extensions/Networking/Weaver/UNetWeaver.cs.ifdefed" startline="1728" endline="1762" pcid="4900">
        {
            if (!td.IsClass)
                return false;

            bool didWork = false;

            // are ANY parent clasess SyncListStruct
            TypeReference parent = td.BaseType;
            while (parent != null)
            {
                if (parent.FullName.Contains("SyncListStruct"))
                {
                    didWork |= ProcessSyncListStructType(td);
                    break;
                }
                try
                {
                    parent = parent.Resolve().BaseType;
                }
                catch (AssemblyResolutionException)
                {
                    // this can happen for pluins.
                    //Console.WriteLine("AssemblyResolutionException: "+ ex.ToString());
                    break;
                }
            }

            // check for embedded types
            foreach (var embedded in td.NestedTypes)
            {
                didWork |= CheckSyncListStruct(embedded);
            }

            return didWork;
        }
</source>
</class>

<class classid="17" nclones="2" nlines="10" similarity="90">
<source file="UnityCsReference/Editor/Mono/LookDevView/LookDevConfig.cs.ifdefed" startline="248" endline="261" pcid="5348">
        {
            if (recordUndo)
            {
                Undo.RecordObject(this, "Update Float property for " + property + " with value " + value);
            }

            lookDevContexts[m_CurrentEditionContextIndex].UpdateProperty(property, value);

            if (m_LookDevProperties[(int)property].linked || forceLinked)
            {
                lookDevContexts[(m_CurrentEditionContextIndex + 1) % 2].UpdateProperty(property, value);
            }
            m_LookDevView.Repaint();
        }
</source>
<source file="UnityCsReference/Editor/Mono/LookDevView/LookDevConfig.cs.ifdefed" startline="264" endline="277" pcid="5351">
        {
            if (recordUndo)
            {
                Undo.RecordObject(this, "Update Int property for " + property + " with value " + value);
            }

            lookDevContexts[m_CurrentEditionContextIndex].UpdateProperty(property, value);

            if (m_LookDevProperties[(int)property].linked || forceLinked)
            {
                lookDevContexts[(m_CurrentEditionContextIndex + 1) % 2].UpdateProperty(property, value);
            }
            m_LookDevView.Repaint();
        }
</source>
</class>

<class classid="18" nclones="2" nlines="17" similarity="88">
<source file="UnityCsReference/Editor/Mono/ObjectSelector.cs.ifdefed" startline="424" endline="443" pcid="5514">
        {
            if (m_ListAreaState == null)
                m_ListAreaState = new ObjectListAreaState(); // is serialized

            if (m_ListArea == null)
            {
                m_ListArea = new ObjectListArea(m_ListAreaState, this, true);
                m_ListArea.allowDeselection = false;
                m_ListArea.allowDragging = false;
                m_ListArea.allowFocusRendering = false;
                m_ListArea.allowMultiSelect = false;
                m_ListArea.allowRenaming = false;
                m_ListArea.allowBuiltinResources = true;
                m_ListArea.repaintCallback += Repaint;
                m_ListArea.itemSelectedCallback += ListAreaItemSelectedCallback;
                m_ListArea.gridSize = m_StartGridSize.value;

                FilterSettingsChanged();
            }
        }
</source>
<source file="UnityCsReference/Modules/PresetsEditor/PresetSelector.cs.ifdefed" startline="178" endline="195" pcid="39356">
        {
            if (m_ListAreaState == null)
                m_ListAreaState = new ObjectListAreaState(); // is serialized

            if (m_ListArea == null)
            {
                m_ListArea = new ObjectListArea(m_ListAreaState, this, true);
                m_ListArea.allowDeselection = false;
                m_ListArea.allowDragging = false;
                m_ListArea.allowFocusRendering = false;
                m_ListArea.allowMultiSelect = false;
                m_ListArea.allowRenaming = false;
                m_ListArea.allowBuiltinResources = false;
                m_ListArea.repaintCallback += Repaint;
                m_ListArea.itemSelectedCallback += ListAreaItemSelectedCallback;
                m_ListArea.gridSize = m_StartGridSize.value;
            }
        }
</source>
</class>

<class classid="19" nclones="2" nlines="10" similarity="80">
<source file="UnityCsReference/Editor/Mono/ObjectListAssetStoreGroup.cs.ifdefed" startline="88" endline="100" pcid="6025">
                    {
                        r = m_Grid.CalcRect(itemIdx, yOffset);
                        // Mouse event handling
                        int clicks = HandleMouse(r);
                        if (clicks != 0)
                            m_Owner.SetSelection(m_Assets[itemIdx], clicks == 2);

                        if (isRepaintEvent)
                        {
                            bool selected = !AssetStoreAssetSelection.Empty && AssetStoreAssetSelection.ContainsAsset(m_Assets[itemIdx].id);
                            DrawLabel(r, m_Assets[itemIdx], selected);
                        }
                    }
</source>
<source file="UnityCsReference/Editor/Mono/ObjectListAssetStoreGroup.cs.ifdefed" startline="108" endline="125" pcid="6028">
                    {
                        r = m_Grid.CalcRect(itemIdx, yOffset);

                        // Label has selection visuals now (keep below)
                        // bool selected = !AssetStoreAssetSelection.Empty && AssetStoreAssetSelection.ContainsAsset (m_Assets[itemIdx].id);
                        // bool selected = false;

                        // Mouse event handling
                        int clicks = HandleMouse(r);
                        if (clicks != 0)
                            m_Owner.SetSelection(m_Assets[itemIdx], clicks == 2);

                        if (isRepaintEvent)
                        {
                            Rect position = new Rect(r.x, r.y, r.width, r.height - s_Styles.resultsGridLabel.fixedHeight);
                            DrawIcon(position, m_Assets[itemIdx]);
                        }
                    }
</source>
</class>

<class classid="20" nclones="4" nlines="12" similarity="75">
<source file="UnityCsReference/Editor/Mono/SceneHierarchySortingWindow.cs.ifdefed" startline="71" endline="84" pcid="6100">
        {
            // We could not use realtimeSinceStartUp since it is set to 0 when entering/exitting playmode, we assume an increasing time when comparing time.
            long nowMilliSeconds = System.DateTime.Now.Ticks / System.TimeSpan.TicksPerMillisecond;
            bool justClosed = nowMilliSeconds < s_LastClosedTime + 50;
            if (!justClosed)
            {
                Event.current.Use();
                if (s_SceneHierarchySortingWindow == null)
                    s_SceneHierarchySortingWindow = CreateInstance<SceneHierarchySortingWindow>();
                s_SceneHierarchySortingWindow.Init(pos, data, callback);
                return true;
            }
            return false;
        }
</source>
<source file="UnityCsReference/Modules/TilemapEditor/Editor/Managed/Grid/GridPaletteAddPopup.cs.ifdefed" startline="126" endline="140" pcid="34644">
        {
            // We could not use realtimeSinceStartUp since it is set to 0 when entering/exitting playmode, we assume an increasing time when comparing time.
            long nowMilliSeconds = System.DateTime.Now.Ticks / System.TimeSpan.TicksPerMillisecond;
            bool justClosed = nowMilliSeconds < s_LastClosedTime + 50;
            if (!justClosed)
            {
                Event.current.Use();
                if (s_Instance == null)
                    s_Instance = ScriptableObject.CreateInstance<GridPaletteAddPopup>();

                s_Instance.Init(buttonRect, owner);
                return true;
            }
            return false;
        }
</source>
<source file="UnityCsReference/Editor/Mono/Annotation/LayerVisibilityWindow.cs.ifdefed" startline="85" endline="98" pcid="15239">
        {
            // We could not use realtimeSinceStartUp since it is set to 0 when entering/exitting playmode, we assume an increasing time when comparing time.
            long nowMilliSeconds = System.DateTime.Now.Ticks / System.TimeSpan.TicksPerMillisecond;
            bool justClosed = nowMilliSeconds < s_LastClosedTime + 50;
            if (!justClosed)
            {
                Event.current.Use();
                if (s_LayerVisibilityWindow == null)
                    s_LayerVisibilityWindow = CreateInstance<LayerVisibilityWindow>();
                s_LayerVisibilityWindow.Init(buttonRect);
                return true;
            }
            return false;
        }
</source>
<source file="UnityCsReference/Editor/Mono/Annotation/AnnotationWindow.cs.ifdefed" startline="153" endline="166" pcid="15152">
        {
            // We could not use realtimeSinceStartUp since it is set to 0 when entering/exitting playmode, we assume an increasing time when comparing time.
            long nowMilliSeconds = System.DateTime.Now.Ticks / System.TimeSpan.TicksPerMillisecond;
            bool justClosed = nowMilliSeconds < s_LastClosedTime + 50;
            if (!justClosed)
            {
                Event.current.Use();
                if (s_AnnotationWindow == null)
                    s_AnnotationWindow = ScriptableObject.CreateInstance<AnnotationWindow>();
                s_AnnotationWindow.Init(buttonRect, isGameView);
                return true;
            }
            return false;
        }
</source>
</class>

<class classid="21" nclones="4" nlines="10" similarity="70">
<source file="UnityCsReference/Editor/Mono/BuildPipeline/BuildPipelineInterfaces.cs.ifdefed" startline="411" endline="423" pcid="6452">
            {
                foreach (IActiveBuildTargetChanged abtc in processors.buildTargetProcessors)
                {
                    try
                    {
                        abtc.OnActiveBuildTargetChanged(previousPlatform, newPlatform);
                    }
                    catch (Exception e)
                    {
                        Debug.LogException(e);
                    }
                }
            }
</source>
<source file="UnityCsReference/Editor/Mono/BuildPipeline/BuildPipelineInterfaces.cs.ifdefed" startline="453" endline="464" pcid="6463">
                {
                    try
                    {
                        step.OnPostBuildPlayerScriptDLLs(report);
                    }
                    catch (Exception e)
                    {
                        Debug.LogException(e);
                        if ((report.summary.options & BuildOptions.StrictMode) != 0 || (report.summary.assetBundleOptions & BuildAssetBundleOptions.StrictMode) != 0)
                            return;
                    }
                }
</source>
<source file="UnityCsReference/Editor/Mono/BuildPipeline/BuildPipelineInterfaces.cs.ifdefed" startline="431" endline="443" pcid="6457">
            {
                foreach (IPreprocessShaders abtc in processors.shaderProcessors)
                {
                    try
                    {
                        abtc.OnProcessShader(shader, snippet, dataList);
                    }
                    catch (Exception e)
                    {
                        Debug.LogException(e);
                    }
                }
            }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/AssemblyDefinitionImporterInspector.cs.ifdefed" startline="85" endline="96" pcid="30804">
            {
                try
                {
                    LoadAssemblyDefinitionFiles();
                }
                catch (Exception e)
                {
                    m_State = null;
                    ShowLoadErrorExceptionGUI(e);
                    return;
                }
            }
</source>
</class>

<class classid="22" nclones="2" nlines="11" similarity="81">
<source file="UnityCsReference/Editor/Mono/BuildPipeline/MonoAssemblyStripping.cs.ifdefed" startline="70" endline="80" pcid="6477">
        {
            Process p = process as Process;
            try
            {
                using (StreamReader outp = p.StandardOutput)
                {
                    Output.Append(outp.ReadToEnd());
                }
            }
            catch (ThreadAbortException) {}
        }
</source>
<source file="UnityCsReference/Editor/Mono/BuildPipeline/MonoAssemblyStripping.cs.ifdefed" startline="83" endline="93" pcid="6481">
        {
            Process p = process as Process;
            try
            {
                using (StreamReader err = p.StandardError)
                {
                    Error.Append(err.ReadToEnd());
                }
            }
            catch (ThreadAbortException) {}
        }
</source>
</class>

<class classid="23" nclones="2" nlines="14" similarity="85">
<source file="UnityCsReference/Editor/Mono/BuildPipeline/MonoAssemblyStripping.cs.ifdefed" startline="122" endline="142" pcid="6488">
        {
            var process = new Process();

            var executableName = Application.platform == RuntimePlatform.WindowsEditor ? "mono.exe" : "mono";
            process.StartInfo.FileName = Paths.Combine(MonoInstallationFinder.GetMonoInstallation(), "bin", executableName);

            // ;; TODO fix this hack for strange process handle duplication problem inside mono
            process.StartInfo.EnvironmentVariables["_WAPI_PROCESS_HANDLE_OFFSET"] = "5";

            // We run the linker on .NET 2.0 profile
            var monoProfile = BuildPipeline.CompatibilityProfileToClassLibFolder(ApiCompatibilityLevel.NET_2_0);
            process.StartInfo.EnvironmentVariables["MONO_PATH"] = MonoInstallationFinder.GetProfileDirectory(monoProfile);
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.RedirectStandardOutput = true;
            process.StartInfo.RedirectStandardError = true;
            process.StartInfo.CreateNoWindow = true;

            process.StartInfo.WorkingDirectory = workDir;

            return process;
        }
</source>
<source file="UnityCsReference/Editor/Mono/BuildPipeline/MonoAssemblyStripping.cs.ifdefed" startline="145" endline="165" pcid="6489">
        {
            var process = new Process();

            var executableName = Application.platform == RuntimePlatform.WindowsEditor ? "mono.exe" : "mono";
            process.StartInfo.FileName = Paths.Combine(MonoInstallationFinder.GetMonoBleedingEdgeInstallation(), "bin", executableName);

            // ;; TODO fix this hack for strange process handle duplication problem inside mono
            process.StartInfo.EnvironmentVariables["_WAPI_PROCESS_HANDLE_OFFSET"] = "5";

            // We run the stripper on .NET 4.6 profile
            var monoProfile = BuildPipeline.CompatibilityProfileToClassLibFolder(ApiCompatibilityLevel.NET_4_6);
            process.StartInfo.EnvironmentVariables["MONO_PATH"] = MonoInstallationFinder.GetProfileDirectory(monoProfile);
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.RedirectStandardOutput = true;
            process.StartInfo.RedirectStandardError = true;
            process.StartInfo.CreateNoWindow = true;

            process.StartInfo.WorkingDirectory = workDir;

            return process;
        }
</source>
</class>

<class classid="24" nclones="2" nlines="15" similarity="75">
<source file="UnityCsReference/Editor/Mono/EditorWindow.cs.ifdefed" startline="441" endline="457" pcid="6728">
        {
            if (m_Parent == null)
            {
                ContainerWindow cw = ScriptableObject.CreateInstance<ContainerWindow>();
                cw.title = titleContent.text;
                HostView host = ScriptableObject.CreateInstance<HostView>();
                host.actualView = this;

                Rect r = m_Parent.borderSize.Add(new Rect(position.x, position.y, position.width, position.height));
                // Order is important here: first set rect of container, then assign main view, then apply various settings, then show.
                // Otherwise the rect won't be set until first resize happens.
                cw.position = r;
                cw.rootView = host;
                MakeParentsSettingsMatchMe();
                cw.ShowPopup();
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/EditorWindow.cs.ifdefed" startline="460" endline="482" pcid="6730">
        {
            if (m_Parent == null)
            {
                SavedGUIState oldState = SavedGUIState.Create();

                ContainerWindow cw = ScriptableObject.CreateInstance<ContainerWindow>();
                cw.title = titleContent.text;
                HostView host = ScriptableObject.CreateInstance<HostView>();
                host.actualView = this;

                Rect r = m_Parent.borderSize.Add(new Rect(position.x, position.y, position.width, position.height));
                // Order is important here: first set rect of container, then assign main view, then apply various settings, then show.
                // Otherwise the rect won't be set until first resize happens.
                cw.position = r;
                cw.rootView = host;
                MakeParentsSettingsMatchMe();
                cw.Show(mode, true, false);
                // set min/max size now that native window is not null so that it will e.g., use proper styleMask on macOS
                cw.SetMinMaxSizes(minSize, maxSize);

                oldState.ApplyAndForget();
            }
        }
</source>
</class>

<class classid="25" nclones="2" nlines="19" similarity="78">
<source file="UnityCsReference/Editor/Mono/EditorWindow.cs.ifdefed" startline="569" endline="591" pcid="6740">
        {
            UnityEngine.Object[] wins = Resources.FindObjectsOfTypeAll(t);
            EditorWindow win = wins.Length > 0 ? (EditorWindow)(wins[0]) : null;

            if (!win)
            {
                win = ScriptableObject.CreateInstance(t) as EditorWindow;
                if (title != null)
                    win.titleContent = new GUIContent(title);
                if (utility)
                    win.ShowUtility();
                else
                    win.Show();
            }
            else if (focus)
            {
                win.Show();  // For some corner cases in saved layouts, the window can be in an unvisible state.
                             // Since the caller asked for focus, it's fair to assume he wants it always to be visible. (case 586743)
                win.Focus();
            }

            return win;
        }
</source>
<source file="UnityCsReference/Editor/Mono/EditorWindow.cs.ifdefed" startline="740" endline="761" pcid="6768">
        {
            UnityEngine.Object[] wins = Resources.FindObjectsOfTypeAll(t);
            EditorWindow win = wins.Length > 0 ? (EditorWindow)(wins[0]) : null;

            if (!win)
            {
                win = ScriptableObject.CreateInstance(t) as EditorWindow;
                win.minSize = new Vector2(rect.width, rect.height);
                win.maxSize = new Vector2(rect.width, rect.height);
                win.position = rect;
                if (title != null)
                    win.titleContent = new GUIContent(title);
                if (utility)
                    win.ShowUtility();
                else
                    win.Show();
            }
            else
                win.Focus();

            return win;
        }
</source>
</class>

<class classid="26" nclones="2" nlines="11" similarity="72">
<source file="UnityCsReference/Editor/Mono/ObjectListArea.cs.ifdefed" startline="1411" endline="1426" pcid="7315">
            {
                foreach (Group g in m_Groups)
                {
                    if (SkipGroup(g))
                        continue;

                    g.ListMode = true;
                    UpdateGroupSizes(g);

                    // ShowNone is only used in object select window and we don't want aiy sset store asset there
                    if (m_LocalAssets.ShowNone)
                        break;
                }

                m_ResizePreviewCacheTo = Mathf.CeilToInt((float)m_TotalRect.height / kListLineHeight) + 10;
            }
</source>
<source file="UnityCsReference/Editor/Mono/ObjectListArea.cs.ifdefed" startline="1450" endline="1465" pcid="7319">
                {
                    // Make room for the scrollbar
                    foreach (Group g in m_Groups)
                    {
                        if (SkipGroup(g))
                            continue;

                        g.m_Grid.fixedWidth = m_TotalRect.width - kSpaceForScrollBar;
                        g.m_Grid.InitNumRowsAndColumns(g.ItemCount, g.m_Grid.CalcRows(g.ItemsWantedShown));
                        g.UpdateHeight();

                        // ShowNone is only used in object select window and we don't want asset store asset there
                        if (m_LocalAssets.ShowNone)
                            break;
                    }
                }
</source>
</class>

<class classid="27" nclones="3" nlines="49" similarity="71">
<source file="UnityCsReference/Editor/Mono/SpriteEditor/SpriteEditorHandles.cs.ifdefed" startline="50" endline="106" pcid="7434">
        {
            Vector2 screenVal = Handles.matrix.MultiplyPoint(pos);

            Event evt = Event.current;
            switch (evt.GetTypeForControl(id))
            {
                case EventType.MouseDown:
                    // am I closest to the thingy?
                    if (evt.button == 0 &&
                        cursorRect.Contains(Event.current.mousePosition) &&
                        !evt.alt)
                    {
                        GUIUtility.hotControl = GUIUtility.keyboardControl = id;    // Grab mouse focus
                        s_CurrentMousePosition = evt.mousePosition;
                        s_DragStartScreenPosition = evt.mousePosition;
                        s_DragScreenOffset = s_CurrentMousePosition - screenVal;
                        evt.Use();
                        EditorGUIUtility.SetWantsMouseJumping(1);
                    }
                    break;
                case EventType.MouseDrag:
                    if (GUIUtility.hotControl == id)
                    {
                        s_CurrentMousePosition += evt.delta;
                        Vector2 oldPos = pos;
                        pos = Handles.inverseMatrix.MultiplyPoint(s_CurrentMousePosition);
                        if (!Mathf.Approximately((oldPos - pos).magnitude, 0f))
                            GUI.changed = true;
                        evt.Use();
                    }
                    break;
                case EventType.MouseUp:
                    if (GUIUtility.hotControl == id && (evt.button == 0 || evt.button == 2))
                    {
                        GUIUtility.hotControl = 0;
                        evt.Use();
                        EditorGUIUtility.SetWantsMouseJumping(0);
                    }
                    break;
                case EventType.KeyDown:
                    if (GUIUtility.hotControl == id)
                    {
                        if (evt.keyCode == KeyCode.Escape)
                        {
                            pos = Handles.inverseMatrix.MultiplyPoint(s_DragStartScreenPosition - s_DragScreenOffset);
                            GUIUtility.hotControl = 0;
                            GUI.changed = true;
                            evt.Use();
                        }
                    }
                    break;
                case EventType.Repaint:
                    EditorGUIUtility.AddCursorRect(cursorRect, cursor, id);
                    break;
            }
            return pos;
        }
</source>
<source file="UnityCsReference/Editor/Mono/SpriteEditor/SpriteEditorHandles.cs.ifdefed" startline="190" endline="253" pcid="7446">
        {
            int id = GUIUtility.GetControlID("SliderRect".GetHashCode(), FocusType.Keyboard);

            Event evt = Event.current;

            // SpriteEditorWindow is telling us we got selected and so we fake a mousedown on our Repaint event to get "one-click dragging" going on
            if (SpriteEditorWindow.s_OneClickDragStarted && evt.type == EventType.Repaint)
            {
                HandleSliderRectMouseDown(id, evt, pos);
                SpriteEditorWindow.s_OneClickDragStarted = false;
            }

            switch (evt.GetTypeForControl(id))
            {
                case EventType.MouseDown:
                    // am I closest to the thingy?
                    if (evt.button == 0 && pos.Contains(Handles.inverseMatrix.MultiplyPoint(Event.current.mousePosition)) && !evt.alt)
                    {
                        HandleSliderRectMouseDown(id, evt, pos);
                        evt.Use();
                    }
                    break;
                case EventType.MouseDrag:
                    if (GUIUtility.hotControl == id)
                    {
                        s_CurrentMousePosition += evt.delta;

                        Vector2 oldCenter = pos.center;
                        pos.center = Handles.inverseMatrix.MultiplyPoint(s_CurrentMousePosition - s_DragScreenOffset);
                        if (!Mathf.Approximately((oldCenter - pos.center).magnitude, 0f))
                            GUI.changed = true;

                        evt.Use();
                    }
                    break;
                case EventType.MouseUp:
                    if (GUIUtility.hotControl == id && (evt.button == 0 || evt.button == 2))
                    {
                        GUIUtility.hotControl = 0;
                        evt.Use();
                        EditorGUIUtility.SetWantsMouseJumping(0);
                    }
                    break;
                case EventType.KeyDown:
                    if (GUIUtility.hotControl == id)
                    {
                        if (evt.keyCode == KeyCode.Escape)
                        {
                            pos.center = Handles.inverseMatrix.MultiplyPoint(s_DragStartScreenPosition - s_DragScreenOffset);
                            GUIUtility.hotControl = 0;
                            GUI.changed = true;
                            evt.Use();
                        }
                    }
                    break;
                case EventType.Repaint:
                    Vector2 topleft = Handles.inverseMatrix.MultiplyPoint(new Vector2(pos.xMin, pos.yMin));
                    Vector2 bottomright = Handles.inverseMatrix.MultiplyPoint(new Vector2(pos.xMax, pos.yMax));
                    EditorGUIUtility.AddCursorRect(new Rect(topleft.x, topleft.y, bottomright.x - topleft.x, bottomright.y - topleft.y), MouseCursor.Arrow, id);
                    break;
            }

            return pos;
        }
</source>
<source file="UnityCsReference/Editor/Mono/SpriteEditor/SpriteEditorHandles.cs.ifdefed" startline="109" endline="187" pcid="7440">
        {
            int id = GUIUtility.GetControlID("Slider1D".GetHashCode(), FocusType.Keyboard);

            // Convert from normalized space to texture space
            pos = new Vector2(sprite.xMin + sprite.width * pos.x, sprite.yMin + sprite.height * pos.y);

            Vector2 screenVal = Handles.matrix.MultiplyPoint(pos);

            Rect handleScreenPos = new Rect(
                    screenVal.x - pivotDot.fixedWidth * .5f,
                    screenVal.y - pivotDot.fixedHeight * .5f,
                    pivotDotActive.fixedWidth,
                    pivotDotActive.fixedHeight
                    );

            Event evt = Event.current;
            switch (evt.GetTypeForControl(id))
            {
                case EventType.MouseDown:
                    // am I closest to the thingy?
                    if (evt.button == 0 && handleScreenPos.Contains(Event.current.mousePosition) && !evt.alt)
                    {
                        GUIUtility.hotControl = GUIUtility.keyboardControl = id;    // Grab mouse focus
                        s_CurrentMousePosition = evt.mousePosition;
                        s_DragStartScreenPosition = evt.mousePosition;
                        Vector2 rectScreenCenter = Handles.matrix.MultiplyPoint(pos);
                        s_DragScreenOffset = s_CurrentMousePosition - rectScreenCenter;
                        evt.Use();
                        EditorGUIUtility.SetWantsMouseJumping(1);
                    }
                    break;
                case EventType.MouseDrag:
                    if (GUIUtility.hotControl == id)
                    {
                        s_CurrentMousePosition += evt.delta;
                        Vector2 oldPos = pos;
                        Vector3 scrPos = Handles.inverseMatrix.MultiplyPoint(s_CurrentMousePosition - s_DragScreenOffset);
                        pos = new Vector2(scrPos.x, scrPos.y);
                        if (!Mathf.Approximately((oldPos - pos).magnitude, 0f))
                            GUI.changed = true;
                        evt.Use();
                    }
                    break;
                case EventType.MouseUp:
                    if (GUIUtility.hotControl == id && (evt.button == 0 || evt.button == 2))
                    {
                        GUIUtility.hotControl = 0;
                        evt.Use();
                        EditorGUIUtility.SetWantsMouseJumping(0);
                    }
                    break;
                case EventType.KeyDown:
                    if (GUIUtility.hotControl == id)
                    {
                        if (evt.keyCode == KeyCode.Escape)
                        {
                            pos = Handles.inverseMatrix.MultiplyPoint(s_DragStartScreenPosition - s_DragScreenOffset);
                            GUIUtility.hotControl = 0;
                            GUI.changed = true;
                            evt.Use();
                        }
                    }
                    break;
                case EventType.Repaint:
                    EditorGUIUtility.AddCursorRect(handleScreenPos, MouseCursor.Arrow, id);

                    if (GUIUtility.hotControl == id)
                        pivotDotActive.Draw(handleScreenPos, GUIContent.none, id);
                    else
                        pivotDot.Draw(handleScreenPos, GUIContent.none, id);

                    break;
            }

            // Convert from texture space back to normalized space
            pos = new Vector2((pos.x - sprite.xMin) / sprite.width, (pos.y - sprite.yMin) / sprite.height);

            return pos;
        }
</source>
</class>

<class classid="28" nclones="3" nlines="10" similarity="80">
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/DopeSheetEditor.cs.ifdefed" startline="141" endline="154" pcid="7888">
            {
                // Control point has a specific texture (sprite image).
                // This will not be batched rendered and must be handled separately.
                if (element.texture != null)
                {
                    m_UnselectedKeysDrawBuffer.Add(element);
                }
                else
                {
                    Rect rect = element.position;
                    rect.size = new Vector2(m_DefaultDopeKeyIcon.width, m_DefaultDopeKeyIcon.height);
                    m_UnselectedKeysRenderer.AddPoint(rect, element.color);
                }
            }
</source>
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/DopeSheetEditor.cs.ifdefed" startline="157" endline="170" pcid="7891">
            {
                // Control point has a specific texture (sprite image).
                // This will not be batched rendered and must be handled separately.
                if (element.texture != null)
                {
                    m_SelectedKeysDrawBuffer.Add(element);
                }
                else
                {
                    Rect rect = element.position;
                    rect.size = new Vector2(m_DefaultDopeKeyIcon.width, m_DefaultDopeKeyIcon.height);
                    m_SelectedKeysRenderer.AddPoint(rect, element.color);
                }
            }
</source>
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/DopeSheetEditor.cs.ifdefed" startline="173" endline="186" pcid="7894">
            {
                // Control point has a specific texture (sprite image).
                // This will not be batched rendered and must be handled separately.
                if (element.texture != null)
                {
                    m_DragDropKeysDrawBuffer.Add(element);
                }
                else
                {
                    Rect rect = element.position;
                    rect.size = new Vector2(m_DefaultDopeKeyIcon.width, m_DefaultDopeKeyIcon.height);
                    m_DragDropKeysRenderer.AddPoint(rect, element.color);
                }
            }
</source>
</class>

<class classid="29" nclones="10" nlines="21" similarity="71">
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/CurveEditorRectangleTool.cs.ifdefed" startline="156" endline="179" pcid="8069">
            {
                m_HBarLeft = new AreaManipulator(styles.rectangleToolHBarLeft, MouseCursor.ResizeHorizontal);

                m_HBarLeft.onStartDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        if (hasSelection && manipulator.rect.Contains(evt.mousePosition))
                        {
                            OnStartScale(ToolCoord.Right, ToolCoord.Left, new Vector2(PixelToTime(evt.mousePosition.x, frameRate), 0f), DragMode.ScaleHorizontal, rippleTimeClutch);
                            return true;
                        }

                        return false;
                    };
                m_HBarLeft.onDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        OnScaleTime(PixelToTime(evt.mousePosition.x, frameRate));
                        return true;
                    };
                m_HBarLeft.onEndDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        OnEndScale();
                        return true;
                    };
            }
</source>
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/CurveEditorRectangleTool.cs.ifdefed" startline="402" endline="425" pcid="8115">
            {
                m_SelectionScaleBottom = new AreaManipulator(styles.rectangleToolScaleBottom, MouseCursor.ResizeVertical);

                m_SelectionScaleBottom.onStartDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        if (hasSelection && manipulator.rect.Contains(evt.mousePosition))
                        {
                            OnStartScale(ToolCoord.Top, ToolCoord.Bottom, new Vector2(0f, PixelToValue(evt.mousePosition.y)), DragMode.ScaleVertical, false);
                            return true;
                        }

                        return false;
                    };
                m_SelectionScaleBottom.onDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        OnScaleValue(PixelToValue(evt.mousePosition.y));
                        return true;
                    };
                m_SelectionScaleBottom.onEndDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        OnEndScale();
                        return true;
                    };
            }
</source>
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/CurveEditorRectangleTool.cs.ifdefed" startline="428" endline="451" pcid="8120">
            {
                m_SelectionScaleTop = new AreaManipulator(styles.rectangleToolScaleTop, MouseCursor.ResizeVertical);

                m_SelectionScaleTop.onStartDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        if (hasSelection && manipulator.rect.Contains(evt.mousePosition))
                        {
                            OnStartScale(ToolCoord.Bottom, ToolCoord.Top, new Vector2(0f, PixelToValue(evt.mousePosition.y)), DragMode.ScaleVertical, false);
                            return true;
                        }

                        return false;
                    };
                m_SelectionScaleTop.onDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        OnScaleValue(PixelToValue(evt.mousePosition.y));
                        return true;
                    };
                m_SelectionScaleTop.onEndDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        OnEndScale();
                        return true;
                    };
            }
</source>
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/DopeSheetEditorRectangleTool.cs.ifdefed" startline="133" endline="156" pcid="10162">
            {
                m_SelectionScaleRight = new AreaManipulator(styles.dopesheetScaleRight, MouseCursor.ResizeHorizontal);

                m_SelectionScaleRight.onStartDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        if (hasSelection && manipulator.rect.Contains(evt.mousePosition))
                        {
                            OnStartScale(ToolCoord.Left, ToolCoord.Right, new Vector2(PixelToTime(evt.mousePosition.x, frameRate), 0f), rippleTimeClutch);
                            return true;
                        }

                        return false;
                    };
                m_SelectionScaleRight.onDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        OnScaleTime(PixelToTime(evt.mousePosition.x, frameRate));
                        return true;
                    };
                m_SelectionScaleRight.onEndDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        OnEndScale();
                        return true;
                    };
            }
</source>
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/CurveEditorRectangleTool.cs.ifdefed" startline="260" endline="283" pcid="8089">
            {
                m_VBarTop = new AreaManipulator(styles.rectangleToolVBarTop, MouseCursor.ResizeVertical);

                m_VBarTop.onStartDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        if (hasSelection && manipulator.rect.Contains(evt.mousePosition))
                        {
                            OnStartScale(ToolCoord.Bottom, ToolCoord.Top, new Vector2(0f, PixelToValue(evt.mousePosition.y)), DragMode.ScaleVertical, false);
                            return true;
                        }

                        return false;
                    };
                m_VBarTop.onDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        OnScaleValue(PixelToValue(evt.mousePosition.y));
                        return true;
                    };
                m_VBarTop.onEndDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        OnEndScale();
                        return true;
                    };
            }
</source>
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/DopeSheetEditorRectangleTool.cs.ifdefed" startline="107" endline="130" pcid="10157">
            {
                m_SelectionScaleLeft = new AreaManipulator(styles.dopesheetScaleLeft, MouseCursor.ResizeHorizontal);

                m_SelectionScaleLeft.onStartDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        if (hasSelection && manipulator.rect.Contains(evt.mousePosition))
                        {
                            OnStartScale(ToolCoord.Right, ToolCoord.Left, new Vector2(PixelToTime(evt.mousePosition.x, frameRate), 0f), rippleTimeClutch);
                            return true;
                        }

                        return false;
                    };
                m_SelectionScaleLeft.onDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        OnScaleTime(PixelToTime(evt.mousePosition.x, frameRate));
                        return true;
                    };
                m_SelectionScaleLeft.onEndDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        OnEndScale();
                        return true;
                    };
            }
</source>
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/CurveEditorRectangleTool.cs.ifdefed" startline="182" endline="205" pcid="8074">
            {
                m_HBarRight = new AreaManipulator(styles.rectangleToolHBarRight, MouseCursor.ResizeHorizontal);

                m_HBarRight.onStartDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        if (hasSelection && manipulator.rect.Contains(evt.mousePosition))
                        {
                            OnStartScale(ToolCoord.Left, ToolCoord.Right, new Vector2(PixelToTime(evt.mousePosition.x, frameRate), 0f), DragMode.ScaleHorizontal, rippleTimeClutch);
                            return true;
                        }

                        return false;
                    };
                m_HBarRight.onDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        OnScaleTime(PixelToTime(evt.mousePosition.x, frameRate));
                        return true;
                    };
                m_HBarRight.onEndDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        OnEndScale();
                        return true;
                    };
            }
</source>
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/CurveEditorRectangleTool.cs.ifdefed" startline="350" endline="373" pcid="8105">
            {
                m_SelectionScaleLeft = new AreaManipulator(styles.rectangleToolScaleLeft, MouseCursor.ResizeHorizontal);

                m_SelectionScaleLeft.onStartDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        if (hasSelection && manipulator.rect.Contains(evt.mousePosition))
                        {
                            OnStartScale(ToolCoord.Right, ToolCoord.Left, new Vector2(PixelToTime(evt.mousePosition.x, frameRate), 0f), DragMode.ScaleHorizontal, rippleTimeClutch);
                            return true;
                        }

                        return false;
                    };
                m_SelectionScaleLeft.onDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        OnScaleTime(PixelToTime(evt.mousePosition.x, frameRate));
                        return true;
                    };
                m_SelectionScaleLeft.onEndDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        OnEndScale();
                        return true;
                    };
            }
</source>
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/CurveEditorRectangleTool.cs.ifdefed" startline="234" endline="257" pcid="8084">
            {
                m_VBarBottom = new AreaManipulator(styles.rectangleToolVBarBottom, MouseCursor.ResizeVertical);

                m_VBarBottom.onStartDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        if (hasSelection && manipulator.rect.Contains(evt.mousePosition))
                        {
                            OnStartScale(ToolCoord.Top, ToolCoord.Bottom, new Vector2(0f, PixelToValue(evt.mousePosition.y)), DragMode.ScaleVertical, false);
                            return true;
                        }

                        return false;
                    };
                m_VBarBottom.onDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        OnScaleValue(PixelToValue(evt.mousePosition.y));
                        return true;
                    };
                m_VBarBottom.onEndDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        OnEndScale();
                        return true;
                    };
            }
</source>
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/CurveEditorRectangleTool.cs.ifdefed" startline="376" endline="399" pcid="8110">
            {
                m_SelectionScaleRight = new AreaManipulator(styles.rectangleToolScaleRight, MouseCursor.ResizeHorizontal);

                m_SelectionScaleRight.onStartDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        if (hasSelection && manipulator.rect.Contains(evt.mousePosition))
                        {
                            OnStartScale(ToolCoord.Left, ToolCoord.Right, new Vector2(PixelToTime(evt.mousePosition.x, frameRate), 0f), DragMode.ScaleHorizontal, rippleTimeClutch);
                            return true;
                        }

                        return false;
                    };
                m_SelectionScaleRight.onDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        OnScaleTime(PixelToTime(evt.mousePosition.x, frameRate));
                        return true;
                    };
                m_SelectionScaleRight.onEndDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        OnEndScale();
                        return true;
                    };
            }
</source>
</class>

<class classid="30" nclones="2" nlines="21" similarity="71">
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/CurveEditorRectangleTool.cs.ifdefed" startline="208" endline="231" pcid="8079">
            {
                m_HBar = new AreaManipulator(styles.rectangleToolHBar, MouseCursor.MoveArrow);

                m_HBar.onStartDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        if (hasSelection && manipulator.rect.Contains(evt.mousePosition))
                        {
                            OnStartMove(new Vector2(PixelToTime(evt.mousePosition.x, frameRate), 0f), DragMode.MoveHorizontal, rippleTimeClutch);
                            return true;
                        }

                        return false;
                    };
                m_HBar.onDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        OnMove(new Vector2(PixelToTime(evt.mousePosition.x, frameRate), 0f));
                        return true;
                    };
                m_HBar.onEndDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        OnEndMove();
                        return true;
                    };
            }
</source>
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/CurveEditorRectangleTool.cs.ifdefed" startline="286" endline="309" pcid="8094">
            {
                m_VBar = new AreaManipulator(styles.rectangleToolVBar, MouseCursor.MoveArrow);

                m_VBar.onStartDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        if (hasSelection && manipulator.rect.Contains(evt.mousePosition))
                        {
                            OnStartMove(new Vector2(0f, PixelToValue(evt.mousePosition.y)), DragMode.MoveVertical, false);
                            return true;
                        }

                        return false;
                    };
                m_VBar.onDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        OnMove(new Vector2(0f, PixelToValue(evt.mousePosition.y)));
                        return true;
                    };
                m_VBar.onEndDrag += (AnimationWindowManipulator manipulator, Event evt) =>
                    {
                        OnEndMove();
                        return true;
                    };
            }
</source>
</class>

<class classid="31" nclones="2" nlines="11" similarity="81">
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/CurveEditorRectangleTool.cs.ifdefed" startline="765" endline="776" pcid="8159">
        {
            Bounds bounds = selectionBounds;
            m_DragMode = dragMode;
            m_Pivot = ToolCoordToPosition(pivotCoord, bounds);
            m_Previous = ToolCoordToPosition(pickedCoord, bounds);
            m_MouseOffset = mousePos - m_Previous;
            m_RippleTime = rippleTime;
            m_RippleTimeStart = bounds.min.x;
            m_RippleTimeEnd = bounds.max.x;

            m_CurveEditor.StartLiveEdit();
        }
</source>
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/DopeSheetEditorRectangleTool.cs.ifdefed" startline="291" endline="303" pcid="10182">
        {
            Bounds bounds = selectionBounds;

            m_IsDragging = true;
            m_Pivot = ToolCoordToPosition(pivotCoord, bounds);
            m_Previous = ToolCoordToPosition(pickedCoord, bounds);
            m_MouseOffset = mousePos - m_Previous;
            m_RippleTime = rippleTime;
            m_RippleTimeStart = bounds.min.x;
            m_RippleTimeEnd = bounds.max.x;

            m_State.StartLiveEdit();
        }
</source>
</class>

<class classid="32" nclones="2" nlines="13" similarity="92">
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/CurveRenderer/NormalCurveRenderer.cs.ifdefed" startline="376" endline="393" pcid="8221">
            {
                mat.SetPass(0);
                for (int r = minRep; r < 0; ++r)
                {
                    //  Even loop
                    if (r % 2 == 0)
                    {
                        Matrix4x4 shiftTransform = Matrix4x4.TRS(new Vector3(r * (rangeEnd - rangeStart), 0.0f, 0.0f), Quaternion.identity, Vector3.one);
                        Graphics.DrawMeshNow(mesh, Handles.matrix * transform * shiftTransform);
                    }
                    //  Odd loop
                    else
                    {
                        Matrix4x4 shiftTransform = Matrix4x4.TRS(new Vector3((r + 1) * (rangeEnd - rangeStart) + rangeStart * 2, 0.0f, 0.0f), Quaternion.identity, new Vector3(-1.0f, 1.0f, 1.0f));
                        Graphics.DrawMeshNow(mesh, Handles.matrix * transform * shiftTransform);
                    }
                }
            }
</source>
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/CurveRenderer/NormalCurveRenderer.cs.ifdefed" startline="436" endline="453" pcid="8230">
            {
                mat.SetPass(0);
                for (int r = 1; r <= maxRep; ++r)
                {
                    //  Even loop
                    if (r % 2 == 0)
                    {
                        Matrix4x4 shiftTransform = Matrix4x4.TRS(new Vector3(r * (rangeEnd - rangeStart), 0.0f, 0.0f), Quaternion.identity, Vector3.one);
                        Graphics.DrawMeshNow(mesh, Handles.matrix * transform * shiftTransform);
                    }
                    //  Odd loop
                    else
                    {
                        Matrix4x4 shiftTransform = Matrix4x4.TRS(new Vector3((r + 1) * (rangeEnd - rangeStart) + rangeStart * 2, 0.0f, 0.0f), Quaternion.identity, new Vector3(-1.0f, 1.0f, 1.0f));
                        Graphics.DrawMeshNow(mesh, Handles.matrix * transform * shiftTransform);
                    }
                }
            }
</source>
</class>

<class classid="33" nclones="2" nlines="13" similarity="84">
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/CurveRenderer/NormalCurveRenderer.cs.ifdefed" startline="511" endline="525" pcid="8240">
            {
                line = new List<Vector3>();
                for (int r = minRep; r < 0; r++)
                {
                    for (int i = 0; i < points.Length; i++)
                    {
                        Vector3 point = points[i];
                        point.x += r * (rangeEnd - rangeStart);
                        point = transform.MultiplyPoint(point);
                        line.Add(point);
                    }
                }
                line.Add(transform.MultiplyPoint(points[0]));
                Handles.DrawPolyLine(line.ToArray());
            }
</source>
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/CurveRenderer/NormalCurveRenderer.cs.ifdefed" startline="564" endline="578" pcid="8250">
            {
                line = new List<Vector3>();
                line.Add(transform.MultiplyPoint(points[last]));
                for (int r = 1; r <= maxRep; r++)
                {
                    for (int i = 0; i < points.Length; i++)
                    {
                        Vector3 point = points[i];
                        point.x += r * (rangeEnd - rangeStart);
                        point = transform.MultiplyPoint(point);
                        line.Add(point);
                    }
                }
                Handles.DrawPolyLine(line.ToArray());
            }
</source>
</class>

<class classid="34" nclones="2" nlines="20" similarity="95">
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/CurveRenderer/NormalCurveRenderer.cs.ifdefed" startline="527" endline="550" pcid="8243">
            {
                line = new List<Vector3>();
                for (int r = minRep; r < 0; r++)
                {
                    for (int i = 0; i < points.Length; i++)
                    {
                        if (r / 2 == r / 2f)
                        {
                            Vector3 point = points[i];
                            point.x += r * (rangeEnd - rangeStart);
                            point = transform.MultiplyPoint(point);
                            line.Add(point);
                        }
                        else
                        {
                            Vector3 point = points[last - i];
                            point.x = -point.x + (r + 1) * (rangeEnd - rangeStart) + rangeStart * 2;
                            point = transform.MultiplyPoint(point);
                            line.Add(point);
                        }
                    }
                }
                Handles.DrawPolyLine(line.ToArray());
            }
</source>
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/CurveRenderer/NormalCurveRenderer.cs.ifdefed" startline="580" endline="603" pcid="8253">
            {
                line = new List<Vector3>();
                for (int r = 1; r <= maxRep; r++)
                {
                    for (int i = 0; i < points.Length; i++)
                    {
                        if (r / 2 == r / 2f)
                        {
                            Vector3 point = points[i];
                            point.x += r * (rangeEnd - rangeStart);
                            point = transform.MultiplyPoint(point);
                            line.Add(point);
                        }
                        else
                        {
                            Vector3 point = points[last - i];
                            point.x = -point.x + (r + 1) * (rangeEnd - rangeStart) + rangeStart * 2;
                            point = transform.MultiplyPoint(point);
                            line.Add(point);
                        }
                    }
                }
                Handles.DrawPolyLine(line.ToArray());
            }
</source>
</class>

<class classid="35" nclones="2" nlines="25" similarity="76">
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/MinMaxCurveEditorWindow.cs.ifdefed" startline="60" endline="89" pcid="8339">
        {
            m_CurveEditor = new CurveEditor(GetCurveEditorRect(), GetCurveWrapperArray(), true);
            m_CurveEditor.curvesUpdated = UpdateCurve;
            m_CurveEditor.scaleWithWindow = true;
            m_CurveEditor.margin = 40;
            if (settings != null)
                m_CurveEditor.settings = settings;
            m_CurveEditor.settings.hTickLabelOffset = 10;
            m_CurveEditor.settings.rectangleToolFlags = CurveEditorSettings.RectangleToolFlags.MiniRectangleTool;
            m_CurveEditor.settings.undoRedoSelection = true;
            m_CurveEditor.settings.showWrapperPopups = true;
            UpdateRegionDomain();

            // For each of horizontal and vertical axis, if we have a finite range for that axis, use that range,
            // otherwise use framing logic to determine shown range for that axis.
            bool frameH = true;
            bool frameV = true;
            if (!float.IsNegativeInfinity(m_CurveEditor.settings.hRangeMin) && !float.IsInfinity(m_CurveEditor.settings.hRangeMax))
            {
                m_CurveEditor.SetShownHRangeInsideMargins(m_CurveEditor.settings.hRangeMin, m_CurveEditor.settings.hRangeMax);
                frameH = false;
            }
            if (!float.IsNegativeInfinity(m_CurveEditor.settings.vRangeMin) && !float.IsInfinity(m_CurveEditor.settings.vRangeMax))
            {
                m_CurveEditor.SetShownVRangeInsideMargins(m_CurveEditor.settings.vRangeMin, m_CurveEditor.settings.vRangeMax);
                frameV = false;
            }

            m_CurveEditor.FrameSelected(frameH, frameV);
        }
</source>
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/CurveEditorWindow.cs.ifdefed" startline="115" endline="152" pcid="8707">
        {
            m_CurveEditor = new CurveEditor(GetCurveEditorRect(), GetCurveWrapperArray(), true);
            m_CurveEditor.curvesUpdated = UpdateCurve;
            m_CurveEditor.scaleWithWindow = true;
            m_CurveEditor.margin = 40;
            if (settings != null)
                m_CurveEditor.settings = settings;
            m_CurveEditor.settings.hTickLabelOffset = 10;
            m_CurveEditor.settings.rectangleToolFlags = CurveEditorSettings.RectangleToolFlags.MiniRectangleTool;

            // As there is no guarantee animation curve changes are recorded in undo redo, we can't really
            // handle curve selection in undo redo either.
            m_CurveEditor.settings.undoRedoSelection = false;
            m_CurveEditor.settings.showWrapperPopups = true;

            // For each of horizontal and vertical axis, if we have a finite range for that axis, use that range,
            // otherwise use framing logic to determine shown range for that axis.
            bool frameH = true;
            bool frameV = true;
            if (m_CurveEditor.settings.hRangeMin != Mathf.NegativeInfinity && m_CurveEditor.settings.hRangeMax != Mathf.Infinity)
            {
                m_CurveEditor.SetShownHRangeInsideMargins(m_CurveEditor.settings.hRangeMin, m_CurveEditor.settings.hRangeMax);
                frameH = false;
            }
            if (m_CurveEditor.settings.vRangeMin != Mathf.NegativeInfinity && m_CurveEditor.settings.vRangeMax != Mathf.Infinity)
            {
                m_CurveEditor.SetShownVRangeInsideMargins(m_CurveEditor.settings.vRangeMin, m_CurveEditor.settings.vRangeMax);
                frameV = false;
            }

            m_CurveEditor.FrameSelected(frameH, frameV);

            titleContent = EditorGUIUtility.TrTextContent("Curve");

            // deal with window size
            minSize = new Vector2(240, 240 + kPresetsHeight);
            maxSize = new Vector2(10000, 10000);
        }
</source>
</class>

<class classid="36" nclones="2" nlines="12" similarity="76">
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/MinMaxCurveEditorWindow.cs.ifdefed" startline="399" endline="409" pcid="8380">
        {
            if (delegateView)
            {
                Event e = EditorGUIUtility.CommandEvent(eventName);
                Repaint();
                delegateView.SendEvent(e);
                if (exitGUI)
                    GUIUtility.ExitGUI();
            }
            GUI.changed = true;
        }
</source>
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/CurveEditorWindow.cs.ifdefed" startline="595" endline="610" pcid="8758">
        {
            if (delegateView)
            {
                Event e = EditorGUIUtility.CommandEvent(eventName);
                Repaint();
                delegateView.SendEvent(e);
                if (exitGUI)
                    GUIUtility.ExitGUI();
            }

            if (m_OnCurveChanged != null)
            {
                m_OnCurveChanged(curve);
            }
            GUI.changed = true;
        }
</source>
</class>

<class classid="37" nclones="2" nlines="14" similarity="92">
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/AnimationWindowControl.cs.ifdefed" startline="175" endline="192" pcid="8910">
        {
            EditorCurveBinding[] bindings = AnimationWindowUtility.PropertyModificationsToEditorCurveBindings(modifications, state.activeRootGameObject, state.activeAnimationClip);
            if (bindings.Length == 0)
                return;

            List<AnimationWindowCurve> curves = new List<AnimationWindowCurve>();
            for (int i = 0; i < state.allCurves.Count; ++i)
            {
                AnimationWindowCurve curve = state.allCurves[i];
                if (Array.Exists(bindings, binding => curve.binding.Equals(binding)))
                    curves.Add(curve);
            }

            float newTime = AnimationWindowUtility.GetPreviousKeyframeTime(curves.ToArray(), time.time, state.clipFrameRate);
            SetCurrentTime(state.SnapToFrame(newTime, AnimationWindowState.SnapMode.SnapToClipFrame));

            state.Repaint();
        }
</source>
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/AnimationWindowControl.cs.ifdefed" startline="203" endline="220" pcid="8913">
        {
            EditorCurveBinding[] bindings = AnimationWindowUtility.PropertyModificationsToEditorCurveBindings(modifications, state.activeRootGameObject, state.activeAnimationClip);
            if (bindings.Length == 0)
                return;

            List<AnimationWindowCurve> curves = new List<AnimationWindowCurve>();
            for (int i = 0; i < state.allCurves.Count; ++i)
            {
                AnimationWindowCurve curve = state.allCurves[i];
                if (Array.Exists(bindings, binding => curve.binding.Equals(binding)))
                    curves.Add(curve);
            }

            float newTime = AnimationWindowUtility.GetNextKeyframeTime(curves.ToArray(), time.time, state.clipFrameRate);
            SetCurrentTime(state.SnapToFrame(newTime, AnimationWindowState.SnapMode.SnapToClipFrame));

            state.Repaint();
        }
</source>
</class>

<class classid="38" nclones="2" nlines="18" similarity="75">
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/Deprecated/EditorGUIExt.cs.ifdefed" startline="304" endline="327" pcid="9013">
                        {
                            if (horiz)
                            {
                                if (mousePosition > thumbRect.xMax - position.x)
                                    value += size * sign * .9f;
                                else
                                    value -= size * sign * .9f;
                            }
                            else
                            {
                                if (mousePosition > thumbRect.yMax - position.y)
                                    value += size * sign * .9f;
                                else
                                    value -= size * sign * .9f;
                            }
                            state.whereWeDrag = 0;
                            GUI.changed = true;
                            s_NextScrollStepTime = System.DateTime.Now.AddMilliseconds(kFirstScrollWait);

                            mousePos = horiz ? evt.mousePosition.x : evt.mousePosition.y;
                            thumbPos = horiz ? thumbRect.x : thumbRect.y;

                            state.whereWeDrag = mousePos > thumbPos ? 4 : 3;
                        }
</source>
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/Deprecated/EditorGUIExt.cs.ifdefed" startline="422" endline="439" pcid="9022">
                    {
                        if (horiz)
                        {
                            if (mousePosition > thumbRect.xMax - position.x)
                                value += size * sign * .9f;
                            else
                                value -= size * sign * .9f;
                        }
                        else
                        {
                            if (mousePosition > thumbRect.yMax - position.y)
                                value += size * sign * .9f;
                            else
                                value -= size * sign * .9f;
                        }
                        state.whereWeDrag = -1;
                        GUI.changed = true;
                    }
</source>
</class>

<class classid="39" nclones="2" nlines="12" similarity="91">
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/Deprecated/EditorGUIExt.cs.ifdefed" startline="825" endline="838" pcid="9064">
        {
            Rect r = new Rect(start.x, start.y, end.x - start.x, end.y - start.y);
            if (r.width < 0)
            {
                r.x += r.width;
                r.width = -r.width;
            }
            if (r.height < 0)
            {
                r.y += r.height;
                r.height = -r.height;
            }
            return r;
        }
</source>
<source file="UnityCsReference/Editor/Mono/PointEditor.cs.ifdefed" startline="282" endline="296" pcid="25325">
        {
            var r = new Rect(from.x, from.y, to.x - from.x, to.y - from.y);

            if (r.width < 0)
            {
                r.x += r.width;
                r.width = -r.width;
            }
            if (r.height < 0)
            {
                r.y += r.height;
                r.height = -r.height;
            }
            return r;
        }
</source>
</class>

<class classid="40" nclones="2" nlines="19" similarity="89">
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/Deprecated/AnimationEventTimeline.cs.ifdefed" startline="161" endline="191" pcid="9083">
                {
                    AnimationEvent evt = events[i];

                    if (sharedLeft == 0)
                    {
                        shared = 1;
                        while (i + shared < events.Length && events[i + shared].time == evt.time)
                            shared++;
                        sharedLeft = shared;
                    }
                    sharedLeft--;

                    // Important to take floor of positions of GUI stuff to get pixel correct alignment of
                    // stuff drawn with both GUI and Handles/GL. Otherwise things are off by one pixel half the time.
                    float keypos = Mathf.Floor(state.FrameToPixel(evt.time * clip.frameRate, rect));
                    int sharedOffset = 0;
                    if (shared > 1)
                    {
                        float spread = Mathf.Min((shared - 1) * (eventMarker.width - 1), (int)(state.FrameDeltaToPixel(rect) - eventMarker.width * 2));
                        sharedOffset = Mathf.FloorToInt(Mathf.Max(0, spread - (eventMarker.width - 1) * (sharedLeft)));
                    }

                    Rect r = new Rect(
                            keypos + sharedOffset - eventMarker.width / 2,
                            (rect.height - 10) * (float)(sharedLeft - shared + 1) / Mathf.Max(1, shared - 1),
                            eventMarker.width,
                            eventMarker.height);

                    hitRects[i] = r;
                    drawRects[i] = r;
                }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/AnimationClipEditor.cs.ifdefed" startline="1492" endline="1522" pcid="28362">
            {
                AnimationEvent evt = events[i];

                if (sharedLeft == 0)
                {
                    shared = 1;
                    while (i + shared < events.Length && events[i + shared].time == evt.time)
                        shared++;
                    sharedLeft = shared;
                }
                sharedLeft--;

                // Important to take floor of positions of GUI stuff to get pixel correct alignment of
                // stuff drawn with both GUI and Handles/GL. Otherwise things are off by one pixel half the time.
                float keypos = Mathf.Floor(m_Timeline.TimeToPixel(evt.time, rect));
                int sharedOffset = 0;
                if (shared > 1)
                {
                    float spread = Mathf.Min((shared - 1) * (eventMarker.width - 1), (int)(1.0f / m_Timeline.PixelDeltaToTime(rect) - eventMarker.width * 2));
                    sharedOffset = Mathf.FloorToInt(Mathf.Max(0, spread - (eventMarker.width - 1) * (sharedLeft)));
                }

                Rect r = new Rect(
                        keypos + sharedOffset - eventMarker.width / 2,
                        (rect.height - 10) * (float)(sharedLeft - shared + 1) / Mathf.Max(1, shared - 1),
                        eventMarker.width,
                        eventMarker.height);

                hitRects[i] = r;
                drawRects[i] = r;
            }
</source>
</class>

<class classid="41" nclones="2" nlines="20" similarity="76">
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/Deprecated/AnimationEventTimeline.cs.ifdefed" startline="424" endline="450" pcid="9107">
        {
            Vector2 mouse = Event.current.mousePosition;
            bool hasFound = false;

            if (events.Length == hitRects.Length)
            {
                for (int i = hitRects.Length - 1; i >= 0; i--)
                {
                    if (hitRects[i].Contains(mouse))
                    {
                        hasFound = true;
                        if (m_HoverEvent != i)
                        {
                            m_HoverEvent = i;
                            m_InstantTooltipText = events[m_HoverEvent].functionName;
                            m_InstantTooltipPoint = new Vector2(hitRects[m_HoverEvent].xMin + (int)(hitRects[m_HoverEvent].width / 2) + eventLineRect.x, eventLineRect.yMax);
                            m_DirtyTooltip = true;
                        }
                    }
                }
            }
            if (!hasFound)
            {
                m_HoverEvent = -1;
                m_InstantTooltipText = "";
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/AnimationClipEditor.cs.ifdefed" startline="1698" endline="1721" pcid="28379">
        {
            Vector2 mouse = Event.current.mousePosition;
            bool hasFound = false;
            m_InstantTooltipText = "";

            if (events.Length == hitRects.Length)
            {
                for (int i = hitRects.Length - 1; i >= 0; i--)
                {
                    if (hitRects[i].Contains(mouse))
                    {
                        hasFound = true;
                        if (m_HoverEvent != i)
                        {
                            m_HoverEvent = i;
                            m_InstantTooltipText = events[m_HoverEvent].functionName;
                            m_InstantTooltipPoint = new Vector2(mouse.x, mouse.y);
                        }
                    }
                }
            }
            if (!hasFound)
                m_HoverEvent = -1;
        }
</source>
</class>

<class classid="42" nclones="3" nlines="11" similarity="70">
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/AnimationWindowEvent.cs.ifdefed" startline="30" endline="48" pcid="9205">
        {
            AnimationEvent animationEvent = new AnimationEvent();
            animationEvent.time = time;

            // Or add a new one
            AnimationEvent[] events = AnimationUtility.GetAnimationEvents(clip);
            int eventIndex = InsertAnimationEvent(ref events, clip, animationEvent);

            AnimationWindowEvent animationWindowEvent = CreateInstance<AnimationWindowEvent>();
            animationWindowEvent.hideFlags = HideFlags.HideInHierarchy;
            animationWindowEvent.name = "Animation Event";

            animationWindowEvent.root = root;
            animationWindowEvent.clip = clip;
            animationWindowEvent.clipInfo = null;
            animationWindowEvent.eventIndex = eventIndex;

            return animationWindowEvent;
        }
</source>
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/AnimationWindowEvent.cs.ifdefed" startline="51" endline="62" pcid="9206">
        {
            AnimationWindowEvent animationWindowEvent = CreateInstance<AnimationWindowEvent>();
            animationWindowEvent.hideFlags = HideFlags.HideInHierarchy;
            animationWindowEvent.name = "Animation Event";

            animationWindowEvent.root = root;
            animationWindowEvent.clip = clip;
            animationWindowEvent.clipInfo = null;
            animationWindowEvent.eventIndex = eventIndex;

            return animationWindowEvent;
        }
</source>
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/AnimationWindowEvent.cs.ifdefed" startline="65" endline="76" pcid="9207">
        {
            AnimationWindowEvent animationWindowEvent = CreateInstance<AnimationWindowEvent>();
            animationWindowEvent.hideFlags = HideFlags.HideInHierarchy;
            animationWindowEvent.name = "Animation Event";

            animationWindowEvent.root = null;
            animationWindowEvent.clip = null;
            animationWindowEvent.clipInfo = clipInfo;
            animationWindowEvent.eventIndex = eventIndex;

            return animationWindowEvent;
        }
</source>
</class>

<class classid="43" nclones="2" nlines="32" similarity="84">
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/CurveEditor.cs.ifdefed" startline="1853" endline="1896" pcid="9470">
        {
            time = Mathf.Clamp(time, settings.hRangeMin, settings.hRangeMax);

            // Add a key on a curve at a specified time
            if (curveIndex >= 0)
            {
                CurveSelection selectedPoint = null;
                CurveWrapper cw = m_AnimationCurves[curveIndex];

                if (cw.animationIsEditable)
                {
                    if (cw.groupId == -1)
                    {
                        selectedPoint = AddKeyAtTime(cw, time);
                    }
                    else
                    {
                        foreach (CurveWrapper cw2 in m_AnimationCurves)
                        {
                            if (cw2.groupId == cw.groupId)
                            {
                                CurveSelection cs = AddKeyAtTime(cw2, time);
                                if (cw2.id == cw.id)
                                    selectedPoint = cs;
                            }
                        }
                    }
                    if (selectedPoint != null)
                    {
                        ClearSelection();
                        AddSelection(selectedPoint);
                        RecalcSecondarySelection();
                    }
                    else
                    {
                        SelectNone();
                    }

                    return true;
                }
            }

            return false;
        }
</source>
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/CurveEditor.cs.ifdefed" startline="1899" endline="1943" pcid="9479">
        {
            localPos.x = Mathf.Clamp(localPos.x, settings.hRangeMin, settings.hRangeMax);

            // Add a key on a curve at a specified time
            if (curveIndex >= 0)
            {
                CurveSelection selectedPoint = null;
                CurveWrapper cw = m_AnimationCurves[curveIndex];

                if (cw.animationIsEditable)
                {
                    if (cw.groupId == -1)
                    {
                        selectedPoint = AddKeyAtPosition(cw, localPos);
                    }
                    else
                    {
                        foreach (CurveWrapper cw2 in m_AnimationCurves)
                        {
                            if (cw2.groupId == cw.groupId)
                            {
                                if (cw2.id == cw.id)
                                    selectedPoint = AddKeyAtPosition(cw2, localPos);
                                else
                                    AddKeyAtTime(cw2, localPos.x);
                            }
                        }
                    }
                    if (selectedPoint != null)
                    {
                        ClearSelection();
                        AddSelection(selectedPoint);
                        RecalcSecondarySelection();
                    }
                    else
                    {
                        SelectNone();
                    }

                    return true;
                }
            }

            return false;
        }
</source>
</class>

<class classid="44" nclones="2" nlines="10" similarity="70">
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/CurveEditor.cs.ifdefed" startline="2222" endline="2233" pcid="9519">
                            {
                                BeginRangeSelection();
                                for (int keyIndex = 0; keyIndex < curve.keys.Length; ++keyIndex)
                                {
                                    if (!selectedCurves.Any(x => x.curveID == selectedPoint.curveID && x.key == keyIndex))
                                    {
                                        var keySelection = new CurveSelection(selectedPoint.curveID, keyIndex);
                                        AddSelection(keySelection);
                                    }
                                }
                                EndRangeSelection();
                            }
</source>
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/CurveEditor.cs.ifdefed" startline="2307" endline="2319" pcid="9534">
                                {
                                    // Try and add all keys on the same curve in the range [keyMin, keyMax]
                                    BeginRangeSelection();
                                    for (var keyIndex = keyMin; keyIndex <= keyMax; ++keyIndex)
                                    {
                                        if (!selectedCurves.Any(x => x.curveID == selectedPoint.curveID && x.key == keyIndex))
                                        {
                                            var rangeSelection = new CurveSelection(selectedPoint.curveID, keyIndex);
                                            AddSelection(rangeSelection);
                                        }
                                    }
                                    EndRangeSelection();
                                }
</source>
</class>

<class classid="45" nclones="2" nlines="14" similarity="85">
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/CurveEditor.cs.ifdefed" startline="3120" endline="3140" pcid="9631">
        {
            AnimationCurve curve = GetCurveFromSelection(selection);
            if (curve == null)
                return false;

            if (selection.key < 1 || selection.key >= curve.length)
                return false;

            Keyframe keyframe = curve[selection.key];
            TangentMode mode = AnimationUtility.GetKeyLeftTangentMode(keyframe);

            // Tangent is already set to Free.
            if (mode == TangentMode.Free)
                return true;

            // If tangent is modified, it will be converted to Free.
            if (mode == TangentMode.ClampedAuto || mode == TangentMode.Auto)
                return true;

            return false;
        }
</source>
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/CurveEditor.cs.ifdefed" startline="3143" endline="3163" pcid="9632">
        {
            AnimationCurve curve = GetCurveFromSelection(selection);
            if (curve == null)
                return false;

            if (selection.key < 0 || selection.key >= (curve.length - 1))
                return false;

            Keyframe keyframe = curve[selection.key];
            TangentMode mode = AnimationUtility.GetKeyRightTangentMode(keyframe);

            // Tangent is already set to Free.
            if (mode == TangentMode.Free)
                return true;

            // If tangent is modified, it will be converted to Free.
            if (mode == TangentMode.ClampedAuto || mode == TangentMode.Auto)
                return true;

            return false;
        }
</source>
</class>

<class classid="46" nclones="2" nlines="23" similarity="70">
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/CurveEditor.cs.ifdefed" startline="3239" endline="3272" pcid="9641">
            {
                CurveSelection sel = selectedCurves[i];

                if (sel.semiSelected)
                    continue;

                CurveWrapper curveWrapper = GetCurveWrapperFromSelection(sel);
                if (curveWrapper == null)
                    continue;

                AnimationCurve curve = curveWrapper.curve;
                if (curve == null)
                    continue;

                if (curve.length == 0)
                    continue;

                if (sel.key < 0 || sel.key >= curve.length)
                    continue;

                Vector2 keyPoint = GetPosition(sel);

                if (IsLeftTangentEditable(sel) && GetKeyframeFromSelection(sel).time != curve.keys[0].time)
                {
                    Vector2 leftTangent = GetPosition(new CurveSelection(sel.curveID, sel.key, CurveSelection.SelectionType.InTangent));
                    DrawLine(leftTangent, keyPoint);
                }

                if (IsRightTangentEditable(sel) && GetKeyframeFromSelection(sel).time != curve.keys[curve.keys.Length - 1].time)
                {
                    Vector2 rightTangent = GetPosition(new CurveSelection(sel.curveID, sel.key, CurveSelection.SelectionType.OutTangent));
                    DrawLine(keyPoint, rightTangent);
                }
            }
</source>
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/CurveEditor.cs.ifdefed" startline="3279" endline="3307" pcid="9644">
            {
                CurveSelection sel = selectedCurves[i];

                if (sel.semiSelected)
                    continue;

                CurveWrapper curveWrapper = GetCurveWrapperFromSelection(sel);
                if (curveWrapper == null)
                    continue;

                AnimationCurve curve = curveWrapper.curve;
                if (curve == null)
                    continue;

                if (curve.length == 0)
                    continue;

                if (IsLeftTangentEditable(sel) && GetKeyframeFromSelection(sel).time != curve.keys[0].time)
                {
                    Vector2 leftTangent = DrawingToViewTransformPoint(GetPosition(new CurveSelection(sel.curveID, sel.key, CurveSelection.SelectionType.InTangent)));
                    DrawTangentPoint(leftTangent, (GetKeyframeFromSelection(sel).weightedMode & WeightedMode.In) == WeightedMode.In);
                }

                if (IsRightTangentEditable(sel) && GetKeyframeFromSelection(sel).time != curve.keys[curve.keys.Length - 1].time)
                {
                    Vector2 rightTangent = DrawingToViewTransformPoint(GetPosition(new CurveSelection(sel.curveID, sel.key, CurveSelection.SelectionType.OutTangent)));
                    DrawTangentPoint(rightTangent, (GetKeyframeFromSelection(sel).weightedMode & WeightedMode.Out) == WeightedMode.Out);
                }
            }
</source>
</class>

<class classid="47" nclones="2" nlines="11" similarity="72">
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/AnimationWindowEventInspector.cs.ifdefed" startline="288" endline="301" pcid="9755">
            {
                bool singleParamValue = Array.TrueForAll(events, evt => evt.floatParameter == firstEvent.floatParameter);

                EditorGUI.BeginChangeCheck();
                EditorGUI.showMixedValue = !singleParamValue;
                float newValue = EditorGUILayout.FloatField("Float", firstEvent.floatParameter);
                EditorGUI.showMixedValue = false;

                if (EditorGUI.EndChangeCheck())
                {
                    foreach (var evt in events)
                        evt.floatParameter = newValue;
                }
            }
</source>
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/AnimationWindowEventInspector.cs.ifdefed" startline="324" endline="337" pcid="9759">
            {
                bool singleParamValue = Array.TrueForAll(events, evt => evt.stringParameter == firstEvent.stringParameter);

                EditorGUI.BeginChangeCheck();
                EditorGUI.showMixedValue = !singleParamValue;
                string newValue = EditorGUILayout.TextField("String", firstEvent.stringParameter);
                EditorGUI.showMixedValue = false;

                if (EditorGUI.EndChangeCheck())
                {
                    foreach (var evt in events)
                        evt.stringParameter = newValue;
                }
            }
</source>
</class>

<class classid="48" nclones="2" nlines="12" similarity="75">
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/AnimationWindowState.cs.ifdefed" startline="999" endline="1013" pcid="9978">
                    {
                        Vector3 v = new Vector3(flipX ? t1 : t2, 0f, 0f);
                        v = matrix.MultiplyPoint3x4(v);

                        float dt = v.x - t2;
                        if (dt > 0f)
                        {
                            float newTime = liveEditKey.keySnapshot.time + dt;
                            liveEditKey.key.time = Mathf.Max((snapToFrame) ? SnapToFrame(newTime, snapshot.curve.clip.frameRate) : newTime, 0f);
                        }
                        else
                        {
                            liveEditKey.key.time = liveEditKey.keySnapshot.time;
                        }
                    }
</source>
<source file="UnityCsReference/Editor/Mono/Animation/AnimationWindow/AnimationWindowState.cs.ifdefed" startline="1015" endline="1029" pcid="9981">
                    {
                        Vector3 v = new Vector3(flipX ? t2 : t1, 0f, 0f);
                        v = matrix.MultiplyPoint3x4(v);

                        float dt = v.x - t1;
                        if (dt < 0f)
                        {
                            float newTime = liveEditKey.keySnapshot.time + dt;
                            liveEditKey.key.time = Mathf.Max((snapToFrame) ? SnapToFrame(newTime, snapshot.curve.clip.frameRate) : newTime, 0f);
                        }
                        else
                        {
                            liveEditKey.key.time = liveEditKey.keySnapshot.time;
                        }
                    }
</source>
</class>

<class classid="49" nclones="4" nlines="24" similarity="70">
<source file="UnityCsReference/Editor/Mono/Utils/ExpressionEvaluator.cs.ifdefed" startline="283" endline="310" pcid="10592">
            {
                if (values.Length == 1)
                {
                    switch (oper)
                    {
                        case 'u':
                            return (T)(object)((float)(object)values[0] * -1.0f);
                    }
                }
                else if (values.Length == 2)
                {
                    switch (oper)
                    {
                        case '+':
                            return (T)(object)((float)(object)values[0] + (float)(object)values[1]);
                        case '-':
                            return (T)(object)((float)(object)values[0] - (float)(object)values[1]);
                        case '*':
                            return (T)(object)((float)(object)values[0] * (float)(object)values[1]);
                        case '/':
                            return (T)(object)((float)(object)values[0] / (float)(object)values[1]);
                        case '%':
                            return (T)(object)((float)(object)values[0] % (float)(object)values[1]);
                        case '^':
                            return (T)(object)UnityEngine.Mathf.Pow((float)(object)values[0], (float)(object)values[1]);
                    }
                }
            }
</source>
<source file="UnityCsReference/Editor/Mono/Utils/ExpressionEvaluator.cs.ifdefed" startline="312" endline="339" pcid="10595">
            {
                if (values.Length == 1)
                {
                    switch (oper)
                    {
                        case 'u':
                            return (T)(object)((int)(object)values[0] * -1);
                    }
                }
                else if (values.Length == 2)
                {
                    switch (oper)
                    {
                        case '+':
                            return (T)(object)((int)(object)values[0] + (int)(object)values[1]);
                        case '-':
                            return (T)(object)((int)(object)values[0] - (int)(object)values[1]);
                        case '*':
                            return (T)(object)((int)(object)values[0] * (int)(object)values[1]);
                        case '/':
                            return (T)(object)((int)(object)values[0] / (int)(object)values[1]);
                        case '%':
                            return (T)(object)((int)(object)values[0] % (int)(object)values[1]);
                        case '^':
                            return (T)(object)(int)Math.Pow((int)(object)values[0], (int)(object)values[1]);
                    }
                }
            }
</source>
<source file="UnityCsReference/Editor/Mono/Utils/ExpressionEvaluator.cs.ifdefed" startline="370" endline="397" pcid="10601">
            {
                if (values.Length == 1)
                {
                    switch (oper)
                    {
                        case 'u':
                            return (T)(object)((long)(object)values[0] * -1);
                    }
                }
                else if (values.Length == 2)
                {
                    switch (oper)
                    {
                        case '+':
                            return (T)(object)((long)(object)values[0] + (long)(object)values[1]);
                        case '-':
                            return (T)(object)((long)(object)values[0] - (long)(object)values[1]);
                        case '*':
                            return (T)(object)((long)(object)values[0] * (long)(object)values[1]);
                        case '/':
                            return (T)(object)((long)(object)values[0] / (long)(object)values[1]);
                        case '%':
                            return (T)(object)((long)(object)values[0] % (long)(object)values[1]);
                        case '^':
                            return (T)(object)(long)System.Math.Pow((long)(object)values[0], (long)(object)values[1]);
                    }
                }
            }
</source>
<source file="UnityCsReference/Editor/Mono/Utils/ExpressionEvaluator.cs.ifdefed" startline="341" endline="368" pcid="10598">
            {
                if (values.Length == 1)
                {
                    switch (oper)
                    {
                        case 'u':
                            return (T)(object)((double)(object)values[0] * -1.0f);
                    }
                }
                else if (values.Length == 2)
                {
                    switch (oper)
                    {
                        case '+':
                            return (T)(object)((double)(object)values[0] + (double)(object)values[1]);
                        case '-':
                            return (T)(object)((double)(object)values[0] - (double)(object)values[1]);
                        case '*':
                            return (T)(object)((double)(object)values[0] * (double)(object)values[1]);
                        case '/':
                            return (T)(object)((double)(object)values[0] / (double)(object)values[1]);
                        case '%':
                            return (T)(object)((double)(object)values[0] % (double)(object)values[1]);
                        case '^':
                            return (T)(object)System.Math.Pow((double)(object)values[0], (double)(object)values[1]);
                    }
                }
            }
</source>
</class>

<class classid="50" nclones="2" nlines="10" similarity="80">
<source file="UnityCsReference/Editor/Mono/SerializedProperty/SerializedPropertyTreeView.cs.ifdefed" startline="569" endline="578" pcid="10787">
            {
                sortAscend = (TreeViewItem lhs, TreeViewItem rhs) =>
                    {
                        return EditorUtility.NaturalCompare(((SerializedPropertyItem)lhs).GetData().name, ((SerializedPropertyItem)rhs).GetData().name);
                    };
                sortDescend = (TreeViewItem lhs, TreeViewItem rhs) =>
                    {
                        return -EditorUtility.NaturalCompare(((SerializedPropertyItem)lhs).GetData().name, ((SerializedPropertyItem)rhs).GetData().name);
                    };
            }
</source>
<source file="UnityCsReference/Editor/Mono/SerializedProperty/SerializedPropertyTreeView.cs.ifdefed" startline="580" endline="589" pcid="10790">
            {
                sortAscend = (TreeViewItem lhs, TreeViewItem rhs) =>
                    {
                        return comp(((SerializedPropertyItem)lhs).GetData().properties[sortIdx], ((SerializedPropertyItem)rhs).GetData().properties[sortIdx]);
                    };
                sortDescend = (TreeViewItem lhs, TreeViewItem rhs) =>
                    {
                        return -comp(((SerializedPropertyItem)lhs).GetData().properties[sortIdx], ((SerializedPropertyItem)rhs).GetData().properties[sortIdx]);
                    };
            }
</source>
</class>

<class classid="51" nclones="2" nlines="12" similarity="83">
<source file="UnityCsReference/Editor/Mono/PresetLibraries/GradientPresetLibrary.cs.ifdefed" startline="28" endline="41" pcid="10822">
        {
            Gradient gradient = presetObject as Gradient;
            if (gradient == null)
            {
                Debug.LogError("Wrong type used in GradientPresetLibrary");
                return;
            }

            Gradient copy = new Gradient();
            copy.alphaKeys = gradient.alphaKeys;
            copy.colorKeys = gradient.colorKeys;
            copy.mode = gradient.mode;
            m_Presets.Add(new GradientPreset(copy, presetName));
        }
</source>
<source file="UnityCsReference/Editor/Mono/PresetLibraries/GradientPresetLibrary.cs.ifdefed" startline="44" endline="57" pcid="10824">
        {
            Gradient gradient = newPresetObject as Gradient;
            if (gradient == null)
            {
                Debug.LogError("Wrong type used in GradientPresetLibrary");
                return;
            }

            Gradient copy = new Gradient();
            copy.alphaKeys = gradient.alphaKeys;
            copy.colorKeys = gradient.colorKeys;
            copy.mode = gradient.mode;
            m_Presets[index].gradient = copy;
        }
</source>
</class>

<class classid="52" nclones="2" nlines="11" similarity="81">
<source file="UnityCsReference/Editor/Mono/PresetLibraries/CurvePresetLibrary.cs.ifdefed" startline="29" endline="41" pcid="10938">
        {
            AnimationCurve curve = presetObject as AnimationCurve;
            if (curve == null)
            {
                Debug.LogError("Wrong type used in CurvePresetLibrary");
                return;
            }

            AnimationCurve copy = new AnimationCurve(curve.keys);
            copy.preWrapMode = curve.preWrapMode;
            copy.postWrapMode = curve.postWrapMode;
            m_Presets.Add(new CurvePreset(copy, presetName));
        }
</source>
<source file="UnityCsReference/Editor/Mono/PresetLibraries/CurvePresetLibrary.cs.ifdefed" startline="44" endline="56" pcid="10940">
        {
            AnimationCurve curve = newPresetObject as AnimationCurve;
            if (curve == null)
            {
                Debug.LogError("Wrong type used in CurvePresetLibrary");
                return;
            }
            AnimationCurve copy = new AnimationCurve(curve.keys);
            copy.preWrapMode = curve.preWrapMode;
            copy.postWrapMode = curve.postWrapMode;

            m_Presets[index].curve = copy;
        }
</source>
</class>

<class classid="53" nclones="3" nlines="14" similarity="78">
<source file="UnityCsReference/Editor/Mono/PresetLibraries/PresetLibraryEditor.cs.ifdefed" startline="802" endline="819" pcid="11092">
        {
            T lib = GetCurrentLib();
            if (lib == null)
                return;

            if (presetIndex < 0 || presetIndex >= lib.Count())
            {
                Debug.LogError("DeletePreset: Invalid index: out of bounds");
                return;
            }

            lib.Remove(presetIndex);
            SaveCurrentLib();
            if (presetsWasReordered != null)
                presetsWasReordered();

            OnLayoutChanged();
        }
</source>
<source file="UnityCsReference/Editor/Mono/PresetLibraries/PresetLibraryEditor.cs.ifdefed" startline="822" endline="837" pcid="11094">
        {
            T lib = GetCurrentLib();
            if (lib == null)
                return;

            if (presetIndex < 0 || presetIndex >= lib.Count())
            {
                Debug.LogError("ReplacePreset: Invalid index: out of bounds");
                return;
            }

            lib.Replace(presetIndex, presetObject);
            SaveCurrentLib();
            if (presetsWasReordered != null)
                presetsWasReordered();
        }
</source>
<source file="UnityCsReference/Editor/Mono/PresetLibraries/PresetLibraryEditor.cs.ifdefed" startline="840" endline="855" pcid="11096">
        {
            T lib = GetCurrentLib();
            if (lib == null)
                return;

            if (presetIndex < 0 || presetIndex >= lib.Count())
            {
                Debug.LogError("ReplacePreset: Invalid index: out of bounds");
                return;
            }

            lib.Move(presetIndex, destPresetIndex, insertAfterDestIndex);
            SaveCurrentLib();
            if (presetsWasReordered != null)
                presetsWasReordered();
        }
</source>
</class>

<class classid="54" nclones="6" nlines="10" similarity="70">
<source file="UnityCsReference/Editor/Mono/EditorHandles/JointAngularLimitHandle.cs.ifdefed" startline="61" endline="71" pcid="11485">
            {
                switch (xMotion)
                {
                    case ConfigurableJointMotion.Free:
                        return xRange.x;
                    case ConfigurableJointMotion.Locked:
                        return 0f;
                    default:
                        return Mathf.Clamp(m_XMinHandle.angle, xRange.x, m_XMaxHandle.angle);
                }
            }
</source>
<source file="UnityCsReference/Editor/Mono/EditorHandles/JointAngularLimitHandle.cs.ifdefed" startline="146" endline="156" pcid="11495">
            {
                switch (zMotion)
                {
                    case ConfigurableJointMotion.Free:
                        return zRange.y;
                    case ConfigurableJointMotion.Locked:
                        return 0f;
                    default:
                        return Mathf.Clamp(m_ZMaxHandle.angle, m_ZMinHandle.angle, zRange.y);
                }
            }
</source>
<source file="UnityCsReference/Editor/Mono/EditorHandles/JointAngularLimitHandle.cs.ifdefed" startline="95" endline="105" pcid="11489">
            {
                switch (yMotion)
                {
                    case ConfigurableJointMotion.Free:
                        return yRange.x;
                    case ConfigurableJointMotion.Locked:
                        return 0f;
                    default:
                        return Mathf.Clamp(m_YMinHandle.angle, yRange.x, m_YMaxHandle.angle);
                }
            }
</source>
<source file="UnityCsReference/Editor/Mono/EditorHandles/JointAngularLimitHandle.cs.ifdefed" startline="112" endline="122" pcid="11491">
            {
                switch (yMotion)
                {
                    case ConfigurableJointMotion.Free:
                        return yRange.y;
                    case ConfigurableJointMotion.Locked:
                        return 0f;
                    default:
                        return Mathf.Clamp(m_YMaxHandle.angle, m_YMinHandle.angle, yRange.y);
                }
            }
</source>
<source file="UnityCsReference/Editor/Mono/EditorHandles/JointAngularLimitHandle.cs.ifdefed" startline="78" endline="88" pcid="11487">
            {
                switch (xMotion)
                {
                    case ConfigurableJointMotion.Free:
                        return xRange.y;
                    case ConfigurableJointMotion.Locked:
                        return 0f;
                    default:
                        return Mathf.Clamp(m_XMaxHandle.angle, m_XMinHandle.angle, xRange.y);
                }
            }
</source>
<source file="UnityCsReference/Editor/Mono/EditorHandles/JointAngularLimitHandle.cs.ifdefed" startline="129" endline="139" pcid="11493">
            {
                switch (zMotion)
                {
                    case ConfigurableJointMotion.Free:
                        return zRange.x;
                    case ConfigurableJointMotion.Locked:
                        return 0f;
                    default:
                        return Mathf.Clamp(m_ZMinHandle.angle, zRange.x, m_ZMaxHandle.angle);
                }
            }
</source>
</class>

<class classid="55" nclones="2" nlines="11" similarity="81">
<source file="UnityCsReference/Editor/Mono/EditorHandles/BoundsHandle/PrimitiveBoundsHandle.cs.ifdefed" startline="105" endline="117" pcid="11556">
            {
                bool exit = true;
                foreach (var id in m_ControlIDs)
                {
                    if (id == GUIUtility.hotControl)
                    {
                        exit = false;
                        break;
                    }
                }
                if (exit)
                    return;
            }
</source>
<source file="UnityCsReference/Editor/Mono/EditorHandles/ArcHandle.cs.ifdefed" startline="151" endline="163" pcid="11768">
            {
                bool exit = true;
                foreach (var id in m_RadiusHandleControlIDs)
                {
                    if (id == GUIUtility.hotControl)
                    {
                        exit = false;
                        break;
                    }
                }
                if (exit && GUIUtility.hotControl != m_AngleHandleControlID)
                    return;
            }
</source>
</class>

<class classid="56" nclones="5" nlines="59" similarity="72">
<source file="UnityCsReference/Editor/Mono/EditorHandles/SliderScale.cs.ifdefed" startline="23" endline="94" pcid="11687">
        {
            var positionOffset = direction * size * handleOffset;
            var s = GUIUtility.hotControl == id
                ? size * scale / s_StartScale
                : size;
            var startPosition = position + positionOffset;
            var cubePosition = position + direction * (s * s_ScaleDrawLength * lineScale) + positionOffset;

            Event evt = Event.current;
            switch (evt.GetTypeForControl(id))
            {
                case EventType.Layout:
                    HandleUtility.AddControl(id, HandleUtility.DistanceToLine(startPosition, cubePosition));
                    HandleUtility.AddControl(id, HandleUtility.DistanceToCircle(cubePosition, size * .3f));
                    break;
                case EventType.MouseDown:
                    // am I closest to the thingy?
                    if (HandleUtility.nearestControl == id && evt.button == 0)
                    {
                        GUIUtility.hotControl = id;    // Grab mouse focus
                        s_CurrentMousePosition = s_StartMousePosition = evt.mousePosition;
                        s_StartScale = scale;
                        evt.Use();
                        EditorGUIUtility.SetWantsMouseJumping(1);
                    }
                    break;
                case EventType.MouseDrag:
                    if (GUIUtility.hotControl == id)
                    {
                        s_CurrentMousePosition += evt.delta;
                        var dist = 1 + HandleUtility.CalcLineTranslation(s_StartMousePosition, s_CurrentMousePosition, position, direction) / size;
                        dist = Handles.SnapValue(dist, snap);
                        scale = s_StartScale * dist;
                        GUI.changed = true;
                        evt.Use();
                    }
                    break;
                case EventType.MouseUp:
                    if (GUIUtility.hotControl == id && (evt.button == 0 || evt.button == 2))
                    {
                        GUIUtility.hotControl = 0;
                        evt.Use();
                        EditorGUIUtility.SetWantsMouseJumping(0);
                    }
                    break;
                case EventType.MouseMove:
                    if (id == HandleUtility.nearestControl)
                        HandleUtility.Repaint();
                    break;
                case EventType.Repaint:
                    Color temp = Color.white;
                    if (id == GUIUtility.hotControl)
                    {
                        temp = Handles.color;
                        Handles.color = Handles.selectedColor;
                    }
                    else if (id == HandleUtility.nearestControl && GUIUtility.hotControl == 0)
                    {
                        temp = Handles.color;
                        Handles.color = Handles.preselectionColor;
                    }

                    Handles.DrawLine(startPosition, cubePosition);
                    Handles.CubeHandleCap(id, cubePosition, rotation, size * .1f, EventType.Repaint);

                    if (id == GUIUtility.hotControl || id == HandleUtility.nearestControl && GUIUtility.hotControl == 0)
                        Handles.color = temp;
                    break;
            }

            return scale;
        }
</source>
<source file="UnityCsReference/Editor/Mono/EditorHandles/Slider1D.cs.ifdefed" startline="113" endline="183" pcid="11890">
        {
            Event evt = Event.current;
            switch (evt.GetTypeForControl(id))
            {
                case EventType.Layout:
                    if (capFunction != null)
                        capFunction(id, position + offset, Quaternion.LookRotation(handleDirection), size, EventType.Layout);
                    else
                        HandleUtility.AddControl(id, HandleUtility.DistanceToCircle(position + offset, size * .2f));
                    break;
                case EventType.MouseDown:
                    // am I closest to the thingy?
                    if (HandleUtility.nearestControl == id && evt.button == 0 && GUIUtility.hotControl == 0)
                    {
                        GUIUtility.hotControl = id;    // Grab mouse focus
                        s_CurrentMousePosition = s_StartMousePosition = evt.mousePosition;
                        s_StartPosition = position;
                        evt.Use();
                        EditorGUIUtility.SetWantsMouseJumping(1);
                    }

                    break;
                case EventType.MouseDrag:
                    if (GUIUtility.hotControl == id)
                    {
                        s_CurrentMousePosition += evt.delta;
                        float dist = HandleUtility.CalcLineTranslation(s_StartMousePosition, s_CurrentMousePosition, s_StartPosition, slideDirection);

                        dist = Handles.SnapValue(dist, snap);

                        Vector3 worldDirection = Handles.matrix.MultiplyVector(slideDirection);
                        Vector3 worldPosition = Handles.matrix.MultiplyPoint(s_StartPosition) + worldDirection * dist;
                        position = Handles.inverseMatrix.MultiplyPoint(worldPosition);
                        GUI.changed = true;
                        evt.Use();
                    }
                    break;
                case EventType.MouseUp:
                    if (GUIUtility.hotControl == id && (evt.button == 0 || evt.button == 2))
                    {
                        GUIUtility.hotControl = 0;
                        evt.Use();
                        EditorGUIUtility.SetWantsMouseJumping(0);
                    }
                    break;
                case EventType.MouseMove:
                    if (id == HandleUtility.nearestControl)
                        HandleUtility.Repaint();
                    break;
                case EventType.Repaint:
                    Color temp = Color.white;

                    if (id == GUIUtility.hotControl)
                    {
                        temp = Handles.color;
                        Handles.color = Handles.selectedColor;
                    }
                    else if (id == HandleUtility.nearestControl && GUIUtility.hotControl == 0)
                    {
                        temp = Handles.color;
                        Handles.color = Handles.preselectionColor;
                    }

                    capFunction(id, position + offset, Quaternion.LookRotation(handleDirection), size, EventType.Repaint);

                    if (id == GUIUtility.hotControl || id == HandleUtility.nearestControl && GUIUtility.hotControl == 0)
                        Handles.color = temp;
                    break;
            }
            return position;
        }
</source>
<source file="UnityCsReference/Editor/Mono/EditorHandles/SliderScale.cs.ifdefed" startline="176" endline="248" pcid="11701">
        {
            Event evt = Event.current;
            switch (evt.GetTypeForControl(id))
            {
                case EventType.Layout:
                    capFunction(id, position, rotation, size * .15f, EventType.Layout);
                    break;
                case EventType.MouseDown:
                    // am I closest to the thingy?
                    if (HandleUtility.nearestControl == id && evt.button == 0)
                    {
                        GUIUtility.hotControl = id;     // Grab mouse focus
                        Tools.LockHandlePosition();
                        s_StartScale = value;
                        s_ValueDrag = 0;
                        evt.Use();
                        EditorGUIUtility.SetWantsMouseJumping(1);
                    }
                    break;
                case EventType.MouseDrag:
                    if (GUIUtility.hotControl == id)
                    {
                        s_ValueDrag += HandleUtility.niceMouseDelta * .01f;
                        value = (Handles.SnapValue(s_ValueDrag, snap) + 1.0f) * s_StartScale;
                        s_ScaleDrawLength = value / s_StartScale;
                        GUI.changed = true;
                        evt.Use();
                    }
                    break;
                case EventType.KeyDown:
                    if (GUIUtility.hotControl == id)
                    {
                        // Cancel dragging on ESC
                        if (evt.keyCode == KeyCode.Escape)
                        {
                            s_ScaleDrawLength = 1.0f;
                        }
                    }
                    break;
                case EventType.MouseUp:
                    if (GUIUtility.hotControl == id && (evt.button == 0 || evt.button == 2))
                    {
                        GUIUtility.hotControl = 0;
                        s_ScaleDrawLength = 1.0f;
                        evt.Use();
                        EditorGUIUtility.SetWantsMouseJumping(0);
                    }
                    break;
                case EventType.MouseMove:
                    if (id == HandleUtility.nearestControl)
                        HandleUtility.Repaint();
                    break;
                case EventType.Repaint:
                    Color temp = Color.white;
                    if (id == GUIUtility.hotControl)
                    {
                        temp = Handles.color;
                        Handles.color = Handles.selectedColor;
                    }
                    else if (id == HandleUtility.nearestControl && GUIUtility.hotControl == 0)
                    {
                        temp = Handles.color;
                        Handles.color = Handles.preselectionColor;
                    }
                    capFunction(id, position, rotation, size * .15f, EventType.Repaint);

                    if (id == GUIUtility.hotControl || id == HandleUtility.nearestControl && GUIUtility.hotControl == 0)
                        Handles.color = temp;
                    break;
            }

            return value;
        }
</source>
<source file="UnityCsReference/Editor/Mono/EditorHandles/Slider1D.cs.ifdefed" startline="35" endline="110" pcid="11882">
        {
            Event evt = Event.current;
            switch (evt.GetTypeForControl(id))
            {
                case EventType.Layout:
                    // This is an ugly hack. It would be better if the drawFunc can handle it's own layout.
                    if (drawFunc == Handles.ArrowCap)
                    {
                        HandleUtility.AddControl(id, HandleUtility.DistanceToLine(position, position + slideDirection * size));
                        HandleUtility.AddControl(id, HandleUtility.DistanceToCircle(position + slideDirection * size, size * .2f));
                    }
                    else
                    {
                        HandleUtility.AddControl(id, HandleUtility.DistanceToCircle(position, size * .2f));
                    }
                    break;
                case EventType.MouseDown:
                    // am I closest to the thingy?
                    if ((HandleUtility.nearestControl == id && evt.button == 0) && GUIUtility.hotControl == 0)
                    {
                        GUIUtility.hotControl = id;    // Grab mouse focus
                        s_CurrentMousePosition = s_StartMousePosition = evt.mousePosition;
                        s_StartPosition = position;
                        evt.Use();
                        EditorGUIUtility.SetWantsMouseJumping(1);
                    }

                    break;
                case EventType.MouseDrag:
                    if (GUIUtility.hotControl == id)
                    {
                        s_CurrentMousePosition += evt.delta;
                        float dist = HandleUtility.CalcLineTranslation(s_StartMousePosition, s_CurrentMousePosition, s_StartPosition, slideDirection);

                        dist = Handles.SnapValue(dist, snap);

                        Vector3 worldDirection = Handles.matrix.MultiplyVector(slideDirection);
                        Vector3 worldPosition = Handles.matrix.MultiplyPoint(s_StartPosition) + worldDirection * dist;
                        position = Handles.inverseMatrix.MultiplyPoint(worldPosition);
                        GUI.changed = true;
                        evt.Use();
                    }
                    break;
                case EventType.MouseUp:
                    if (GUIUtility.hotControl == id && (evt.button == 0 || evt.button == 2))
                    {
                        GUIUtility.hotControl = 0;
                        evt.Use();
                        EditorGUIUtility.SetWantsMouseJumping(0);
                    }
                    break;
                case EventType.MouseMove:
                    if (id == HandleUtility.nearestControl)
                        HandleUtility.Repaint();
                    break;
                case EventType.Repaint:
                    Color temp = Color.white;

                    if (id == GUIUtility.hotControl)
                    {
                        temp = Handles.color;
                        Handles.color = Handles.selectedColor;
                    }
                    else if (id == HandleUtility.nearestControl && GUIUtility.hotControl == 0)
                    {
                        temp = Handles.color;
                        Handles.color = Handles.preselectionColor;
                    }
                    drawFunc(id, position, Quaternion.LookRotation(handleDirection), size);

                    if (id == GUIUtility.hotControl || id == HandleUtility.nearestControl && GUIUtility.hotControl == 0)
                        Handles.color = temp;
                    break;
            }
            return position;
        }
</source>
<source file="UnityCsReference/Editor/Mono/EditorHandles/SliderScale.cs.ifdefed" startline="101" endline="173" pcid="11693">
        {
            Event evt = Event.current;
            switch (evt.GetTypeForControl(id))
            {
                case EventType.Layout:
                    HandleUtility.AddControl(id, HandleUtility.DistanceToCircle(position, size * .15f));
                    break;
                case EventType.MouseDown:
                    // am I closest to the thingy?
                    if (HandleUtility.nearestControl == id && evt.button == 0)
                    {
                        GUIUtility.hotControl = id;     // Grab mouse focus
                        s_StartScale = value;
                        s_ValueDrag = 0;
                        evt.Use();
                        EditorGUIUtility.SetWantsMouseJumping(1);
                    }
                    break;
                case EventType.MouseDrag:
                    if (GUIUtility.hotControl == id)
                    {
                        s_ValueDrag += HandleUtility.niceMouseDelta * .01f;
                        value = (Handles.SnapValue(s_ValueDrag, snap) + 1.0f) * s_StartScale;
                        s_ScaleDrawLength = value / s_StartScale;
                        GUI.changed = true;
                        evt.Use();
                    }
                    break;
                case EventType.MouseMove:
                    if (id == HandleUtility.nearestControl)
                        HandleUtility.Repaint();
                    break;
                case EventType.KeyDown:
                    if (GUIUtility.hotControl == id)
                    {
                        // Cancel dragging on ESC
                        if (evt.keyCode == KeyCode.Escape)
                        {
                            s_ScaleDrawLength = 1.0f;
                            // We do not use the event nor clear hotcontrol to ensure auto revert value kicks in from native side
                        }
                    }
                    break;
                case EventType.MouseUp:
                    if (GUIUtility.hotControl == id && (evt.button == 0 || evt.button == 2))
                    {
                        GUIUtility.hotControl = 0;
                        s_ScaleDrawLength = 1.0f;
                        evt.Use();
                        EditorGUIUtility.SetWantsMouseJumping(0);
                    }
                    break;
                case EventType.Repaint:
                    Color temp = Color.white;
                    if (id == GUIUtility.hotControl)
                    {
                        temp = Handles.color;
                        Handles.color = Handles.selectedColor;
                    }
                    else if (id == HandleUtility.nearestControl && GUIUtility.hotControl == 0)
                    {
                        temp = Handles.color;
                        Handles.color = Handles.preselectionColor;
                    }
                    capFunc(id, position, rotation, size * .15f);

                    if (id == GUIUtility.hotControl || id == HandleUtility.nearestControl && GUIUtility.hotControl == 0)
                        Handles.color = temp;
                    break;
            }

            return value;
        }
</source>
</class>

<class classid="57" nclones="3" nlines="16" similarity="73">
<source file="UnityCsReference/Editor/Mono/EditorHandles/PositionHandle.cs.ifdefed" startline="35" endline="47" pcid="11713">
                {
                    switch (index)
                    {
                        case 0: return x;
                        case 1: return y;
                        case 2: return z;
                        case 3: return xy;
                        case 4: return yz;
                        case 5: return xz;
                        case 6: return xyz;
                    }
                    return -1;
                }
</source>
<source file="UnityCsReference/Editor/Mono/EditorHandles/RotationHandle.cs.ifdefed" startline="33" endline="43" pcid="11739">
                {
                    switch (index)
                    {
                        case 0: return x;
                        case 1: return y;
                        case 2: return z;
                        case 3: return cameraAxis;
                        case 4: return xyz;
                    }
                    return -1;
                }
</source>
<source file="UnityCsReference/Editor/Mono/EditorHandles/ScaleHandle.cs.ifdefed" startline="32" endline="41" pcid="11829">
                {
                    switch (index)
                    {
                        case 0: return x;
                        case 1: return y;
                        case 2: return z;
                        case 3: return xyz;
                    }
                    return -1;
                }
</source>
</class>

<class classid="58" nclones="2" nlines="105" similarity="98">
<source file="UnityCsReference/Editor/Mono/EditorHandles/FreeMove.cs.ifdefed" startline="21" endline="158" pcid="11782">
        {
            Vector3 worldPosition = Handles.matrix.MultiplyPoint(position);
            Matrix4x4 origMatrix = Handles.matrix;

            VertexSnapping.HandleKeyAndMouseMove(id);

            Event evt = Event.current;
            switch (evt.GetTypeForControl(id))
            {
                case EventType.Layout:
                    // We only want the position to be affected by the Handles.matrix.
                    Handles.matrix = Matrix4x4.identity;
                    HandleUtility.AddControl(id, HandleUtility.DistanceToCircle(worldPosition, size * 1.2f));
                    Handles.matrix = origMatrix;
                    break;
                case EventType.MouseDown:
                    // am I closest to the thingy?
                    if (HandleUtility.nearestControl == id && evt.button == 0)
                    {
                        GUIUtility.hotControl = id;     // Grab mouse focus
                        s_CurrentMousePosition = s_StartMousePosition = evt.mousePosition;
                        s_StartPosition = position;
                        HandleUtility.ignoreRaySnapObjects = null;
                        evt.Use();
                        EditorGUIUtility.SetWantsMouseJumping(1);
                    }
                    break;
                case EventType.MouseDrag:
                    if (GUIUtility.hotControl == id)
                    {
                        bool rayDrag = EditorGUI.actionKey && evt.shift;

                        if (rayDrag)
                        {
                            if (HandleUtility.ignoreRaySnapObjects == null)
                                Handles.SetupIgnoreRaySnapObjects();

                            object hit = HandleUtility.RaySnap(HandleUtility.GUIPointToWorldRay(evt.mousePosition));
                            if (hit != null)
                            {
                                RaycastHit rh = (RaycastHit)hit;
                                float offset = 0;
                                if (Tools.pivotMode == PivotMode.Center)
                                {
                                    float geomOffset = HandleUtility.CalcRayPlaceOffset(HandleUtility.ignoreRaySnapObjects, rh.normal);
                                    if (geomOffset != Mathf.Infinity)
                                    {
                                        offset = Vector3.Dot(position, rh.normal) - geomOffset;
                                    }
                                }
                                position = Handles.inverseMatrix.MultiplyPoint(rh.point + (rh.normal * offset));
                            }
                            else
                            {
                                rayDrag = false;
                            }
                        }

                        if (!rayDrag)
                        {
                            // normal drag
                            s_CurrentMousePosition += new Vector2(evt.delta.x, -evt.delta.y) * EditorGUIUtility.pixelsPerPoint;
                            Vector3 screenPos = Camera.current.WorldToScreenPoint(Handles.matrix.MultiplyPoint(s_StartPosition));
                            screenPos += (Vector3)(s_CurrentMousePosition - s_StartMousePosition);
                            position = Handles.inverseMatrix.MultiplyPoint(Camera.current.ScreenToWorldPoint(screenPos));

                            // Due to floating point inaccuracies, the back-and-forth transformations used may sometimes introduce
                            // tiny unintended movement in wrong directions. People notice when using a straight top/left/right ortho camera.
                            // In that case, just restrain the movement to the plane.
                            if (Camera.current.transform.forward == Vector3.forward || Camera.current.transform.forward == -Vector3.forward)
                                position.z = s_StartPosition.z;
                            if (Camera.current.transform.forward == Vector3.up || Camera.current.transform.forward == -Vector3.up)
                                position.y = s_StartPosition.y;
                            if (Camera.current.transform.forward == Vector3.right || Camera.current.transform.forward == -Vector3.right)
                                position.x = s_StartPosition.x;

                            if (Tools.vertexDragging)
                            {
                                if (HandleUtility.ignoreRaySnapObjects == null)
                                    Handles.SetupIgnoreRaySnapObjects();
                                Vector3 near;
                                if (HandleUtility.FindNearestVertex(evt.mousePosition, null, out near))
                                {
                                    position = Handles.inverseMatrix.MultiplyPoint(near);
                                }
                            }

                            if (EditorGUI.actionKey && !evt.shift)
                            {
                                Vector3 delta = position - s_StartPosition;
                                delta.x = Handles.SnapValue(delta.x, snap.x);
                                delta.y = Handles.SnapValue(delta.y, snap.y);
                                delta.z = Handles.SnapValue(delta.z, snap.z);
                                position = s_StartPosition + delta;
                            }
                        }
                        GUI.changed = true;
                        evt.Use();
                    }
                    break;
                case EventType.MouseUp:
                    if (GUIUtility.hotControl == id && (evt.button == 0 || evt.button == 2))
                    {
                        GUIUtility.hotControl = 0;
                        HandleUtility.ignoreRaySnapObjects = null;
                        evt.Use();
                        EditorGUIUtility.SetWantsMouseJumping(0);
                    }
                    break;
                case EventType.MouseMove:
                    if (id == HandleUtility.nearestControl)
                        HandleUtility.Repaint();
                    break;
                case EventType.Repaint:
                    Color temp = Color.white;

                    if (id == GUIUtility.hotControl)
                    {
                        temp = Handles.color;
                        Handles.color = Handles.selectedColor;
                    }
                    else if (id == HandleUtility.nearestControl && GUIUtility.hotControl == 0)
                    {
                        temp = Handles.color;
                        Handles.color = Handles.preselectionColor;
                    }

                    // We only want the position to be affected by the Handles.matrix.
                    Handles.matrix = Matrix4x4.identity;
                    capFunc(id, worldPosition, Camera.current.transform.rotation, size);
                    Handles.matrix = origMatrix;

                    if (id == GUIUtility.hotControl || id == HandleUtility.nearestControl && GUIUtility.hotControl == 0)
                        Handles.color = temp;
                    break;
            }
            return position;
        }
</source>
<source file="UnityCsReference/Editor/Mono/EditorHandles/FreeMove.cs.ifdefed" startline="161" endline="298" pcid="11797">
        {
            Vector3 worldPosition = Handles.matrix.MultiplyPoint(position);
            Matrix4x4 origMatrix = Handles.matrix;

            VertexSnapping.HandleKeyAndMouseMove(id);

            Event evt = Event.current;
            switch (evt.GetTypeForControl(id))
            {
                case EventType.Layout:
                    // We only want the position to be affected by the Handles.matrix.
                    Handles.matrix = Matrix4x4.identity;
                    handleFunction(id, worldPosition, Camera.current.transform.rotation, size, EventType.Layout);
                    Handles.matrix = origMatrix;
                    break;
                case EventType.MouseDown:
                    // am I closest to the thingy?
                    if (HandleUtility.nearestControl == id && evt.button == 0)
                    {
                        GUIUtility.hotControl = id;     // Grab mouse focus
                        s_CurrentMousePosition = s_StartMousePosition = evt.mousePosition;
                        s_StartPosition = position;
                        HandleUtility.ignoreRaySnapObjects = null;
                        evt.Use();
                        EditorGUIUtility.SetWantsMouseJumping(1);
                    }
                    break;
                case EventType.MouseDrag:
                    if (GUIUtility.hotControl == id)
                    {
                        bool rayDrag = EditorGUI.actionKey && evt.shift;

                        if (rayDrag)
                        {
                            if (HandleUtility.ignoreRaySnapObjects == null)
                                Handles.SetupIgnoreRaySnapObjects();

                            object hit = HandleUtility.RaySnap(HandleUtility.GUIPointToWorldRay(evt.mousePosition));
                            if (hit != null)
                            {
                                RaycastHit rh = (RaycastHit)hit;
                                float offset = 0;
                                if (Tools.pivotMode == PivotMode.Center)
                                {
                                    float geomOffset = HandleUtility.CalcRayPlaceOffset(HandleUtility.ignoreRaySnapObjects, rh.normal);
                                    if (geomOffset != Mathf.Infinity)
                                    {
                                        offset = Vector3.Dot(position, rh.normal) - geomOffset;
                                    }
                                }
                                position = Handles.inverseMatrix.MultiplyPoint(rh.point + (rh.normal * offset));
                            }
                            else
                            {
                                rayDrag = false;
                            }
                        }

                        if (!rayDrag)
                        {
                            // normal drag
                            s_CurrentMousePosition += new Vector2(evt.delta.x, -evt.delta.y) * EditorGUIUtility.pixelsPerPoint;
                            Vector3 screenPos = Camera.current.WorldToScreenPoint(Handles.matrix.MultiplyPoint(s_StartPosition));
                            screenPos += (Vector3)(s_CurrentMousePosition - s_StartMousePosition);
                            position = Handles.inverseMatrix.MultiplyPoint(Camera.current.ScreenToWorldPoint(screenPos));

                            // Due to floating point inaccuracies, the back-and-forth transformations used may sometimes introduce
                            // tiny unintended movement in wrong directions. People notice when using a straight top/left/right ortho camera.
                            // In that case, just restrain the movement to the plane.
                            if (Camera.current.transform.forward == Vector3.forward || Camera.current.transform.forward == -Vector3.forward)
                                position.z = s_StartPosition.z;
                            if (Camera.current.transform.forward == Vector3.up || Camera.current.transform.forward == -Vector3.up)
                                position.y = s_StartPosition.y;
                            if (Camera.current.transform.forward == Vector3.right || Camera.current.transform.forward == -Vector3.right)
                                position.x = s_StartPosition.x;

                            if (Tools.vertexDragging)
                            {
                                if (HandleUtility.ignoreRaySnapObjects == null)
                                    Handles.SetupIgnoreRaySnapObjects();
                                Vector3 near;
                                if (HandleUtility.FindNearestVertex(evt.mousePosition, null, out near))
                                {
                                    position = Handles.inverseMatrix.MultiplyPoint(near);
                                }
                            }

                            if (EditorGUI.actionKey && !evt.shift)
                            {
                                Vector3 delta = position - s_StartPosition;
                                delta.x = Handles.SnapValue(delta.x, snap.x);
                                delta.y = Handles.SnapValue(delta.y, snap.y);
                                delta.z = Handles.SnapValue(delta.z, snap.z);
                                position = s_StartPosition + delta;
                            }
                        }
                        GUI.changed = true;
                        evt.Use();
                    }
                    break;
                case EventType.MouseUp:
                    if (GUIUtility.hotControl == id && (evt.button == 0 || evt.button == 2))
                    {
                        GUIUtility.hotControl = 0;
                        HandleUtility.ignoreRaySnapObjects = null;
                        evt.Use();
                        EditorGUIUtility.SetWantsMouseJumping(0);
                    }
                    break;
                case EventType.MouseMove:
                    if (id == HandleUtility.nearestControl)
                        HandleUtility.Repaint();
                    break;
                case EventType.Repaint:
                    Color temp = Color.white;

                    if (id == GUIUtility.hotControl)
                    {
                        temp = Handles.color;
                        Handles.color = Handles.selectedColor;
                    }
                    else if (id == HandleUtility.nearestControl && GUIUtility.hotControl == 0)
                    {
                        temp = Handles.color;
                        Handles.color = Handles.preselectionColor;
                    }

                    // We only want the position to be affected by the Handles.matrix.
                    Handles.matrix = Matrix4x4.identity;
                    handleFunction(id, worldPosition, Camera.current.transform.rotation, size, EventType.Repaint);
                    Handles.matrix = origMatrix;

                    if (id == GUIUtility.hotControl || id == HandleUtility.nearestControl && GUIUtility.hotControl == 0)
                        Handles.color = temp;
                    break;
            }
            return position;
        }
</source>
</class>

<class classid="59" nclones="2" nlines="97" similarity="71">
<source file="UnityCsReference/Editor/Mono/EditorHandles/Slider2D.cs.ifdefed" startline="151" endline="287" pcid="11853">
        {
            Vector2 deltaDistanceAlongDirections = new Vector2(0, 0);

            Event evt = Event.current;
            switch (evt.GetTypeForControl(id))
            {
                case EventType.Layout:
                    // This is an ugly hack. It would be better if the drawFunc can handle it's own layout.
                    if (drawFunc == Handles.ArrowCap)
                    {
                        HandleUtility.AddControl(id, HandleUtility.DistanceToLine(handlePos + offset, handlePos + handleDir * handleSize));
                        HandleUtility.AddControl(id, HandleUtility.DistanceToCircle((handlePos + offset) + handleDir * handleSize, handleSize * .2f));
                    }
                    else if (drawFunc == Handles.RectangleCap)
                    {
                        HandleUtility.AddControl(id, HandleUtility.DistanceToRectangle(handlePos + offset, Quaternion.LookRotation(handleDir, slideDir1), handleSize));
                    }
                    else
                    {
                        HandleUtility.AddControl(id, HandleUtility.DistanceToCircle(handlePos + offset, handleSize * .5f));
                    }
                    break;

                case EventType.MouseDown:
                    // am I closest to the thingy?
                    if (HandleUtility.nearestControl == id && evt.button == 0 && GUIUtility.hotControl == 0)
                    {
                        Plane plane = new Plane(Handles.matrix.MultiplyVector(handleDir), Handles.matrix.MultiplyPoint(handlePos));
                        Ray mouseRay = HandleUtility.GUIPointToWorldRay(evt.mousePosition);
                        float dist = 0.0f;
                        plane.Raycast(mouseRay, out dist);

                        GUIUtility.hotControl = id; // Grab mouse focus
                        s_CurrentMousePosition = evt.mousePosition;
                        s_StartPosition = handlePos;

                        Vector3 localMousePoint = Handles.inverseMatrix.MultiplyPoint(mouseRay.GetPoint(dist));
                        Vector3 clickOffset = localMousePoint - handlePos;
                        s_StartPlaneOffset.x = Vector3.Dot(clickOffset, slideDir1);
                        s_StartPlaneOffset.y = Vector3.Dot(clickOffset, slideDir2);

                        evt.Use();
                        EditorGUIUtility.SetWantsMouseJumping(1);
                    }
                    break;

                case EventType.MouseDrag:
                    if (GUIUtility.hotControl == id)
                    {
                        s_CurrentMousePosition += evt.delta;
                        Vector3 worldPosition = Handles.matrix.MultiplyPoint(handlePos);
                        Vector3 worldSlideDir1 = Handles.matrix.MultiplyVector(slideDir1).normalized;
                        Vector3 worldSlideDir2 = Handles.matrix.MultiplyVector(slideDir2).normalized;

                        // Detect hit with plane (ray from campos to cursor)
                        Ray mouseRay = HandleUtility.GUIPointToWorldRay(s_CurrentMousePosition);
                        Plane plane = new Plane(worldPosition, worldPosition + worldSlideDir1, worldPosition + worldSlideDir2);
                        float dist = 0.0f;
                        if (plane.Raycast(mouseRay, out dist))
                        {
                            Vector3 hitpos = Handles.inverseMatrix.MultiplyPoint(mouseRay.GetPoint(dist));

                            // Determine hitpos projection onto slideDirs
                            deltaDistanceAlongDirections.x = HandleUtility.PointOnLineParameter(hitpos, s_StartPosition, slideDir1);
                            deltaDistanceAlongDirections.y = HandleUtility.PointOnLineParameter(hitpos, s_StartPosition, slideDir2);
                            deltaDistanceAlongDirections -= s_StartPlaneOffset;
                            if (snap.x > 0 || snap.y > 0)
                            {
                                deltaDistanceAlongDirections.x = Handles.SnapValue(deltaDistanceAlongDirections.x, snap.x);
                                deltaDistanceAlongDirections.y = Handles.SnapValue(deltaDistanceAlongDirections.y, snap.y);
                            }

                            GUI.changed = true;
                        }
                        evt.Use();
                    }
                    break;
                case EventType.MouseUp:
                    if (GUIUtility.hotControl == id && (evt.button == 0 || evt.button == 2))
                    {
                        GUIUtility.hotControl = 0;
                        evt.Use();
                        EditorGUIUtility.SetWantsMouseJumping(0);
                    }
                    break;
                case EventType.MouseMove:
                    if (id == HandleUtility.nearestControl)
                        HandleUtility.Repaint();
                    break;
                case EventType.Repaint:
                {
                    if (drawFunc == null)
                        break;

                    Vector3 position = handlePos + offset;
                    Quaternion rotation = Quaternion.LookRotation(handleDir, slideDir1);

                    Color temp = Color.white;

                    if (id == GUIUtility.hotControl)
                    {
                        temp = Handles.color;
                        Handles.color = Handles.selectedColor;
                    }
                    else if (id == HandleUtility.nearestControl && GUIUtility.hotControl == 0)
                    {
                        temp = Handles.color;
                        Handles.color = Handles.preselectionColor;
                    }

                    drawFunc(id, position, rotation, handleSize);

                    if (id == GUIUtility.hotControl || id == HandleUtility.nearestControl && GUIUtility.hotControl == 0)
                        Handles.color = temp;

                    // Draw a helper rectangle to show what plane we are dragging in
                    if (drawHelper && GUIUtility.hotControl == id)
                    {
                        Vector3[] verts = new Vector3[4];
                        float helperSize = handleSize * 10.0f;
                        verts[0] = position + (slideDir1 * helperSize + slideDir2 * helperSize);
                        verts[1] = verts[0] - slideDir1 * helperSize * 2.0f;
                        verts[2] = verts[1] - slideDir2 * helperSize * 2.0f;
                        verts[3] = verts[2] + slideDir1 * helperSize * 2.0f;
                        Color prevColor = Handles.color;
                        Handles.color = Color.white;
                        float outline = 0.6f;
                        Handles.DrawSolidRectangleWithOutline(verts, new Color(1, 1, 1, 0.05f), new Color(outline, outline, outline, 0.4f));
                        Handles.color = prevColor;
                    }
                }

                break;
            }

            return deltaDistanceAlongDirections;
        }
</source>
<source file="UnityCsReference/Editor/Mono/EditorHandles/Slider2D.cs.ifdefed" startline="301" endline="414" pcid="11866">
        {
            Vector3 position = handlePos + offset;
            Quaternion rotation = Quaternion.LookRotation(handleDir, slideDir1);
            Vector2 deltaDistanceAlongDirections = new Vector2(0, 0);

            Event evt = Event.current;
            switch (evt.GetTypeForControl(id))
            {
                case EventType.Layout:
                    if (capFunction != null)
                        capFunction(id, position, rotation, handleSize, EventType.Layout);
                    else
                        HandleUtility.AddControl(id, HandleUtility.DistanceToCircle(handlePos + offset, handleSize * .5f));
                    break;
                case EventType.MouseDown:
                    // am I closest to the thingy?
                    if (HandleUtility.nearestControl == id && evt.button == 0 && GUIUtility.hotControl == 0)
                    {
                        s_CurrentMousePosition = evt.mousePosition;
                        bool success = true;
                        Vector3 localMousePoint = Handles.inverseMatrix.MultiplyPoint(GetMousePosition(handleDir, handlePos, ref success));
                        if (success)
                        {
                            GUIUtility.hotControl = id; // Grab mouse focus
                            s_StartPosition = handlePos;

                            Vector3 clickOffset = localMousePoint - handlePos;
                            s_StartPlaneOffset.x = Vector3.Dot(clickOffset, slideDir1);
                            s_StartPlaneOffset.y = Vector3.Dot(clickOffset, slideDir2);

                            evt.Use();
                            EditorGUIUtility.SetWantsMouseJumping(1);
                        }
                    }
                    break;
                case EventType.MouseDrag:
                    if (GUIUtility.hotControl == id)
                    {
                        s_CurrentMousePosition += evt.delta;
                        bool success = true;
                        Vector3 localMousePoint = Handles.inverseMatrix.MultiplyPoint(GetMousePosition(handleDir, handlePos, ref success));
                        if (success)
                        {
                            // Determine hitpos projection onto slideDirs
                            deltaDistanceAlongDirections.x = HandleUtility.PointOnLineParameter(localMousePoint, s_StartPosition, slideDir1);
                            deltaDistanceAlongDirections.y = HandleUtility.PointOnLineParameter(localMousePoint, s_StartPosition, slideDir2);
                            deltaDistanceAlongDirections -= s_StartPlaneOffset;
                            if (snap.x > 0 || snap.y > 0)
                            {
                                deltaDistanceAlongDirections.x = Handles.SnapValue(deltaDistanceAlongDirections.x, snap.x);
                                deltaDistanceAlongDirections.y = Handles.SnapValue(deltaDistanceAlongDirections.y, snap.y);
                            }

                            GUI.changed = true;
                        }
                        evt.Use();
                    }
                    break;
                case EventType.MouseUp:
                    if (GUIUtility.hotControl == id && (evt.button == 0 || evt.button == 2))
                    {
                        GUIUtility.hotControl = 0;
                        evt.Use();
                        EditorGUIUtility.SetWantsMouseJumping(0);
                    }
                    break;
                case EventType.MouseMove:
                    if (id == HandleUtility.nearestControl)
                        HandleUtility.Repaint();
                    break;
                case EventType.Repaint:
                {
                    if (capFunction == null)
                        break;

                    Color temp = Color.white;
                    if (id == GUIUtility.hotControl)
                    {
                        temp = Handles.color;
                        Handles.color = Handles.selectedColor;
                    }
                    else if (id == HandleUtility.nearestControl && GUIUtility.hotControl == 0)
                    {
                        temp = Handles.color;
                        Handles.color = Handles.preselectionColor;
                    }

                    capFunction(id, position, rotation, handleSize, EventType.Repaint);

                    if (id == GUIUtility.hotControl || id == HandleUtility.nearestControl && GUIUtility.hotControl == 0)
                        Handles.color = temp;

                    // Draw a helper rectangle to show what plane we are dragging in
                    if (drawHelper && GUIUtility.hotControl == id)
                    {
                        Vector3[] verts = new Vector3[4];
                        float helperSize = handleSize * 10.0f;
                        verts[0] = position + (slideDir1 * helperSize + slideDir2 * helperSize);
                        verts[1] = verts[0] - slideDir1 * helperSize * 2.0f;
                        verts[2] = verts[1] - slideDir2 * helperSize * 2.0f;
                        verts[3] = verts[2] + slideDir1 * helperSize * 2.0f;
                        Color prevColor = Handles.color;
                        Handles.color = Color.white;
                        float outline = 0.6f;
                        Handles.DrawSolidRectangleWithOutline(verts, new Color(1, 1, 1, 0.05f), new Color(outline, outline, outline, 0.4f));
                        Handles.color = prevColor;
                    }
                }

                break;
            }

            return deltaDistanceAlongDirections;
        }
</source>
</class>

<class classid="60" nclones="2" nlines="35" similarity="94">
<source file="UnityCsReference/Editor/Mono/EditorHandles/Button.cs.ifdefed" startline="18" endline="60" pcid="11896">
        {
            Event evt = Event.current;

            switch (evt.GetTypeForControl(id))
            {
                case EventType.Layout:
                    if (GUI.enabled)
                        HandleUtility.AddControl(id, HandleUtility.DistanceToCircle(position, pickSize));
                    break;
                case EventType.MouseMove:
                    if (HandleUtility.nearestControl == id && evt.button == 0)
                        HandleUtility.Repaint();
                    break;
                case EventType.MouseDown:
                    // am I closest to the thingy?
                    if (HandleUtility.nearestControl == id && (evt.button == 0 || evt.button == 2))
                    {
                        GUIUtility.hotControl = id; // Grab mouse focus
                        evt.Use();
                    }
                    break;
                case EventType.MouseUp:
                    if (GUIUtility.hotControl == id && (evt.button == 0 || evt.button == 2))
                    {
                        GUIUtility.hotControl = 0;
                        evt.Use();

                        if (HandleUtility.nearestControl == id)
                            return true;
                    }
                    break;
                case EventType.Repaint:
                    Color origColor = Handles.color;
                    if (HandleUtility.nearestControl == id && GUI.enabled && GUIUtility.hotControl == 0)
                        Handles.color = Handles.preselectionColor;

                    capFunc(id, position, direction, size);

                    Handles.color = origColor;
                    break;
            }
            return false;
        }
</source>
<source file="UnityCsReference/Editor/Mono/EditorHandles/Button.cs.ifdefed" startline="63" endline="105" pcid="11899">
        {
            Event evt = Event.current;

            switch (evt.GetTypeForControl(id))
            {
                case EventType.Layout:
                    if (GUI.enabled)
                        capFunction(id, position, direction, pickSize, EventType.Layout);
                    break;
                case EventType.MouseMove:
                    if (HandleUtility.nearestControl == id && evt.button == 0)
                        HandleUtility.Repaint();
                    break;
                case EventType.MouseDown:
                    // am I closest to the thingy?
                    if (HandleUtility.nearestControl == id && (evt.button == 0 || evt.button == 2))
                    {
                        GUIUtility.hotControl = id; // Grab mouse focus
                        evt.Use();
                    }
                    break;
                case EventType.MouseUp:
                    if (GUIUtility.hotControl == id && (evt.button == 0 || evt.button == 2))
                    {
                        GUIUtility.hotControl = 0;
                        evt.Use();

                        if (HandleUtility.nearestControl == id)
                            return true;
                    }
                    break;
                case EventType.Repaint:
                    Color origColor = Handles.color;
                    if (HandleUtility.nearestControl == id && GUI.enabled && GUIUtility.hotControl == 0)
                        Handles.color = Handles.preselectionColor;

                    capFunction(id, position, direction, size, EventType.Repaint);

                    Handles.color = origColor;
                    break;
            }
            return false;
        }
</source>
</class>

<class classid="61" nclones="2" nlines="31" similarity="70">
<source file="UnityCsReference/Editor/Mono/HandleUtility.cs.ifdefed" startline="159" endline="196" pcid="11916">
        {
            Vector3 sideways = rotation * new Vector3(size.x, 0, 0);
            Vector3 up = rotation * new Vector3(0, size.y, 0);
            s_Points[0] = WorldToGUIPoint(position + sideways + up);
            s_Points[1] = WorldToGUIPoint(position + sideways - up);
            s_Points[2] = WorldToGUIPoint(position - sideways - up);
            s_Points[3] = WorldToGUIPoint(position - sideways + up);
            s_Points[4] = s_Points[0];

            Vector2 pos = Event.current.mousePosition;
            bool oddNodes = false;
            int j = 4;
            for (int i = 0; i < 5; i++)
            {
                if ((s_Points[i].y > pos.y) != (s_Points[j].y > pos.y))
                {
                    if (pos.x < (s_Points[j].x - s_Points[i].x) * (pos.y - s_Points[i].y) / (s_Points[j].y - s_Points[i].y) + s_Points[i].x)
                    {
                        oddNodes = !oddNodes;
                    }
                }
                j = i;
            }
            if (!oddNodes)
            {
                // Distance to closest edge (not so fast)
                float closestDist = -1f;
                j = 1;
                for (int i = 0; i < 4; i++)
                {
                    var dist = DistancePointToLineSegment(pos, s_Points[i], s_Points[j++]);
                    if (dist < closestDist || closestDist < 0)
                        closestDist = dist;
                }
                return closestDist;
            }
            return 0;
        }
</source>
<source file="UnityCsReference/Editor/Mono/HandleUtility.cs.ifdefed" startline="204" endline="241" pcid="11923">
        {
            Vector3 sideways = rotation * new Vector3(size, 0, 0);
            Vector3 up = rotation * new Vector3(0, size, 0);
            s_Points[0] = WorldToGUIPoint(position + sideways);
            s_Points[1] = WorldToGUIPoint(position - up);
            s_Points[2] = WorldToGUIPoint(position - sideways);
            s_Points[3] = WorldToGUIPoint(position + up);
            s_Points[4] = s_Points[0];

            Vector2 pos = mousePosition;
            bool oddNodes = false;
            int j = 4;
            for (int i = 0; i < 5; i++)
            {
                if ((s_Points[i].y > pos.y) != (s_Points[j].y > pos.y))
                {
                    if (pos.x < (s_Points[j].x - s_Points[i].x) * (pos.y - s_Points[i].y) / (s_Points[j].y - s_Points[i].y) + s_Points[i].x)
                    {
                        oddNodes = !oddNodes;
                    }
                }
                j = i;
            }
            if (!oddNodes)
            {
                // Distance to closest edge (not so fast)
                float dist, closestDist = -1f;
                j = 1;
                for (int i = 0; i < 4; i++)
                {
                    dist = DistancePointToLineSegment(pos, s_Points[i], s_Points[j++]);
                    if (dist < closestDist || closestDist < 0)
                        closestDist = dist;
                }
                return closestDist;
            }
            return 0;
        }
</source>
</class>

<class classid="62" nclones="2" nlines="11" similarity="90">
<source file="UnityCsReference/Editor/Mono/ArrayUtility.cs.ifdefed" startline="25" endline="38" pcid="11997">
        {
            if (lhs == null || rhs == null)
                return lhs == rhs;

            if (lhs.Length != rhs.Length)
                return false;

            for (int i = 0; i < lhs.Length; i++)
            {
                if (!lhs[i].Equals(rhs[i]))
                    return false;
            }
            return true;
        }
</source>
<source file="UnityCsReference/Editor/Mono/ArrayUtility.cs.ifdefed" startline="42" endline="55" pcid="11999">
        {
            if (lhs == null || rhs == null)
                return lhs == rhs;

            if (lhs.Length != rhs.Length)
                return false;

            for (int i = 0; i < lhs.Length; i++)
            {
                if (!object.ReferenceEquals(lhs[i], rhs[i]))
                    return false;
            }
            return true;
        }
</source>
</class>

<class classid="63" nclones="2" nlines="12" similarity="75">
<source file="UnityCsReference/Editor/Mono/TerrainEditor/TerrainInspector.cs.ifdefed" startline="44" endline="57" pcid="12199">
        {
            if (target > height)
            {
                height += brushStrength;
                height = Mathf.Min(height, target);
                return height;
            }
            else
            {
                height -= brushStrength;
                height = Mathf.Max(height, target);
                return height;
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/TerrainEditor/TerrainInspector.cs.ifdefed" startline="376" endline="389" pcid="12231">
            {
                if (targetHeight > height)
                {
                    height += brushStrength;
                    height = Mathf.Min(height, targetHeight);
                    return height;
                }
                else
                {
                    height -= brushStrength;
                    height = Mathf.Max(height, targetHeight);
                    return height;
                }
            }
</source>
</class>

<class classid="64" nclones="2" nlines="21" similarity="71">
<source file="UnityCsReference/Editor/Mono/TerrainEditor/TerrainInspector.cs.ifdefed" startline="827" endline="855" pcid="12261">
        {
            GUILayout.BeginVertical("box", GUILayout.MinHeight(10));
            int retval = 0;

            doubleClick = false;

            if (textures.Length != 0)
            {
                float columns = (EditorGUIUtility.currentViewWidth - 20) / approxSize;
                int rows = (int)Mathf.Ceil(textures.Length / columns);
                Rect r = GUILayoutUtility.GetAspectRect(columns / rows);

                Event evt = Event.current;
                if (evt.type == EventType.MouseDown && evt.clickCount == 2 && r.Contains(evt.mousePosition))
                {
                    doubleClick = true;
                    evt.Use();
                }

                retval = GUI.SelectionGrid(r, System.Math.Min(selected, textures.Length - 1), textures, Mathf.RoundToInt(EditorGUIUtility.currentViewWidth - 20) / approxSize, style);
            }
            else
            {
                GUILayout.Label(emptyString);
            }

            GUILayout.EndVertical();
            return retval;
        }
</source>
<source file="UnityCsReference/Editor/Mono/TerrainEditor/TerrainInspector.cs.ifdefed" startline="870" endline="896" pcid="12266">
        {
            EditorGUILayout.BeginVertical(GUIContent.none, EditorStyles.helpBox, GUILayout.MinHeight(10));
            int retval = 0;

            doubleClick = false;

            if (textures.Length != 0)
            {
                int xCount = 0;
                Rect rect = GetBrushAspectRect(textures.Length, approxSize, 12, out xCount);

                Event evt = Event.current;
                if (evt.type == EventType.MouseDown && evt.clickCount == 2 && rect.Contains(evt.mousePosition))
                {
                    doubleClick = true;
                    evt.Use();
                }
                retval = GUI.SelectionGrid(rect, System.Math.Min(selected, textures.Length - 1), textures, xCount, style);
            }
            else
            {
                GUILayout.Label(emptyString);
            }

            GUILayout.EndVertical();
            return retval;
        }
</source>
</class>

<class classid="65" nclones="2" nlines="23" similarity="100">
<source file="UnityCsReference/Editor/Mono/WebViewEditorWindow/WebViewEditorWindow.cs.ifdefed" startline="352" endline="385" pcid="12600">
        {
            if (!webView)
                return;

            var scriptCodeBuffer = new StringBuilder();
            scriptCodeBuffer.Append(objectName);
            scriptCodeBuffer.Append('.');
            scriptCodeBuffer.Append(name);
            scriptCodeBuffer.Append('(');

            var isFirst = true;
            foreach (var arg in args)
            {
                if (!isFirst)
                    scriptCodeBuffer.Append(',');

                // Quote strings.  This is pretty simple-minded as we don't escape
                // things within the string.
                var isString = arg is string;
                if (isString)
                    scriptCodeBuffer.Append('"');

                scriptCodeBuffer.Append(arg);

                if (isString)
                    scriptCodeBuffer.Append('"');

                isFirst = false;
            }

            scriptCodeBuffer.Append(");");

            webView.ExecuteJavascript(scriptCodeBuffer.ToString());
        }
</source>
<source file="UnityCsReference/Editor/Mono/AssetStore/AssetStoreWindow.cs.ifdefed" startline="273" endline="306" pcid="22879">
        {
            if (!webView)
                return;

            var scriptCodeBuffer = new StringBuilder();
            scriptCodeBuffer.Append(objectName);
            scriptCodeBuffer.Append('.');
            scriptCodeBuffer.Append(name);
            scriptCodeBuffer.Append('(');

            var isFirst = true;
            foreach (var arg in args)
            {
                if (!isFirst)
                    scriptCodeBuffer.Append(',');

                // Quote strings.  This is pretty simple-minded as we don't escape
                // things within the string.
                var isString = arg is string;
                if (isString)
                    scriptCodeBuffer.Append('"');

                scriptCodeBuffer.Append(arg);

                if (isString)
                    scriptCodeBuffer.Append('"');

                isFirst = false;
            }

            scriptCodeBuffer.Append(");");

            webView.ExecuteJavascript(scriptCodeBuffer.ToString());
        }
</source>
</class>

<class classid="66" nclones="2" nlines="28" similarity="70">
<source file="UnityCsReference/Editor/Mono/SceneModeWindows/LightingWindowBakeSettings.cs.ifdefed" startline="205" endline="240" pcid="13096">
        {
            EditorGUILayout.BeginHorizontal();

            EditorGUIInternal.AssetPopup<LightmapParameters>(prop, content, "giparams", "Default-Medium");

            string label = "Edit...";

            if (isBuiltIn(prop))
                label = "View";

            bool editClicked = false;

            if (prop.objectReferenceValue == null)
            {
                using (new EditorGUI.DisabledScope(true))
                {
                    if (GUILayout.Button(label, EditorStyles.miniButton, GUILayout.ExpandWidth(false)))
                    {
                        Selection.activeObject = null;
                        editClicked = true;
                    }
                }
            }
            else
            {
                if (GUILayout.Button(label, EditorStyles.miniButton, GUILayout.ExpandWidth(false)))
                {
                    Selection.activeObject = prop.objectReferenceValue;
                    editClicked = true;
                }
            }

            EditorGUILayout.EndHorizontal();

            return editClicked;
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/LightingSettingsInspector.cs.ifdefed" startline="527" endline="571" pcid="29067">
        {
            EditorGUILayout.BeginHorizontal();

            EditorGUIInternal.AssetPopup<LightmapParameters>(prop, content, "giparams", "Scene Default Parameters");

            string label = "Edit...";

            if (isBuiltIn(prop))
                label = "View";

            bool editClicked = false;

            // If object is null, then get the scene parameter setting and view this instead.
            if (prop.objectReferenceValue == null)
            {
                SerializedObject so = new SerializedObject(LightmapEditorSettings.GetLightmapSettings());
                SerializedProperty lightmapParameters = so.FindProperty("m_LightmapEditorSettings.m_LightmapParameters");

                using (new EditorGUI.DisabledScope(lightmapParameters == null))
                {
                    if (isBuiltIn(lightmapParameters))
                        label = "View";
                    else
                        label = "Edit...";

                    if (GUILayout.Button(label, EditorStyles.miniButton, GUILayout.ExpandWidth(false)))
                    {
                        Selection.activeObject = lightmapParameters.objectReferenceValue;
                        editClicked = true;
                    }
                }
            }
            else
            {
                if (GUILayout.Button(label, EditorStyles.miniButton, GUILayout.ExpandWidth(false)))
                {
                    Selection.activeObject = prop.objectReferenceValue;
                    editClicked = true;
                }
            }

            EditorGUILayout.EndHorizontal();

            return editClicked;
        }
</source>
</class>

<class classid="67" nclones="2" nlines="11" similarity="81">
<source file="UnityCsReference/Editor/Mono/Scripting/ScriptCompilers.cs.ifdefed" startline="34" endline="44" pcid="13369">
        {
            _target = target;
            _development_player = false;
            _editor = false;
            _allowUnsafeCode = allowUnsafeCode;
            _api_compatibility_level = api_compatibility_level;
            _files = files;
            _references = references;
            _defines = defines;
            _output = output;
        }
</source>
<source file="UnityCsReference/Editor/Mono/Scripting/ScriptCompilers.cs.ifdefed" startline="47" endline="57" pcid="13370">
        {
            _target = target;
            _development_player = development_player;
            _editor = editor;
            _allowUnsafeCode = allowUnsafeCode;
            _api_compatibility_level = api_compatibility_level;
            _files = files;
            _references = references;
            _defines = defines;
            _output = output;
        }
</source>
</class>

<class classid="68" nclones="2" nlines="11" similarity="72">
<source file="UnityCsReference/Editor/Mono/Scripting/ScriptCompilation/AssemblyBuilder.cs.ifdefed" startline="140" endline="152" pcid="13534">
        {
            if (buildStarted == null)
                return;

            try
            {
                buildStarted(assemblyPath);
            }
            catch (Exception e)
            {
                UnityEngine.Debug.LogException(e);
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/Scripting/ScriptCompilation/AssemblyBuilder.cs.ifdefed" startline="155" endline="169" pcid="13537">
        {
            if (buildFinished == null)
                return;

            var convertedMessages = EditorCompilation.ConvertCompilerMessages(messages);

            try
            {
                buildFinished(assemblyPath, convertedMessages);
            }
            catch (Exception e)
            {
                UnityEngine.Debug.LogException(e);
            }
        }
</source>
</class>

<class classid="69" nclones="2" nlines="11" similarity="90">
<source file="UnityCsReference/Editor/Mono/Audio/Mixer/Bindings/AudioMixerController.cs.ifdefed" startline="446" endline="461" pcid="13905">
        {
            if (snapshots.Length < 2)
                return;

            var deletedSnapshot = TargetSnapshot;

            Undo.RecordObject(this, "Remove Snapshot");

            var snapshotList = new List<AudioMixerSnapshotController>(snapshots);
            snapshotList.Remove(deletedSnapshot);
            snapshots = snapshotList.ToArray();

            Undo.DestroyObjectImmediate(deletedSnapshot);

            OnSubAssetChanged();
        }
</source>
<source file="UnityCsReference/Editor/Mono/Audio/Mixer/Bindings/AudioMixerController.cs.ifdefed" startline="464" endline="479" pcid="13906">
        {
            if (snapshots.Length < 2)
                return;

            var deletedSnapshot = snapshot;

            Undo.RecordObject(this, "Remove Snapshot");

            var snapshotList = new List<AudioMixerSnapshotController>(snapshots);
            snapshotList.Remove(deletedSnapshot);
            snapshots = snapshotList.ToArray();

            Undo.DestroyObjectImmediate(deletedSnapshot);

            OnSubAssetChanged();
        }
</source>
</class>

<class classid="70" nclones="2" nlines="20" similarity="75">
<source file="UnityCsReference/Editor/Mono/Audio/Mixer/GUI/AudioMixerGroupViewList.cs.ifdefed" startline="98" endline="124" pcid="14012">
        {
            if (s_Styles == null)
                s_Styles = new Styles();

            Rect headerRect, contentRect;
            using (new EditorGUI.DisabledScope(m_Controller == null))
            {
                AudioMixerDrawUtils.DrawRegionBg(rect, out headerRect, out contentRect);
                AudioMixerDrawUtils.HeaderLabel(headerRect, s_Styles.header, s_Styles.viewsIcon);
            }

            if (m_Controller != null)
            {
                // Ensure in-sync
                if (m_ReorderableListWithRenameAndScrollView.list.index != m_Controller.currentViewIndex)
                {
                    m_ReorderableListWithRenameAndScrollView.list.index = m_Controller.currentViewIndex;
                    m_ReorderableListWithRenameAndScrollView.FrameItem(m_Controller.currentViewIndex);
                }

                m_ReorderableListWithRenameAndScrollView.OnGUI(contentRect);

                // Call after list to prevent id mismatch
                if (GUI.Button(new Rect(headerRect.xMax - 15f, headerRect.y + 3f, 15f, 15f), s_Styles.addButton, EditorStyles.label))
                    Add();
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/Audio/Mixer/GUI/AudioMixerSnapshotView.cs.ifdefed" startline="136" endline="161" pcid="14216">
        {
            if (s_Styles == null)
                s_Styles = new Styles();

            Rect headerRect, contentRect;
            using (new EditorGUI.DisabledScope(m_Controller == null))
            {
                AudioMixerDrawUtils.DrawRegionBg(rect, out headerRect, out contentRect);
                AudioMixerDrawUtils.HeaderLabel(headerRect, s_Styles.header, s_Styles.snapshotsIcon);
            }

            if (m_Controller != null)
            {
                // Ensure gui is in-sync with backend (TargetSnapShotIndex can be changed anytime from the backend)
                int targetIndex = GetSnapshotIndex(m_Controller.TargetSnapshot);
                if (targetIndex != m_ReorderableListWithRenameAndScrollView.list.index)
                {
                    m_ReorderableListWithRenameAndScrollView.list.index = targetIndex;
                    m_ReorderableListWithRenameAndScrollView.FrameItem(targetIndex);
                }
                m_ReorderableListWithRenameAndScrollView.OnGUI(contentRect);

                if (GUI.Button(new Rect(headerRect.xMax - 15f, headerRect.y + 3f, 15f, 15f), s_Styles.addButton, EditorStyles.label))
                    Add();
            }
        }
</source>
</class>

<class classid="71" nclones="2" nlines="13" similarity="84">
<source file="UnityCsReference/Editor/Mono/Audio/Mixer/GUI/AudioMixerDrawUtils.cs.ifdefed" startline="189" endline="203" pcid="14063">
        {
            if (Event.current.type != EventType.Repaint)
                return;
            //Profiler.BeginSample ("DrawGradientRect");
            HandleUtility.ApplyWireMaterial();
            GL.Begin(GL.QUADS);
            GL.Color(new Color(c1.r, c1.g, c1.b, c1.a * GetAlpha()));
            Vertex(r.x, r.y);
            Vertex(r.x + r.width, r.y);
            GL.Color(new Color(c2.r, c2.g, c2.b, c2.a * GetAlpha()));
            Vertex(r.x + r.width, r.y + r.height);
            Vertex(r.x, r.y + r.height);
            GL.End();
            //Profiler.EndSample ();
        }
</source>
<source file="UnityCsReference/Editor/Mono/Audio/Mixer/GUI/AudioMixerDrawUtils.cs.ifdefed" startline="206" endline="220" pcid="14064">
        {
            if (Event.current.type != EventType.Repaint)
                return;
            //Profiler.BeginSample ("DrawGradientRectHorizontal");
            HandleUtility.ApplyWireMaterial();
            GL.Begin(GL.QUADS);
            GL.Color(new Color(c1.r, c1.g, c1.b, c1.a * GetAlpha()));
            Vertex(r.x + r.width, r.y);
            Vertex(r.x + r.width, r.y + r.height);
            GL.Color(new Color(c2.r, c2.g, c2.b, c2.a * GetAlpha()));
            Vertex(r.x, r.y + r.height);
            Vertex(r.x, r.y);
            GL.End();
            //Profiler.EndSample ();
        }
</source>
</class>

<class classid="72" nclones="3" nlines="13" similarity="84">
<source file="UnityCsReference/Editor/Mono/Audio/Mixer/GUI/AudioMixerDrawUtils.cs.ifdefed" startline="246" endline="258" pcid="14068">
        {
            GUIStyle style = new GUIStyle();
            style.focused.background = style.onNormal.background;
            style.focused.textColor = color;
            style.alignment = anchor;
            style.fontSize = fontSize;
            style.fontStyle = fontstyle;
            style.wordWrap = wrapText;
            style.clipping = TextClipping.Clip;
            style.normal.textColor = color;
            style.padding = new RectOffset(4, 4, 4, 4);
            return style;
        }
</source>
<source file="UnityCsReference/Editor/Mono/Audio/Effects/ParamEQGUI.cs.ifdefed" startline="35" endline="46" pcid="14723">
        {
            GUIStyle style = new GUIStyle();
            style.focused.background = style.onNormal.background;
            style.focused.textColor = color;
            style.alignment = anchor;
            style.fontSize = fontSize;
            style.fontStyle = fontstyle;
            style.wordWrap = wrapText;
            style.clipping = TextClipping.Overflow;
            style.normal.textColor = color;
            return style;
        }
</source>
<source file="UnityCsReference/Editor/Mono/Audio/Effects/DuckVolumeGUI.cs.ifdefed" startline="36" endline="47" pcid="14695">
        {
            GUIStyle style = new GUIStyle();
            style.focused.background = style.onNormal.background;
            style.focused.textColor = color;
            style.alignment = anchor;
            style.fontSize = fontSize;
            style.fontStyle = fontstyle;
            style.wordWrap = wrapText;
            style.clipping = TextClipping.Overflow;
            style.normal.textColor = color;
            return style;
        }
</source>
</class>

<class classid="73" nclones="2" nlines="28" similarity="72">
<source file="UnityCsReference/Editor/Mono/Audio/Mixer/GUI/TreeViewForAudioMixerGroups.cs.ifdefed" startline="155" endline="193" pcid="14422">
            {
                if (m_TreeView.isSearching)
                {
                    base.GetFirstAndLastRowVisible(out firstRowVisible, out lastRowVisible);
                    return;
                }
                var rowCount = m_TreeView.data.rowCount;
                if (rowCount != m_RowRects.Count)
                    Debug.LogError("Mismatch in state: rows vs cached rects");

                int firstVisible = -1;
                int lastVisible = -1;

                float topPixel = m_TreeView.state.scrollPos.y;
                float heightInPixels = m_TreeView.GetTotalRect().height;
                for (int i = 0; i < m_RowRects.Count; ++i)
                {
                    bool visible = ((m_RowRects[i].y > topPixel && (m_RowRects[i].y < topPixel + heightInPixels))) ||
                        ((m_RowRects[i].yMax > topPixel && (m_RowRects[i].yMax < topPixel + heightInPixels)));

                    if (visible)
                    {
                        if (firstVisible == -1)
                            firstVisible = i;
                        lastVisible = i;
                    }
                }

                if (firstVisible != -1 && lastVisible != -1)
                {
                    firstRowVisible = firstVisible;
                    lastRowVisible = lastVisible;
                }
                else
                {
                    firstRowVisible = 0;
                    lastRowVisible = rowCount - 1;
                }
            }
</source>
<source file="UnityCsReference/Editor/Mono/GUI/TreeView/TreeViewGUIWithCustomItemHeights.cs.ifdefed" startline="103" endline="140" pcid="20946">
        {
            float topPixel = m_TreeView.state.scrollPos.y;
            float heightInPixels = m_TreeView.GetTotalRect().height;

            var rowCount = m_TreeView.data.rowCount;
            if (rowCount != m_RowRects.Count)
            {
                Debug.LogError("Mismatch in state: rows vs cached rects. Did you remember to hook up: dataSource.onVisibleRowsChanged += gui.CalculateRowRects ?");
                CalculateRowRects();
            }

            int firstVisible = -1;
            int lastVisible = -1;

            for (int i = 0; i < m_RowRects.Count; ++i)
            {
                bool visible = ((m_RowRects[i].y > topPixel && (m_RowRects[i].y < topPixel + heightInPixels))) ||
                    ((m_RowRects[i].yMax > topPixel && (m_RowRects[i].yMax < topPixel + heightInPixels)));

                if (visible)
                {
                    if (firstVisible == -1)
                        firstVisible = i;
                    lastVisible = i;
                }
            }

            if (firstVisible != -1 && lastVisible != -1)
            {
                firstRowVisible = firstVisible;
                lastRowVisible = lastVisible;
            }
            else
            {
                firstRowVisible = 0;
                lastRowVisible = rowCount - 1;
            }
        }
</source>
</class>

<class classid="74" nclones="2" nlines="16" similarity="70">
<source file="UnityCsReference/Editor/Mono/Audio/Effects/DuckVolumeGUI.cs.ifdefed" startline="206" endline="225" pcid="14709">
                    {
                        float level = x * dbRange + dbMin;
                        float gain = level;
                        float t = level - duckThreshold;
                        col = ScaleAlpha(duckSidechainLevel > level ? AudioCurveRendering.kAudioOrange : Color.grey, blend);
                        if (t > -duckKnee && t < duckKnee)
                        {
                            t += duckKnee;
                            gain = t * (duckKneeC1 * t + 1.0f) + duckKneeC2;

                            if (dragtype == DragType.ThresholdAndKnee)
                            {
                                const float mult = 1.2f;
                                col = new Color(col.r * mult, col.g * mult, col.b * mult);
                            }
                        }
                        else if (t > 0.0f)
                            gain = duckThreshold + duckGradient * t;
                        return (2.0f * (gain + duckMakeupGain - dbMin) / dbRange) - 1.0f;
                    }
</source>
<source file="UnityCsReference/Editor/Mono/Audio/Effects/DuckVolumeGUI.cs.ifdefed" startline="230" endline="249" pcid="14712">
                {
                    AudioCurveRendering.DrawCurve(
                        r,
                        delegate(float x)
                        {
                            float level = x * dbRange + dbMin;
                            float gain = level;
                            float t = level - duckThreshold;
                            if (t > -duckKnee && t < duckKnee)
                            {
                                t += duckKnee;
                                gain = t * (duckKneeC1 * t + 1.0f) + duckKneeC2;
                            }
                            else if (t > 0.0f)
                                gain = duckThreshold + duckGradient * t;
                            return (2.0f * (gain + duckMakeupGain - dbMin) / dbRange) - 1.0f;
                        },
                        Color.white
                        );
                }
</source>
</class>

<class classid="75" nclones="2" nlines="33" similarity="70">
<source file="UnityCsReference/Editor/Mono/Audio/Effects/AudioCurveRendering.cs.ifdefed" startline="84" endline="122" pcid="14752">
        {
            if (Event.current.type != EventType.Repaint)
                return;

            HandleUtility.ApplyWireMaterial();

            GL.Begin(GL.LINES);

            // Adjust by a half pixel to each side so that the transition covers a full pixel.
            // This is needed for very slowly rising edges.
            float pixelScale = (float)EditorGUIUtility.pixelsPerPoint;
            float pixelSize = 1.0f / pixelScale;
            float pixelHalfSize = 0.5f * pixelSize;
            float pixelWidth = Mathf.Ceil(r.width) * pixelScale;
            float startx = Mathf.Floor(r.x) + pixelEpsilon;
            float wx = 1.0f / (float)(pixelWidth - 1);
            float cy = r.height * 0.5f;
            float my = r.y + 0.5f * r.height;
            float y1 = r.y + r.height;
            Color color;

            float py = Mathf.Clamp(cy * eval(0.0f, out color), -cy, cy);
            for (int x = 0; x < pixelWidth; x++)
            {
                float nx = startx + x * pixelSize;
                float ny = Mathf.Clamp(cy * eval(x * wx, out color), -cy, cy);
                float e1 = Mathf.Min(ny, py) - pixelHalfSize;
                float e2 = Mathf.Max(ny, py) + pixelHalfSize;
                GL.Color(new Color(color.r, color.g, color.b, 0.0f));
                AudioMixerDrawUtils.Vertex(nx, my - e2);
                GL.Color(color);
                AudioMixerDrawUtils.Vertex(nx, my - e1);
                AudioMixerDrawUtils.Vertex(nx, my - e1);
                AudioMixerDrawUtils.Vertex(nx, y1);
                py = ny;
            }

            GL.End();
        }
</source>
<source file="UnityCsReference/Editor/Mono/Audio/Effects/AudioCurveRendering.cs.ifdefed" startline="186" endline="227" pcid="14758">
        {
            if (Event.current.type != EventType.Repaint)
                return;

            HandleUtility.ApplyWireMaterial();

            GL.Begin(GL.LINES);

            // Adjust by a half pixel to each side so that the transition covers a full pixel.
            // This is needed for very slowly rising edges.
            float pixelScale = (float)EditorGUIUtility.pixelsPerPoint;
            float pixelSize = 1.0f / pixelScale;
            float pixelHalfSize = 0.5f * pixelSize;
            float pixelWidth = Mathf.Ceil(r.width) * pixelScale;
            float startx = Mathf.Floor(r.x) + pixelEpsilon;
            float wx = 1.0f / (float)(pixelWidth - 1);
            float cy = r.height * 0.5f;
            float my = r.y + 0.5f * r.height;
            Color color;

            float py = Mathf.Clamp(cy * eval(0.0001f, out color), 0.0f, cy);
            for (int x = 0; x < pixelWidth; x++)
            {
                float nx = startx + x * pixelSize;
                float ny = Mathf.Clamp(cy * eval(x * wx, out color), 0.0f, cy);
                float e1 = Mathf.Max(Mathf.Min(ny, py) - pixelHalfSize, 0.0f); // Avoid self-intersection
                float e2 = Mathf.Min(Mathf.Max(ny, py) + pixelHalfSize, cy);
                Color edgeColor = new Color(color.r, color.g, color.b, 0.0f);
                GL.Color(edgeColor);
                AudioMixerDrawUtils.Vertex(nx, my - e2);
                GL.Color(color);
                AudioMixerDrawUtils.Vertex(nx, my - e1);
                AudioMixerDrawUtils.Vertex(nx, my - e1);
                AudioMixerDrawUtils.Vertex(nx, my + e1);
                AudioMixerDrawUtils.Vertex(nx, my + e1);
                GL.Color(edgeColor);
                AudioMixerDrawUtils.Vertex(nx, my + e2);
                py = ny;
            }

            GL.End();
        }
</source>
</class>

<class classid="76" nclones="2" nlines="46" similarity="72">
<source file="UnityCsReference/Editor/Mono/Audio/StreamedAudioClipPreview.cs.ifdefed" startline="308" endline="372" pcid="14800">
        {
            var channels = m_Clip.channels;
            var samples = details.previewSamples;
            var delta = details.deltaStep;
            var position = details.normalizedStart * samples;
            var preview = details.preview;

            if (delta > 0.5)
            {
                int oldPosition = (int)position, floorPosition = oldPosition;
                // for each step, there's more than one sample so we do min max on the min max data
                // to avoid aliasing issues
                for (int i = 0; i < details.previewPixelsToRender; ++i)
                {
                    for (int c = 0; c < channels; ++c)
                    {
                        var x = oldPosition;
                        floorPosition = (int)position;

                        float min = preview[2 * x * channels + c * 2];
                        float max = preview[2 * x * channels + c * 2 + 1];

                        while (++x < floorPosition)
                        {
                            // yes, the data contained in the min max audio util overview is actually swapped (maxmin data)
                            min = Mathf.Max(min, preview[2 * x * channels + c * 2]);
                            max = Mathf.Min(max, preview[2 * x * channels + c * 2 + 1]);
                        }

                        resampledPreview[2 * i * channels + c * 2] = max;
                        resampledPreview[2 * i * channels + c * 2 + 1] = min;
                    }

                    position += delta;
                    oldPosition = floorPosition;
                }
            }
            else
            {
                // fractionate interpolation
                for (int i = 0; i < details.previewPixelsToRender; ++i)
                {
                    var x = (int)(position - 1);
                    var x1 = x + 1;
                    float fraction = (float)((position - 1) - x);

                    x = Mathf.Max(0, x);
                    x1 = Mathf.Min(x1, samples - 1);

                    for (int c = 0; c < channels; ++c)
                    {
                        var minCurrent = preview[2 * x * channels + c * 2];
                        var maxCurrent = preview[2 * x * channels + c * 2 + 1];

                        var minNext = preview[2 * x1 * channels + c * 2];
                        var maxNext = preview[2 * x1 * channels + c * 2 + 1];

                        resampledPreview[2 * i * channels + c * 2] = fraction * maxNext + (1 - fraction) * maxCurrent;
                        resampledPreview[2 * i * channels + c * 2 + 1] = fraction * minNext + (1 - fraction) * minCurrent;
                    }

                    position += delta;
                }
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/Audio/StreamedAudioClipPreview.cs.ifdefed" startline="375" endline="445" pcid="14808">
        {
            var previewSize = details.preview.Length;
            var channels = m_Clip.channels;
            var samples = details.previewSamples;

            var delta = details.deltaStep;
            var position = details.normalizedStart * samples;
            var preview = details.preview;

            if (delta > 0.5)
            {
                int oldPosition = (int)position, floorPosition = oldPosition;
                // for each step, there's more than one sample so we do min max on the min max data
                // to avoid aliasing issues
                for (int i = 0; i < details.previewPixelsToRender; ++i)
                {
                    for (int c = 0; c < channels; ++c)
                    {
                        var x = oldPosition;
                        floorPosition = (int)position;

                        var wrappedIndex = (2 * x * channels + c * 2) % previewSize;

                        float min = preview[wrappedIndex];
                        float max = preview[wrappedIndex + 1];

                        while (++x < floorPosition)
                        {
                            wrappedIndex = (2 * x * channels + c * 2) % previewSize;
                            // yes, the data contained in the min max audio util overview is actually swapped (maxmin data)
                            min = Mathf.Max(min, preview[wrappedIndex]);
                            max = Mathf.Min(max, preview[wrappedIndex + 1]);
                        }

                        resampledPreview[2 * i * channels + c * 2] = max;
                        resampledPreview[2 * i * channels + c * 2 + 1] = min;
                    }

                    position += delta;
                    oldPosition = floorPosition;
                }
            }
            else
            {
                // fractionate interpolation
                for (int i = 0; i < details.previewPixelsToRender; ++i)
                {
                    var x = (int)(position - 1);
                    var x1 = x + 1;
                    float fraction = (float)((position - 1) - x);

                    for (int c = 0; c < channels; ++c)
                    {
                        var xWrapped = (2 * x * channels + c * 2) % previewSize;

                        var minCurrent = preview[xWrapped];
                        var maxCurrent = preview[xWrapped + 1];

                        var x1Wrapped = (2 * x1 * channels + c * 2) % previewSize;

                        var minNext = preview[x1Wrapped];
                        var maxNext = preview[x1Wrapped + 1];

                        resampledPreview[2 * i * channels + c * 2] = fraction * maxNext + (1 - fraction) * maxCurrent;
                        resampledPreview[2 * i * channels + c * 2 + 1] = fraction * minNext + (1 - fraction) * minCurrent;
                    }

                    position += delta;
                }
            }
        }
</source>
</class>

<class classid="77" nclones="3" nlines="19" similarity="85">
<source file="UnityCsReference/Editor/Mono/GUIDebugger/GUIClipInspectView.cs.ifdefed" startline="104" endline="128" pcid="14895">
        {
            string currentProjectPath = Application.dataPath;

            int index = -1;

            for (int i = 0; i < stacktrace.Length; ++i)
            {
                StackFrame sf = stacktrace[i];
                if (string.IsNullOrEmpty(sf.sourceFile))
                    continue;
                if (sf.signature.StartsWith("UnityEngine.GUIClip"))
                    continue;

                if (index == -1)
                    index = i;

                if (sf.sourceFile.StartsWith(currentProjectPath))
                    return i;
            }

            if (index != -1)
                return index;

            return stacktrace.Length - 1;
        }
</source>
<source file="UnityCsReference/Editor/Mono/GUIDebugger/StyleDrawInspectView.cs.ifdefed" startline="171" endline="205" pcid="14993">
        {
            //We try to find the first frame that belongs to the user project.
            //If there is no frame inside the user project, we will return the first frame outside any class starting with:
            //UnityEngine.GUI or UnityEditor.EditorGUI, this should include:
            // - UnityEngine.GUIStyle
            // - UnityEngine.GUILayout
            // - UnityEngine.GUI
            // - UnityEditor.EditorGUI
            // - UnityEditor.EditorGUILayout
            string currentProjectPath = Application.dataPath;

            int index = -1;

            for (int i = 0; i < stacktrace.Length; ++i)
            {
                StackFrame sf = stacktrace[i];
                if (string.IsNullOrEmpty(sf.sourceFile))
                    continue;
                if (sf.signature.StartsWith("UnityEngine.GUI"))
                    continue;
                if (sf.signature.StartsWith("UnityEditor.EditorGUI"))
                    continue;

                if (index == -1)
                    index = i;

                if (sf.sourceFile.StartsWith(currentProjectPath))
                    return i;
            }

            if (index != -1)
                return index;

            return stacktrace.Length - 1;
        }
</source>
<source file="UnityCsReference/Editor/Mono/GUIDebugger/GUILayoutInspectView.cs.ifdefed" startline="132" endline="161" pcid="15015">
        {
            //We try to find the first frame that belongs to the user project.
            //If there is no frame inside the user project, we will return the first frame outside any class starting with:
            // - UnityEngine.GUILayoutUtility
            string currentProjectPath = Application.dataPath;

            int index = -1;

            for (int i = 0; i < stacktrace.Length; ++i)
            {
                StackFrame sf = stacktrace[i];
                if (string.IsNullOrEmpty(sf.sourceFile))
                    continue;
                if (sf.signature.StartsWith("UnityEngine.GUIDebugger"))
                    continue;
                if (sf.signature.StartsWith("UnityEngine.GUILayoutUtility"))
                    continue;

                if (index == -1)
                    index = i;

                if (sf.sourceFile.StartsWith(currentProjectPath))
                    return i;
            }

            if (index != -1)
                return index;

            return stacktrace.Length - 1;
        }
</source>
</class>

<class classid="78" nclones="3" nlines="13" similarity="80">
<source file="UnityCsReference/Editor/Mono/Annotation/SceneRenderModeWindow.cs.ifdefed" startline="207" endline="227" pcid="15217">
        {
            if (m_SceneView == null || m_SceneView.sceneViewState == null)
                return;

            // We do not use the layout event
            if (Event.current.type == EventType.Layout)
                return;

            Draw(editorWindow, rect.width);

            // Use mouse move so we get hover state correctly in the menu item rows
            if (Event.current.type == EventType.MouseMove)
                Event.current.Use();

            // Escape closes the window
            if (Event.current.type == EventType.KeyDown && Event.current.keyCode == KeyCode.Escape)
            {
                editorWindow.Close();
                GUIUtility.ExitGUI();
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/Annotation/SceneFXWindow.cs.ifdefed" startline="35" endline="59" pcid="15266">
        {
            if (m_SceneView == null || m_SceneView.sceneViewState == null)
                return;

            // We do not use the layout event
            if (Event.current.type == EventType.Layout)
                return;

            if (s_Styles == null)
                s_Styles = new Styles();

            // Content
            Draw(rect);

            // Use mouse move so we get hover state correctly in the menu item rows
            if (Event.current.type == EventType.MouseMove)
                Event.current.Use();

            // Escape closes the window
            if (Event.current.type == EventType.KeyDown && Event.current.keyCode == KeyCode.Escape)
            {
                editorWindow.Close();
                GUIUtility.ExitGUI();
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/ShaderInspector.cs.ifdefed" startline="484" endline="504" pcid="30774">
        {
            if (m_Shader == null)
                return;

            // We do not use the layout event
            if (Event.current.type == EventType.Layout)
                return;

            Draw(editorWindow, rect.width);

            // Use mouse move so we get hover state correctly in the menu item rows
            if (Event.current.type == EventType.MouseMove)
                Event.current.Use();

            // Escape closes the window
            if (Event.current.type == EventType.KeyDown && Event.current.keyCode == KeyCode.Escape)
            {
                editorWindow.Close();
                GUIUtility.ExitGUI();
            }
        }
</source>
</class>

<class classid="79" nclones="2" nlines="14" similarity="78">
<source file="UnityCsReference/Editor/Mono/RetainedMode.cs.ifdefed" startline="70" endline="88" pcid="15637">
        {
            var iterator = UIElementsUtility.GetPanelsIterator();
            while (iterator.MoveNext())
            {
                var panel = iterator.Current.Value;

                // Game panels' scheduler are ticked by the engine
                if (panel.contextType != ContextType.Editor)
                    continue;

                // Dispatch might have triggered a repaint request.
                if (panel.visualTree.IsDirty(ChangeType.Repaint))
                {
                    var guiView = panel.ownerObject as GUIView;
                    if (guiView != null)
                        guiView.Repaint();
                }
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/RetainedMode.cs.ifdefed" startline="154" endline="175" pcid="15652">
        {
            // clear caches that depend on loaded style sheets
            StyleSheetCache.ClearCaches();

            // for now we don't bother tracking which panel depends on which style sheet
            var iterator = UIElementsUtility.GetPanelsIterator();
            while (iterator.MoveNext())
            {
                var panel = iterator.Current.Value;

                // In-game doesn't support styling
                if (panel.contextType != ContextType.Editor)
                    continue;

                panel.styleContext.DirtyStyleSheets();
                panel.visualTree.Dirty(ChangeType.Styles); // dirty all styles

                var guiView = panel.ownerObject as GUIView;
                if (guiView != null)
                    guiView.Repaint();
            }
        }
</source>
</class>

<class classid="80" nclones="2" nlines="45" similarity="76">
<source file="UnityCsReference/Editor/Mono/ImportSettings/TextureImporterInspector.cs.ifdefed" startline="127" endline="224" pcid="16069">
            {
                if (s_TextureFormatsValueAll != null)
                    return s_TextureFormatsValueAll;

                bool requireETC = false;
                bool requirePVRTC = false;
                bool requireETC2 = false;
                bool requireASTC = false;

                // Build available formats based on available platforms
                BuildPlatform[] validPlatforms = GetBuildPlayerValidPlatforms();
                foreach (BuildPlatform platform in validPlatforms)
                {
                    switch (platform.defaultTarget)
                    {
                        case BuildTarget.Android:
                            requirePVRTC = true;
                            requireETC = true;
                            requireETC2 = true;
                            requireASTC = true;
                            break;
                        case BuildTarget.iOS:
                            requirePVRTC = true;
                            requireETC = true;
                            requireETC2 = true;
                            break;
                        case BuildTarget.tvOS:
                            requirePVRTC = true;
                            requireASTC = true;
                            requireETC = true;
                            requireETC2 = true;
                            break;
                    }
                }
                List<int> formatValues = new List<int>();

                formatValues.AddRange(new[] {
                    (int)TextureImporterFormat.DXT1,
                    (int)TextureImporterFormat.DXT5,
                });

                if (requireETC)
                    formatValues.Add((int)TextureImporterFormat.ETC_RGB4);

                if (requirePVRTC)
                    formatValues.AddRange(new[] {
                        (int)TextureImporterFormat.PVRTC_RGB2,
                        (int)TextureImporterFormat.PVRTC_RGBA2,
                        (int)TextureImporterFormat.PVRTC_RGB4,
                        (int)TextureImporterFormat.PVRTC_RGBA4
                    });

                if (requireETC2)
                    formatValues.AddRange(new[] {
                        (int)TextureImporterFormat.ETC2_RGB4,
                        (int)TextureImporterFormat.ETC2_RGB4_PUNCHTHROUGH_ALPHA,
                        (int)TextureImporterFormat.ETC2_RGBA8
                    });

                if (requireASTC)
                    formatValues.AddRange(new[] {
                        (int)TextureImporterFormat.ASTC_RGB_4x4,
                        (int)TextureImporterFormat.ASTC_RGB_5x5,
                        (int)TextureImporterFormat.ASTC_RGB_6x6,
                        (int)TextureImporterFormat.ASTC_RGB_8x8,
                        (int)TextureImporterFormat.ASTC_RGB_10x10,
                        (int)TextureImporterFormat.ASTC_RGB_12x12,
                        (int)TextureImporterFormat.ASTC_RGBA_4x4,
                        (int)TextureImporterFormat.ASTC_RGBA_5x5,
                        (int)TextureImporterFormat.ASTC_RGBA_6x6,
                        (int)TextureImporterFormat.ASTC_RGBA_8x8,
                        (int)TextureImporterFormat.ASTC_RGBA_10x10,
                        (int)TextureImporterFormat.ASTC_RGBA_12x12
                    });


                formatValues.AddRange(new[] {
                    (int)TextureImporterFormat.RGB16,
                    (int)TextureImporterFormat.ARGB16,
                    (int)TextureImporterFormat.RGBA16,

                    (int)TextureImporterFormat.RGB24,
                    (int)TextureImporterFormat.Alpha8,
                    (int)TextureImporterFormat.ARGB32,
                    (int)TextureImporterFormat.RGBA32,
                    (int)TextureImporterFormat.RGBAHalf,
                    (int)TextureImporterFormat.BC6H,
                    (int)TextureImporterFormat.BC7,

                    (int)TextureImporterFormat.DXT1Crunched,
                    (int)TextureImporterFormat.DXT5Crunched,
                    (int)TextureImporterFormat.ETC_RGB4Crunched,
                    (int)TextureImporterFormat.ETC2_RGBA8Crunched,
                });

                s_TextureFormatsValueAll = formatValues.ToArray();
                return s_TextureFormatsValueAll;
            }
</source>
<source file="UnityCsReference/Editor/Mono/ImportSettings/TextureImporterInspector.cs.ifdefed" startline="231" endline="316" pcid="16071">
            {
                bool requireETC = false;
                bool requirePVRTC = false;
                bool requireETC2 = false;
                bool requireASTC = false;

                // Build available normals formats based on available platforms
                BuildPlatform[] validPlatforms = GetBuildPlayerValidPlatforms();
                foreach (BuildPlatform platform in validPlatforms)
                {
                    switch (platform.defaultTarget)
                    {
                        case BuildTarget.Android:
                            requirePVRTC = true;
                            requireETC = true;
                            requireETC2 = true;
                            requireASTC = true;
                            break;
                        case BuildTarget.iOS:
                            requirePVRTC = true;
                            requireETC = true;
                            requireETC2 = true;
                            break;
                        case BuildTarget.tvOS:
                            requirePVRTC = true;
                            requireASTC = true;
                            requireETC = true;
                            requireETC2 = true;
                            break;
                    }
                }
                List<int> formatValues = new List<int>();

                formatValues.AddRange(new[] {
                    (int)TextureImporterFormat.DXT5
                });

                if (requirePVRTC)
                    formatValues.AddRange(new[] {
                        (int)TextureImporterFormat.PVRTC_RGB2,
                        (int)TextureImporterFormat.PVRTC_RGBA2,
                        (int)TextureImporterFormat.PVRTC_RGB4,
                        (int)TextureImporterFormat.PVRTC_RGBA4,
                    });

                if (requireETC)
                    formatValues.AddRange(new int[] {
                        (int)TextureImporterFormat.ETC_RGB4,
                    });

                if (requireETC2)
                    formatValues.AddRange(new[] {
                        (int)TextureImporterFormat.ETC2_RGB4,
                        (int)TextureImporterFormat.ETC2_RGB4_PUNCHTHROUGH_ALPHA,
                        (int)TextureImporterFormat.ETC2_RGBA8
                    });

                if (requireASTC)
                    formatValues.AddRange(new[] {
                        (int)TextureImporterFormat.ASTC_RGB_4x4,
                        (int)TextureImporterFormat.ASTC_RGB_5x5,
                        (int)TextureImporterFormat.ASTC_RGB_6x6,
                        (int)TextureImporterFormat.ASTC_RGB_8x8,
                        (int)TextureImporterFormat.ASTC_RGB_10x10,
                        (int)TextureImporterFormat.ASTC_RGB_12x12,
                        (int)TextureImporterFormat.ASTC_RGBA_4x4,
                        (int)TextureImporterFormat.ASTC_RGBA_5x5,
                        (int)TextureImporterFormat.ASTC_RGBA_6x6,
                        (int)TextureImporterFormat.ASTC_RGBA_8x8,
                        (int)TextureImporterFormat.ASTC_RGBA_10x10,
                        (int)TextureImporterFormat.ASTC_RGBA_12x12
                    });

                formatValues.AddRange(new[] {
                    (int)TextureImporterFormat.ARGB16,
                    (int)TextureImporterFormat.RGBA16,

                    (int)TextureImporterFormat.RGBA32,

                    (int)TextureImporterFormat.DXT5Crunched
                });

                s_NormalFormatsValueAll = formatValues.ToArray();

                return s_NormalFormatsValueAll;
            }
</source>
</class>

<class classid="81" nclones="2" nlines="11" similarity="75">
<source file="UnityCsReference/Editor/Mono/ImportSettings/TextureImporterInspector.cs.ifdefed" startline="1340" endline="1352" pcid="16132">
            {
                EditorGUI.BeginChangeCheck();
                EditorGUI.showMixedValue = m_Aniso.hasMultipleDifferentValues;
                int aniso = m_Aniso.intValue;
                if (aniso == -1)
                    aniso = 1;
                aniso = EditorGUILayout.IntSlider("Aniso Level", aniso, 0, 16);
                EditorGUI.showMixedValue = false;
                if (EditorGUI.EndChangeCheck())
                    m_Aniso.intValue = aniso;

                TextureInspector.DoAnisoGlobalSettingNote(aniso);
            }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/TextureInspector.cs.ifdefed" startline="353" endline="362" pcid="26434">
        {
            EditorGUI.BeginChangeCheck();
            EditorGUI.showMixedValue = m_Aniso.hasMultipleDifferentValues;
            int aniso = m_Aniso.intValue;
            aniso = EditorGUILayout.IntSlider("Aniso Level", aniso, 0, 16);
            EditorGUI.showMixedValue = false;
            if (EditorGUI.EndChangeCheck())
                m_Aniso.intValue = aniso;
            DoAnisoGlobalSettingNote(aniso);
        }
</source>
</class>

<class classid="82" nclones="2" nlines="13" similarity="73">
<source file="UnityCsReference/Editor/Mono/ImportSettings/TextureImporterInspector.cs.ifdefed" startline="1488" endline="1507" pcid="16148">
        {
            foreach (AssetImporter importer in targets)
            {
                Texture tex = AssetDatabase.LoadMainAssetAtPath(importer.assetPath) as Texture;
                if (tex != null) // This can happen if the texture fails to import (for example, cube texture with non-PoT input).
                {
                    if (m_Aniso.intValue != -1)
                        TextureUtil.SetAnisoLevelNoDirty(tex, m_Aniso.intValue);
                    if (m_FilterMode.intValue != -1)
                        TextureUtil.SetFilterModeNoDirty(tex, (FilterMode)m_FilterMode.intValue);
                    if ((m_WrapU.intValue != -1 || m_WrapV.intValue != -1 || m_WrapW.intValue != -1) &&
                        !m_WrapU.hasMultipleDifferentValues && !m_WrapV.hasMultipleDifferentValues && !m_WrapW.hasMultipleDifferentValues)
                    {
                        TextureUtil.SetWrapModeNoDirty(tex, (TextureWrapMode)m_WrapU.intValue, (TextureWrapMode)m_WrapV.intValue, (TextureWrapMode)m_WrapW.intValue);
                    }
                }
            }

            SceneView.RepaintAll();
        }
</source>
<source file="UnityCsReference/Editor/Mono/ImportSettings/IHVImageFormatImporterInspector.cs.ifdefed" startline="81" endline="95" pcid="16208">
            {
                // copy pasted from TextureImporterInspector.TextureSettingsGUI()
                foreach (AssetImporter importer in targets)
                {
                    Texture tex = AssetDatabase.LoadMainAssetAtPath(importer.assetPath) as Texture;
                    if (m_FilterMode.intValue != -1)
                        TextureUtil.SetFilterModeNoDirty(tex, (FilterMode)m_FilterMode.intValue);
                    if ((m_WrapU.intValue != -1 || m_WrapV.intValue != -1 || m_WrapW.intValue != -1) &&
                        !m_WrapU.hasMultipleDifferentValues && !m_WrapV.hasMultipleDifferentValues && !m_WrapW.hasMultipleDifferentValues)
                    {
                        TextureUtil.SetWrapModeNoDirty(tex, (TextureWrapMode)m_WrapU.intValue, (TextureWrapMode)m_WrapV.intValue, (TextureWrapMode)m_WrapW.intValue);
                    }
                }
                SceneView.RepaintAll();
            }
</source>
</class>

<class classid="83" nclones="2" nlines="13" similarity="92">
<source file="UnityCsReference/Editor/Mono/ImportSettings/TextureImporterInspector.cs.ifdefed" startline="1511" endline="1526" pcid="16152">
        {
            // DoesSourceTextureHaveAlpha will throw exception on importer reset (593478).
            try
            {
                count = 0;
                foreach (Object t in importers)
                    if ((t as TextureImporter).DoesSourceTextureHaveAlpha())
                        count++;
                return true;
            }
            catch
            {
                count = importers.Length;
                return false;
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/ImportSettings/TextureImporterInspector.cs.ifdefed" startline="1529" endline="1544" pcid="16155">
        {
            // DoesSourceTextureHaveAlpha will throw exception on importer reset (593478).
            try
            {
                count = 0;
                foreach (Object t in importers)
                    if ((t as TextureImporter).IsSourceTextureHDR())
                        count++;
                return true;
            }
            catch
            {
                count = importers.Length;
                return false;
            }
        }
</source>
</class>

<class classid="84" nclones="2" nlines="13" similarity="76">
<source file="UnityCsReference/Editor/Mono/ImportSettings/ModelImporterClipEditor.cs.ifdefed" startline="930" endline="945" pcid="16380">
                {
                    GUILayout.BeginHorizontal(EditorStyles.helpBox);
                    GUILayout.Label(styles.MaskHasAPath,
                        EditorStyles.wordWrappedMiniLabel);
                    GUILayout.FlexibleSpace();
                    GUILayout.BeginVertical();
                    GUILayout.Space(5);
                    if (GUILayout.Button(styles.UpdateMask))
                    {
                        SetTransformMaskFromReference(clipInfo);
                        m_MaskInspector.FillNodeInfos();
                    }

                    GUILayout.EndVertical();
                    GUILayout.EndHorizontal();
                }
</source>
<source file="UnityCsReference/Editor/Mono/ImportSettings/ModelImporterClipEditor.cs.ifdefed" startline="947" endline="960" pcid="16382">
                {
                    GUILayout.BeginHorizontal(EditorStyles.helpBox);
                    GUILayout.Label(styles.SourceMaskHasChanged,
                        EditorStyles.wordWrappedMiniLabel);
                    GUILayout.FlexibleSpace();
                    GUILayout.BeginVertical();
                    GUILayout.Space(5);
                    if (GUILayout.Button(styles.UpdateMask))
                    {
                        clipInfo.MaskToClip(clipInfo.maskSource);
                    }
                    GUILayout.EndVertical();
                    GUILayout.EndHorizontal();
                }
</source>
</class>

<class classid="85" nclones="2" nlines="13" similarity="84">
<source file="UnityCsReference/Editor/Mono/ImportSettings/AssetImporterEditor.cs.ifdefed" startline="180" endline="198" pcid="16497">
        {
            // When using the cache server we have to write all import settings to disk first.
            // Then perform the import (Otherwise the cache server will not be used for the import)
            foreach (string path in paths)
                AssetDatabase.WriteImportSettingsIfDirty(path);

            try
            {
                AssetDatabase.StartAssetEditing();
                foreach (string path in paths)
                    AssetDatabase.ImportAsset(path);
            }
            finally
            {
                AssetDatabase.StopAssetEditing();
            }

            OnAssetImportDone();
        }
</source>
<source file="UnityCsReference/Editor/Mono/ImportSettings/ModelImporterRigEditor.cs.ifdefed" startline="449" endline="463" pcid="16778">
            {
                foreach (string path in paths)
                    SetupReferencedClip(path);

                try
                {
                    AssetDatabase.StartAssetEditing();
                    foreach (string path in paths)
                        AssetDatabase.ImportAsset(path);
                }
                finally
                {
                    AssetDatabase.StopAssetEditing();
                }
            }
</source>
</class>

<class classid="86" nclones="2" nlines="30" similarity="75">
<source file="UnityCsReference/Editor/Mono/ImportSettings/SpeedTreeImporterInspector.cs.ifdefed" startline="334" endline="382" pcid="16600">
                {
                    // Slightly grow position on the x because edge buttons overflow by 5 pixels
                    var barPosition = sliderPosition;
                    barPosition.x -= 5;
                    barPosition.width += 10;

                    if (barPosition.Contains(evt.mousePosition))
                    {
                        evt.Use();
                        GUIUtility.hotControl = sliderId;

                        // Check for button click
                        var clickedButton = false;

                        // case:464019 have to re-sort the LOD array for these buttons to get the overlaps in the right order...
                        var lodsLeft = lods.Where(lod => lod.ScreenPercent > 0.5f).OrderByDescending(x => x.LODLevel);
                        var lodsRight = lods.Where(lod => lod.ScreenPercent <= 0.5f).OrderBy(x => x.LODLevel);

                        var lodButtonOrder = new List<LODGroupGUI.LODInfo>();
                        lodButtonOrder.AddRange(lodsLeft);
                        lodButtonOrder.AddRange(lodsRight);

                        foreach (var lod in lodButtonOrder)
                        {
                            if (lod.m_ButtonPosition.Contains(evt.mousePosition))
                            {
                                m_SelectedLODSlider = lod.LODLevel;
                                m_SelectedLODRange = lod.LODLevel;
                                clickedButton = true;
                                break;
                            }
                        }

                        if (!clickedButton)
                        {
                            // Check for range click
                            foreach (var lod in lodButtonOrder)
                            {
                                if (lod.m_RangePosition.Contains(evt.mousePosition))
                                {
                                    m_SelectedLODSlider = -1;
                                    m_SelectedLODRange = lod.LODLevel;
                                    break;
                                }
                            }
                        }
                    }
                    break;
                }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/LODGroupEditor.cs.ifdefed" startline="790" endline="830" pcid="30319">
                    {
                        evt.Use();
                        GUIUtility.hotControl = sliderId;

                        // Check for button click
                        var clickedButton = false;

                        // case:464019 have to re-sort the LOD array for these buttons to get the overlaps in the right order...
                        var lodsLeft = lods.Where(lod => lod.ScreenPercent > 0.5f).OrderByDescending(x => x.LODLevel);
                        var lodsRight = lods.Where(lod => lod.ScreenPercent <= 0.5f).OrderBy(x => x.LODLevel);

                        var lodButtonOrder = new List<LODGroupGUI.LODInfo>();
                        lodButtonOrder.AddRange(lodsLeft);
                        lodButtonOrder.AddRange(lodsRight);

                        foreach (var lod in lodButtonOrder)
                        {
                            if (lod.m_ButtonPosition.Contains(evt.mousePosition))
                            {
                                m_SelectedLODSlider = lod.LODLevel;
                                clickedButton = true;
                                // Bias by 0.1% so that there is no skipping when sliding
                                BeginLODDrag(lod.RawScreenPercent + 0.001f, m_LODGroup);
                                break;
                            }
                        }

                        if (!clickedButton)
                        {
                            // Check for range click
                            foreach (var lod in lodButtonOrder)
                            {
                                if (lod.m_RangePosition.Contains(evt.mousePosition))
                                {
                                    m_SelectedLODSlider = -1;
                                    m_SelectedLOD = lod.LODLevel;
                                    break;
                                }
                            }
                        }
                    }
</source>
</class>

<class classid="87" nclones="2" nlines="11" similarity="72">
<source file="UnityCsReference/Editor/Mono/ImportSettings/ModelImporterRigEditor.cs.ifdefed" startline="621" endline="635" pcid="16798">
            {
                foreach (InspectorWindow i in InspectorWindow.GetAllInspectorWindows())
                {
                    ActiveEditorTracker activeEditor = i.tracker;
                    foreach (Editor e in activeEditor.activeEditors)
                    {
                        // the tab is no longer an editor, so we must always refer to the panel container
                        if (e is ModelImporterEditor && ((ModelImporterEditor)e).activeTab == this)
                        {
                            return i.isLocked;
                        }
                    }
                }
                return false;
            }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/Avatar/AvatarEditor.cs.ifdefed" startline="589" endline="602" pcid="28462">
        {
            foreach (InspectorWindow i in InspectorWindow.GetAllInspectorWindows())
            {
                ActiveEditorTracker activeEditor = i.tracker;
                foreach (Editor e in activeEditor.activeEditors)
                {
                    if (e == this)
                    {
                        m_InspectorLocked = i.isLocked;
                        i.isLocked = locked;
                    }
                }
            }
        }
</source>
</class>

<class classid="88" nclones="2" nlines="13" similarity="71">
<source file="UnityCsReference/Editor/Mono/ImportSettings/ModelImporterRigEditor.cs.ifdefed" startline="709" endline="729" pcid="16812">
                {
                    ModelImporter importer = targets[i] as ModelImporter;

                    GameObject go = AssetDatabase.LoadMainAssetAtPath(importer.assetPath) as GameObject;
                    // The character could be optimized right now
                    // 'm_OptimizeGameObjects' can't be used to tell if it is optimized, because the user can change this value from UI,
                    // and the change hasn't been applied yet.
                    Animator animator = go.GetComponent<Animator>();
                    bool noTransformHierarchy = animator && !animator.hasTransformHierarchy;
                    if (noTransformHierarchy)
                    {
                        go = Instantiate(go) as GameObject;
                        AnimatorUtility.DeoptimizeTransformHierarchy(go);
                    }

                    SerializedObject so = new SerializedObject(targets[i]);
                    so.ApplyModifiedPropertiesWithoutUndo();

                    if (noTransformHierarchy)
                        DestroyImmediate(go);
                }
</source>
<source file="UnityCsReference/Editor/Mono/ImportSettings/ModelImporterRigEditor.cs.ifdefed" startline="755" endline="768" pcid="16816">
                    {
                        Animator animator = go.GetComponent<Animator>();
                        bool noTransformHierarchy = animator && !animator.hasTransformHierarchy;
                        if (noTransformHierarchy)
                        {
                            go = Instantiate(go) as GameObject;
                            AnimatorUtility.DeoptimizeTransformHierarchy(go);
                        }
                        AvatarSetupTool.AutoSetupOnInstance(go, so);
                        m_IsBiped = AvatarBipedMapper.IsBiped(go.transform, m_BipedMappingReport);

                        if (noTransformHierarchy)
                            DestroyImmediate(go);
                    }
</source>
</class>

<class classid="89" nclones="2" nlines="32" similarity="73">
<source file="UnityCsReference/Editor/Mono/Modules/DefaultTextureImportSettingsExtension.cs.ifdefed" startline="129" endline="172" pcid="17047">
                        {
                            // on gles targets we use rgb normal maps so no need to split formats
                            if (TextureImporterInspector.IsGLESMobileTargetPlatform(platformSettings.m_Target))
                            {
                                if (platformSettings.m_Target == BuildTarget.iOS || platformSettings.m_Target == BuildTarget.tvOS)
                                {
                                    formatValues = TextureImportPlatformSettings.kTextureFormatsValueApplePVR;
                                    formatStrings = TextureImporterInspector.s_TextureFormatStringsApplePVR;
                                }
                                else
                                {
                                    formatValues = TextureImportPlatformSettings.kTextureFormatsValueAndroid;
                                    formatStrings = TextureImporterInspector.s_TextureFormatStringsAndroid;
                                }
                            }
                            else if (textureTypeForThis == TextureImporterType.NormalMap)
                            {
                                formatValues = TextureImportPlatformSettings.kNormalFormatsValueDefault;
                                formatStrings = TextureImporterInspector.s_NormalFormatStringsDefault;
                            }
                            else
                            {
                                if (platformSettings.m_Target == BuildTarget.WebGL)
                                {
                                    formatValues = TextureImportPlatformSettings.kTextureFormatsValueWebGL;
                                    formatStrings = TextureImporterInspector.s_TextureFormatStringsWebGL;
                                }
                                else if (platformSettings.m_Target == BuildTarget.PSP2)
                                {
                                    formatValues = TextureImportPlatformSettings.kTextureFormatsValuePSP2;
                                    formatStrings = TextureImporterInspector.s_TextureFormatStringsPSP2;
                                }
                                else if (platformSettings.m_Target == BuildTarget.Switch)
                                {
                                    formatValues = TextureImportPlatformSettings.kTextureFormatsValueSwitch;
                                    formatStrings = TextureImporterInspector.s_TextureFormatStringsSwitch;
                                }
                                else
                                {
                                    formatValues = TextureImportPlatformSettings.kTextureFormatsValueDefault;
                                    formatStrings = TextureImporterInspector.s_TextureFormatStringsDefault;
                                }
                            }
                        }
</source>
<source file="UnityCsReference/Editor/Mono/2D/Common/TexturePlatformSettingsFormatHelper.cs.ifdefed" startline="13" endline="50" pcid="18663">
        {
            if (TextureImporterInspector.IsGLESMobileTargetPlatform(buildTarget))
            {
                if (buildTarget == BuildTarget.iOS || buildTarget == BuildTarget.tvOS)
                {
                    formatValues = TextureImportPlatformSettings.kTextureFormatsValueApplePVR;
                    formatStrings = TextureImporterInspector.s_TextureFormatStringsApplePVR;
                }
                else
                {
                    formatValues = TextureImportPlatformSettings.kTextureFormatsValueAndroid;
                    formatStrings = TextureImporterInspector.s_TextureFormatStringsAndroid;
                }
            }
            else
            {
                if (buildTarget == BuildTarget.WebGL)
                {
                    formatValues = TextureImportPlatformSettings.kTextureFormatsValueWebGL;
                    formatStrings = TextureImporterInspector.s_TextureFormatStringsWebGL;
                }
                else if (buildTarget == BuildTarget.PSP2)
                {
                    formatValues = TextureImportPlatformSettings.kTextureFormatsValuePSP2;
                    formatStrings = TextureImporterInspector.s_TextureFormatStringsPSP2;
                }
                else if (buildTarget == BuildTarget.Switch)
                {
                    formatValues = TextureImportPlatformSettings.kTextureFormatsValueSwitch;
                    formatStrings = TextureImporterInspector.s_TextureFormatStringsSwitch;
                }
                else
                {
                    formatValues = TextureImportPlatformSettings.kTextureFormatsValueDefault;
                    formatStrings = TextureImporterInspector.s_TextureFormatStringsDefault;
                }
            }
        }
</source>
</class>

<class classid="90" nclones="3" nlines="23" similarity="86">
<source file="UnityCsReference/Editor/Mono/PerformanceTools/FrameDebugger.cs.ifdefed" startline="1004" endline="1038" pcid="17172">
        {
            GUILayout.BeginHorizontal();
            GUILayout.Space(kShaderPropertiesIndention);

            ShaderFloatInfo t = floats[startIndex];

            if (numValues == 1)
            {
                GUILayout.Label(t.name, EditorStyles.miniLabel, GUILayout.MinWidth(kNameFieldWidth));
                DrawShaderPropertyFlags(t.flags);
                GUILayout.Label(t.value.ToString(kFloatFormat), EditorStyles.miniLabel, GUILayout.MinWidth(kValueFieldWidth));
                ShaderPropertyCopyValueMenu(GUILayoutUtility.GetLastRect(), t.value);
            }
            else
            {
                string arrayName = String.Format("{0} [{1}]", t.name, numValues);
                GUILayout.Label(arrayName, EditorStyles.miniLabel, GUILayout.MinWidth(kNameFieldWidth));
                DrawShaderPropertyFlags(t.flags);

                Rect buttonRect = GUILayoutUtility.GetRect(Styles.arrayValuePopupButton, GUI.skin.button, GUILayout.MinWidth(kValueFieldWidth));
                buttonRect.width = kArrayValuePopupBtnWidth;
                if (GUI.Button(buttonRect, Styles.arrayValuePopupButton))
                {
                    ArrayValuePopup.GetValueStringDelegate getValueString =
                        (int index, bool highPrecision) => floats[index].value.ToString(highPrecision ? kFloatDetailedFormat : kFloatFormat);

                    PopupWindowWithoutFocus.Show(
                        buttonRect,
                        new ArrayValuePopup(startIndex, numValues, 100.0f, getValueString),
                        new[] { PopupLocationHelper.PopupLocation.Left, PopupLocationHelper.PopupLocation.Below, PopupLocationHelper.PopupLocation.Right });
                }
            }

            GUILayout.EndHorizontal();
        }
</source>
<source file="UnityCsReference/Editor/Mono/PerformanceTools/FrameDebugger.cs.ifdefed" startline="1078" endline="1112" pcid="17180">
        {
            GUILayout.BeginHorizontal();
            GUILayout.Space(kShaderPropertiesIndention);

            ShaderMatrixInfo t = matrices[startIndex];

            if (numValues == 1)
            {
                GUILayout.Label(t.name, EditorStyles.miniLabel, GUILayout.MinWidth(kNameFieldWidth));
                DrawShaderPropertyFlags(t.flags);
                GUILayout.Label(t.value.ToString(kFloatFormat), EditorStyles.miniLabel, GUILayout.MinWidth(kValueFieldWidth));
                ShaderPropertyCopyValueMenu(GUILayoutUtility.GetLastRect(), t.value);
            }
            else
            {
                string arrayName = String.Format("{0} [{1}]", t.name, numValues);
                GUILayout.Label(arrayName, EditorStyles.miniLabel, GUILayout.MinWidth(kNameFieldWidth));
                DrawShaderPropertyFlags(t.flags);

                Rect buttonRect = GUILayoutUtility.GetRect(Styles.arrayValuePopupButton, GUI.skin.button, GUILayout.MinWidth(kValueFieldWidth));
                buttonRect.width = kArrayValuePopupBtnWidth;
                if (GUI.Button(buttonRect, Styles.arrayValuePopupButton))
                {
                    ArrayValuePopup.GetValueStringDelegate getValueString =
                        (int index, bool highPrecision) => '\n' + matrices[index].value.ToString(highPrecision ? kFloatDetailedFormat : kFloatFormat);

                    PopupWindowWithoutFocus.Show(
                        buttonRect,
                        new ArrayValuePopup(startIndex, numValues, 200.0f, getValueString),
                        new[] { PopupLocationHelper.PopupLocation.Left, PopupLocationHelper.PopupLocation.Below, PopupLocationHelper.PopupLocation.Right });
                }
            }

            GUILayout.EndHorizontal();
        }
</source>
<source file="UnityCsReference/Editor/Mono/PerformanceTools/FrameDebugger.cs.ifdefed" startline="1041" endline="1075" pcid="17176">
        {
            GUILayout.BeginHorizontal();
            GUILayout.Space(kShaderPropertiesIndention);

            ShaderVectorInfo t = vectors[startIndex];

            if (numValues == 1)
            {
                GUILayout.Label(t.name, EditorStyles.miniLabel, GUILayout.MinWidth(kNameFieldWidth));
                DrawShaderPropertyFlags(t.flags);
                GUILayout.Label(t.value.ToString(kFloatFormat), EditorStyles.miniLabel, GUILayout.MinWidth(kValueFieldWidth));
                ShaderPropertyCopyValueMenu(GUILayoutUtility.GetLastRect(), t.value);
            }
            else
            {
                string arrayName = String.Format("{0} [{1}]", t.name, numValues);
                GUILayout.Label(arrayName, EditorStyles.miniLabel, GUILayout.MinWidth(kNameFieldWidth));
                DrawShaderPropertyFlags(t.flags);

                Rect buttonRect = GUILayoutUtility.GetRect(Styles.arrayValuePopupButton, GUI.skin.button, GUILayout.MinWidth(kValueFieldWidth));
                buttonRect.width = kArrayValuePopupBtnWidth;
                if (GUI.Button(buttonRect, Styles.arrayValuePopupButton))
                {
                    ArrayValuePopup.GetValueStringDelegate getValueString =
                        (int index, bool highPrecision) => vectors[index].value.ToString(highPrecision ? kFloatDetailedFormat : kFloatFormat);

                    PopupWindowWithoutFocus.Show(
                        buttonRect,
                        new ArrayValuePopup(startIndex, numValues, 200.0f, getValueString),
                        new[] { PopupLocationHelper.PopupLocation.Left, PopupLocationHelper.PopupLocation.Below, PopupLocationHelper.PopupLocation.Right });
                }
            }

            GUILayout.EndHorizontal();
        }
</source>
</class>

<class classid="91" nclones="2" nlines="12" similarity="75">
<source file="UnityCsReference/Editor/Mono/ScriptAttributeGUI/PropertyHandler.cs.ifdefed" startline="120" endline="134" pcid="18244">
            {
                foreach (DecoratorDrawer decorator in m_DecoratorDrawers)
                {
                    position.height = decorator.GetHeight();

                    oldLabelWidth = EditorGUIUtility.labelWidth;
                    oldFieldWidth = EditorGUIUtility.fieldWidth;
                    decorator.OnGUI(position);
                    EditorGUIUtility.labelWidth = oldLabelWidth;
                    EditorGUIUtility.fieldWidth = oldFieldWidth;

                    position.y += position.height;
                    propHeight -= position.height;
                }
            }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/MaterialPropertyDrawer.cs.ifdefed" startline="32" endline="46" pcid="30143">
            {
                foreach (var decorator in m_DecoratorDrawers)
                {
                    position.height = decorator.GetPropertyHeight(prop, label.text, editor);

                    oldLabelWidth = EditorGUIUtility.labelWidth;
                    oldFieldWidth = EditorGUIUtility.fieldWidth;
                    decorator.OnGUI(position, prop, label, editor);
                    EditorGUIUtility.labelWidth = oldLabelWidth;
                    EditorGUIUtility.fieldWidth = oldFieldWidth;

                    position.y += position.height;
                    propHeight -= position.height;
                }
            }
</source>
</class>

<class classid="92" nclones="2" nlines="13" similarity="92">
<source file="UnityCsReference/Editor/Mono/2D/Interface/ISpriteEditorDataProvider.cs.ifdefed" startline="168" endline="185" pcid="18504">
        {
            var outlineSP = mode == SpriteImportMode.Multiple ?
                importer.FindProperty("m_SpriteSheet.m_Sprites").GetArrayElementAtIndex(index).FindPropertyRelative("m_Outline") :
                importer.FindProperty("m_SpriteSheet.m_Outline");

            var outline = new List<Vector2[]>();
            for (int j = 0; j < outlineSP.arraySize; ++j)
            {
                SerializedProperty outlinePathSP = outlineSP.GetArrayElementAtIndex(j);
                var o = new Vector2[outlinePathSP.arraySize];
                for (int k = 0; k < outlinePathSP.arraySize; ++k)
                {
                    o[k] = outlinePathSP.GetArrayElementAtIndex(k).vector2Value;
                }
                outline.Add(o);
            }
            return outline;
        }
</source>
<source file="UnityCsReference/Editor/Mono/2D/Interface/ISpriteEditorDataProvider.cs.ifdefed" startline="382" endline="399" pcid="18532">
        {
            var outlineSP = mode == SpriteImportMode.Multiple ?
                importer.FindProperty("m_SpriteSheet.m_Sprites").GetArrayElementAtIndex(index).FindPropertyRelative("m_PhysicsShape") :
                importer.FindProperty("m_SpriteSheet.m_PhysicsShape");

            var outline = new List<Vector2[]>();
            for (int j = 0; j < outlineSP.arraySize; ++j)
            {
                SerializedProperty outlinePathSP = outlineSP.GetArrayElementAtIndex(j);
                var o = new Vector2[outlinePathSP.arraySize];
                for (int k = 0; k < outlinePathSP.arraySize; ++k)
                {
                    o[k] = outlinePathSP.GetArrayElementAtIndex(k).vector2Value;
                }
                outline.Add(o);
            }
            return outline;
        }
</source>
</class>

<class classid="93" nclones="2" nlines="14" similarity="78">
<source file="UnityCsReference/Editor/Mono/2D/Interface/ISpriteEditorDataProvider.cs.ifdefed" startline="188" endline="203" pcid="18507">
        {
            var outlineSP = rectSP.FindPropertyRelative("m_Outline");
            outlineSP.ClearArray();
            for (int j = 0; j < outline.Count; ++j)
            {
                outlineSP.InsertArrayElementAtIndex(j);
                var o = outline[j];
                SerializedProperty outlinePathSP = outlineSP.GetArrayElementAtIndex(j);
                outlinePathSP.ClearArray();
                for (int k = 0; k < o.Length; ++k)
                {
                    outlinePathSP.InsertArrayElementAtIndex(k);
                    outlinePathSP.GetArrayElementAtIndex(k).vector2Value = o[k];
                }
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/2D/Interface/ISpriteEditorDataProvider.cs.ifdefed" startline="402" endline="417" pcid="18535">
        {
            var outlineSP = rectSP.FindPropertyRelative("m_PhysicsShape");
            outlineSP.ClearArray();
            for (int j = 0; j < value.Count; ++j)
            {
                outlineSP.InsertArrayElementAtIndex(j);
                var o = value[j];
                SerializedProperty outlinePathSP = outlineSP.GetArrayElementAtIndex(j);
                outlinePathSP.ClearArray();
                for (int k = 0; k < o.Length; ++k)
                {
                    outlinePathSP.InsertArrayElementAtIndex(k);
                    outlinePathSP.GetArrayElementAtIndex(k).vector2Value = o[k];
                }
            }
        }
</source>
</class>

<class classid="94" nclones="2" nlines="10" similarity="70">
<source file="UnityCsReference/Editor/Mono/GUI/Splitter.cs.ifdefed" startline="171" endline="183" pcid="18782">
            {
                diff -= m1 - h1;
                realSizes[i2] += realSizes[i1] - m1;
                realSizes[i1] = m1;

                if (i1 != 0)
                    DoSplitter(i1 - 1, i2, diff);
                else
                    // can't resize more...
                    splitterInitialOffset -= diff;

                diffed = true;
            }
</source>
<source file="UnityCsReference/Editor/Mono/GUI/Splitter.cs.ifdefed" startline="203" endline="215" pcid="18785">
                {
                    diff -= realSizes[i1] - x1;
                    realSizes[i2] += realSizes[i1] - x1;
                    realSizes[i1] = x1;

                    if (i1 != 0)
                        DoSplitter(i1 - 1, i2, diff);
                    else
                        // can't resize more...
                        splitterInitialOffset -= diff;

                    diffed = true;
                }
</source>
</class>

<class classid="95" nclones="2" nlines="10" similarity="70">
<source file="UnityCsReference/Editor/Mono/GUI/Splitter.cs.ifdefed" startline="185" endline="197" pcid="18783">
            {
                diff -= h2 - m2;
                realSizes[i1] += realSizes[i2] - m2;
                realSizes[i2] = m2;

                if (i2 != realSizes.Length - 1)
                    DoSplitter(i1, i2 + 1, diff);
                else
                    // can't resize more...
                    splitterInitialOffset -= diff;

                diffed = true;
            }
</source>
<source file="UnityCsReference/Editor/Mono/GUI/Splitter.cs.ifdefed" startline="217" endline="229" pcid="18786">
                {
                    diff -= h2 - x2;
                    realSizes[i1] += realSizes[i2] - x2;
                    realSizes[i2] = x2;

                    if (i2 != realSizes.Length - 1)
                        DoSplitter(i1, i2 + 1, diff);
                    else
                        // can't resize more...
                        splitterInitialOffset -= diff;

                    diffed = true;
                }
</source>
</class>

<class classid="96" nclones="2" nlines="23" similarity="100">
<source file="UnityCsReference/Editor/Mono/GUI/Splitter.cs.ifdefed" startline="331" endline="360" pcid="18799">
                {
                    // If we have a GUIStyle here, we need to respect the subelements' margins
                    if (style != GUIStyle.none)
                    {
                        foreach (GUILayoutEntry i in entries)
                        {
                            float topMar = Mathf.Max(i.margin.top, padding.top);
                            float thisY = y + topMar;
                            float thisHeight = height - Mathf.Max(i.margin.bottom, padding.bottom) - topMar;

                            if (i.stretchHeight != 0)
                                i.SetVertical(thisY, thisHeight);
                            else
                                i.SetVertical(thisY, Mathf.Clamp(thisHeight, i.minHeight, i.maxHeight));
                        }
                    }
                    else
                    {
                        // If not, the subelements' margins have already been propagated upwards to this group, so we can safely ignore them
                        float thisY = y - margin.top;
                        float thisHeight = height + margin.vertical;
                        foreach (GUILayoutEntry i in entries)
                        {
                            if (i.stretchHeight != 0)
                                i.SetVertical(thisY + i.margin.top, thisHeight - i.margin.vertical);
                            else
                                i.SetVertical(thisY + i.margin.top, Mathf.Clamp(thisHeight - i.margin.vertical, i.minHeight, i.maxHeight));
                        }
                    }
                }
</source>
<source file="UnityCsReference/Modules/IMGUI/LayoutGroup.cs.ifdefed" startline="585" endline="614" pcid="35639">
            {
                // If we have a GUIStyle here, we need to respect the subelements' margins
                if (style != GUIStyle.none)
                {
                    foreach (GUILayoutEntry i in entries)
                    {
                        float topMar = Mathf.Max(i.margin.top, padding.top);
                        float thisY = y + topMar;
                        float thisHeight = height - Mathf.Max(i.margin.bottom, padding.bottom) - topMar;

                        if (i.stretchHeight != 0)
                            i.SetVertical(thisY, thisHeight);
                        else
                            i.SetVertical(thisY, Mathf.Clamp(thisHeight, i.minHeight, i.maxHeight));
                    }
                }
                else
                {
                    // If not, the subelements' margins have already been propagated upwards to this group, so we can safely ignore them
                    float thisY = y - margin.top;
                    float thisHeight = height + margin.vertical;
                    foreach (GUILayoutEntry i in entries)
                    {
                        if (i.stretchHeight != 0)
                            i.SetVertical(thisY + i.margin.top, thisHeight - i.margin.vertical);
                        else
                            i.SetVertical(thisY + i.margin.top, Mathf.Clamp(thisHeight - i.margin.vertical, i.minHeight, i.maxHeight));
                    }
                }
            }
</source>
</class>

<class classid="97" nclones="2" nlines="11" similarity="72">
<source file="UnityCsReference/Editor/Mono/GUI/PackageImportTreeView.cs.ifdefed" startline="85" endline="97" pcid="18885">
                {
                    done.Add(pitem);
                    var current = pitem.parent as PackageImportTreeViewItem;
                    while (current != null)
                    {
                        if (!done.Contains(current))
                        {
                            current.enableState = EnabledState.Mixed;
                            done.Add(current);
                        }
                        current = current.parent as PackageImportTreeViewItem;
                    }
                }
</source>
<source file="UnityCsReference/Editor/Mono/GUI/PackageExportTreeView.cs.ifdefed" startline="82" endline="94" pcid="21590">
                {
                    done.Add(pitem);
                    var current = pitem.parent as PackageExportTreeViewItem;
                    while (current != null)
                    {
                        if (!done.Contains(current))
                        {
                            current.enabledState = EnabledState.Mixed;
                            done.Add(current);
                        }
                        current = current.parent as PackageExportTreeViewItem;
                    }
                }
</source>
</class>

<class classid="98" nclones="2" nlines="13" similarity="92">
<source file="UnityCsReference/Editor/Mono/GUI/PackageImportTreeView.cs.ifdefed" startline="424" endline="440" pcid="18923">
            {
                // Toggle on/off
                EditorGUI.BeginChangeCheck();
                Toggle(m_PackageImportView.packageItems, pitem, toggleRect);
                if (EditorGUI.EndChangeCheck())
                {
                    // Only change selection if we already have single selection (Keep multi-selection when toggling)
                    if (m_TreeView.GetSelection().Length <= 1 || !m_TreeView.GetSelection().Contains(pitem.id))
                    {
                        m_TreeView.SetSelection(new int[] { pitem.id }, false);
                        m_TreeView.NotifyListenersThatSelectionChanged();
                    }
                    if (itemWasToggled != null)
                        itemWasToggled(pitem);
                    Event.current.Use();
                }
            }
</source>
<source file="UnityCsReference/Editor/Mono/GUI/PackageExportTreeView.cs.ifdefed" startline="292" endline="308" pcid="21616">
            {
                // Toggle on/off
                EditorGUI.BeginChangeCheck();
                Toggle(m_PackageExportView.items, pitem, toggleRect);
                if (EditorGUI.EndChangeCheck())
                {
                    // Only change selection if we already have single selection (Keep multi-selection when toggling)
                    if (m_TreeView.GetSelection().Length <= 1 || !m_TreeView.GetSelection().Contains(pitem.id))
                    {
                        m_TreeView.SetSelection(new int[] { pitem.id }, false);
                        m_TreeView.NotifyListenersThatSelectionChanged();
                    }
                    if (itemWasToggled != null)
                        itemWasToggled(pitem);
                    Event.current.Use();
                }
            }
</source>
</class>

<class classid="99" nclones="2" nlines="35" similarity="94">
<source file="UnityCsReference/Editor/Mono/GUI/PackageImportTreeView.cs.ifdefed" startline="579" endline="638" pcid="18940">
            {
                //We're in the root folder, so just return the root item as the parent.
                if (folderPath == "")
                    return m_RootItem;

                // Does folder path exist?
                int id = folderPath.GetHashCode();
                TreeViewItem item = TreeViewUtility.FindItem(id, m_RootItem);

                if (item != null)
                    return item;

                // Add folders as needed
                string[] splitPath = folderPath.Split('/');
                string currentPath = "";
                TreeViewItem currentItem = m_RootItem;
                int folderDepth = -1; // Will be incremented to the right depth in the loop.

                for (int depth = 0; depth < splitPath.Length; ++depth)
                {
                    string folder = splitPath[depth];
                    if (currentPath != "")
                        currentPath += '/';

                    currentPath += folder;

                    // Dont create a 'Assets' folder (we already have that as a hidden root)
                    if (depth == 0 && currentPath == "Assets")
                        continue;

                    // Only increment the folder depth if we are past the root "Assets" folder.
                    ++folderDepth;

                    id = currentPath.GetHashCode();

                    PackageImportTreeViewItem foundItem;
                    if (treeViewFolders.TryGetValue(currentPath, out foundItem))
                    {
                        currentItem = foundItem;
                    }
                    else
                    {
                        // If we do not have a tree view item for this folder we create one
                        var folderItem = new PackageImportTreeViewItem(null, id, folderDepth, currentItem, folder);

                        // Add to children array of the parent
                        currentItem.AddChild(folderItem);
                        currentItem = folderItem;

                        // Auto expand all folder items
                        if (initExpandedState)
                            m_TreeView.state.expandedIDs.Add(id);

                        // For faster finding of folders
                        treeViewFolders[currentPath] = folderItem;
                    }
                }

                return currentItem;
            }
</source>
<source file="UnityCsReference/Editor/Mono/GUI/PackageExportTreeView.cs.ifdefed" startline="422" endline="481" pcid="21629">
            {
                // We're in the root folder, so just return the root item as the parent.
                if (folderPath == "")
                    return m_RootItem;

                // Does folder path exist?
                int id = folderPath.GetHashCode();
                TreeViewItem item = TreeViewUtility.FindItem(id, m_RootItem);

                if (item != null)
                    return item;

                // Add folders as needed
                string[] splitPath = folderPath.Split('/');
                string currentPath = "";
                TreeViewItem currentItem = m_RootItem;
                int folderDepth = -1; // Will be incremented to the right depth in the loop.

                for (int depth = 0; depth < splitPath.Length; ++depth)
                {
                    string folder = splitPath[depth];
                    if (currentPath != "")
                        currentPath += '/';

                    currentPath += folder;

                    // Dont create a 'Assets' folder (we already have that as a hidden root)
                    if (depth == 0 && currentPath == "Assets")
                        continue;

                    // Only increment the folder depth if we are past the root "Assets" folder.
                    ++folderDepth;

                    id = currentPath.GetHashCode();

                    PackageExportTreeViewItem foundItem;
                    if (treeViewFolders.TryGetValue(currentPath, out foundItem))
                    {
                        currentItem = foundItem;
                    }
                    else
                    {
                        // If we do not have a tree view item for this folder we create one
                        var folderItem = new PackageExportTreeViewItem(null, id, folderDepth, currentItem, folder);

                        // Add to children array of the parent
                        currentItem.AddChild(folderItem);
                        currentItem = folderItem;

                        // Auto expand all folder items
                        if (initExpandedState)
                            m_TreeView.state.expandedIDs.Add(id);

                        // For faster finding of folders
                        treeViewFolders[currentPath] = folderItem;
                    }
                }

                return currentItem;
            }
</source>
</class>

<class classid="100" nclones="2" nlines="36" similarity="73">
<source file="UnityCsReference/Editor/Mono/GUI/PragmaFixingWindow.cs.ifdefed" startline="44" endline="96" pcid="18967">
        {
            if (s_Styles == null)
            {
                s_Styles = new Styles();
                minSize = new Vector2(450, 300);
                position = new Rect(position.x, position.y, minSize.x, minSize.y);
            }

            GUILayout.Space(10);
            GUILayout.Label("#pragma implicit and #pragma downcast need to be added to following files\nfor backwards compatibility");
            GUILayout.Space(10);

            GUILayout.BeginHorizontal();
            GUILayout.Space(10);
            foreach (ListViewElement el in ListViewGUILayout.ListView(m_LV, s_Styles.box))
            {
                if (el.row == m_LV.row && Event.current.type == EventType.Repaint)
                    s_Styles.selected.Draw(el.position, false, false, false, false);

                GUILayout.Label(m_Paths[el.row]);
            }
            GUILayout.Space(10);
            GUILayout.EndHorizontal();
            GUILayout.Space(10);

            GUILayout.BeginHorizontal();
            GUILayout.FlexibleSpace();
            if (GUILayout.Button("Fix now", s_Styles.button))
            {
                Close();
                PragmaFixing30.FixFiles(m_Paths);
                // bugfix (377429): do not call AssetDatabase.Refresh here as that screws up project upgrading.
                // When this script is invoked from Application::InitializeProject, the assets will be refreshed anyway.
                GUIUtility.ExitGUI();
            }

            if (GUILayout.Button("Ignore", s_Styles.button))
            {
                Close();
                GUIUtility.ExitGUI();
            }

            if (GUILayout.Button("Quit", s_Styles.button))
            {
                EditorApplication.Exit(0);
                GUIUtility.ExitGUI();
            }

            GUILayout.Space(10);
            GUILayout.EndHorizontal();

            GUILayout.Space(10);
        }
</source>
<source file="UnityCsReference/Editor/Mono/GUI/BumpMapSettingsFixingWindow.cs.ifdefed" startline="44" endline="86" pcid="19230">
        {
            if (s_Styles == null)
            {
                s_Styles = new Styles();
                minSize = new Vector2(400, 300);
                position = new Rect(position.x, position.y, minSize.x, minSize.y);
            }

            GUILayout.Space(5);
            GUILayout.Label(s_Styles.overviewText);
            GUILayout.Space(10);

            GUILayout.BeginHorizontal();
            GUILayout.Space(10);
            foreach (ListViewElement el in ListViewGUILayout.ListView(m_LV, s_Styles.box))
            {
                if (el.row == m_LV.row && Event.current.type == EventType.Repaint)
                    s_Styles.selected.Draw(el.position, false, false, false, false);

                GUILayout.Label(m_Paths[el.row]);
            }
            GUILayout.Space(10);
            GUILayout.EndHorizontal();
            GUILayout.Space(10);

            GUILayout.BeginHorizontal();
            GUILayout.FlexibleSpace();
            if (GUILayout.Button("Fix now", s_Styles.button))
            {
                InternalEditorUtility.BumpMapSettingsFixingWindowReportResult(1);
                Close();
            }

            if (GUILayout.Button("Ignore", s_Styles.button))
            {
                InternalEditorUtility.BumpMapSettingsFixingWindowReportResult(0);
                Close();
            }
            GUILayout.Space(10);
            GUILayout.EndHorizontal();

            GUILayout.Space(10);
        }
</source>
</class>

<class classid="101" nclones="2" nlines="11" similarity="72">
<source file="UnityCsReference/Editor/Mono/GUI/AssetSaveDialog.cs.ifdefed" startline="200" endline="212" pcid="19022">
        {
            List<string> newAssets = new List<string>();
            for (int i = 0; i < m_SelectedItems.Length; i++)
            {
                if (m_SelectedItems[i])
                    m_AssetsToSave.Add(m_Assets[i]);
                else
                    newAssets.Add(m_Assets[i]);
            }

            m_Assets = newAssets;
            RebuildLists(false);
        }
</source>
<source file="UnityCsReference/Editor/Mono/GUI/AssetSaveDialog.cs.ifdefed" startline="215" endline="228" pcid="19024">
        {
            List<string> newAssets = new List<string>();
            for (int i = 0; i < m_SelectedItems.Length; i++)
            {
                if (!m_SelectedItems[i])
                    newAssets.Add(m_Assets[i]);
            }

            m_Assets = newAssets;
            RebuildLists(false);

            if (m_Assets.Count == 0)
                CloseWindow();
        }
</source>
</class>

<class classid="102" nclones="2" nlines="10" similarity="70">
<source file="UnityCsReference/Editor/Mono/GUI/ReorderableList.cs.ifdefed" startline="385" endline="400" pcid="19095">
        {
            if (s_Defaults == null)
                s_Defaults = new Defaults();

            // do the custom or default header GUI
            Rect headerRect = GUILayoutUtility.GetRect(0, headerHeight, GUILayout.ExpandWidth(true));
            //Elements area
            Rect listRect = GUILayoutUtility.GetRect(10, GetListElementHeight(), GUILayout.ExpandWidth(true));
            // do the footer GUI
            Rect footerRect = GUILayoutUtility.GetRect(4, footerHeight, GUILayout.ExpandWidth(true));

            // do the parts of our list
            DoListHeader(headerRect);
            DoListElements(listRect);
            DoListFooter(footerRect);
        }
</source>
<source file="UnityCsReference/Editor/Mono/GUI/ReorderableList.cs.ifdefed" startline="403" endline="418" pcid="19096">
        {
            if (s_Defaults == null)
                s_Defaults = new Defaults();

            // do the custom or default header GUI
            Rect headerRect = new Rect(rect.x, rect.y, rect.width, headerHeight);
            //Elements area
            Rect listRect = new Rect(rect.x, headerRect.y + headerRect.height, rect.width, GetListElementHeight());
            // do the footer GUI
            Rect footerRect = new Rect(rect.x, listRect.y + listRect.height, rect.width, footerHeight);

            // do the parts of our list
            DoListHeader(headerRect);
            DoListElements(listRect);
            DoListFooter(footerRect);
        }
</source>
</class>

<class classid="103" nclones="2" nlines="10" similarity="90">
<source file="UnityCsReference/Editor/Mono/GUI/SplitView.cs.ifdefed" startline="522" endline="532" pcid="19537">
            {
                float delta = -p2;
                for (int i = 0; i < splitPos - 1; i++)
                {
                    if (vertical)
                        sources[i].y += delta;
                    else
                        sources[i].x += delta;
                }
                end += delta;
            }
</source>
<source file="UnityCsReference/Editor/Mono/GUI/SplitView.cs.ifdefed" startline="561" endline="571" pcid="19542">
            {
                float delta = limit - p2;
                for (int i = 0; i < splitPos - 1; i++)
                {
                    if (vertical)
                        sources[i].y += delta;
                    else
                        sources[i].x += delta;
                }
                end += delta;
            }
</source>
</class>

<class classid="104" nclones="3" nlines="23" similarity="73">
<source file="UnityCsReference/Editor/Mono/GUI/ObjectField.cs.ifdefed" startline="112" endline="143" pcid="19832">
                    {
                        Object[] references = DragAndDrop.objectReferences;
                        Object validatedObject = validator(references, objType, property, ObjectFieldValidatorOptions.None);

                        if (validatedObject != null)
                        {
                            // If scene objects are not allowed and object is a scene object then clear
                            if (!allowSceneObjects && !EditorUtility.IsPersistent(validatedObject))
                                validatedObject = null;
                        }

                        if (validatedObject != null)
                        {
                            DragAndDrop.visualMode = DragAndDropVisualMode.Generic;
                            if (eventType == EventType.DragPerform)
                            {
                                if (property != null)
                                    property.objectReferenceValue = validatedObject;
                                else
                                    obj = validatedObject;

                                GUI.changed = true;
                                DragAndDrop.AcceptDrag();
                                DragAndDrop.activeControlID = 0;
                            }
                            else
                            {
                                DragAndDrop.activeControlID = id;
                            }
                            Event.current.Use();
                        }
                    }
</source>
<source file="UnityCsReference/Editor/Mono/GUI/ObjectField.cs.ifdefed" startline="404" endline="432" pcid="19864">
                    {
                        Object[] references = DragAndDrop.objectReferences;
                        Object validatedObject = validator(references, objType, null, ObjectFieldValidatorOptions.None);

                        if (validatedObject != null)
                        {
                            // If scene objects are not allowed and object is a scene object then clear
                            if (!allowSceneObjects && !EditorUtility.IsPersistent(validatedObject))
                                validatedObject = null;
                        }

                        if (validatedObject != null)
                        {
                            DragAndDrop.visualMode = DragAndDropVisualMode.Generic;
                            if (eventType == EventType.DragPerform)
                            {
                                GUI.changed = true;
                                DragAndDrop.AcceptDrag();
                                DragAndDrop.activeControlID = 0;
                                Event.current.Use();
                                return validatedObject;
                            }
                            else
                            {
                                DragAndDrop.activeControlID = id;
                                Event.current.Use();
                            }
                        }
                    }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/Avatar/AvatarSetupTool.cs.ifdefed" startline="221" endline="253" pcid="28500">
                        {
                            Object[] references = DragAndDrop.objectReferences;
                            Object validatedObject = references.Length == 1 ? references[0] : null;
                            if (validatedObject != null)
                            {
                                if (!(validatedObject is Transform || validatedObject is GameObject) || EditorUtility.IsPersistent(validatedObject))
                                    validatedObject = null;
                            }
                            if (validatedObject != null)
                            {
                                DragAndDrop.visualMode = DragAndDropVisualMode.Generic;
                                if (eventType == EventType.DragPerform)
                                {
                                    Undo.RegisterCompleteObjectUndo(editor, "Avatar mapping modified");

                                    if (validatedObject is GameObject)
                                        bone = (validatedObject as GameObject).transform;
                                    else
                                        bone = validatedObject as Transform;

                                    Serialize(serializedObject);

                                    GUI.changed = true;
                                    DragAndDrop.AcceptDrag();
                                    DragAndDrop.activeControlID = 0;
                                }
                                else
                                {
                                    DragAndDrop.activeControlID = id;
                                }
                                Event.current.Use();
                            }
                        }
</source>
</class>

<class classid="105" nclones="2" nlines="37" similarity="97">
<source file="UnityCsReference/Editor/Mono/GUI/QuadTree.cs.ifdefed" startline="89" endline="144" pcid="20119">
        {
            float minX = Mathf.Min(p1.x, p2.x);
            float maxX = Mathf.Max(p1.x, p2.x);

            if (maxX > rect.xMax)
            {
                maxX = rect.xMax;
            }

            if (minX < rect.xMin)
            {
                minX = rect.xMin;
            }

            if (minX > maxX)
            {
                return false;
            }

            float minY = Mathf.Min(p1.y, p2.y);
            float maxY = Mathf.Max(p1.y, p2.y);

            float dx = p2.x - p1.x;

            if (Mathf.Abs(dx) > 0.0000001f)
            {
                float a = (p2.y - p1.y) / dx;
                float b = p1.y - a * p1.x;
                minY = a * minX + b;
                maxY = a * maxX + b;
            }

            if (minY > maxY)
            {
                float tmp = maxY;
                maxY = minY;
                minY = tmp;
            }

            if (maxY > rect.yMax)
            {
                maxY = rect.yMax;
            }

            if (minY < rect.yMin)
            {
                minY = rect.yMin;
            }

            if (minY > maxY)
            {
                return false;
            }

            return true;
        }
</source>
<source file="UnityCsReference/Modules/GraphViewEditor/Utils/RectUtils.cs.ifdefed" startline="13" endline="68" pcid="34053">
        {
            float minX = Mathf.Min(p1.x, p2.x);
            float maxX = Mathf.Max(p1.x, p2.x);

            if (maxX > rect.xMax)
            {
                maxX = rect.xMax;
            }

            if (minX < rect.xMin)
            {
                minX = rect.xMin;
            }

            if (minX > maxX)
            {
                return false;
            }

            float minY = Mathf.Min(p1.y, p2.y);
            float maxY = Mathf.Max(p1.y, p2.y);

            float dx = p2.x - p1.x;

            if (Mathf.Abs(dx) > float.Epsilon)
            {
                float a = (p2.y - p1.y) / dx;
                float b = p1.y - a * p1.x;
                minY = a * minX + b;
                maxY = a * maxX + b;
            }

            if (minY > maxY)
            {
                float tmp = maxY;
                maxY = minY;
                minY = tmp;
            }

            if (maxY > rect.yMax)
            {
                maxY = rect.yMax;
            }

            if (minY < rect.yMin)
            {
                minY = rect.yMin;
            }

            if (minY > maxY)
            {
                return false;
            }

            return true;
        }
</source>
</class>

<class classid="106" nclones="2" nlines="14" similarity="78">
<source file="UnityCsReference/Editor/Mono/GUI/TreeView/TreeViewTests/TreeViewTestBackEnd.cs.ifdefed" startline="186" endline="203" pcid="20252">
        {
            if (item == null)
                return null;

            if (item.id == id)
                return item;

            if (item.children == null)
                return null;

            foreach (Foo child in item.children)
            {
                Foo result = FindItemRecursive(child, id);
                if (result != null)
                    return result;
            }
            return null;
        }
</source>
<source file="UnityCsReference/Editor/Mono/GUI/TreeView/TreeViewUtililty.cs.ifdefed" startline="60" endline="77" pcid="20843">
        {
            if (item == null)
                return null;

            if (item.id == id)
                return item;

            if (!item.hasChildren)
                return null;

            foreach (TreeViewItem child in item.children)
            {
                TreeViewItem result = FindItemRecursive(id, child);
                if (result != null)
                    return result;
            }
            return null;
        }
</source>
</class>

<class classid="107" nclones="2" nlines="11" similarity="72">
<source file="UnityCsReference/Editor/Mono/GUI/TreeView/TreeViewTests/TreeViewTestDataSource.cs.ifdefed" startline="31" endline="43" pcid="20283">
        {
            if (source.hasChildren)
            {
                dest.children = new List<TreeViewItem>(source.children.Count);
                for (int i = 0; i < source.children.Count; ++i)
                {
                    BackendData.Foo s = source.children[i];
                    dest.children.Add(new FooTreeViewItem(s.id, dest.depth + 1, dest, s.name, s));
                    itemCounter++;
                    AddChildrenRecursive(s, dest.children[i]);
                }
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/GUI/TreeView/TreeViewTests/TreeViewTestLazyDataSource.cs.ifdefed" startline="38" endline="50" pcid="20299">
            {
                if (source.children != null && source.children.Count > 0)
                {
                    dest.children = new List<TreeViewItem>(source.children.Count);
                    for (int i = 0; i < source.children.Count; ++i)
                    {
                        BackendData.Foo s = source.children[i];
                        dest.children.Add(new FooTreeViewItem(s.id, dest.depth + 1, dest, s.name, s));
                        ++itemCounter;
                        AddVisibleChildrenRecursive(s, dest.children[i]);
                    }
                }
            }
</source>
</class>

<class classid="108" nclones="2" nlines="12" similarity="83">
<source file="UnityCsReference/Editor/Mono/GUI/TreeView/TreeViewController.cs.ifdefed" startline="1112" endline="1125" pcid="20676">
        {
            firstIndex = -1;
            lastIndex = -1;
            for (int i = 0; i < items.Count; ++i)
            {
                if (state.selectedIDs.Contains(items[i].id))
                {
                    if (firstIndex == -1)
                        firstIndex = i;
                    lastIndex = i; // just overwrite and we will have the last in the end...
                }
            }
            return firstIndex != -1 && lastIndex != -1;
        }
</source>
<source file="UnityCsReference/Editor/Mono/InternalEditorUtility.cs.ifdefed" startline="260" endline="273" pcid="25279">
        {
            firstIndex = -1;
            lastIndex = -1;
            for (int i = 0; i < allInstanceIDs.Count; ++i)
            {
                if (selectedInstanceIDs.Contains(allInstanceIDs[i]))
                {
                    if (firstIndex == -1)
                        firstIndex = i;
                    lastIndex = i; // just overwrite and we will have the last in the end...
                }
            }
            return firstIndex != -1 && lastIndex != -1;
        }
</source>
</class>

<class classid="109" nclones="2" nlines="12" similarity="83">
<source file="UnityCsReference/Editor/Mono/GUI/TreeView/TreeViewControl/TreeViewControlDataSource.cs.ifdefed" startline="82" endline="97" pcid="20775">
                {
                    TreeViewItem current = stack.Pop();
                    if (current.children != null)
                    {
                        foreach (var child in current.children)
                        {
                            if (child != null)
                            {
                                if (m_Owner.DoesItemMatchSearch(child, search))
                                    result.Add(child);

                                stack.Push(child);
                            }
                        }
                    }
                }
</source>
<source file="UnityCsReference/Editor/Mono/GUI/TreeView/TreeViewUtililty.cs.ifdefed" startline="27" endline="40" pcid="20836">
            {
                TreeViewItem current = stack.Pop();
                if (current.children != null)
                {
                    foreach (var child in current.children)
                    {
                        if (child != null)
                        {
                            child.depth = current.depth + 1;
                            stack.Push(child);
                        }
                    }
                }
            }
</source>
</class>

<class classid="110" nclones="2" nlines="15" similarity="86">
<source file="UnityCsReference/Editor/Mono/GUI/Knob.cs.ifdefed" startline="60" endline="80" pcid="21306">
            {
                if (KnobState().isEditing && CurrentEventType() != EventType.Repaint)
                    return DoKeyboardInput();

                switch (CurrentEventType())
                {
                    case EventType.MouseDown:
                        return OnMouseDown();

                    case EventType.MouseDrag:
                        return OnMouseDrag();

                    case EventType.MouseUp:
                        return OnMouseUp();

                    case EventType.Repaint:
                        return OnRepaint();
                }

                return currentValue;
            }
</source>
<source file="UnityCsReference/Modules/IMGUI/SliderHandler.cs.ifdefed" startline="48" endline="67" pcid="35695">
        {
            if (slider == null || thumb == null)
                return currentValue;

            switch (CurrentEventType())
            {
                case EventType.MouseDown:
                    return OnMouseDown();

                case EventType.MouseDrag:
                    return OnMouseDrag();

                case EventType.MouseUp:
                    return OnMouseUp();

                case EventType.Repaint:
                    return OnRepaint();
            }
            return currentValue;
        }
</source>
</class>

<class classid="111" nclones="2" nlines="11" similarity="75">
<source file="UnityCsReference/Editor/Mono/GUI/ScreenShotting.cs.ifdefed" startline="33" endline="43" pcid="21483">
        {
            GUIView v = GetMouseOverView();
            if (v != null)
            {
                string name = GetGUIViewName(v);
                Rect r = v.screenPosition;
                r.y -= 1;
                r.height += 2;
                SaveScreenShot(r, name);
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/GUI/ScreenShotting.cs.ifdefed" startline="62" endline="74" pcid="21487">
        {
            GUIView v = GetMouseOverView();
            if (v != null)
            {
                string name = GetGUIViewName(v) + "Extended";
                var main = Resources.FindObjectsOfTypeAll<MainView>()[0];
                Rect r = v.screenPosition;
                r.xMax = main.window.position.xMax;
                r.y -= 1;
                r.height += 2;
                SaveScreenShot(r, name);
            }
        }
</source>
</class>

<class classid="112" nclones="2" nlines="10" similarity="80">
<source file="UnityCsReference/Editor/Mono/BuildPipeline.bindings.cs.ifdefed" startline="391" endline="402" pcid="21748">
        {
            crc = 0;
            try
            {
                return BuildAssetBundleInternal(mainAsset, assets, null, pathName, assetBundleOptions, targetPlatformGroup, targetPlatform, out crc);
            }
            catch (System.Exception exception)
            {
                LogBuildExceptionAndExit("BuildPipeline.BuildAssetBundle", exception);
                return false;
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/BuildPipeline.bindings.cs.ifdefed" startline="422" endline="433" pcid="21753">
        {
            crc = 0;
            try
            {
                return BuildAssetBundleInternal(null, assets, assetNames, pathName, assetBundleOptions, targetPlatformGroup, targetPlatform, out crc);
            }
            catch (System.Exception exception)
            {
                LogBuildExceptionAndExit("BuildPipeline.BuildAssetBundleExplicitAssetNames", exception);
                return false;
            }
        }
</source>
</class>

<class classid="113" nclones="2" nlines="11" similarity="72">
<source file="UnityCsReference/Editor/Mono/Collab/CollabDialogs.cs.ifdefed" startline="25" endline="38" pcid="22191">
        {
            CollabPublishDialog dialog = ScriptableObject.CreateInstance<CollabPublishDialog>();
            dialog.Changelist = changelist;

            var rect = new Rect(100, 100, 600, 225);
            dialog.minSize = new Vector2(rect.width, rect.height);
            dialog.maxSize = new Vector2(rect.width, rect.height);
            dialog.position = rect;
            dialog.ShowModal();

            dialog.m_Parent.window.m_DontSaveToLayout = true;

            return dialog;
        }
</source>
<source file="UnityCsReference/Editor/Mono/Collab/CollabDialogs.cs.ifdefed" startline="94" endline="107" pcid="22196">
        {
            CollabCannotPublishDialog dialog = ScriptableObject.CreateInstance<CollabCannotPublishDialog>();
            dialog.InfoMessage = infoMessage;

            var rect = new Rect(100, 100, 600, 150);
            dialog.minSize = new Vector2(rect.width, rect.height);
            dialog.maxSize = new Vector2(rect.width, rect.height);
            dialog.position = rect;
            dialog.ShowModal();

            dialog.m_Parent.window.m_DontSaveToLayout = true;

            return dialog;
        }
</source>
</class>

<class classid="114" nclones="2" nlines="10" similarity="100">
<source file="UnityCsReference/Editor/Mono/AssetStore/Json.cs.ifdefed" startline="314" endline="324" pcid="22655">
        {
            str = str.Replace("\"", "\\\"");
            str = str.Replace("\\", "\\\\");
            str = str.Replace("\b", "\\b");
            str = str.Replace("\f", "\\f");
            str = str.Replace("\n", "\\n");
            str = str.Replace("\r", "\\r");
            str = str.Replace("\t", "\\t");
            // We do not use \uXXXX specifier but direct unicode in the string.
            return str;
        }
</source>
<source file="UnityCsReference/Editor/Mono/AssetStore/AssetStoreClient.cs.ifdefed" startline="45" endline="55" pcid="22697">
        {
            str = str.Replace("\"", "\\\"");
            str = str.Replace("\\", "\\\\");
            str = str.Replace("\b", "\\b");
            str = str.Replace("\f", "\\f");
            str = str.Replace("\n", "\\n");
            str = str.Replace("\r", "\\r");
            str = str.Replace("\t", "\\t");
            // We do not use \uXXXX specifier but direct unicode in the string.
            return str;
        }
</source>
</class>

<class classid="115" nclones="2" nlines="38" similarity="76">
<source file="UnityCsReference/Editor/Mono/AssetStore/AssetStoreInstaBuyWindow.cs.ifdefed" startline="245" endline="292" pcid="22824">
        {
            AssetStoreAsset.PreviewInfo item = m_Asset.previewInfo;
            GUILayout.BeginHorizontal();
            GUILayout.Space(5);
            GUILayout.Label(s_AssetStoreLogo, GUIStyle.none, GUILayout.ExpandWidth(false));
            GUILayout.BeginVertical();
            GUILayout.Label("Purchase completed succesfully", EditorStyles.boldLabel);
            GUILayout.Label("You will receive a receipt in your email soon.");

            bool hasMessage = m_Message != null && m_Message != "";
            float newHeight = kStandardHeight + (hasMessage ? 20 : 0);
            if (newHeight != position.height)
                position = new Rect(position.x, position.y, position.width, newHeight);

            if (hasMessage)
                GUILayout.Label(m_Message, EditorStyles.wordWrappedLabel);

            GUILayout.Label("Package: " + item.packageName, EditorStyles.wordWrappedLabel);

            GUILayout.EndVertical();
            GUILayout.Space(5);
            GUILayout.EndHorizontal();

            GUILayout.FlexibleSpace();

            GUILayout.BeginHorizontal();
            GUILayout.Space(8);

            GUILayout.FlexibleSpace();
            if (GUILayout.Button("Close"))
            {
                UsabilityAnalytics.Track(string.Format("/AssetStore/PurchaseOk/{0}/{1}", m_Asset.packageID, m_Asset.id));
                m_Asset = null;
                this.Close();
            }
            GUILayout.Space(5);
            if (GUILayout.Button("Import package"))
            {
                UsabilityAnalytics.Track(string.Format("/AssetStore/PurchaseOkImport/{0}/{1}", m_Asset.packageID, m_Asset.id));
                m_BuildAttempts = 1;
                m_Asset.previewInfo.buildProgress = 0f;
                m_Purchasing = PurchaseStatus.StartBuild;
            }
            GUILayout.Space(5);
            GUILayout.EndHorizontal();

            GUILayout.Space(5);
        }
</source>
<source file="UnityCsReference/Editor/Mono/AssetStore/AssetStoreInstaBuyWindow.cs.ifdefed" startline="333" endline="380" pcid="22829">
        {
            AssetStoreAsset.PreviewInfo item = m_Asset.previewInfo;
            GUILayout.BeginHorizontal();
            GUILayout.Space(5);
            GUILayout.Label(s_AssetStoreLogo, GUIStyle.none, GUILayout.ExpandWidth(false));
            GUILayout.BeginVertical();
            GUILayout.Label("Purchase declined", EditorStyles.boldLabel);
            GUILayout.Label("No money has been drawn from you credit card");

            bool hasMessage = m_Message != null && m_Message != "";
            float newHeight = kStandardHeight + (hasMessage ? 20 : 0);
            if (newHeight != position.height)
                position = new Rect(position.x, position.y, position.width, newHeight);

            if (hasMessage)
                GUILayout.Label(m_Message, EditorStyles.wordWrappedLabel);

            GUILayout.Label("Package: " + item.packageName, EditorStyles.wordWrappedLabel);

            GUILayout.EndVertical();
            GUILayout.Space(5);
            GUILayout.EndHorizontal();

            GUILayout.FlexibleSpace();

            GUILayout.BeginHorizontal();
            GUILayout.Space(8);

            GUILayout.FlexibleSpace();
            if (GUILayout.Button("Close"))
            {
                UsabilityAnalytics.Track(string.Format("/AssetStore/DeclinedAbort/{0}/{1}", m_Asset.packageID, m_Asset.id));
                m_Asset = null;
                Close();
            }
            GUILayout.Space(5);
            if (GUILayout.Button("Put to basket"))
            {
                AssetStore.Open(string.Format("content/{0}/basketpurchase", m_Asset.packageID));
                UsabilityAnalytics.Track(string.Format("/AssetStore/DeclinedPutToBasket/{0}/{1}", m_Asset.packageID, m_Asset.id));
                m_Asset = null;
                Close();
            }
            GUILayout.Space(5);
            GUILayout.EndHorizontal();

            GUILayout.Space(5);
        }
</source>
</class>

<class classid="116" nclones="3" nlines="23" similarity="82">
<source file="UnityCsReference/Editor/Mono/AssetPostprocessor.cs.ifdefed" startline="241" endline="270" pcid="23061">
        {
            List<uint> versions = new List<uint>();

            foreach (var assetPostprocessorClass in EditorAssemblies.SubclassesOf(typeof(AssetPostprocessor)))
            {
                try
                {
                    var inst = Activator.CreateInstance(assetPostprocessorClass) as AssetPostprocessor;
                    var type = inst.GetType();
                    bool hasPreProcessMethod = type.GetMethod("OnPreprocessModel", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance) != null;
                    bool hasProcessMeshAssignMethod = type.GetMethod("OnProcessMeshAssingModel", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance) != null;
                    bool hasPostProcessMethod = type.GetMethod("OnPostprocessModel", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance) != null;
                    uint version = inst.GetVersion();
                    if (version != 0 && (hasPreProcessMethod || hasProcessMeshAssignMethod || hasPostProcessMethod))
                    {
                        versions.Add(version);
                    }
                }
                catch (MissingMethodException)
                {
                    LogPostProcessorMissingDefaultConstructor(assetPostprocessorClass);
                }
                catch (Exception e)
                {
                    Debug.LogException(e);
                }
            }

            return versions.ToArray();
        }
</source>
<source file="UnityCsReference/Editor/Mono/AssetPostprocessor.cs.ifdefed" startline="467" endline="495" pcid="23105">
        {
            List<uint> versions = new List<uint>();

            foreach (var assetPostprocessorClass in EditorAssemblies.SubclassesOf(typeof(AssetPostprocessor)))
            {
                try
                {
                    var inst = Activator.CreateInstance(assetPostprocessorClass) as AssetPostprocessor;
                    var type = inst.GetType();
                    bool hasPreProcessMethod = type.GetMethod("OnPreprocessAudio", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance) != null;
                    bool hasPostProcessMethod = type.GetMethod("OnPostprocessAudio", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance) != null;
                    uint version = inst.GetVersion();
                    if (version != 0 && (hasPreProcessMethod || hasPostProcessMethod))
                    {
                        versions.Add(version);
                    }
                }
                catch (MissingMethodException)
                {
                    LogPostProcessorMissingDefaultConstructor(assetPostprocessorClass);
                }
                catch (Exception e)
                {
                    Debug.LogException(e);
                }
            }

            return versions.ToArray();
        }
</source>
<source file="UnityCsReference/Editor/Mono/AssetPostprocessor.cs.ifdefed" startline="395" endline="424" pcid="23091">
        {
            List<uint> versions = new List<uint>();

            foreach (var assetPostprocessorClass in EditorAssemblies.SubclassesOf(typeof(AssetPostprocessor)))
            {
                try
                {
                    var inst = Activator.CreateInstance(assetPostprocessorClass) as AssetPostprocessor;
                    var type = inst.GetType();
                    bool hasPreProcessMethod = type.GetMethod("OnPreprocessTexture", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance) != null;
                    bool hasPostProcessMethod = (type.GetMethod("OnPostprocessTexture", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance) != null) ||
                        (type.GetMethod("OnPostprocessCubemap", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance) != null);
                    uint version = inst.GetVersion();
                    if (version != 0 && (hasPreProcessMethod || hasPostProcessMethod))
                    {
                        versions.Add(version);
                    }
                }
                catch (MissingMethodException)
                {
                    LogPostProcessorMissingDefaultConstructor(assetPostprocessorClass);
                }
                catch (Exception e)
                {
                    Debug.LogException(e);
                }
            }

            return versions.ToArray();
        }
</source>
</class>

<class classid="117" nclones="2" nlines="13" similarity="76">
<source file="UnityCsReference/Editor/Mono/VersionControl/UI/VCListControl.cs.ifdefed" startline="893" endline="910" pcid="23439">
        {
            int count = (int)listState.Scroll;

            ListItem find = visibleList.Count > 0 ? visibleList[0] : null;
            while (find != null && count >= 0)
            {
                if (find == item)
                {
                    listState.Scroll = count;
                    return true;
                }

                --count;
                find = find.PrevOpenVisible;
            }

            return false;
        }
</source>
<source file="UnityCsReference/Editor/Mono/VersionControl/UI/VCListControl.cs.ifdefed" startline="914" endline="931" pcid="23442">
        {
            int count = (int)listState.Scroll;

            ListItem find = visibleList.Count > 0 ? visibleList[visibleList.Count - 1] : null;
            while (find != null && count >= 0)
            {
                if (find == item)
                {
                    listState.Scroll = count;
                    return true;
                }

                ++count;
                find = find.NextOpenVisible;
            }

            return false;
        }
</source>
</class>

<class classid="118" nclones="2" nlines="15" similarity="86">
<source file="UnityCsReference/Editor/Mono/VersionControl/UI/VCListControl.cs.ifdefed" startline="1226" endline="1246" pcid="23487">
        {
            ListItem it;
            ListItem limit = item;

            for (it = item; it != null; it = it.PrevOpenVisible)
            {
                if (IsSelected(it))
                    limit = it;
            }

            if (item == limit)
                return false;

            SelectedClear();
            SelectedAdd(limit);

            for (it = item; it != limit; it = it.PrevOpenVisible)
                SelectedAdd(it);

            return true;
        }
</source>
<source file="UnityCsReference/Editor/Mono/VersionControl/UI/VCListControl.cs.ifdefed" startline="1250" endline="1270" pcid="23489">
        {
            ListItem it;
            ListItem limit = item;

            for (it = item; it != null; it = it.NextOpenVisible)
            {
                if (IsSelected(it))
                    limit = it;
            }

            if (item == limit)
                return false;

            SelectedClear();
            SelectedAdd(limit);

            for (it = item; it != limit; it = it.NextOpenVisible)
                SelectedAdd(it);

            return true;
        }
</source>
</class>

<class classid="119" nclones="2" nlines="10" similarity="90">
<source file="UnityCsReference/Editor/Mono/VersionControl/UI/VCListControl.cs.ifdefed" startline="1285" endline="1298" pcid="23493">
        {
            ListItem item = SelectedCurrentIn(root);
            ListItem find = item;

            while (find != null)
            {
                if (IsSelected(find))
                    item = find;

                find = find.PrevOpenVisible;
            }

            return item;
        }
</source>
<source file="UnityCsReference/Editor/Mono/VersionControl/UI/VCListControl.cs.ifdefed" startline="1301" endline="1314" pcid="23495">
        {
            ListItem item = SelectedCurrentIn(root);
            ListItem find = item;

            while (find != null)
            {
                if (IsSelected(find))
                    item = find;

                find = find.NextOpenVisible;
            }

            return item;
        }
</source>
</class>

<class classid="120" nclones="2" nlines="13" similarity="85">
<source file="UnityCsReference/Editor/Mono/VersionControl/UI/VCWindowPending.cs.ifdefed" startline="57" endline="74" pcid="23578">
            {
                if (sStatusWheel == null)
                {
                    sStatusWheel = new GUIContent[12];
                    for (int i = 0; i < 12; i++)
                    {
                        GUIContent gc = new GUIContent();
                        gc.image = EditorGUIUtility.LoadIcon("WaitSpin" + i.ToString("00")) as Texture2D;
                        //EditorGUIUtility.LoadIconForSkin(
                        //gc.image = tex != null ? tex : EditorGUIUtility.LoadIcon("Builtin Skins/Icons/    WaitSpin" + i.ToString("00") + ".png") as Texture2D;
                        gc.image.hideFlags = HideFlags.HideAndDontSave;
                        gc.image.name = "Spinner";
                        sStatusWheel[i] = gc;
                    }
                }
                int frame = (int)Mathf.Repeat(Time.realtimeSinceStartup * 10, 11.99f);
                return sStatusWheel[frame];
            }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/AssetStoreAssetInspector.cs.ifdefed" startline="423" endline="436" pcid="26522">
            {
                if (sStatusWheel == null)
                {
                    sStatusWheel = new GUIContent[12];
                    for (int i = 0; i < 12; i++)
                    {
                        GUIContent gc = new GUIContent();
                        gc.image = EditorGUIUtility.LoadIcon("WaitSpin" + i.ToString("00")) as Texture2D;
                        sStatusWheel[i] = gc;
                    }
                }
                int frame = (int)Mathf.Repeat(Time.realtimeSinceStartup * 10, 11.99f);
                return sStatusWheel[frame];
            }
</source>
</class>

<class classid="121" nclones="2" nlines="14" similarity="78">
<source file="UnityCsReference/Editor/Mono/VersionControl/UI/VCWindowPending.cs.ifdefed" startline="127" endline="143" pcid="23587">
        {
            if (!Provider.isActive)
                return;

            Task task = Provider.ChangeSetStatus(change);
            task.userIdentifier = item.Identifier;
            task.SetCompletionAction(CompletionAction.OnChangeContentsPendingWindow);

            if (!item.HasChildren)
            {
                Asset asset = new Asset("Updating...");
                ListItem changeItem = pendingList.Add(item, asset.prettyPath, asset);
                changeItem.Dummy = true;
                pendingList.Refresh(false);  //true here would cause recursion
                Repaint();
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/VersionControl/UI/VCWindowPending.cs.ifdefed" startline="146" endline="162" pcid="23589">
        {
            if (!Provider.isActive)
                return;

            Task task = Provider.IncomingChangeSetAssets(change);

            task.userIdentifier = item.Identifier;
            task.SetCompletionAction(CompletionAction.OnChangeContentsPendingWindow);
            if (!item.HasChildren)
            {
                Asset asset = new Asset("Updating...");
                ListItem changeItem = incomingList.Add(item, asset.prettyPath, asset);
                changeItem.Dummy = true;
                incomingList.Refresh(false);  //true here would cause recursion
                Repaint();
            }
        }
</source>
</class>

<class classid="122" nclones="2" nlines="15" similarity="80">
<source file="UnityCsReference/Editor/Mono/UIElements/UIElementsViewImporter.cs.ifdefed" startline="174" endline="189" pcid="23831">
                {
                    switch (error.level)
                    {
                        case Error.Level.Info:
                            Debug.LogFormat(obj, error.ToString());
                            break;
                        case Error.Level.Warning:
                            Debug.LogWarningFormat(obj, error.ToString());
                            break;
                        case Error.Level.Fatal:
                            Debug.LogErrorFormat(obj, error.ToString());
                            break;
                        default:
                            throw new ArgumentOutOfRangeException();
                    }
                }
</source>
<source file="UnityCsReference/Editor/Mono/UIElements/UIElementsViewImporter.cs.ifdefed" startline="191" endline="206" pcid="23832">
                {
                    switch (error.level)
                    {
                        case Error.Level.Info:
                            Debug.Log(error.ToString());
                            break;
                        case Error.Level.Warning:
                            Debug.LogWarning(error.ToString());
                            break;
                        case Error.Level.Fatal:
                            Debug.LogError(error.ToString());
                            break;
                        default:
                            throw new ArgumentOutOfRangeException();
                    }
                }
</source>
</class>

<class classid="123" nclones="5" nlines="11" similarity="70">
<source file="UnityCsReference/Editor/Mono/UIElements/Controls/TextValueField.cs.ifdefed" startline="59" endline="75" pcid="23890">
        {
            if (!EqualityComparer<T>.Default.Equals(value, newValue))
            {
                using (ChangeEvent<T> evt = ChangeEvent<T>.GetPooled(value, newValue))
                {
                    evt.target = this;
                    value = newValue;
                    UIElementsUtility.eventDispatcher.DispatchEvent(evt, panel);
                }
            }
            else if (!isDelayed && m_UpdateTextFromValue)
            {
                // Value is the same but the text might not be in sync
                // In the case of an expression like 2+2, the text might not be equal to the result
                text = ValueToString(m_Value);
            }
        }
</source>
<source file="UnityCsReference/Modules/UIElements/Controls/BaseControl.cs.ifdefed" startline="83" endline="93" pcid="38579">
        {
            if (!EqualityComparer<T>.Default.Equals(value, newValue))
            {
                using (ChangeEvent<T> evt = ChangeEvent<T>.GetPooled(value, newValue))
                {
                    evt.target = this;
                    value = newValue;
                    UIElementsUtility.eventDispatcher.DispatchEvent(evt, panel);
                }
            }
        }
</source>
<source file="UnityCsReference/Modules/UIElements/Controls/BaseControl.cs.ifdefed" startline="39" endline="49" pcid="38571">
        {
            if (!EqualityComparer<T>.Default.Equals(value, newValue))
            {
                using (ChangeEvent<T> evt = ChangeEvent<T>.GetPooled(value, newValue))
                {
                    evt.target = this;
                    value = newValue;
                    UIElementsUtility.eventDispatcher.DispatchEvent(evt, panel);
                }
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/UIElements/Controls/BaseValueField.cs.ifdefed" startline="33" endline="43" pcid="23945">
        {
            if (!EqualityComparer<T>.Default.Equals(m_Value, newValue))
            {
                using (ChangeEvent<T> evt = ChangeEvent<T>.GetPooled(value, newValue))
                {
                    evt.target = this;
                    value = newValue;
                    UIElementsUtility.eventDispatcher.DispatchEvent(evt, panel);
                }
            }
        }
</source>
<source file="UnityCsReference/Modules/UIElements/Controls/TextInputFieldBase.cs.ifdefed" startline="85" endline="96" pcid="38589">
        {
            if (text != value)
            {
                // Setting the VisualElement text here cause a repaint since it dirty the layout flag.
                using (InputEvent evt = InputEvent.GetPooled(text, value))
                {
                    evt.target = this;
                    text = value;
                    UIElementsUtility.eventDispatcher.DispatchEvent(evt, panel);
                }
            }
        }
</source>
</class>

<class classid="124" nclones="2" nlines="10" similarity="70">
<source file="UnityCsReference/Editor/Mono/UIElements/SerializableJsonDictionary.cs.ifdefed" startline="31" endline="43" pcid="24011">
        {
            if (!ContainsKey(key))
                return null;

            if (m_Dict[key] is string)
            {
                T obj = Activator.CreateInstance<T>();
                EditorJsonUtility.FromJsonOverwrite((string)m_Dict[key], obj);
                m_Dict[key] = obj;
            }

            return m_Dict[key] as T;
        }
</source>
<source file="UnityCsReference/Editor/Mono/UIElements/SerializableJsonDictionary.cs.ifdefed" startline="46" endline="58" pcid="24013">
        {
            if (!ContainsKey(key))
                return null;

            if (m_Dict[key] is string)
            {
                var newObject = ScriptableObject.CreateInstance<T>();
                EditorJsonUtility.FromJsonOverwrite((string)m_Dict[key], newObject);
                m_Dict[key] = newObject;
            }

            return m_Dict[key] as T;
        }
</source>
</class>

<class classid="125" nclones="2" nlines="10" similarity="70">
<source file="UnityCsReference/Editor/Mono/AssetModificationProcessor.cs.ifdefed" startline="196" endline="208" pcid="24079">
            {
                MethodInfo method = assetModificationProcessorClass.GetMethod("OnWillMoveAsset", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static);
                if (method != null)
                {
                    RequireTeamLicense();

                    object[] args = { fromPath, toPath };
                    if (!CheckArgumentsAndReturnType(args, method, finalResult.GetType()))
                        continue;

                    finalResult |= (AssetMoveResult)method.Invoke(null, args);
                }
            }
</source>
<source file="UnityCsReference/Editor/Mono/AssetModificationProcessor.cs.ifdefed" startline="220" endline="232" pcid="24082">
            {
                MethodInfo method = assetModificationProcessorClass.GetMethod("OnWillDeleteAsset", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static);
                if (method != null)
                {
                    RequireTeamLicense();

                    object[] args = { assetPath, options };
                    if (!CheckArgumentsAndReturnType(args, method, finalResult.GetType()))
                        continue;

                    finalResult |= (AssetDeleteResult)method.Invoke(null, args);
                }
            }
</source>
</class>

<class classid="126" nclones="2" nlines="16" similarity="75">
<source file="UnityCsReference/Editor/Mono/ParticleSystemEditor/ParticleSystemCurveEditor.cs.ifdefed" startline="653" endline="673" pcid="24355">
                {
                    optimizeButtonShown = true;
                    if (GUI.Button(buttonRect, s_Styles.optimizeCurveText))
                    {
                        for (int j = 0; j < selection.Count; ++j)
                        {
                            CurveWrapper cw = m_CurveEditor.GetCurveWrapperFromSelection(selection[j]);
                            if (!AnimationUtility.IsValidOptimizedPolynomialCurve(cw.curve))
                            {
                                // Reset wrap mode
                                cw.curve.preWrapMode = WrapMode.Clamp;
                                cw.curve.postWrapMode = WrapMode.Clamp;
                                cw.renderer.SetWrap(WrapMode.Clamp, WrapMode.Clamp);

                                AnimationUtility.ConstrainToPolynomialCurve(cw.curve);
                                cw.changed = true; // Used in SaveChangedCurves () later in OnGUI
                            }
                        }
                        m_CurveEditor.SelectNone();
                    }
                }
</source>
<source file="UnityCsReference/Editor/Mono/ParticleSystemEditor/ParticleSystemCurveEditor.cs.ifdefed" startline="676" endline="697" pcid="24359">
            {
                // Check if top most curve can be optimized
                int topMostCurveID;
                if (m_CurveEditor.GetTopMostCurveID(out topMostCurveID))
                {
                    CurveWrapper cw = m_CurveEditor.GetCurveWrapperFromID(topMostCurveID);
                    if (!AnimationUtility.IsValidOptimizedPolynomialCurve(cw.curve))
                    {
                        optimizeButtonShown = true;
                        if (GUI.Button(buttonRect, s_Styles.optimizeCurveText))
                        {
                            // Reset wrap mode
                            cw.curve.preWrapMode = WrapMode.Clamp;
                            cw.curve.postWrapMode = WrapMode.Clamp;
                            cw.renderer.SetWrap(WrapMode.Clamp, WrapMode.Clamp);

                            AnimationUtility.ConstrainToPolynomialCurve(cw.curve);
                            cw.changed = true; // Used in SaveChangedCurves () later in OnGUI
                        }
                    }
                }
            }
</source>
</class>

<class classid="127" nclones="2" nlines="14" similarity="78">
<source file="UnityCsReference/Editor/Mono/ParticleSystemEditor/ParticleSystemModules/SizeByVelocityModuleUI.cs.ifdefed" startline="36" endline="52" pcid="24423">
        {
            // Already initialized?
            if (m_X != null)
                return;
            if (s_Texts == null)
                s_Texts = new Texts();

            m_SeparateAxes = GetProperty("separateAxes");
            m_Range = GetProperty("range");

            m_X = new SerializedMinMaxCurve(this, s_Texts.x, "curve"); // use "curve" instead of "x" for backwards compatibility reasons: the old system used to only support one axis, and this was its name
            m_X.m_AllowConstant = false;
            m_Y = new SerializedMinMaxCurve(this, s_Texts.y, "y", false, false, m_SeparateAxes.boolValue);
            m_Y.m_AllowConstant = false;
            m_Z = new SerializedMinMaxCurve(this, s_Texts.z, "z", false, false, m_SeparateAxes.boolValue);
            m_Z.m_AllowConstant = false;
        }
</source>
<source file="UnityCsReference/Editor/Mono/ParticleSystemEditor/ParticleSystemModules/SizeModuleUI.cs.ifdefed" startline="34" endline="48" pcid="24577">
        {
            // Already initialized?
            if (m_X != null)
                return;
            if (s_Texts == null)
                s_Texts = new Texts();

            m_SeparateAxes = GetProperty("separateAxes");
            m_X = new SerializedMinMaxCurve(this, s_Texts.x, "curve");
            m_Y = new SerializedMinMaxCurve(this, s_Texts.y, "y", false, false, m_SeparateAxes.boolValue);
            m_Z = new SerializedMinMaxCurve(this, s_Texts.z, "z", false, false, m_SeparateAxes.boolValue);
            m_X.m_AllowConstant = false;
            m_Y.m_AllowConstant = false;
            m_Z.m_AllowConstant = false;
        }
</source>
</class>

<class classid="128" nclones="4" nlines="25" similarity="74">
<source file="UnityCsReference/Editor/Mono/ParticleSystemEditor/ParticleSystemModules/SizeByVelocityModuleUI.cs.ifdefed" startline="55" endline="92" pcid="24424">
        {
            EditorGUI.BeginChangeCheck();
            bool separateAxes = GUIToggle(s_Texts.separateAxes, m_SeparateAxes);
            if (EditorGUI.EndChangeCheck())
            {
                // Remove old curves from curve editor
                if (!separateAxes)
                {
                    m_Y.RemoveCurveFromEditor();
                    m_Z.RemoveCurveFromEditor();
                }
            }

            // Keep states in sync
            if (!m_X.stateHasMultipleDifferentValues)
            {
                m_Z.SetMinMaxState(m_X.state, separateAxes);
                m_Y.SetMinMaxState(m_X.state, separateAxes);
            }

            MinMaxCurveState state = m_Z.state;

            if (separateAxes)
            {
                m_X.m_DisplayName = s_Texts.x;
                GUITripleMinMaxCurve(GUIContent.none, s_Texts.x, m_X, s_Texts.y, m_Y, s_Texts.z, m_Z, null);
            }
            else
            {
                m_X.m_DisplayName = s_Texts.size;
                GUIMinMaxCurve(s_Texts.size, m_X);
            }

            using (new EditorGUI.DisabledScope((state == MinMaxCurveState.k_Scalar) || (state == MinMaxCurveState.k_TwoScalars)))
            {
                GUIMinMaxRange(s_Texts.velocityRange, m_Range);
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/ParticleSystemEditor/ParticleSystemModules/SizeModuleUI.cs.ifdefed" startline="51" endline="81" pcid="24578">
        {
            EditorGUI.BeginChangeCheck();
            bool separateAxes = GUIToggle(s_Texts.separateAxes, m_SeparateAxes);
            if (EditorGUI.EndChangeCheck())
            {
                // Remove old curves from curve editor
                if (!separateAxes)
                {
                    m_Y.RemoveCurveFromEditor();
                    m_Z.RemoveCurveFromEditor();
                }
            }

            // Keep states in sync
            if (!m_X.stateHasMultipleDifferentValues)
            {
                m_Z.SetMinMaxState(m_X.state, separateAxes);
                m_Y.SetMinMaxState(m_X.state, separateAxes);
            }

            if (separateAxes)
            {
                m_X.m_DisplayName = s_Texts.x;
                GUITripleMinMaxCurve(GUIContent.none, s_Texts.x, m_X, s_Texts.y, m_Y, s_Texts.z, m_Z, null);
            }
            else
            {
                m_X.m_DisplayName = s_Texts.size;
                GUIMinMaxCurve(s_Texts.size, m_X);
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/ParticleSystemEditor/ParticleSystemModules/RotationByVelocityModuleUI.cs.ifdefed" startline="53" endline="90" pcid="24672">
        {
            EditorGUI.BeginChangeCheck();
            bool separateAxes = GUIToggle(s_Texts.separateAxes, m_SeparateAxes);
            if (EditorGUI.EndChangeCheck())
            {
                // Remove old curves from curve editor
                if (!separateAxes)
                {
                    m_X.RemoveCurveFromEditor();
                    m_Y.RemoveCurveFromEditor();
                }
            }

            // Keep states in sync
            if (!m_Z.stateHasMultipleDifferentValues)
            {
                m_X.SetMinMaxState(m_Z.state, separateAxes);
                m_Y.SetMinMaxState(m_Z.state, separateAxes);
            }

            MinMaxCurveState state = m_Z.state;

            if (separateAxes)
            {
                m_Z.m_DisplayName = s_Texts.z;
                GUITripleMinMaxCurve(GUIContent.none, s_Texts.x, m_X, s_Texts.y, m_Y, s_Texts.z, m_Z, null);
            }
            else
            {
                m_Z.m_DisplayName = s_Texts.rotation;
                GUIMinMaxCurve(s_Texts.rotation, m_Z);
            }

            using (new EditorGUI.DisabledScope((state == MinMaxCurveState.k_Scalar) || (state == MinMaxCurveState.k_TwoScalars)))
            {
                GUIMinMaxRange(s_Texts.velocityRange, m_Range);
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/ParticleSystemEditor/ParticleSystemModules/RotationModuleUI.cs.ifdefed" startline="52" endline="82" pcid="24857">
        {
            EditorGUI.BeginChangeCheck();
            bool separateAxes = GUIToggle(s_Texts.separateAxes, m_SeparateAxes);
            if (EditorGUI.EndChangeCheck())
            {
                // Remove old curves from curve editor
                if (!separateAxes)
                {
                    m_X.RemoveCurveFromEditor();
                    m_Y.RemoveCurveFromEditor();
                }
            }

            // Keep states in sync
            if (!m_Z.stateHasMultipleDifferentValues)
            {
                m_X.SetMinMaxState(m_Z.state, separateAxes);
                m_Y.SetMinMaxState(m_Z.state, separateAxes);
            }

            if (separateAxes)
            {
                m_Z.m_DisplayName = s_Texts.z;
                GUITripleMinMaxCurve(GUIContent.none, s_Texts.x, m_X, s_Texts.y, m_Y, s_Texts.z, m_Z, null);
            }
            else
            {
                m_Z.m_DisplayName = s_Texts.rotation;
                GUIMinMaxCurve(s_Texts.rotation, m_Z);
            }
        }
</source>
</class>

<class classid="129" nclones="2" nlines="10" similarity="90">
<source file="UnityCsReference/Editor/Mono/ParticleSystemEditor/ParticleSystemModules/CollisionModuleUI.cs.ifdefed" startline="357" endline="367" pcid="24483">
        {
            GameObject go = new GameObject(name);
            if (go)
            {
                if (parentOfGameObject)
                    go.transform.parent = parentOfGameObject.transform;
                Undo.RegisterCreatedObjectUndo(go, "Created `" + name + "`");
                return go;
            }
            return null;
        }
</source>
<source file="UnityCsReference/Editor/Mono/ParticleSystemEditor/ParticleSystemModules/TriggerModuleUI.cs.ifdefed" startline="102" endline="112" pcid="24968">
        {
            GameObject go = new GameObject(name);
            if (go)
            {
                if (parentOfGameObject)
                    go.transform.parent = parentOfGameObject.transform;
                go.AddComponent<SphereCollider>();
                return go;
            }
            return null;
        }
</source>
</class>

<class classid="130" nclones="2" nlines="36" similarity="94">
<source file="UnityCsReference/Editor/Mono/ParticleSystemEditor/ParticleSystemModules/CollisionModuleUI.cs.ifdefed" startline="543" endline="591" pcid="24509">
        {
            if (s_VisualizeBounds == false)
                return;

            Color oldColor = Handles.color;
            Handles.color = Color.green;
            Matrix4x4 oldMatrix = Handles.matrix;

            Vector3[] points0 = new Vector3[20];
            Vector3[] points1 = new Vector3[20];
            Vector3[] points2 = new Vector3[20];

            Handles.SetDiscSectionPoints(points0, Vector3.zero, Vector3.forward, Vector3.right, 360, 1.0f);
            Handles.SetDiscSectionPoints(points1, Vector3.zero, Vector3.up, -Vector3.right, 360, 1.0f);
            Handles.SetDiscSectionPoints(points2, Vector3.zero, Vector3.right, Vector3.up, 360, 1.0f);

            Vector3[] points = new Vector3[points0.Length + points1.Length + points2.Length];
            points0.CopyTo(points, 0);
            points1.CopyTo(points, 20);
            points2.CopyTo(points, 40);

            foreach (ParticleSystem ps in m_ParticleSystemUI.m_ParticleSystems)
            {
                if (!ps.collision.enabled)
                    continue;

                ParticleSystem.Particle[] particles = new ParticleSystem.Particle[ps.particleCount];
                int count = ps.GetParticles(particles);

                Matrix4x4 transform = Matrix4x4.identity;
                if (ps.main.simulationSpace == ParticleSystemSimulationSpace.Local)
                {
                    transform = ps.GetLocalToWorldMatrix();
                }

                for (int i = 0; i < count; i++)
                {
                    ParticleSystem.Particle particle = particles[i];
                    Vector3 size = particle.GetCurrentSize3D(ps);

                    float radius = System.Math.Max(size.x, System.Math.Max(size.y, size.z)) * 0.5f * ps.collision.radiusScale;
                    Handles.matrix = transform * Matrix4x4.TRS(particle.position, Quaternion.identity, new Vector3(radius, radius, radius));
                    Handles.DrawPolyLine(points);
                }
            }

            Handles.color = oldColor;
            Handles.matrix = oldMatrix;
        }
</source>
<source file="UnityCsReference/Editor/Mono/ParticleSystemEditor/ParticleSystemModules/TriggerModuleUI.cs.ifdefed" startline="176" endline="224" pcid="24981">
        {
            if (s_VisualizeBounds == false)
                return;

            Color oldColor = Handles.color;
            Handles.color = Color.green;
            Matrix4x4 oldMatrix = Handles.matrix;

            Vector3[] points0 = new Vector3[20];
            Vector3[] points1 = new Vector3[20];
            Vector3[] points2 = new Vector3[20];

            Handles.SetDiscSectionPoints(points0, Vector3.zero, Vector3.forward, Vector3.right, 360, 1.0f);
            Handles.SetDiscSectionPoints(points1, Vector3.zero, Vector3.up, -Vector3.right, 360, 1.0f);
            Handles.SetDiscSectionPoints(points2, Vector3.zero, Vector3.right, Vector3.up, 360, 1.0f);

            Vector3[] points = new Vector3[points0.Length + points1.Length + points2.Length];
            points0.CopyTo(points, 0);
            points1.CopyTo(points, 20);
            points2.CopyTo(points, 40);

            foreach (ParticleSystem ps in m_ParticleSystemUI.m_ParticleSystems)
            {
                if (!ps.trigger.enabled)
                    continue;

                ParticleSystem.Particle[] particles = new ParticleSystem.Particle[ps.particleCount];
                int count = ps.GetParticles(particles);

                Matrix4x4 transform = Matrix4x4.identity;
                if (ps.main.simulationSpace == ParticleSystemSimulationSpace.Local)
                {
                    transform = ps.GetLocalToWorldMatrix();
                }

                for (int i = 0; i < count; i++)
                {
                    ParticleSystem.Particle particle = particles[i];
                    Vector3 size = particle.GetCurrentSize3D(ps);

                    float radius = System.Math.Max(size.x, System.Math.Max(size.y, size.z)) * 0.5f * ps.trigger.radiusScale;
                    Handles.matrix = transform * Matrix4x4.TRS(particle.position, Quaternion.identity, new Vector3(radius, radius, radius));
                    Handles.DrawPolyLine(points);
                }
            }

            Handles.color = oldColor;
            Handles.matrix = oldMatrix;
        }
</source>
</class>

<class classid="131" nclones="2" nlines="14" similarity="92">
<source file="UnityCsReference/Editor/Mono/ParticleSystemEditor/ParticleSystemModules/RotationByVelocityModuleUI.cs.ifdefed" startline="35" endline="50" pcid="24671">
        {
            // Already initialized?
            if (m_Z != null)
                return;
            if (s_Texts == null)
                s_Texts = new Texts();

            m_SeparateAxes = GetProperty("separateAxes");
            m_Range = GetProperty("range");
            m_X = new SerializedMinMaxCurve(this, s_Texts.x, "x", kUseSignedRange, false, m_SeparateAxes.boolValue);
            m_Y = new SerializedMinMaxCurve(this, s_Texts.y, "y", kUseSignedRange, false, m_SeparateAxes.boolValue);
            m_Z = new SerializedMinMaxCurve(this, s_Texts.z, "curve", kUseSignedRange);
            m_X.m_RemapValue = Mathf.Rad2Deg;
            m_Y.m_RemapValue = Mathf.Rad2Deg;
            m_Z.m_RemapValue = Mathf.Rad2Deg;
        }
</source>
<source file="UnityCsReference/Editor/Mono/ParticleSystemEditor/ParticleSystemModules/RotationModuleUI.cs.ifdefed" startline="35" endline="49" pcid="24856">
        {
            // Already initialized?
            if (m_Z != null)
                return;
            if (s_Texts == null)
                s_Texts = new Texts();

            m_SeparateAxes = GetProperty("separateAxes");
            m_X = new SerializedMinMaxCurve(this, s_Texts.x, "x", kUseSignedRange, false, m_SeparateAxes.boolValue);
            m_Y = new SerializedMinMaxCurve(this, s_Texts.y, "y", kUseSignedRange, false, m_SeparateAxes.boolValue);
            m_Z = new SerializedMinMaxCurve(this, s_Texts.z, "curve", kUseSignedRange);
            m_X.m_RemapValue = Mathf.Rad2Deg;
            m_Y.m_RemapValue = Mathf.Rad2Deg;
            m_Z.m_RemapValue = Mathf.Rad2Deg;
        }
</source>
</class>

<class classid="132" nclones="3" nlines="10" similarity="70">
<source file="UnityCsReference/Editor/Mono/ParticleSystemEditor/ParticleSystemModules/ModuleUIHelpers.cs.ifdefed" startline="530" endline="539" pcid="24735">
        {
            Rect rect = GetControlRect(kSingleLineHeight, layoutOptions);
            label = EditorGUI.BeginProperty(rect, label, enumProperty);
            rect = PrefixLabel(rect, label);
            EditorGUI.BeginChangeCheck();
            int enumVal = (int)(UVChannelFlags)EditorGUI.EnumFlagsField(rect, (UVChannelFlags)enumProperty.intValue, ParticleSystemStyles.Get().popup);
            if (EditorGUI.EndChangeCheck())
                enumProperty.intValue = enumVal;
            EditorGUI.EndProperty();
        }
</source>
<source file="UnityCsReference/Editor/Mono/ParticleSystemEditor/ParticleSystemModules/ModuleUIHelpers.cs.ifdefed" startline="542" endline="553" pcid="24736">
        {
            Rect rect = GetControlRect(kSingleLineHeight, layoutOptions);
            label = EditorGUI.BeginProperty(rect, label, intProp);
            rect = PrefixLabel(rect, label);

            EditorGUI.BeginChangeCheck();
            int newValue = EditorGUI.MaskField(rect, label, intProp.intValue, options, ParticleSystemStyles.Get().popup);
            if (EditorGUI.EndChangeCheck())
                intProp.intValue = newValue;

            EditorGUI.EndProperty();
        }
</source>
<source file="UnityCsReference/Editor/Mono/ParticleSystemEditor/ParticleSystemModules/ModuleUIHelpers.cs.ifdefed" startline="556" endline="568" pcid="24737">
        {
            Rect rect = GetControlRect(kSingleLineHeight, layoutOptions);
            label = EditorGUI.BeginProperty(rect, label, intProp);
            rect = PrefixLabel(rect, label);

            EditorGUI.BeginChangeCheck();
            int newValue = EditorGUI.Popup(rect, null, intProp.intValue, options, ParticleSystemStyles.Get().popup);
            if (EditorGUI.EndChangeCheck())
                intProp.intValue = newValue;

            EditorGUI.EndProperty();
            return intProp.intValue;
        }
</source>
</class>

<class classid="133" nclones="2" nlines="12" similarity="76">
<source file="UnityCsReference/Editor/Mono/ParticleSystemEditor/ParticleSystemModules/ModuleUIHelpers.cs.ifdefed" startline="668" endline="685" pcid="24751">
            {
                Rect labelPosition;
                controlRect = FieldPosition(rect, out labelPosition);
                labelPosition.width -= kSpacingSubLabel;

                // Draw with the minimum width so we don't lose the draggable functionality to the left of the float field
                float textWidth = ParticleSystemStyles.Get().editableLabel.CalcSize(GUIContent.Temp(editableLabel.stringValue)).x;
                labelPosition.width = Mathf.Min(labelPosition.width, textWidth + kSpacingSubLabel);

                EditorGUI.BeginProperty(labelPosition, GUIContent.none, editableLabel);

                EditorGUI.BeginChangeCheck();
                string newString = EditorGUI.TextFieldInternal(GUIUtility.GetControlID(FocusType.Passive, labelPosition), labelPosition, editableLabel.stringValue, ParticleSystemStyles.Get().editableLabel);
                if (EditorGUI.EndChangeCheck())
                    editableLabel.stringValue = newString;

                EditorGUI.EndProperty();
            }
</source>
<source file="UnityCsReference/Editor/Mono/ParticleSystemEditor/ParticleSystemModules/ModuleUIHelpers.cs.ifdefed" startline="823" endline="836" pcid="24767">
            {
                Rect labelPosition;
                gradientRect = FieldPosition(rect, out labelPosition);
                labelPosition.width -= kSpacingSubLabel;

                EditorGUI.BeginProperty(labelPosition, GUIContent.none, editableLabel);

                EditorGUI.BeginChangeCheck();
                string newString = EditorGUI.TextFieldInternal(GUIUtility.GetControlID(FocusType.Passive, labelPosition), labelPosition, editableLabel.stringValue, ParticleSystemStyles.Get().editableLabel);
                if (EditorGUI.EndChangeCheck())
                    editableLabel.stringValue = newString;

                EditorGUI.EndProperty();
            }
</source>
</class>

<class classid="134" nclones="2" nlines="29" similarity="72">
<source file="UnityCsReference/Editor/Mono/ParticleSystemEditor/ParticleSystemModules/ModuleUIHelpers.cs.ifdefed" startline="696" endline="734" pcid="24754">
            {
                MinMaxCurveState state = mmCurve.state;

                // Scalar field
                if (state == MinMaxCurveState.k_Scalar)
                {
                    EditorGUI.BeginChangeCheck();
                    float newValue = FloatDraggable(rect, mmCurve.scalar, mmCurve.m_RemapValue, EditorGUIUtility.labelWidth);
                    if (EditorGUI.EndChangeCheck() && !mmCurve.signedRange)
                        mmCurve.scalar.floatValue = Mathf.Max(newValue, 0f);
                }
                else if (state == MinMaxCurveState.k_TwoScalars)
                {
                    Rect halfRect = controlRect;
                    halfRect.width = (controlRect.width - kDragSpace) * 0.5f;

                    Rect halfRectWithDragger = halfRect;
                    halfRectWithDragger.xMin -= kDragSpace;

                    EditorGUI.BeginChangeCheck();
                    float newMinValue = FloatDraggable(halfRectWithDragger, mmCurve.minScalar, mmCurve.m_RemapValue, kDragSpace, "g5");
                    if (EditorGUI.EndChangeCheck() && !mmCurve.signedRange)
                        mmCurve.minScalar.floatValue = Mathf.Max(newMinValue, 0f);

                    halfRectWithDragger.x += halfRect.width + kDragSpace;

                    EditorGUI.BeginChangeCheck();
                    float newMaxValue = FloatDraggable(halfRectWithDragger, mmCurve.scalar, mmCurve.m_RemapValue, kDragSpace, "g5");
                    if (EditorGUI.EndChangeCheck() && !mmCurve.signedRange)
                        mmCurve.scalar.floatValue = Mathf.Max(newMaxValue, 0f);
                }
                else
                {
                    // Curve field
                    Rect previewRange = mmCurve.signedRange ? kSignedRange : kUnsignedRange;
                    SerializedProperty minCurve = (state == MinMaxCurveState.k_TwoCurves) ? mmCurve.minCurve : null;
                    GUICurveField(controlRect, mmCurve.maxCurve, minCurve, GetColor(mmCurve), previewRange, mmCurve.OnCurveAreaMouseDown);
                }
            }
</source>
<source file="UnityCsReference/Editor/Mono/ParticleSystemEditor/ParticleSystemModules/ModuleUIHelpers.cs.ifdefed" startline="751" endline="788" pcid="24760">
            {
                MinMaxCurveState state = mmCurve.state;

                // Scalar field
                if (state == MinMaxCurveState.k_Scalar)
                {
                    EditorGUI.BeginChangeCheck();
                    float newValue = FloatDraggable(rect, mmCurve.scalar, mmCurve.m_RemapValue, dragWidth, "n0");
                    if (EditorGUI.EndChangeCheck() && !mmCurve.signedRange)
                        mmCurve.scalar.floatValue = Mathf.Max(newValue, 0f);
                }
                else if (state == MinMaxCurveState.k_TwoScalars)
                {
                    Rect halfRect = rect;
                    halfRect.width = (rect.width * 0.5f);

                    Rect halfRectWithDragger = halfRect;

                    EditorGUI.BeginChangeCheck();
                    float newMinValue = FloatDraggable(halfRectWithDragger, mmCurve.minScalar, mmCurve.m_RemapValue, dragWidth, "n0");
                    if (EditorGUI.EndChangeCheck() && !mmCurve.signedRange)
                        mmCurve.minScalar.floatValue = Mathf.Max(newMinValue, 0f);

                    halfRectWithDragger.x += halfRect.width;

                    EditorGUI.BeginChangeCheck();
                    float newMaxValue = FloatDraggable(halfRectWithDragger, mmCurve.scalar, mmCurve.m_RemapValue, dragWidth, "n0");
                    if (EditorGUI.EndChangeCheck() && !mmCurve.signedRange)
                        mmCurve.scalar.floatValue = Mathf.Max(newMaxValue, 0f);
                }
                else
                {
                    // Curve field
                    Rect previewRange = mmCurve.signedRange ? kSignedRange : kUnsignedRange;
                    SerializedProperty minCurve = (state == MinMaxCurveState.k_TwoCurves) ? mmCurve.minCurve : null;
                    GUICurveField(rect, mmCurve.maxCurve, minCurve, GetColor(mmCurve), previewRange, mmCurve.OnCurveAreaMouseDown);
                }
            }
</source>
</class>

<class classid="135" nclones="2" nlines="12" similarity="75">
<source file="UnityCsReference/Editor/Mono/ParticleSystemEditor/ParticleSystemModules/ModuleUIHelpers.cs.ifdefed" startline="1152" endline="1166" pcid="24802">
        {
            if (EditorGUI.DropdownButton(rect, GUIContent.none, FocusType.Passive, ParticleSystemStyles.Get().minMaxCurveStateDropDown))
            {
                GenericMenu menu = new GenericMenu();
                GUIContent[] texts = { EditorGUIUtility.TrTextContent("Constant Color"), EditorGUIUtility.TrTextContent("Random Between Two Colors") };
                bool[] states = { false, true };

                for (int i = 0; i < texts.Length; ++i)
                {
                    menu.AddItem(texts[i], (boolProp.boolValue == states[i]), SelectMinMaxColorStateCallback, new ColorCallbackData(states[i], boolProp));
                }
                menu.ShowAsContext();
                Event.current.Use();
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/ParticleSystemEditor/ParticleSystemModules/EmissionModuleUI.cs.ifdefed" startline="209" endline="223" pcid="24959">
        {
            if (EditorGUI.DropdownButton(rect, GUIContent.none, FocusType.Passive, ParticleSystemStyles.Get().minMaxCurveStateDropDown))
            {
                GUIContent[] texts = { EditorGUIUtility.TrTextContent("Infinite"), EditorGUIUtility.TrTextContent("Count") };

                GenericMenu menu = new GenericMenu();
                for (int i = 0; i < texts.Length; ++i)
                {
                    menu.AddItem(texts[i], (modeProp.intValue == i), SelectModeCallback, new ModeCallbackData(i, modeProp));
                }

                menu.ShowAsContext();
                Event.current.Use();
            }
        }
</source>
</class>

<class classid="136" nclones="2" nlines="10" similarity="70">
<source file="UnityCsReference/Editor/Mono/ParticleSystemEditor/ParticleSystemModules/ShapeModuleUI.cs.ifdefed" startline="566" endline="577" pcid="24915">
                {
                    EditorGUI.BeginChangeCheck();
                    float radius = Handles.DoSimpleRadiusHandle(Quaternion.identity, Vector3.zero, shapeModule.radius, false);
                    if (EditorGUI.EndChangeCheck())
                    {
                        Undo.RecordObject(ps, "Sphere Handle Change");
                        shapeModule.radius = radius;
                    }

                    Matrix4x4 textureTransform = transformMatrix * Matrix4x4.TRS(Vector3.zero, Quaternion.identity, Vector3.one * shapeModule.radius * 2.0f);
                    OnSceneViewTextureGUI(shapeModule, s_SphereMesh, false, s_SphereTextureMaterial, textureTransform);
                }
</source>
<source file="UnityCsReference/Editor/Mono/ParticleSystemEditor/ParticleSystemModules/ShapeModuleUI.cs.ifdefed" startline="600" endline="611" pcid="24919">
                {
                    EditorGUI.BeginChangeCheck();
                    float radius = Handles.DoSimpleRadiusHandle(Quaternion.identity, Vector3.zero, shapeModule.radius, true);
                    if (EditorGUI.EndChangeCheck())
                    {
                        Undo.RecordObject(ps, "Hemisphere Handle Change");
                        shapeModule.radius = radius;
                    }

                    Matrix4x4 textureTransform = transformMatrix * Matrix4x4.TRS(Vector3.zero, Quaternion.identity, Vector3.one * shapeModule.radius * 2.0f);
                    OnSceneViewTextureGUI(shapeModule, s_HemisphereMesh, false, s_SphereTextureMaterial, textureTransform);
                }
</source>
</class>

<class classid="137" nclones="2" nlines="10" similarity="80">
<source file="UnityCsReference/Editor/Mono/BuildPlayerWindowPublish.cs.ifdefed" startline="133" endline="144" pcid="25090">
            {
                if (GUILayout.Button("Add", GUILayout.Width(60)))
                {
                    if (packmanOperationRunning)
                        return;

                    AddRequest add = Client.Add(LatestXiaomiPackageId);
                    requestList.Add(new RequestQueueItem(add, PackmanOperationType.Add));
                    System.Console.WriteLine("Adding: " + LatestXiaomiPackageId);
                    packmanOperationRunning = true;
                }
            }
</source>
<source file="UnityCsReference/Editor/Mono/BuildPlayerWindowPublish.cs.ifdefed" startline="151" endline="162" pcid="25094">
                    {
                        if (packmanOperationRunning)
                            return;

                        if (EditorUtility.DisplayDialog("Update Xiaomi SDK", "Are you sure you want to update to " + latestXiaomiPackageVersion + " ?", "Yes", "No"))
                        {
                            AddRequest add = Client.Add(LatestXiaomiPackageId);
                            requestList.Add(new RequestQueueItem(add, PackmanOperationType.Add));
                            System.Console.WriteLine("Updating to: " + LatestXiaomiPackageId);
                            packmanOperationRunning = true;
                        }
                    }
</source>
</class>

<class classid="138" nclones="2" nlines="10" similarity="90">
<source file="UnityCsReference/Editor/Mono/AsyncHTTPClient.cs.ifdefed" startline="86" endline="95" pcid="25332">
        {
            m_ToUrl = _toUrl;
            m_FromData = null;
            m_Method = "";
            state = State.INIT;
            header = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            m_Handle = (IntPtr)0;
            tag = "";
            statusCallback = null;
        }
</source>
<source file="UnityCsReference/Editor/Mono/AsyncHTTPClient.cs.ifdefed" startline="101" endline="110" pcid="25333">
        {
            m_ToUrl = _toUrl;
            m_FromData = null;
            m_Method = _method;
            state = State.INIT;
            header = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            m_Handle = (IntPtr)0;
            tag = "";
            statusCallback = null;
        }
</source>
</class>

<class classid="139" nclones="5" nlines="13" similarity="75">
<source file="UnityCsReference/Editor/Mono/Inspector/AimConstraintEditor.cs.ifdefed" startline="68" endline="87" pcid="25425">
        {
            if (s_Style == null)
                s_Style = new Styles();

            m_RotationAtRest = serializedObject.FindProperty("m_RotationAtRest");
            m_RotationOffset = serializedObject.FindProperty("m_RotationOffset");

            m_AimVector = serializedObject.FindProperty("m_AimVector");
            m_UpVector = serializedObject.FindProperty("m_UpVector");
            m_WorldUpVector = serializedObject.FindProperty("m_WorldUpVector");
            m_WorldUpObject = serializedObject.FindProperty("m_WorldUpObject");
            m_WorldUpType = serializedObject.FindProperty("m_UpType");

            m_Weight = serializedObject.FindProperty("m_Weight");
            m_IsContraintActive = serializedObject.FindProperty("m_IsContraintActive");
            m_IsLocked = serializedObject.FindProperty("m_IsLocked");
            m_Sources = serializedObject.FindProperty("m_Sources");

            OnEnable(s_Style);
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/LookAtConstraintEditor.cs.ifdefed" startline="51" endline="68" pcid="29860">
        {
            if (s_Style == null)
                s_Style = new Styles();

            m_RotationAtRest = serializedObject.FindProperty("m_RotationAtRest");
            m_RotationOffset = serializedObject.FindProperty("m_RotationOffset");

            m_UseUpObject = serializedObject.FindProperty("m_UseUpObject");
            m_WorldUpObject = serializedObject.FindProperty("m_WorldUpObject");
            m_Roll = serializedObject.FindProperty("m_Roll");

            m_Weight = serializedObject.FindProperty("m_Weight");
            m_IsContraintActive = serializedObject.FindProperty("m_IsContraintActive");
            m_IsLocked = serializedObject.FindProperty("m_IsLocked");
            m_Sources = serializedObject.FindProperty("m_Sources");

            OnEnable(s_Style);
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/RotationConstraintEditor.cs.ifdefed" startline="43" endline="55" pcid="25835">
        {
            if (s_Style == null)
                s_Style = new Styles();

            m_RotationAtRest = serializedObject.FindProperty("m_RotationAtRest");
            m_RotationOffset = serializedObject.FindProperty("m_RotationOffset");
            m_Weight = serializedObject.FindProperty("m_Weight");
            m_IsContraintActive = serializedObject.FindProperty("m_IsContraintActive");
            m_IsLocked = serializedObject.FindProperty("m_IsLocked");
            m_Sources = serializedObject.FindProperty("m_Sources");

            OnEnable(s_Style);
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/ScaleConstraintEditor.cs.ifdefed" startline="43" endline="55" pcid="30702">
        {
            if (s_Style == null)
                s_Style = new Styles();

            m_ScaleAtRest = serializedObject.FindProperty("m_ScaleAtRest");
            m_ScaleOffset = serializedObject.FindProperty("m_ScaleOffset");
            m_Weight = serializedObject.FindProperty("m_Weight");
            m_IsContraintActive = serializedObject.FindProperty("m_IsContraintActive");
            m_IsLocked = serializedObject.FindProperty("m_IsLocked");
            m_Sources = serializedObject.FindProperty("m_Sources");

            OnEnable(s_Style);
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/PositionConstraintEditor.cs.ifdefed" startline="44" endline="56" pcid="29877">
        {
            if (s_Style == null)
                s_Style = new Styles();

            m_TranslationAtRest = serializedObject.FindProperty("m_TranslationAtRest");
            m_TranslationOffset = serializedObject.FindProperty("m_TranslationOffset");
            m_Weight = serializedObject.FindProperty("m_Weight");
            m_IsContraintActive = serializedObject.FindProperty("m_IsContraintActive");
            m_IsLocked = serializedObject.FindProperty("m_IsLocked");
            m_Sources = serializedObject.FindProperty("m_Sources");

            OnEnable(s_Style);
        }
</source>
</class>

<class classid="140" nclones="2" nlines="12" similarity="91">
<source file="UnityCsReference/Editor/Mono/Inspector/RectHandles.cs.ifdefed" startline="190" endline="203" pcid="25449">
        {
            if (s_Styles == null)
                s_Styles = new Styles();

            switch (eventType)
            {
                case EventType.Layout:
                    HandleUtility.AddControl(controlID, HandleUtility.DistanceToCircle(position, size * .5f));
                    break;
                case EventType.Repaint:
                    DrawImageBasedCap(controlID, position, rotation, size, s_Styles.dragdot, s_Styles.dragdotactive);
                    break;
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/RectHandles.cs.ifdefed" startline="206" endline="219" pcid="25450">
        {
            if (s_Styles == null)
                s_Styles = new Styles();

            switch (eventType)
            {
                case EventType.Layout:
                    HandleUtility.AddControl(controlID, HandleUtility.DistanceToCircle(position, size * .5f));
                    break;
                case EventType.Repaint:
                    DrawImageBasedCap(controlID, position, rotation, size, s_Styles.pivotdot, s_Styles.pivotdotactive);
                    break;
            }
        }
</source>
</class>

<class classid="141" nclones="5" nlines="14" similarity="70">
<source file="UnityCsReference/Editor/Mono/Inspector/ModelInspector.cs.ifdefed" startline="164" endline="184" pcid="25598">
        {
            if (!ShaderUtil.hardwareSupportsRectRenderTexture)
            {
                if (Event.current.type == EventType.Repaint)
                    EditorGUI.DropShadowLabel(new Rect(r.x, r.y, r.width, 40), "Mesh preview requires\nrender texture support");
                return;
            }

            Init();

            previewDir = PreviewGUI.Drag2D(previewDir, r);

            if (Event.current.type != EventType.Repaint)
                return;

            m_PreviewUtility.BeginPreview(r, background);

            DoRenderPreview();

            m_PreviewUtility.EndAndDrawPreview(r);
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/GameObjectInspector.cs.ifdefed" startline="760" endline="779" pcid="27787">
        {
            if (!ShaderUtil.hardwareSupportsRectRenderTexture)
            {
                if (Event.current.type == EventType.Repaint)
                    EditorGUI.DropShadowLabel(new Rect(r.x, r.y, r.width, 40), "Preview requires\nrender texture support");
                return;
            }

            previewDir = PreviewGUI.Drag2D(previewDir, r);

            if (Event.current.type != EventType.Repaint)
                return;

            var previewUtility = GetPreviewData().renderUtility;
            previewUtility.BeginPreview(r, background);

            DoRenderPreview();

            previewUtility.EndAndDrawPreview(r);
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/MaterialEditor.cs.ifdefed" startline="1900" endline="1924" pcid="26385">
        {
            if (!ShaderUtil.hardwareSupportsRectRenderTexture)
            {
                if (Event.current.type == EventType.Repaint)
                    EditorGUI.DropShadowLabel(new Rect(r.x, r.y, r.width, 40), "Material preview \nnot available");
                return;
            }

            Init();

            var mat = target as Material;
            var viewType = GetPreviewType(mat);

            if (DoesPreviewAllowRotation(viewType))
                m_PreviewDir = PreviewGUI.Drag2D(m_PreviewDir, r);

            if (Event.current.type != EventType.Repaint)
                return;

            m_PreviewUtility.BeginPreview(r,  background);

            DoRenderPreview();

            m_PreviewUtility.EndAndDrawPreview(r);
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/LODGroupEditor.cs.ifdefed" startline="1111" endline="1131" pcid="30360">
        {
            if (!ShaderUtil.hardwareSupportsRectRenderTexture)
            {
                if (Event.current.type == EventType.Repaint)
                    EditorGUI.DropShadowLabel(new Rect(r.x, r.y, r.width, 40), "LOD preview \nnot available");
                return;
            }

            InitPreview();
            m_PreviewDir = PreviewGUI.Drag2D(m_PreviewDir, r);
            m_PreviewDir.y = Mathf.Clamp(m_PreviewDir.y, -89.0f, 89.0f);

            if (Event.current.type != EventType.Repaint)
                return;

            m_PreviewUtility.BeginPreview(r, background);

            DoRenderPreview();

            m_PreviewUtility.EndAndDrawPreview(r);
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/BillboardAssetInspector.cs.ifdefed" startline="154" endline="174" pcid="29893">
        {
            if (!ShaderUtil.hardwareSupportsRectRenderTexture)
            {
                if (Event.current.type == EventType.Repaint)
                    EditorGUI.DropShadowLabel(new Rect(r.x, r.y, r.width, 40), "Preview requires\nrender texture support");
                return;
            }

            InitPreview();

            m_PreviewDir = PreviewGUI.Drag2D(m_PreviewDir, r);

            if (Event.current.type != EventType.Repaint)
                return;

            m_PreviewUtility.BeginPreview(r,  background);

            DoRenderPreview(m_PreviewShaded);

            m_PreviewUtility.EndAndDrawPreview(r);
        }
</source>
</class>

<class classid="142" nclones="2" nlines="11" similarity="90">
<source file="UnityCsReference/Editor/Mono/Inspector/AdvancedDropdown/AdvancedDropdownDataSource.cs.ifdefed" startline="52" endline="66" pcid="25634">
                {
                    var search = searchWords[w];
                    if (name.Contains(search))
                    {
                        // If the start of the item matches the first search word, make a note of that.
                        if (w == 0 && name.StartsWith(search))
                            didMatchStart = true;
                    }
                    else
                    {
                        // As soon as any word is not matched, we disregard this item.
                        didMatchAll = false;
                        break;
                    }
                }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/AnimatorOverrideControllerInspector.cs.ifdefed" startline="146" endline="160" pcid="28119">
                {
                    string search = searchWords[w];
                    if (name.Contains(search))
                    {
                        // If the start of the item matches the first search word, make a note of that.
                        if (w == 0 && name.StartsWith(search))
                            didMatchStart = true;
                    }
                    else
                    {
                        // As soon as any word is not matched, we disregard this item.
                        didMatchAll = false;
                        break;
                    }
                }
</source>
</class>

<class classid="143" nclones="2" nlines="15" similarity="80">
<source file="UnityCsReference/Editor/Mono/Inspector/LineRendererCurveEditor.cs.ifdefed" startline="68" endline="83" pcid="25712">
        {
            float colorMultiplier = !EditorGUIUtility.isProSkin ? 0.9f : 1.0f;
            Color colorMult = new Color(colorMultiplier, colorMultiplier, colorMultiplier, 1);

            CurveWrapper wrapper = new CurveWrapper();
            wrapper.id = 0;
            wrapper.groupId = -1;
            wrapper.color = new Color(1.0f, 0.0f, 0.0f, 1.0f) * colorMult;
            wrapper.hidden = false;
            wrapper.readOnly = false;
            wrapper.renderer = new NormalCurveRenderer(curve);
            wrapper.renderer.SetCustomRange(0.0f, 1.0f);
            wrapper.getAxisUiScalarsCallback = GetAxisScalars;
            wrapper.setAxisUiScalarsCallback = SetAxisScalars;
            return wrapper;
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/AudioSourceInspector.cs.ifdefed" startline="336" endline="350" pcid="27621">
        {
            float colorMultiplier = !EditorGUIUtility.isProSkin ? 0.9f : 1.0f;
            Color colorMult = new Color(colorMultiplier, colorMultiplier, colorMultiplier, 1);

            CurveWrapper wrapper = new CurveWrapper();
            wrapper.id = audioCurve.id;
            wrapper.groupId = -1;
            wrapper.color = audioCurve.color * colorMult;
            wrapper.hidden = false;
            wrapper.readOnly = false;
            wrapper.renderer = new NormalCurveRenderer(curve);
            wrapper.renderer.SetCustomRange(0.0f, 1.0f);
            wrapper.getAxisUiScalarsCallback = GetAxisScalars;
            return wrapper;
        }
</source>
</class>

<class classid="144" nclones="2" nlines="18" similarity="88">
<source file="UnityCsReference/Editor/Mono/Inspector/MovieTextureInspector.cs.ifdefed" startline="59" endline="83" pcid="25747">
        {
            if (Event.current.type == EventType.Repaint)
                background.Draw(r, false, false, false, false);

            // show texture
            MovieTexture t = target as MovieTexture;

            float zoomLevel = Mathf.Min(Mathf.Min(r.width / t.width, r.height / t.height), 1);
            Rect wantedRect = new Rect(r.x, r.y, t.width * zoomLevel, t.height * zoomLevel);
            PreviewGUI.BeginScrollView(r, m_Pos, wantedRect, "PreHorizontalScrollbar", "PreHorizontalScrollbarThumb");
            EditorGUI.DrawPreviewTexture(wantedRect, t, null, ScaleMode.StretchToFill);
            m_Pos = PreviewGUI.EndScrollView();

            // force update GUI
            if (t.isPlaying)
                GUIView.current.Repaint();

            if (Application.isPlaying)
            {
                if (t.isPlaying)
                    EditorGUI.DropShadowLabel(new Rect(r.x, r.y + 10, r.width, 20), "Can't pause preview when in play mode");
                else
                    EditorGUI.DropShadowLabel(new Rect(r.x, r.y + 10, r.width, 20), "Can't start preview when in play mode");
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/WebCamTextureInspector.cs.ifdefed" startline="61" endline="85" pcid="27954">
        {
            if (Event.current.type == EventType.Repaint)
                background.Draw(r, false, false, false, false);

            // show texture
            WebCamTexture t = target as WebCamTexture;

            float zoomLevel = Mathf.Min(Mathf.Min(r.width / t.width, r.height / t.height), 1);
            Rect wantedRect = new Rect(r.x, r.y, t.width * zoomLevel, t.height * zoomLevel);
            PreviewGUI.BeginScrollView(r, m_Pos, wantedRect, "PreHorizontalScrollbar", "PreHorizontalScrollbarThumb");
            GUI.DrawTexture(wantedRect, t, ScaleMode.StretchToFill, false);
            m_Pos = PreviewGUI.EndScrollView();

            // force update GUI
            if (t.isPlaying)
                GUIView.current.Repaint();

            if (Application.isPlaying)
            {
                if (t.isPlaying)
                    EditorGUI.DropShadowLabel(new Rect(r.x, r.y + 10, r.width, 20), "Can't pause preview when in play mode");
                else
                    EditorGUI.DropShadowLabel(new Rect(r.x, r.y + 10, r.width, 20), "Can't start preview when in play mode");
            }
        }
</source>
</class>

<class classid="145" nclones="2" nlines="10" similarity="70">
<source file="UnityCsReference/Editor/Mono/Inspector/CurvePresetLibraryInspector.cs.ifdefed" startline="60" endline="70" pcid="25880">
        {
            switch (m_CurveLibraryType)
            {
                case CurveLibraryType.NormalizedZeroToOne:
                    return "Curve Preset Library (Normalized 0 - 1)";
                case CurveLibraryType.Unbounded:
                    return "Curve Preset Library";
                default:
                    return "Curve Preset Library ?";
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/CurvePresetLibraryInspector.cs.ifdefed" startline="73" endline="83" pcid="25881">
        {
            switch (m_CurveLibraryType)
            {
                case CurveLibraryType.NormalizedZeroToOne:
                    return new Rect(0, 0, 1, 1);
                case CurveLibraryType.Unbounded:
                    return new Rect();
                default:
                    return new Rect();
            }
        }
</source>
</class>

<class classid="146" nclones="3" nlines="10" similarity="90">
<source file="UnityCsReference/Editor/Mono/Inspector/StandardRoughnessShaderGUI.cs.ifdefed" startline="102" endline="117" pcid="25920">
        {
            FindProperties(props); // MaterialProperties can be animated so we do not cache them but fetch them every event to ensure animated values are updated correctly
            m_MaterialEditor = materialEditor;
            Material material = materialEditor.target as Material;

            // Make sure that needed setup (ie keywords/renderqueue) are set up if we're switching some existing
            // material to a standard shader.
            // Do this before any GUI code has been issued to prevent layout issues in subsequent GUILayout statements (case 780071)
            if (m_FirstTimeApply)
            {
                MaterialChanged(material);
                m_FirstTimeApply = false;
            }

            ShaderPropertiesGUI(material);
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/StandardShaderGUI.cs.ifdefed" startline="131" endline="146" pcid="27798">
        {
            FindProperties(props); // MaterialProperties can be animated so we do not cache them but fetch them every event to ensure animated values are updated correctly
            m_MaterialEditor = materialEditor;
            Material material = materialEditor.target as Material;

            // Make sure that needed setup (ie keywords/renderqueue) are set up if we're switching some existing
            // material to a standard shader.
            // Do this before any GUI code has been issued to prevent layout issues in subsequent GUILayout statements (case 780071)
            if (m_FirstTimeApply)
            {
                MaterialChanged(material, m_WorkflowMode);
                m_FirstTimeApply = false;
            }

            ShaderPropertiesGUI(material);
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/StandardParticlesShaderGUI.cs.ifdefed" startline="153" endline="169" pcid="26697">
        {
            FindProperties(props); // MaterialProperties can be animated so we do not cache them but fetch them every event to ensure animated values are updated correctly
            m_MaterialEditor = materialEditor;
            Material material = materialEditor.target as Material;

            // Make sure that needed setup (ie keywords/renderqueue) are set up if we're switching some existing
            // material to a standard shader.
            // Do this before any GUI code has been issued to prevent layout issues in subsequent GUILayout statements (case 780071)
            if (m_FirstTimeApply)
            {
                MaterialChanged(material);
                CacheRenderersUsingThisMaterial(material);
                m_FirstTimeApply = false;
            }

            ShaderPropertiesGUI(material);
        }
</source>
</class>

<class classid="147" nclones="2" nlines="39" similarity="89">
<source file="UnityCsReference/Editor/Mono/Inspector/StandardRoughnessShaderGUI.cs.ifdefed" startline="120" endline="172" pcid="25922">
        {
            // Use default labelWidth
            EditorGUIUtility.labelWidth = 0f;

            // Detect any changes to the material
            EditorGUI.BeginChangeCheck();
            {
                BlendModePopup();

                // Primary properties
                GUILayout.Label(Styles.primaryMapsText, EditorStyles.boldLabel);
                DoAlbedoArea(material);
                m_MaterialEditor.TexturePropertySingleLine(Styles.metallicMapText, metallicMap, metallicMap.textureValue != null ? null : metallic);
                m_MaterialEditor.TexturePropertySingleLine(Styles.roughnessText, roughnessMap, roughnessMap.textureValue != null ? null : roughness);
                m_MaterialEditor.TexturePropertySingleLine(Styles.normalMapText, bumpMap, bumpMap.textureValue != null ? bumpScale : null);
                m_MaterialEditor.TexturePropertySingleLine(Styles.heightMapText, heightMap, heightMap.textureValue != null ? heigtMapScale : null);
                m_MaterialEditor.TexturePropertySingleLine(Styles.occlusionText, occlusionMap, occlusionMap.textureValue != null ? occlusionStrength : null);
                m_MaterialEditor.TexturePropertySingleLine(Styles.detailMaskText, detailMask);
                DoEmissionArea(material);
                EditorGUI.BeginChangeCheck();
                m_MaterialEditor.TextureScaleOffsetProperty(albedoMap);
                if (EditorGUI.EndChangeCheck())
                    emissionMap.textureScaleAndOffset = albedoMap.textureScaleAndOffset; // Apply the main texture scale and offset to the emission texture as well, for Enlighten's sake

                EditorGUILayout.Space();

                // Secondary properties
                GUILayout.Label(Styles.secondaryMapsText, EditorStyles.boldLabel);
                m_MaterialEditor.TexturePropertySingleLine(Styles.detailAlbedoText, detailAlbedoMap);
                m_MaterialEditor.TexturePropertySingleLine(Styles.detailNormalMapText, detailNormalMap, detailNormalMapScale);
                m_MaterialEditor.TextureScaleOffsetProperty(detailAlbedoMap);
                m_MaterialEditor.ShaderProperty(uvSetSecondary, Styles.uvSetLabel.text);

                // Third properties
                GUILayout.Label(Styles.forwardText, EditorStyles.boldLabel);
                if (highlights != null)
                    m_MaterialEditor.ShaderProperty(highlights, Styles.highlightsText);
                if (reflections != null)
                    m_MaterialEditor.ShaderProperty(reflections, Styles.reflectionsText);
            }
            if (EditorGUI.EndChangeCheck())
            {
                foreach (var obj in blendMode.targets)
                    MaterialChanged((Material)obj);
            }

            EditorGUILayout.Space();

            // NB renderqueue editor is not shown on purpose: we want to override it based on blend mode
            GUILayout.Label(Styles.advancedText, EditorStyles.boldLabel);
            m_MaterialEditor.EnableInstancingField();
            m_MaterialEditor.DoubleSidedGIField();
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/StandardShaderGUI.cs.ifdefed" startline="149" endline="200" pcid="27800">
        {
            // Use default labelWidth
            EditorGUIUtility.labelWidth = 0f;

            // Detect any changes to the material
            EditorGUI.BeginChangeCheck();
            {
                BlendModePopup();

                // Primary properties
                GUILayout.Label(Styles.primaryMapsText, EditorStyles.boldLabel);
                DoAlbedoArea(material);
                DoSpecularMetallicArea();
                DoNormalArea();
                m_MaterialEditor.TexturePropertySingleLine(Styles.heightMapText, heightMap, heightMap.textureValue != null ? heigtMapScale : null);
                m_MaterialEditor.TexturePropertySingleLine(Styles.occlusionText, occlusionMap, occlusionMap.textureValue != null ? occlusionStrength : null);
                m_MaterialEditor.TexturePropertySingleLine(Styles.detailMaskText, detailMask);
                DoEmissionArea(material);
                EditorGUI.BeginChangeCheck();
                m_MaterialEditor.TextureScaleOffsetProperty(albedoMap);
                if (EditorGUI.EndChangeCheck())
                    emissionMap.textureScaleAndOffset = albedoMap.textureScaleAndOffset; // Apply the main texture scale and offset to the emission texture as well, for Enlighten's sake

                EditorGUILayout.Space();

                // Secondary properties
                GUILayout.Label(Styles.secondaryMapsText, EditorStyles.boldLabel);
                m_MaterialEditor.TexturePropertySingleLine(Styles.detailAlbedoText, detailAlbedoMap);
                m_MaterialEditor.TexturePropertySingleLine(Styles.detailNormalMapText, detailNormalMap, detailNormalMapScale);
                m_MaterialEditor.TextureScaleOffsetProperty(detailAlbedoMap);
                m_MaterialEditor.ShaderProperty(uvSetSecondary, Styles.uvSetLabel.text);

                // Third properties
                GUILayout.Label(Styles.forwardText, EditorStyles.boldLabel);
                if (highlights != null)
                    m_MaterialEditor.ShaderProperty(highlights, Styles.highlightsText);
                if (reflections != null)
                    m_MaterialEditor.ShaderProperty(reflections, Styles.reflectionsText);
            }
            if (EditorGUI.EndChangeCheck())
            {
                foreach (var obj in blendMode.targets)
                    MaterialChanged((Material)obj, m_WorkflowMode);
            }

            EditorGUILayout.Space();

            // NB renderqueue editor is not shown on purpose: we want to override it based on blend mode
            GUILayout.Label(Styles.advancedText, EditorStyles.boldLabel);
            m_MaterialEditor.EnableInstancingField();
            m_MaterialEditor.DoubleSidedGIField();
        }
</source>
</class>

<class classid="148" nclones="3" nlines="20" similarity="82">
<source file="UnityCsReference/Editor/Mono/Inspector/StandardRoughnessShaderGUI.cs.ifdefed" startline="175" endline="205" pcid="25925">
        {
            // _Emission property is lost after assigning Standard shader to the material
            // thus transfer it before assigning the new shader
            if (material.HasProperty("_Emission"))
            {
                material.SetColor("_EmissionColor", material.GetColor("_Emission"));
            }

            base.AssignNewShaderToMaterial(material, oldShader, newShader);

            if (oldShader == null || !oldShader.name.Contains("Legacy Shaders/"))
            {
                SetupMaterialWithBlendMode(material, (BlendMode)material.GetFloat("_Mode"));
                return;
            }

            BlendMode blendMode = BlendMode.Opaque;
            if (oldShader.name.Contains("/Transparent/Cutout/"))
            {
                blendMode = BlendMode.Cutout;
            }
            else if (oldShader.name.Contains("/Transparent/"))
            {
                // NOTE: legacy shaders did not provide physically based transparency
                // therefore Fade mode
                blendMode = BlendMode.Fade;
            }
            material.SetFloat("_Mode", (float)blendMode);

            MaterialChanged(material);
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/StandardShaderGUI.cs.ifdefed" startline="213" endline="244" pcid="27804">
        {
            // _Emission property is lost after assigning Standard shader to the material
            // thus transfer it before assigning the new shader
            if (material.HasProperty("_Emission"))
            {
                material.SetColor("_EmissionColor", material.GetColor("_Emission"));
            }

            base.AssignNewShaderToMaterial(material, oldShader, newShader);

            if (oldShader == null || !oldShader.name.Contains("Legacy Shaders/"))
            {
                SetupMaterialWithBlendMode(material, (BlendMode)material.GetFloat("_Mode"));
                return;
            }

            BlendMode blendMode = BlendMode.Opaque;
            if (oldShader.name.Contains("/Transparent/Cutout/"))
            {
                blendMode = BlendMode.Cutout;
            }
            else if (oldShader.name.Contains("/Transparent/"))
            {
                // NOTE: legacy shaders did not provide physically based transparency
                // therefore Fade mode
                blendMode = BlendMode.Fade;
            }
            material.SetFloat("_Mode", (float)blendMode);

            DetermineWorkflow(MaterialEditor.GetMaterialProperties(new Material[] { material }));
            MaterialChanged(material, m_WorkflowMode);
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/StandardParticlesShaderGUI.cs.ifdefed" startline="226" endline="262" pcid="26704">
        {
            // Sync the lighting flag for the unlit shader
            if (newShader.name.Contains("Unlit"))
                material.SetFloat("_LightingEnabled", 0.0f);
            else
                material.SetFloat("_LightingEnabled", 1.0f);

            // _Emission property is lost after assigning Standard shader to the material
            // thus transfer it before assigning the new shader
            if (material.HasProperty("_Emission"))
            {
                material.SetColor("_EmissionColor", material.GetColor("_Emission"));
            }

            base.AssignNewShaderToMaterial(material, oldShader, newShader);

            if (oldShader == null || !oldShader.name.Contains("Legacy Shaders/"))
            {
                SetupMaterialWithBlendMode(material, (BlendMode)material.GetFloat("_Mode"));
                return;
            }

            BlendMode blendMode = BlendMode.Opaque;
            if (oldShader.name.Contains("/Transparent/Cutout/"))
            {
                blendMode = BlendMode.Cutout;
            }
            else if (oldShader.name.Contains("/Transparent/"))
            {
                // NOTE: legacy shaders did not provide physically based transparency
                // therefore Fade mode
                blendMode = BlendMode.Fade;
            }
            material.SetFloat("_Mode", (float)blendMode);

            MaterialChanged(material);
        }
</source>
</class>

<class classid="149" nclones="3" nlines="11" similarity="100">
<source file="UnityCsReference/Editor/Mono/Inspector/StandardRoughnessShaderGUI.cs.ifdefed" startline="208" endline="221" pcid="25930">
        {
            EditorGUI.showMixedValue = blendMode.hasMixedValue;
            var mode = (BlendMode)blendMode.floatValue;

            EditorGUI.BeginChangeCheck();
            mode = (BlendMode)EditorGUILayout.Popup(Styles.renderingMode, (int)mode, Styles.blendNames);
            if (EditorGUI.EndChangeCheck())
            {
                m_MaterialEditor.RegisterPropertyChangeUndo("Rendering Mode");
                blendMode.floatValue = (float)mode;
            }

            EditorGUI.showMixedValue = false;
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/StandardParticlesShaderGUI.cs.ifdefed" startline="265" endline="278" pcid="26709">
        {
            EditorGUI.showMixedValue = blendMode.hasMixedValue;
            var mode = (BlendMode)blendMode.floatValue;

            EditorGUI.BeginChangeCheck();
            mode = (BlendMode)EditorGUILayout.Popup(Styles.renderingMode, (int)mode, Styles.blendNames);
            if (EditorGUI.EndChangeCheck())
            {
                m_MaterialEditor.RegisterPropertyChangeUndo("Rendering Mode");
                blendMode.floatValue = (float)mode;
            }

            EditorGUI.showMixedValue = false;
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/StandardShaderGUI.cs.ifdefed" startline="247" endline="260" pcid="27809">
        {
            EditorGUI.showMixedValue = blendMode.hasMixedValue;
            var mode = (BlendMode)blendMode.floatValue;

            EditorGUI.BeginChangeCheck();
            mode = (BlendMode)EditorGUILayout.Popup(Styles.renderingMode, (int)mode, Styles.blendNames);
            if (EditorGUI.EndChangeCheck())
            {
                m_MaterialEditor.RegisterPropertyChangeUndo("Rendering Mode");
                blendMode.floatValue = (float)mode;
            }

            EditorGUI.showMixedValue = false;
        }
</source>
</class>

<class classid="150" nclones="2" nlines="10" similarity="100">
<source file="UnityCsReference/Editor/Mono/Inspector/StandardRoughnessShaderGUI.cs.ifdefed" startline="233" endline="250" pcid="25934">
        {
            // Emission for GI?
            if (m_MaterialEditor.EmissionEnabledProperty())
            {
                bool hadEmissionTexture = emissionMap.textureValue != null;

                // Texture and HDR color controls
                m_MaterialEditor.TexturePropertyWithHDRColor(Styles.emissionText, emissionMap, emissionColorForRendering, false);

                // If texture was assigned and color was black set color to white
                float brightness = emissionColorForRendering.colorValue.maxColorComponent;
                if (emissionMap.textureValue != null && !hadEmissionTexture && brightness <= 0f)
                    emissionColorForRendering.colorValue = Color.white;

                // change the GI flag and fix it up with emissive as black if necessary
                m_MaterialEditor.LightmapEmissionFlagsProperty(MaterialEditor.kMiniTextureFieldLabelIndentLevel, true);
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/StandardShaderGUI.cs.ifdefed" startline="284" endline="301" pcid="27815">
        {
            // Emission for GI?
            if (m_MaterialEditor.EmissionEnabledProperty())
            {
                bool hadEmissionTexture = emissionMap.textureValue != null;

                // Texture and HDR color controls
                m_MaterialEditor.TexturePropertyWithHDRColor(Styles.emissionText, emissionMap, emissionColorForRendering, false);

                // If texture was assigned and color was black set color to white
                float brightness = emissionColorForRendering.colorValue.maxColorComponent;
                if (emissionMap.textureValue != null && !hadEmissionTexture && brightness <= 0f)
                    emissionColorForRendering.colorValue = Color.white;

                // change the GI flag and fix it up with emissive as black if necessary
                m_MaterialEditor.LightmapEmissionFlagsProperty(MaterialEditor.kMiniTextureFieldLabelIndentLevel, true);
            }
        }
</source>
</class>

<class classid="151" nclones="2" nlines="44" similarity="100">
<source file="UnityCsReference/Editor/Mono/Inspector/StandardRoughnessShaderGUI.cs.ifdefed" startline="253" endline="297" pcid="25936">
        {
            switch (blendMode)
            {
                case BlendMode.Opaque:
                    material.SetOverrideTag("RenderType", "");
                    material.SetInt("_SrcBlend", (int)UnityEngine.Rendering.BlendMode.One);
                    material.SetInt("_DstBlend", (int)UnityEngine.Rendering.BlendMode.Zero);
                    material.SetInt("_ZWrite", 1);
                    material.DisableKeyword("_ALPHATEST_ON");
                    material.DisableKeyword("_ALPHABLEND_ON");
                    material.DisableKeyword("_ALPHAPREMULTIPLY_ON");
                    material.renderQueue = -1;
                    break;
                case BlendMode.Cutout:
                    material.SetOverrideTag("RenderType", "TransparentCutout");
                    material.SetInt("_SrcBlend", (int)UnityEngine.Rendering.BlendMode.One);
                    material.SetInt("_DstBlend", (int)UnityEngine.Rendering.BlendMode.Zero);
                    material.SetInt("_ZWrite", 1);
                    material.EnableKeyword("_ALPHATEST_ON");
                    material.DisableKeyword("_ALPHABLEND_ON");
                    material.DisableKeyword("_ALPHAPREMULTIPLY_ON");
                    material.renderQueue = (int)UnityEngine.Rendering.RenderQueue.AlphaTest;
                    break;
                case BlendMode.Fade:
                    material.SetOverrideTag("RenderType", "Transparent");
                    material.SetInt("_SrcBlend", (int)UnityEngine.Rendering.BlendMode.SrcAlpha);
                    material.SetInt("_DstBlend", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);
                    material.SetInt("_ZWrite", 0);
                    material.DisableKeyword("_ALPHATEST_ON");
                    material.EnableKeyword("_ALPHABLEND_ON");
                    material.DisableKeyword("_ALPHAPREMULTIPLY_ON");
                    material.renderQueue = (int)UnityEngine.Rendering.RenderQueue.Transparent;
                    break;
                case BlendMode.Transparent:
                    material.SetOverrideTag("RenderType", "Transparent");
                    material.SetInt("_SrcBlend", (int)UnityEngine.Rendering.BlendMode.One);
                    material.SetInt("_DstBlend", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);
                    material.SetInt("_ZWrite", 0);
                    material.DisableKeyword("_ALPHATEST_ON");
                    material.DisableKeyword("_ALPHABLEND_ON");
                    material.EnableKeyword("_ALPHAPREMULTIPLY_ON");
                    material.renderQueue = (int)UnityEngine.Rendering.RenderQueue.Transparent;
                    break;
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/StandardShaderGUI.cs.ifdefed" startline="334" endline="378" pcid="27821">
        {
            switch (blendMode)
            {
                case BlendMode.Opaque:
                    material.SetOverrideTag("RenderType", "");
                    material.SetInt("_SrcBlend", (int)UnityEngine.Rendering.BlendMode.One);
                    material.SetInt("_DstBlend", (int)UnityEngine.Rendering.BlendMode.Zero);
                    material.SetInt("_ZWrite", 1);
                    material.DisableKeyword("_ALPHATEST_ON");
                    material.DisableKeyword("_ALPHABLEND_ON");
                    material.DisableKeyword("_ALPHAPREMULTIPLY_ON");
                    material.renderQueue = -1;
                    break;
                case BlendMode.Cutout:
                    material.SetOverrideTag("RenderType", "TransparentCutout");
                    material.SetInt("_SrcBlend", (int)UnityEngine.Rendering.BlendMode.One);
                    material.SetInt("_DstBlend", (int)UnityEngine.Rendering.BlendMode.Zero);
                    material.SetInt("_ZWrite", 1);
                    material.EnableKeyword("_ALPHATEST_ON");
                    material.DisableKeyword("_ALPHABLEND_ON");
                    material.DisableKeyword("_ALPHAPREMULTIPLY_ON");
                    material.renderQueue = (int)UnityEngine.Rendering.RenderQueue.AlphaTest;
                    break;
                case BlendMode.Fade:
                    material.SetOverrideTag("RenderType", "Transparent");
                    material.SetInt("_SrcBlend", (int)UnityEngine.Rendering.BlendMode.SrcAlpha);
                    material.SetInt("_DstBlend", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);
                    material.SetInt("_ZWrite", 0);
                    material.DisableKeyword("_ALPHATEST_ON");
                    material.EnableKeyword("_ALPHABLEND_ON");
                    material.DisableKeyword("_ALPHAPREMULTIPLY_ON");
                    material.renderQueue = (int)UnityEngine.Rendering.RenderQueue.Transparent;
                    break;
                case BlendMode.Transparent:
                    material.SetOverrideTag("RenderType", "Transparent");
                    material.SetInt("_SrcBlend", (int)UnityEngine.Rendering.BlendMode.One);
                    material.SetInt("_DstBlend", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);
                    material.SetInt("_ZWrite", 0);
                    material.DisableKeyword("_ALPHATEST_ON");
                    material.DisableKeyword("_ALPHABLEND_ON");
                    material.EnableKeyword("_ALPHAPREMULTIPLY_ON");
                    material.renderQueue = (int)UnityEngine.Rendering.RenderQueue.Transparent;
                    break;
            }
        }
</source>
</class>

<class classid="152" nclones="2" nlines="16" similarity="72">
<source file="UnityCsReference/Editor/Mono/Inspector/RectTransformEditor.cs.ifdefed" startline="530" endline="550" pcid="26071">
        {
            using (new EditorGUI.DisabledScope(targets.Any(x => ((x as RectTransform).drivenProperties & driven) != 0)))
            {
                float value = getter(target as RectTransform);
                EditorGUI.showMixedValue = targets.Select(x => getter(x as RectTransform)).Distinct().Count() >= 2;

                EditorGUI.BeginChangeCheck();

                int id = GUIUtility.GetControlID(s_FloatFieldHash, FocusType.Keyboard, position);
                Rect positionLabel = new Rect(position.x, position.y, position.width, EditorGUIUtility.singleLineHeight);
                Rect positionField = new Rect(position.x, position.y + EditorGUIUtility.singleLineHeight, position.width, EditorGUIUtility.singleLineHeight);
                EditorGUI.HandlePrefixLabel(position, positionLabel, label, id);
                float newValue = EditorGUI.DoFloatField(EditorGUI.s_RecycledEditor, positionField, positionLabel, id, value, EditorGUI.kFloatFieldFormatString, EditorStyles.textField, true);
                if (EditorGUI.EndChangeCheck())
                {
                    Undo.RecordObjects(targets, "Inspector");
                    foreach (RectTransform tr in targets)
                        setter(tr, newValue);
                }
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/RectTransformEditor.cs.ifdefed" startline="586" endline="601" pcid="26075">
        {
            using (new EditorGUI.DisabledScope(targets.Any(x => ((x as RectTransform).drivenProperties & driven) != 0)))
            {
                float value = getter(target as RectTransform);
                EditorGUI.showMixedValue = targets.Select(x => getter(x as RectTransform)).Distinct().Count() >= 2;

                EditorGUI.BeginChangeCheck();
                float newValue = EditorGUI.FloatField(position, label, value);
                if (EditorGUI.EndChangeCheck())
                {
                    Undo.RecordObjects(targets, "Inspector");
                    foreach (RectTransform tr in targets)
                        setter(tr, newValue);
                }
            }
        }
</source>
</class>

<class classid="153" nclones="3" nlines="10" similarity="80">
<source file="UnityCsReference/Editor/Mono/Inspector/MaterialEditor.cs.ifdefed" startline="501" endline="507" pcid="26215">
        {
            hasMixedValue = false;
            Color f = ((Material)targets[0]).GetColor(propertyName);
            for (int i = 1; i < targets.Length; i++)
                if (((Material)targets[i]).GetColor(propertyName) != f) { hasMixedValue = true; break; }
            return f;
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/MaterialEditor.cs.ifdefed" startline="518" endline="524" pcid="26218">
        {
            hasMixedValue = false;
            Vector4 f = ((Material)targets[0]).GetVector(propertyName);
            for (int i = 1; i < targets.Length; i++)
                if (((Material)targets[i]).GetVector(propertyName) != f) { hasMixedValue = true; break; }
            return f;
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/MaterialEditor.cs.ifdefed" startline="535" endline="541" pcid="26221">
        {
            hasMixedValue = false;
            Texture f = ((Material)targets[0]).GetTexture(propertyName);
            for (int i = 1; i < targets.Length; i++)
                if (((Material)targets[i]).GetTexture(propertyName) != f) { hasMixedValue = true; break; }
            return f;
        }
</source>
</class>

<class classid="154" nclones="2" nlines="17" similarity="88">
<source file="UnityCsReference/Editor/Mono/Inspector/MaterialEditor.cs.ifdefed" startline="552" endline="565" pcid="26224">
        {
            hasMixedValueX = false;
            hasMixedValueY = false;
            Vector2 f = ((Material)targets[0]).GetTextureScale(propertyName);
            for (int i = 1; i < targets.Length; i++)
            {
                Vector2 f2 = ((Material)targets[i]).GetTextureScale(propertyName);
                if (f2.x != f.x) { hasMixedValueX = true; }
                if (f2.y != f.y) { hasMixedValueY = true; }
                if (hasMixedValueX && hasMixedValueY)
                    break;
            }
            return f;
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/MaterialEditor.cs.ifdefed" startline="569" endline="582" pcid="26228">
        {
            hasMixedValueX = false;
            hasMixedValueY = false;
            Vector2 f = ((Material)targets[0]).GetTextureOffset(propertyName);
            for (int i = 1; i < targets.Length; i++)
            {
                Vector2 f2 = ((Material)targets[i]).GetTextureOffset(propertyName);
                if (f2.x != f.x) { hasMixedValueX = true; }
                if (f2.y != f.y) { hasMixedValueY = true; }
                if (hasMixedValueX && hasMixedValueY)
                    break;
            }
            return f;
        }
</source>
</class>

<class classid="155" nclones="2" nlines="12" similarity="75">
<source file="UnityCsReference/Editor/Mono/Inspector/MaterialEditor.cs.ifdefed" startline="634" endline="652" pcid="26240">
        {
            EditorGUI.BeginChangeCheck();
            EditorGUI.showMixedValue = prop.hasMixedValue;

            // For range properties we want to show the slider so we adjust label width to use default width (setting it to 0)
            // See SetDefaultGUIWidths where we set: EditorGUIUtility.labelWidth = GUIClip.visibleRect.width - EditorGUIUtility.fieldWidth - 17;
            float oldLabelWidth = EditorGUIUtility.labelWidth;
            EditorGUIUtility.labelWidth = 0f;

            float newValue = EditorGUI.PowerSlider(position, label, prop.floatValue, prop.rangeLimits.x, prop.rangeLimits.y, power);
            EditorGUI.showMixedValue = false;

            EditorGUIUtility.labelWidth = oldLabelWidth;

            if (EditorGUI.EndChangeCheck())
                prop.floatValue = newValue;

            return prop.floatValue;
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/MaterialEditor.cs.ifdefed" startline="655" endline="673" pcid="26241">
        {
            EditorGUI.BeginChangeCheck();
            EditorGUI.showMixedValue = prop.hasMixedValue;

            // For range properties we want to show the slider so we adjust label width to use default width (setting it to 0)
            // See SetDefaultGUIWidths where we set: EditorGUIUtility.labelWidth = GUIClip.visibleRect.width - EditorGUIUtility.fieldWidth - 17;
            float oldLabelWidth = EditorGUIUtility.labelWidth;
            EditorGUIUtility.labelWidth = 0f;

            int newValue = EditorGUI.IntSlider(position, label, (int)prop.floatValue, (int)prop.rangeLimits.x, (int)prop.rangeLimits.y);
            EditorGUI.showMixedValue = false;

            EditorGUIUtility.labelWidth = oldLabelWidth;

            if (EditorGUI.EndChangeCheck())
                prop.floatValue = (float)newValue;

            return (int)prop.floatValue;
        }
</source>
</class>

<class classid="156" nclones="2" nlines="11" similarity="81">
<source file="UnityCsReference/Editor/Mono/Inspector/AssetStoreAssetInspector.cs.ifdefed" startline="514" endline="524" pcid="26536">
        {
            AssetStoreLoginWindow.Login("Please login to the Asset Store in order to get payment information about the package.",
                delegate(string errorMessage) {
                    if (errorMessage != null)
                        return; // aborted

                    AssetStoreAssetSelection.RefreshFromServer(delegate() {
                        InitiateBuySelected(false);
                    });
                });
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/AssetStoreAssetInspector.cs.ifdefed" startline="535" endline="545" pcid="26540">
        {
            AssetStoreLoginWindow.Login("Please login to the Asset Store in order to get download information for the package.",
                delegate(string errorMessage) {
                    if (errorMessage != null)
                        return; // aborted

                    AssetStoreAssetSelection.RefreshFromServer(delegate() {
                        AssetStoreInstaBuyWindow.ShowAssetStoreInstaBuyWindowBuilding(asset);
                    });
                });
        }
</source>
</class>

<class classid="157" nclones="2" nlines="33" similarity="90">
<source file="UnityCsReference/Editor/Mono/Inspector/Rigidbody2DEditor.cs.ifdefed" startline="202" endline="238" pcid="26682">
        {
            EditorGUI.indentLevel++;
            m_ShowContacts.target = EditorGUILayout.Foldout(m_ShowContacts.target, "Contacts");
            if (EditorGUILayout.BeginFadeGroup(m_ShowContacts.faded))
            {
                var contactCount = body.GetContacts(m_Contacts);
                if (contactCount > 0)
                {
                    m_ContactScrollPosition = EditorGUILayout.BeginScrollView(m_ContactScrollPosition, GUILayout.Height(180));
                    EditorGUI.BeginDisabledGroup(true);
                    for (var i = 0; i < contactCount; ++i)
                    {
                        var contact = m_Contacts[i];
                        EditorGUILayout.HelpBox(string.Format("Contact#{0}", i), MessageType.None);
                        EditorGUI.indentLevel++;
                        EditorGUILayout.Vector2Field("Point", contact.point);
                        EditorGUILayout.Vector2Field("Normal", contact.normal);
                        EditorGUILayout.Vector2Field("Relative Velocity", contact.relativeVelocity);
                        EditorGUILayout.FloatField("Normal Impulse", contact.normalImpulse);
                        EditorGUILayout.FloatField("Tangent Impulse", contact.tangentImpulse);
                        EditorGUILayout.ObjectField("Collider", contact.collider, typeof(Collider2D), true);
                        EditorGUILayout.ObjectField("Rigidbody", contact.rigidbody, typeof(Rigidbody2D), false);
                        EditorGUILayout.ObjectField("OtherCollider", contact.otherCollider, typeof(Collider2D), false);
                        EditorGUI.indentLevel--;
                        EditorGUILayout.Space();
                    }
                    EditorGUI.EndDisabledGroup();
                    EditorGUILayout.EndScrollView();
                }
                else
                {
                    EditorGUILayout.HelpBox("No Contacts", MessageType.Info);
                }
            }
            FixedEndFadeGroup(m_ShowContacts.faded);
            EditorGUI.indentLevel--;
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/Collider2DEditorBase.cs.ifdefed" startline="159" endline="196" pcid="29421">
        {
            EditorGUI.indentLevel++;
            m_ShowContacts.target = EditorGUILayout.Foldout(m_ShowContacts.target, "Contacts");
            if (EditorGUILayout.BeginFadeGroup(m_ShowContacts.faded))
            {
                var contactCount = collider.GetContacts(m_Contacts);
                if (contactCount > 0)
                {
                    m_ContactScrollPosition = EditorGUILayout.BeginScrollView(m_ContactScrollPosition, GUILayout.Height(180));
                    EditorGUI.BeginDisabledGroup(true);

                    for (var i = 0; i < contactCount; ++i)
                    {
                        var contact = m_Contacts[i];
                        EditorGUILayout.HelpBox(string.Format("Contact#{0}", i), MessageType.None);
                        EditorGUI.indentLevel++;
                        EditorGUILayout.Vector2Field("Point", contact.point);
                        EditorGUILayout.Vector2Field("Normal", contact.normal);
                        EditorGUILayout.Vector2Field("Relative Velocity", contact.relativeVelocity);
                        EditorGUILayout.FloatField("Normal Impulse", contact.normalImpulse);
                        EditorGUILayout.FloatField("Tangent Impulse", contact.tangentImpulse);
                        EditorGUILayout.ObjectField("Collider", contact.collider, typeof(Collider2D), false);
                        EditorGUILayout.ObjectField("Rigidbody", contact.rigidbody, typeof(Rigidbody2D), false);
                        EditorGUILayout.ObjectField("OtherRigidbody", contact.otherRigidbody, typeof(Rigidbody2D), false);
                        EditorGUI.indentLevel--;
                        EditorGUILayout.Space();
                    }
                    EditorGUI.EndDisabledGroup();
                    EditorGUILayout.EndScrollView();
                }
                else
                {
                    EditorGUILayout.HelpBox("No Contacts", MessageType.Info);
                }
            }
            FixedEndFadeGroup(m_ShowContacts.faded);
            EditorGUI.indentLevel--;
        }
</source>
</class>

<class classid="158" nclones="2" nlines="14" similarity="78">
<source file="UnityCsReference/Editor/Mono/Inspector/Rigidbody2DEditor.cs.ifdefed" startline="251" endline="265" pcid="26688">
        {
            var toggle = ((int)value & (1 << bit)) != 0;
            EditorGUI.showMixedValue = (m_Constraints.hasMultipleDifferentValuesBitwise & (1 << bit)) != 0;
            EditorGUI.BeginChangeCheck();
            var oldIndent = EditorGUI.indentLevel;
            EditorGUI.indentLevel = 0;
            toggle = EditorGUI.ToggleLeft(r, label, toggle);
            EditorGUI.indentLevel = oldIndent;
            if (EditorGUI.EndChangeCheck())
            {
                Undo.RecordObjects(targets, "Edit Constraints2D");
                m_Constraints.SetBitAtIndexForAllTargetsImmediate(bit, toggle);
            }
            EditorGUI.showMixedValue = false;
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/RigidbodyEditor.cs.ifdefed" startline="25" endline="39" pcid="30445">
        {
            bool toggle = ((int)value & (1 << bit)) != 0;
            EditorGUI.showMixedValue = (m_Constraints.hasMultipleDifferentValuesBitwise & (1 << bit)) != 0;
            EditorGUI.BeginChangeCheck();
            int oldIndent = EditorGUI.indentLevel;
            EditorGUI.indentLevel = 0;
            toggle = EditorGUI.ToggleLeft(r, label, toggle);
            EditorGUI.indentLevel = oldIndent;
            if (EditorGUI.EndChangeCheck())
            {
                Undo.RecordObjects(targets, "Edit Constraints");
                m_Constraints.SetBitAtIndexForAllTargetsImmediate(bit, toggle);
            }
            EditorGUI.showMixedValue = false;
        }
</source>
</class>

<class classid="159" nclones="2" nlines="23" similarity="72">
<source file="UnityCsReference/Editor/Mono/Inspector/LineRendererToolModes.cs.ifdefed" startline="119" endline="144" pcid="26777">
        {
            if (m_Selection.Count == 0)
                return;

            Undo.RecordObject(m_LineRenderer, "Delete Selected");
            var positions = new Vector3[m_LineRenderer.positionCount];
            var newPositions = new Vector3[m_LineRenderer.positionCount - m_Selection.Count];
            m_LineRenderer.GetPositions(positions);

            int selectionIndex = 0;
            int insertIndex = 0;
            for (int i = 0; i < positions.Length; ++i)
            {
                if (i == m_Selection[selectionIndex])
                {
                    if (selectionIndex < m_Selection.Count - 1)
                        ++selectionIndex;
                }
                else
                    newPositions[insertIndex++] = positions[i];
            }

            m_LineRenderer.positionCount = newPositions.Length;
            m_LineRenderer.SetPositions(newPositions);
            m_Selection.Clear();
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/LineRendererToolModes.cs.ifdefed" startline="147" endline="177" pcid="26780">
        {
            if (m_Selection.Count == 0)
                return;

            Undo.RecordObject(m_LineRenderer, "Duplicate Selected");
            var positions = new Vector3[m_LineRenderer.positionCount];
            var newPositions = new Vector3[m_LineRenderer.positionCount + m_Selection.Count];
            m_LineRenderer.GetPositions(positions);

            int selectionIndex = 0;
            int insertIndex = 0;
            var insertedIndexes = new List<int>(m_Selection.Count);
            for (int i = 0; i < positions.Length; ++i)
            {
                if (i == m_Selection[selectionIndex])
                {
                    if (selectionIndex < m_Selection.Count - 1)
                        ++selectionIndex;

                    newPositions[insertIndex++] = positions[i];
                    insertedIndexes.Add(insertIndex); // Select the duplicate
                    newPositions[insertIndex++] = positions[i];
                }
                else
                    newPositions[insertIndex++] = positions[i];
            }

            m_LineRenderer.positionCount = newPositions.Length;
            m_LineRenderer.SetPositions(newPositions);
            m_Selection = insertedIndexes;
        }
</source>
</class>

<class classid="160" nclones="2" nlines="43" similarity="79">
<source file="UnityCsReference/Editor/Mono/Inspector/LightEditor.cs.ifdefed" startline="517" endline="569" pcid="27113">
        {
            // Command buffers are not serialized data, so can't get to them through
            // serialized property (hence no multi-edit).
            if (targets.Length != 1)
                return;
            var light = target as Light;
            if (light == null)
                return;
            int count = light.commandBufferCount;
            if (count == 0)
                return;

            m_CommandBuffersShown = GUILayout.Toggle(m_CommandBuffersShown, GUIContent.Temp(count + " command buffers"), EditorStyles.foldout);
            if (!m_CommandBuffersShown)
                return;
            EditorGUI.indentLevel++;
            foreach (LightEvent le in (LightEvent[])System.Enum.GetValues(typeof(LightEvent)))
            {
                CommandBuffer[] cbs = light.GetCommandBuffers(le);
                foreach (CommandBuffer cb in cbs)
                {
                    using (new GUILayout.HorizontalScope())
                    {
                        // row with event & command buffer information label
                        Rect rowRect = GUILayoutUtility.GetRect(GUIContent.none, EditorStyles.miniLabel);
                        rowRect.xMin += EditorGUI.indent;
                        Rect minusRect = GetRemoveButtonRect(rowRect);
                        rowRect.xMax = minusRect.x;
                        GUI.Label(rowRect, string.Format("{0}: {1} ({2})", le, cb.name, EditorUtility.FormatBytes(cb.sizeInBytes)), EditorStyles.miniLabel);
                        // and a button to remove it
                        if (GUI.Button(minusRect, s_Styles.iconRemove, s_Styles.invisibleButton))
                        {
                            light.RemoveCommandBuffer(le, cb);
                            SceneView.RepaintAll();
                            GameView.RepaintAll();
                            GUIUtility.ExitGUI();
                        }
                    }
                }
            }
            // "remove all" button
            using (new GUILayout.HorizontalScope())
            {
                GUILayout.FlexibleSpace();
                if (GUILayout.Button("Remove all", EditorStyles.miniButton))
                {
                    light.RemoveAllCommandBuffers();
                    SceneView.RepaintAll();
                    GameView.RepaintAll();
                }
            }
            EditorGUI.indentLevel--;
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/CameraEditor.cs.ifdefed" startline="499" endline="551" pcid="28006">
        {
            // Command buffers are not serialized data, so can't get to them through
            // serialized property (hence no multi-edit).
            if (targets.Length != 1)
                return;
            var cam = target as Camera;
            if (cam == null)
                return;
            int count = cam.commandBufferCount;
            if (count == 0)
                return;

            m_CommandBuffersShown = GUILayout.Toggle(m_CommandBuffersShown, GUIContent.Temp(count + " command buffers"), EditorStyles.foldout);
            if (!m_CommandBuffersShown)
                return;
            EditorGUI.indentLevel++;
            foreach (CameraEvent ce in (CameraEvent[])System.Enum.GetValues(typeof(CameraEvent)))
            {
                CommandBuffer[] cbs = cam.GetCommandBuffers(ce);
                foreach (CommandBuffer cb in cbs)
                {
                    using (new GUILayout.HorizontalScope())
                    {
                        // row with event & command buffer information label
                        Rect rowRect = GUILayoutUtility.GetRect(GUIContent.none, EditorStyles.miniLabel);
                        rowRect.xMin += EditorGUI.indent;
                        Rect minusRect = GetRemoveButtonRect(rowRect);
                        rowRect.xMax = minusRect.x;
                        GUI.Label(rowRect, string.Format("{0}: {1} ({2})", ce, cb.name, EditorUtility.FormatBytes(cb.sizeInBytes)), EditorStyles.miniLabel);
                        // and a button to remove it
                        if (GUI.Button(minusRect, Styles.iconRemove, Styles.invisibleButton))
                        {
                            cam.RemoveCommandBuffer(ce, cb);
                            SceneView.RepaintAll();
                            GameView.RepaintAll();
                            GUIUtility.ExitGUI();
                        }
                    }
                }
            }
            // "remove all" button
            using (new GUILayout.HorizontalScope())
            {
                GUILayout.FlexibleSpace();
                if (GUILayout.Button("Remove all", EditorStyles.miniButton))
                {
                    cam.RemoveAllCommandBuffers();
                    SceneView.RepaintAll();
                    GameView.RepaintAll();
                }
            }
            EditorGUI.indentLevel--;
        }
</source>
</class>

<class classid="161" nclones="2" nlines="18" similarity="72">
<source file="UnityCsReference/Editor/Mono/Inspector/BlendTreeInspector.cs.ifdefed" startline="1927" endline="1947" pcid="27559">
            {
                m_Controller = new AnimatorController();
                m_Controller.pushUndo = false;
                m_Controller.AddLayer("viz");
                m_StateMachine = m_Controller.layers[0].stateMachine;
                m_StateMachine.pushUndo = false;
                CreateParameters();
                m_State = m_StateMachine.AddState("viz");
                m_State.pushUndo = false;
                m_State.motion = m_BlendTree;
                m_State.iKOnFeet = false;

                m_State.hideFlags = HideFlags.HideAndDontSave;
                m_StateMachine.hideFlags = HideFlags.HideAndDontSave;
                m_Controller.hideFlags = HideFlags.HideAndDontSave;

                AnimatorController.SetAnimatorController(m_Animator, m_Controller);

                m_Controller.OnAnimatorControllerDirty += ControllerDirty;
                m_ControllerIsDirty = false;
            }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/BlendTreeInspector.cs.ifdefed" startline="2041" endline="2062" pcid="27573">
                {
                    m_Controller = new AnimatorController();
                    m_Controller.pushUndo = false;
                    m_Controller.AddLayer("preview");
                    m_StateMachine = m_Controller.layers[0].stateMachine;
                    m_StateMachine.pushUndo = false;
                    CreateParameters();

                    m_State = m_StateMachine.AddState("preview");
                    m_State.pushUndo = false;
                    m_State.motion = m_BlendTree;
                    m_State.iKOnFeet = m_AvatarPreview.IKOnFeet;

                    m_State.hideFlags = HideFlags.HideAndDontSave;
                    m_Controller.hideFlags = HideFlags.HideAndDontSave;
                    m_StateMachine.hideFlags = HideFlags.HideAndDontSave;

                    AnimatorController.SetAnimatorController(m_AvatarPreview.Animator, m_Controller);
                    m_Controller.OnAnimatorControllerDirty += ControllerDirty;

                    m_ControllerIsDirty = false;
                }
</source>
</class>

<class classid="162" nclones="2" nlines="11" similarity="81">
<source file="UnityCsReference/Editor/Mono/Inspector/BlendTreeInspector.cs.ifdefed" startline="1951" endline="1963" pcid="27560">
        {
            if (m_Animator != null)
                AnimatorController.SetAnimatorController(m_Animator, null);

            if (m_Controller != null)
                m_Controller.OnAnimatorControllerDirty -= ControllerDirty;

            Object.DestroyImmediate(m_Controller);
            Object.DestroyImmediate(m_State);
            m_StateMachine = null;
            m_Controller = null;
            m_State = null;
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/BlendTreeInspector.cs.ifdefed" startline="2070" endline="2081" pcid="27574">
        {
            if (m_AvatarPreview != null && m_AvatarPreview.Animator != null) AnimatorController.SetAnimatorController(m_AvatarPreview.Animator, null);

            if (m_Controller != null)
                m_Controller.OnAnimatorControllerDirty -= ControllerDirty;

            Object.DestroyImmediate(m_Controller);
            Object.DestroyImmediate(m_State);
            m_StateMachine = null;
            m_Controller = null;
            m_State = null;
        }
</source>
</class>

<class classid="163" nclones="2" nlines="17" similarity="76">
<source file="UnityCsReference/Editor/Mono/Inspector/AudioSourceInspector.cs.ifdefed" startline="124" endline="145" pcid="27597">
        {
            m_AddSpatializerExtension = false;

            int numTargetsWithSpatializerExtensions = 0;
            for (int i = 0; i < targets.Length; i++)
            {
                AudioSource source = targets[i] as AudioSource;
                if (source != null)
                {
                    System.Type spatializerExtensionType = AudioExtensionManager.GetSourceSpatializerExtensionType();
                    if ((spatializerExtensionType != null) && (source.GetNumExtensionPropertiesForThisExtension(spatializerExtensionType.Name) > 0))
                    {
                        m_AddSpatializerExtension = true;
                        numTargetsWithSpatializerExtensions++;
                    }
                }
            }

            m_AddSpatializerExtensionMixedValues = ((numTargetsWithSpatializerExtensions == 0) || (numTargetsWithSpatializerExtensions == targets.Length)) ? false : true;
            if (m_AddSpatializerExtensionMixedValues)
                m_AddSpatializerExtension = false;
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/AudioListenerInspector.cs.ifdefed" startline="111" endline="132" pcid="30510">
        {
            m_AddSpatializerExtension = false;

            int numTargetsWithSpatializerExtensions = 0;
            for (int i = 0; i < targets.Length; i++)
            {
                AudioListener listener = targets[i] as AudioListener;
                if (listener != null)
                {
                    System.Type spatializerExtensionType = AudioExtensionManager.GetListenerSpatializerExtensionType();
                    if ((spatializerExtensionType != null) && (listener.GetNumExtensionPropertiesForThisExtension(spatializerExtensionType.Name) > 0))
                    {
                        m_AddSpatializerExtension = true;
                        numTargetsWithSpatializerExtensions++;
                    }
                }
            }

            m_AddSpatializerExtensionMixedValues = ((numTargetsWithSpatializerExtensions == 0) || (numTargetsWithSpatializerExtensions == targets.Length)) ? false : true;
            if (m_AddSpatializerExtensionMixedValues)
                m_AddSpatializerExtension = false;
        }
</source>
</class>

<class classid="164" nclones="2" nlines="50" similarity="73">
<source file="UnityCsReference/Editor/Mono/Inspector/AudioSourceInspector.cs.ifdefed" startline="551" endline="613" pcid="27644">
                    {
                        EditorGUI.showMixedValue = m_AddSpatializerExtensionMixedValues;
                        bool addSpatializerExtensionNew = EditorGUILayout.Toggle(ms_Styles.addSpatializerExtensionLabel, m_AddSpatializerExtension);
                        EditorGUI.showMixedValue = false;

                        bool showExtensionProperties = false;
                        if (m_AddSpatializerExtension != addSpatializerExtensionNew)
                        {
                            m_AddSpatializerExtension = addSpatializerExtensionNew;
                            if (m_AddSpatializerExtension)
                            {
                                CreateExtensionEditors();

                                if (m_SpatializerEditor != null)
                                    showExtensionProperties = m_SpatializerEditor.FindAudioExtensionProperties(serializedObject);
                            }
                            else
                            {
                                ClearExtensionProperties();
                                DestroyExtensionEditors();
                                showExtensionProperties = false;
                            }
                        }
                        else if (m_SpatializerEditor != null)
                        {
                            showExtensionProperties = m_SpatializerEditor.FindAudioExtensionProperties(serializedObject);
                            if (!showExtensionProperties)
                            {
                                m_AddSpatializerExtension = false;
                                ClearExtensionProperties();
                                DestroyExtensionEditors();
                            }
                        }

                        if ((m_SpatializerEditor != null) && showExtensionProperties)
                        {
                            EditorGUI.indentLevel++;
                            m_SpatializerEditor.OnAudioSourceGUI();
                            EditorGUI.indentLevel--;

                            // Push any AudioSource extension property changes to the AudioSourceExtension properties. We always attempt to do this
                            // because we may be playing in Editor or previewing sound in the scene view.
                            for (int i = 0; i < targets.Length; i++)
                            {
                                AudioSource source = targets[i] as AudioSource;
                                AudioSourceExtension extension = (source != null) ? AudioExtensionManager.GetSpatializerExtension(source) : null;

                                if ((source != null) && (extension != null) && source.isPlaying)
                                {
                                    string extensionName = AudioExtensionManager.GetSourceSpatializerExtensionType().Name;
                                    for (int j = 0; j < m_SpatializerEditor.GetNumExtensionProperties(); j++)
                                    {
                                        PropertyName propertyName = m_SpatializerEditor.GetExtensionPropertyName(j);
                                        float value = 0.0f;
                                        if (source.ReadExtensionProperty(extensionName, propertyName, ref value))
                                        {
                                            extension.WriteExtensionProperty(propertyName, value);
                                        }
                                    }
                                }
                            }
                        }
                    }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/AudioListenerInspector.cs.ifdefed" startline="30" endline="101" pcid="30496">
        {
            serializedObject.Update();

            bool allowExtensionEditing = (m_AddSpatializerExtension && !m_AddSpatializerExtensionMixedValues) || !serializedObject.isEditingMultipleObjects;
            if (AudioExtensionManager.IsListenerSpatializerExtensionRegistered() && allowExtensionEditing)
            {
                EditorGUI.showMixedValue = m_AddSpatializerExtensionMixedValues;
                bool addSpatializerExtensionNew = EditorGUILayout.Toggle(addSpatializerExtensionLabel, m_AddSpatializerExtension);
                EditorGUI.showMixedValue = false;

                bool showExtensionProperties = false;
                if (m_AddSpatializerExtension != addSpatializerExtensionNew)
                {
                    m_AddSpatializerExtension = addSpatializerExtensionNew;
                    if (m_AddSpatializerExtension)
                    {
                        CreateExtensionEditors();

                        if (m_SpatializerEditor != null)
                            showExtensionProperties = m_SpatializerEditor.FindAudioExtensionProperties(serializedObject);
                    }
                    else
                    {
                        ClearExtensionProperties();
                        DestroyExtensionEditors();
                        showExtensionProperties = false;
                    }
                }
                else if (m_SpatializerEditor != null)
                {
                    showExtensionProperties = m_SpatializerEditor.FindAudioExtensionProperties(serializedObject);
                    if (!showExtensionProperties)
                    {
                        m_AddSpatializerExtension = false;
                        ClearExtensionProperties();
                        DestroyExtensionEditors();
                    }
                }

                if ((m_SpatializerEditor != null) && showExtensionProperties)
                {
                    EditorGUI.indentLevel++;
                    m_SpatializerEditor.OnAudioListenerGUI();
                    EditorGUI.indentLevel--;

                    // Update AudioSourceExtension properties, if we are currently playing in Editor.
                    for (int i = 0; i < targets.Length; i++)
                    {
                        AudioListener listener = targets[i] as AudioListener;
                        if (listener != null)
                        {
                            AudioListenerExtension extension = AudioExtensionManager.GetSpatializerExtension(listener);
                            if (extension != null)
                            {
                                string extensionName = AudioExtensionManager.GetListenerSpatializerExtensionType().Name;
                                for (int j = 0; j < m_SpatializerEditor.GetNumExtensionProperties(); j++)
                                {
                                    PropertyName propertyName = m_SpatializerEditor.GetExtensionPropertyName(j);
                                    float value = 0.0f;
                                    if (listener.ReadExtensionProperty(extensionName, propertyName, ref value))
                                    {
                                        extension.WriteExtensionProperty(propertyName, value);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            serializedObject.ApplyModifiedProperties();
        }
</source>
</class>

<class classid="165" nclones="2" nlines="30" similarity="80">
<source file="UnityCsReference/Editor/Mono/Inspector/ReflectionProbeEditor.cs.ifdefed" startline="348" endline="387" pcid="27851">
        {
            // Show the master tool selector
            GUILayout.BeginHorizontal();
            GUILayout.FlexibleSpace();
            GUI.changed = false;
            var oldEditMode = EditMode.editMode;

            EditorGUI.BeginChangeCheck();
            EditMode.DoInspectorToolbar(Styles.sceneViewEditModes, Styles.toolContents, this);
            if (EditorGUI.EndChangeCheck())
                s_LastInteractedEditor = this;

            if (oldEditMode != EditMode.editMode)
            {
                switch (EditMode.editMode)
                {
                    case EditMode.SceneViewEditMode.ReflectionProbeOrigin:
                        UpdateOldLocalSpace();
                        break;
                }
                if (Toolbar.get != null)
                    Toolbar.get.Repaint();
            }

            GUILayout.FlexibleSpace();
            GUILayout.EndHorizontal();

            // Info box for tools
            GUILayout.BeginVertical(EditorStyles.helpBox);
            string helpText = Styles.baseSceneEditingToolText;
            if (sceneViewEditing)
            {
                int index = ArrayUtility.IndexOf(Styles.sceneViewEditModes, EditMode.editMode);
                if (index >= 0)
                    helpText = Styles.toolNames[index].text;
            }
            GUILayout.Label(helpText, Styles.richTextMiniLabel);
            GUILayout.EndVertical();
            EditorGUILayout.Space();
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/LightProbeProxyVolumeEditor.cs.ifdefed" startline="183" endline="217" pcid="30570">
        {
            using (new EditorGUI.DisabledScope(m_BoundingBoxMode.intValue != (int)LightProbeProxyVolume.BoundingBoxMode.Custom))
            {
                GUILayout.BeginHorizontal();
                GUILayout.FlexibleSpace();
                var oldEditMode = EditMode.editMode;

                EditorGUI.BeginChangeCheck();
                EditMode.DoInspectorToolbar(Styles.sceneViewEditModes, Styles.toolContents, this);
                if (EditorGUI.EndChangeCheck())
                    s_LastInteractedEditor = this;

                if (oldEditMode != EditMode.editMode)
                {
                    if (Toolbar.get != null)
                        Toolbar.get.Repaint();
                }

                GUILayout.FlexibleSpace();
                GUILayout.EndHorizontal();

                // Info box for tools
                GUILayout.BeginVertical(EditorStyles.helpBox);
                string helpText = Styles.baseSceneEditingToolText;
                if (sceneViewEditing)
                {
                    int index = ArrayUtility.IndexOf(Styles.sceneViewEditModes, EditMode.editMode);
                    if (index >= 0)
                        helpText = Styles.toolNames[index].text;
                }
                GUILayout.Label(helpText, Styles.richTextMiniLabel);
                GUILayout.EndVertical();
                EditorGUILayout.Space();
            }
        }
</source>
</class>

<class classid="166" nclones="2" nlines="13" similarity="71">
<source file="UnityCsReference/Editor/Mono/Inspector/ReflectionProbeEditor.cs.ifdefed" startline="725" endline="738" pcid="27892">
        {
            if (!sceneViewEditing)
                return;

            switch (EditMode.editMode)
            {
                case EditMode.SceneViewEditMode.ReflectionProbeBox:
                    DoBoxEditing();
                    break;
                case EditMode.SceneViewEditMode.ReflectionProbeOrigin:
                    DoOriginEditing();
                    break;
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/LightProbeProxyVolumeEditor.cs.ifdefed" startline="331" endline="347" pcid="30585">
        {
            if (!sceneViewEditing)
                return;

            if (m_BoundingBoxMode.intValue != (int)LightProbeProxyVolume.BoundingBoxMode.Custom)
                EditMode.QuitEditMode();

            switch (EditMode.editMode)
            {
                case EditMode.SceneViewEditMode.LightProbeProxyVolumeBox:
                    DoBoxEditing();
                    break;
                case EditMode.SceneViewEditMode.LightProbeProxyVolumeOrigin:
                    DoOriginEditing();
                    break;
            }
        }
</source>
</class>

<class classid="167" nclones="2" nlines="10" similarity="80">
<source file="UnityCsReference/Editor/Mono/Inspector/AudioExtensionEditor.cs.ifdefed" startline="107" endline="117" pcid="28101">
        {
            Rect rect = EditorGUILayout.GetControlRect();
            title = EditorGUI.BeginProperty(rect, title, property);
            EditorGUI.BeginChangeCheck();
            bool newValue = EditorGUI.Toggle(rect, title, property.floatValue > 0.0f ? true : false);
            if (EditorGUI.EndChangeCheck())
            {
                property.floatValue = newValue ? 1.0f : 0.0f;
            }
            EditorGUI.EndProperty();
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/DirectorEditor.cs.ifdefed" startline="222" endline="232" pcid="29583">
        {
            Rect rect = EditorGUILayout.GetControlRect();
            title = EditorGUI.BeginProperty(rect, title, property);
            EditorGUI.BeginChangeCheck();
            float newValue = EditorGUI.FloatField(rect, title, (float)property.doubleValue);
            if (EditorGUI.EndChangeCheck())
            {
                property.doubleValue = newValue;
            }
            EditorGUI.EndProperty();
        }
</source>
</class>

<class classid="168" nclones="2" nlines="16" similarity="75">
<source file="UnityCsReference/Editor/Mono/Inspector/RectTransformSnapping.cs.ifdefed" startline="195" endline="215" pcid="28194">
        {
            for (int axis = 0; axis < 2; axis++)
                s_SnapGuides[axis].Clear();

            if (parentSpace == null)
                return;

            List<SnapGuide> guides;
            for (int axis = 0; axis < 2; axis++)
            {
                int handle = (axis == 0 ? xHandle : yHandle);
                if (handle == 1)
                    continue;

                guides = GetSnapGuides(parentSpace, self, parentRect, rect, axis, handle);
                foreach (SnapGuide guide in guides)
                {
                    s_SnapGuides[axis].AddGuide(guide);
                }
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/RectTransformSnapping.cs.ifdefed" startline="218" endline="238" pcid="28197">
        {
            for (int axis = 0; axis < 2; axis++)
                s_SnapGuides[axis].Clear();

            if (parentSpace == null)
                return;

            List<SnapGuide> guides;
            for (int axis = 0; axis < 2; axis++)
            {
                for (int side = 0; side < kSidesAndMiddle.Length; side++)
                {
                    guides = GetSnapGuides(parentSpace, self, parentRect, rect, axis, side);
                    foreach (SnapGuide guide in guides)
                    {
                        guide.value = GetGuideValueForRect(rect, guide.value, axis, kSidesAndMiddle[side]);
                        s_SnapGuides[axis].AddGuide(guide);
                    }
                }
            }
        }
</source>
</class>

<class classid="169" nclones="2" nlines="14" similarity="78">
<source file="UnityCsReference/Editor/Mono/Inspector/PointEffector2DEditor.cs.ifdefed" startline="32" endline="47" pcid="29191">
        {
            base.OnEnable();

            m_ShowForceRollout.value = true;
            m_ShowForceRollout.valueChanged.AddListener(Repaint);
            m_ForceMagnitude = serializedObject.FindProperty("m_ForceMagnitude");
            m_ForceVariation = serializedObject.FindProperty("m_ForceVariation");
            m_ForceSource = serializedObject.FindProperty("m_ForceSource");
            m_ForceTarget = serializedObject.FindProperty("m_ForceTarget");
            m_ForceMode = serializedObject.FindProperty("m_ForceMode");
            m_DistanceScale = serializedObject.FindProperty("m_DistanceScale");

            m_ShowDampingRollout.valueChanged.AddListener(Repaint);
            m_Drag = serializedObject.FindProperty("m_Drag");
            m_AngularDrag = serializedObject.FindProperty("m_AngularDrag");
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/AreaEffector2DEditor.cs.ifdefed" startline="31" endline="45" pcid="30038">
        {
            base.OnEnable();

            m_ShowForceRollout.value = true;
            m_ShowForceRollout.valueChanged.AddListener(Repaint);
            m_UseGlobalAngle = serializedObject.FindProperty("m_UseGlobalAngle");
            m_ForceAngle = serializedObject.FindProperty("m_ForceAngle");
            m_ForceMagnitude = serializedObject.FindProperty("m_ForceMagnitude");
            m_ForceVariation = serializedObject.FindProperty("m_ForceVariation");
            m_ForceTarget = serializedObject.FindProperty("m_ForceTarget");

            m_ShowDampingRollout.valueChanged.AddListener(Repaint);
            m_Drag = serializedObject.FindProperty("m_Drag");
            m_AngularDrag = serializedObject.FindProperty("m_AngularDrag");
        }
</source>
</class>

<class classid="170" nclones="2" nlines="22" similarity="86">
<source file="UnityCsReference/Editor/Mono/Inspector/PointEffector2DEditor.cs.ifdefed" startline="58" endline="87" pcid="29193">
        {
            base.OnInspectorGUI();

            serializedObject.Update();

            // Force.
            m_ShowForceRollout.target = EditorGUILayout.Foldout(m_ShowForceRollout.target, "Force", true);
            if (EditorGUILayout.BeginFadeGroup(m_ShowForceRollout.faded))
            {
                EditorGUILayout.PropertyField(m_ForceMagnitude);
                EditorGUILayout.PropertyField(m_ForceVariation);
                EditorGUILayout.PropertyField(m_DistanceScale);
                EditorGUILayout.PropertyField(m_ForceSource);
                EditorGUILayout.PropertyField(m_ForceTarget);
                EditorGUILayout.PropertyField(m_ForceMode);
                EditorGUILayout.Space();
            }
            EditorGUILayout.EndFadeGroup();

            // Drag.
            m_ShowDampingRollout.target = EditorGUILayout.Foldout(m_ShowDampingRollout.target, "Damping", true);
            if (EditorGUILayout.BeginFadeGroup(m_ShowDampingRollout.faded))
            {
                EditorGUILayout.PropertyField(m_Drag);
                EditorGUILayout.PropertyField(m_AngularDrag);
            }
            EditorGUILayout.EndFadeGroup();

            serializedObject.ApplyModifiedProperties();
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/AreaEffector2DEditor.cs.ifdefed" startline="56" endline="84" pcid="30040">
        {
            base.OnInspectorGUI();

            serializedObject.Update();

            // Force.
            m_ShowForceRollout.target = EditorGUILayout.Foldout(m_ShowForceRollout.target, "Force", true);
            if (EditorGUILayout.BeginFadeGroup(m_ShowForceRollout.faded))
            {
                EditorGUILayout.PropertyField(m_UseGlobalAngle);
                EditorGUILayout.PropertyField(m_ForceAngle);
                EditorGUILayout.PropertyField(m_ForceMagnitude);
                EditorGUILayout.PropertyField(m_ForceVariation);
                EditorGUILayout.PropertyField(m_ForceTarget);
                EditorGUILayout.Space();
            }
            EditorGUILayout.EndFadeGroup();

            // Drag.
            m_ShowDampingRollout.target = EditorGUILayout.Foldout(m_ShowDampingRollout.target, "Damping", true);
            if (EditorGUILayout.BeginFadeGroup(m_ShowDampingRollout.faded))
            {
                EditorGUILayout.PropertyField(m_Drag);
                EditorGUILayout.PropertyField(m_AngularDrag);
            }
            EditorGUILayout.EndFadeGroup();

            serializedObject.ApplyModifiedProperties();
        }
</source>
</class>

<class classid="171" nclones="2" nlines="10" similarity="70">
<source file="UnityCsReference/Editor/Mono/Inspector/ClothInspector.cs.ifdefed" startline="1377" endline="1388" pcid="29767">
            {
                switch (state.ToolMode)
                {
                    case ToolMode.Select:
                        SelectionPreSceneGUI(id);
                        break;

                    case ToolMode.Paint:
                        PaintPreSceneGUI(id);
                        break;
                }
            }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/ClothInspector.cs.ifdefed" startline="1391" endline="1403" pcid="29768">
            {
                switch (state.CollToolMode)
                {
                    case CollToolMode.Select:
                        SelectionPreSceneGUI(id);
                        break;

                    case CollToolMode.Paint:
                    case CollToolMode.Erase:
                        PaintPreSceneGUI(id);
                        break;
                }
            }
</source>
</class>

<class classid="172" nclones="2" nlines="13" similarity="71">
<source file="UnityCsReference/Editor/Mono/Inspector/ScriptExecutionOrderInspector.cs.ifdefed" startline="690" endline="706" pcid="30010">
                {
                    for (int i = 0; i < elements.Count; i++)
                    {
                        // Don't draw the dragged element as part of loop
                        if (i == s_ReorderingDraggedElement)
                            continue;
                        if (IsDefaultTimeElement(elements[i]))
                        {
                            defPos = i;
                            i++;
                            continue;
                        }
                        elementRect.y = position.y + s_ReorderingPositions[i] * elementHeight;
                        drawElementDelegate(elementRect, elements[i], false);
                    }
                    defRect = new Rect(elementRect.x, position.y + s_ReorderingPositions[defPos] * elementHeight, elementRect.width, (s_ReorderingPositions[defPos + 1] - s_ReorderingPositions[defPos] + 1) * elementHeight);
                }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/ScriptExecutionOrderInspector.cs.ifdefed" startline="710" endline="723" pcid="30013">
                {
                    for (int i = 0; i < elements.Count; i++)
                    {
                        elementRect.y = position.y + i * elementHeight;
                        if (IsDefaultTimeElement(elements[i]))
                        {
                            defPos = i;
                            i++;
                            continue;
                        }
                        drawElementDelegate(elementRect, elements[i], false);
                    }
                    defRect = new Rect(elementRect.x, position.y + defPos * elementHeight, elementRect.width, elementHeight * 2);
                }
</source>
</class>

<class classid="173" nclones="2" nlines="16" similarity="75">
<source file="UnityCsReference/Editor/Mono/Inspector/MaterialPropertyDrawer.cs.ifdefed" startline="284" endline="304" pcid="30178">
        {
            if (!IsPropertyTypeSuitable(prop))
            {
                GUIContent c = EditorGUIUtility.TempContent("Toggle used on a non-float property: " + prop.name,
                        EditorGUIUtility.GetHelpIcon(MessageType.Warning));
                EditorGUI.LabelField(position, c, EditorStyles.helpBox);
                return;
            }

            EditorGUI.BeginChangeCheck();

            bool value = (Math.Abs(prop.floatValue) > 0.001f);
            EditorGUI.showMixedValue = prop.hasMixedValue;
            value = EditorGUI.Toggle(position, label, value);
            EditorGUI.showMixedValue = false;
            if (EditorGUI.EndChangeCheck())
            {
                prop.floatValue = value ? 1.0f : 0.0f;
                SetKeyword(prop, value);
            }
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/MaterialPropertyDrawer.cs.ifdefed" startline="468" endline="488" pcid="30213">
        {
            if (!IsPropertyTypeSuitable(prop))
            {
                GUIContent c = EditorGUIUtility.TempContent("KeywordEnum used on a non-float property: " + prop.name,
                        EditorGUIUtility.GetHelpIcon(MessageType.Warning));
                EditorGUI.LabelField(position, c, EditorStyles.helpBox);
                return;
            }

            EditorGUI.BeginChangeCheck();

            EditorGUI.showMixedValue = prop.hasMixedValue;
            var value = (int)prop.floatValue;
            value = EditorGUI.Popup(position, label, value, keywords);
            EditorGUI.showMixedValue = false;
            if (EditorGUI.EndChangeCheck())
            {
                prop.floatValue = value;
                SetKeyword(prop, value);
            }
        }
</source>
</class>

<class classid="174" nclones="2" nlines="18" similarity="77">
<source file="UnityCsReference/Editor/Mono/Inspector/AudioReverbZoneEditor.cs.ifdefed" startline="33" endline="50" pcid="30675">
        {
            m_MinDistance = serializedObject.FindProperty("m_MinDistance");
            m_MaxDistance = serializedObject.FindProperty("m_MaxDistance");
            m_ReverbPreset = serializedObject.FindProperty("m_ReverbPreset");
            m_Room = serializedObject.FindProperty("m_Room"); // room effect level (at mid frequencies)
            m_RoomHF = serializedObject.FindProperty("m_RoomHF"); // relative room effect level at high frequencies
            m_RoomLF = serializedObject.FindProperty("m_RoomLF"); // relative room effect level at low frequencies
            m_DecayTime = serializedObject.FindProperty("m_DecayTime"); // reverberation decay time at mid frequencies
            m_DecayHFRatio = serializedObject.FindProperty("m_DecayHFRatio"); //  high-frequency to mid-frequency decay time ratio
            m_Reflections = serializedObject.FindProperty("m_Reflections"); // early reflections level relative to room effect
            m_ReflectionsDelay = serializedObject.FindProperty("m_ReflectionsDelay"); //  initial reflection delay time
            m_Reverb = serializedObject.FindProperty("m_Reverb"); //  late reverberation level relative to room effect
            m_ReverbDelay = serializedObject.FindProperty("m_ReverbDelay"); //  late reverberation delay time relative to initial reflection
            m_HFReference = serializedObject.FindProperty("m_HFReference"); // reference high frequency (hz)
            m_LFReference = serializedObject.FindProperty("m_LFReference"); // reference low frequency (hz)
            m_Diffusion = serializedObject.FindProperty("m_Diffusion"); //  Value that controls the echo density in the late reverberation decay
            m_Density = serializedObject.FindProperty("m_Density"); // Value that controls the modal density in the late reverberation decay
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/AudioReverbFilterEditor.cs.ifdefed" startline="33" endline="49" pcid="30723">
        {
            m_ReverbPreset = serializedObject.FindProperty("m_ReverbPreset");
            m_DryLevel = serializedObject.FindProperty("m_DryLevel"); // room effect level (at mid frequencies)
            m_Room = serializedObject.FindProperty("m_Room"); // room effect level (at mid frequencies)
            m_RoomHF = serializedObject.FindProperty("m_RoomHF"); // relative room effect level at high frequencies
            m_RoomLF = serializedObject.FindProperty("m_RoomLF"); // relative room effect level at low frequencies
            m_DecayTime = serializedObject.FindProperty("m_DecayTime"); // reverberation decay time at mid frequencies
            m_DecayHFRatio = serializedObject.FindProperty("m_DecayHFRatio"); //  high-frequency to mid-frequency decay time ratio
            m_ReflectionsLevel = serializedObject.FindProperty("m_ReflectionsLevel"); // early reflections level relative to room effect
            m_ReflectionsDelay = serializedObject.FindProperty("m_ReflectionsDelay"); //  initial reflection delay time
            m_ReverbLevel = serializedObject.FindProperty("m_ReverbLevel"); //  late reverberation level relative to room effect
            m_ReverbDelay = serializedObject.FindProperty("m_ReverbDelay"); //  late reverberation delay time relative to initial reflection
            m_HFReference = serializedObject.FindProperty("m_HFReference"); // reference high frequency (hz)
            m_LFReference = serializedObject.FindProperty("m_LFReference"); // reference low frequency (hz)
            m_Diffusion = serializedObject.FindProperty("m_Diffusion"); //  Value that controls the echo density in the late reverberation decay
            m_Density = serializedObject.FindProperty("m_Density"); // Value that controls the modal density in the late reverberation decay
        }
</source>
</class>

<class classid="175" nclones="2" nlines="26" similarity="70">
<source file="UnityCsReference/Editor/Mono/Inspector/AudioReverbZoneEditor.cs.ifdefed" startline="53" endline="84" pcid="30676">
        {
            serializedObject.Update();

            EditorGUILayout.PropertyField(m_MinDistance);
            EditorGUILayout.PropertyField(m_MaxDistance);

            EditorGUILayout.Space();
            EditorGUI.BeginChangeCheck();
            EditorGUILayout.PropertyField(m_ReverbPreset);
            // Changing the preset changes all the other properties as well, so we need to do a full refresh afterwards
            if (EditorGUI.EndChangeCheck())
                serializedObject.SetIsDifferentCacheDirty();

            using (new EditorGUI.DisabledScope(m_ReverbPreset.enumValueIndex != 27 || m_ReverbPreset.hasMultipleDifferentValues))
            {
                EditorGUILayout.IntSlider(m_Room, -10000, 0);
                EditorGUILayout.IntSlider(m_RoomHF, -10000, 0);
                EditorGUILayout.IntSlider(m_RoomLF, -10000, 0);
                EditorGUILayout.Slider(m_DecayTime, 0.1f, 20.0f);
                EditorGUILayout.Slider(m_DecayHFRatio, 0.1f, 2.0f);
                EditorGUILayout.IntSlider(m_Reflections, -10000, 1000);
                EditorGUILayout.Slider(m_ReflectionsDelay, 0.0f, 0.3f);
                EditorGUILayout.IntSlider(m_Reverb, -10000, 2000);
                EditorGUILayout.Slider(m_ReverbDelay, 0.0f, 0.1f);
                EditorGUILayout.Slider(m_HFReference, 1000.0f, 20000.0f);
                EditorGUILayout.Slider(m_LFReference, 20.0f, 1000.0f);
                EditorGUILayout.Slider(m_Diffusion, 0.0f, 100.0f);
                EditorGUILayout.Slider(m_Density, 0.0f, 100.0f);
            }

            serializedObject.ApplyModifiedProperties();
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/AudioReverbFilterEditor.cs.ifdefed" startline="52" endline="79" pcid="30724">
        {
            serializedObject.Update();

            EditorGUI.BeginChangeCheck();
            EditorGUILayout.PropertyField(m_ReverbPreset);
            if (EditorGUI.EndChangeCheck())
                serializedObject.SetIsDifferentCacheDirty();

            using (new EditorGUI.DisabledScope(m_ReverbPreset.enumValueIndex != 27 || m_ReverbPreset.hasMultipleDifferentValues))
            {
                EditorGUILayout.Slider(m_DryLevel, -10000, 0);
                EditorGUILayout.Slider(m_Room, -10000, 0);
                EditorGUILayout.Slider(m_RoomHF, -10000, 0);
                EditorGUILayout.Slider(m_RoomLF, -10000, 0);
                EditorGUILayout.Slider(m_DecayTime, 0.1f, 20.0f);
                EditorGUILayout.Slider(m_DecayHFRatio, 0.1f, 2.0f);
                EditorGUILayout.Slider(m_ReflectionsLevel, -10000, 1000);
                EditorGUILayout.Slider(m_ReflectionsDelay, 0.0f, 0.3f);
                EditorGUILayout.Slider(m_ReverbLevel, -10000, 2000);
                EditorGUILayout.Slider(m_ReverbDelay, 0.0f, 0.1f);
                EditorGUILayout.Slider(m_HFReference, 1000.0f, 20000.0f);
                EditorGUILayout.Slider(m_LFReference, 20.0f, 1000.0f);
                EditorGUILayout.Slider(m_Diffusion, 0.0f, 100.0f);
                EditorGUILayout.Slider(m_Density, 0.0f, 100.0f);
            }

            serializedObject.ApplyModifiedProperties();
        }
</source>
</class>

<class classid="176" nclones="2" nlines="21" similarity="76">
<source file="UnityCsReference/Editor/Mono/Inspector/ShaderInspector.cs.ifdefed" startline="301" endline="332" pcid="30751">
        {
            var hasSurface = ShaderUtil.HasSurfaceShaders(s);
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.PrefixLabel("Surface shader", EditorStyles.miniButton);
            if (hasSurface)
            {
                // check if this is a built-in shader (has no importer);
                // we can't show generated code in that case
                var builtinShader = (AssetImporter.GetAtPath(AssetDatabase.GetAssetPath(s)) == null);
                if (!builtinShader)
                {
                    if (GUILayout.Button(Styles.showSurface, EditorStyles.miniButton, GUILayout.ExpandWidth(false)))
                    {
                        ShaderUtil.OpenParsedSurfaceShader(s);
                        GUIUtility.ExitGUI();
                    }
                }
                else
                {
                    // See comment below why this is a button.
                    GUILayout.Button(Styles.builtinShader, GUI.skin.label);
                }
            }
            else
            {
                // Note: PrefixLabel is sometimes buggy if followed by a non-control (like Label).
                // We just want to show a label here, but have to pretend it's a button so it is treated like
                // a control.
                GUILayout.Button(Styles.no, GUI.skin.label);
            }
            EditorGUILayout.EndHorizontal();
        }
</source>
<source file="UnityCsReference/Editor/Mono/Inspector/ShaderInspector.cs.ifdefed" startline="336" endline="367" pcid="30757">
        {
            var hasFF = ShaderUtil.HasFixedFunctionShaders(s);
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.PrefixLabel("Fixed function", EditorStyles.miniButton);
            if (hasFF)
            {
                // check if this is a built-in shader (has no importer);
                // we can't show generated code in that case
                var builtinShader = (AssetImporter.GetAtPath(AssetDatabase.GetAssetPath(s)) == null);
                if (!builtinShader)
                {
                    if (GUILayout.Button(Styles.showFF, EditorStyles.miniButton, GUILayout.ExpandWidth(false)))
                    {
                        ShaderUtil.OpenGeneratedFixedFunctionShader(s);
                        GUIUtility.ExitGUI();
                    }
                }
                else
                {
                    // See comment below why this is a button.
                    GUILayout.Button(Styles.builtinShader, GUI.skin.label);
                }
            }
            else
            {
                // Note: PrefixLabel is sometimes buggy if followed by a non-control (like Label).
                // We just want to show a label here, but have to pretend it's a button so it is treated like
                // a control.
                GUILayout.Button(Styles.no, GUI.skin.label);
            }
            EditorGUILayout.EndHorizontal();
        }
</source>
</class>

<class classid="177" nclones="3" nlines="10" similarity="80">
<source file="UnityCsReference/artifacts/generated/bindings_old/common/Core/RenderingCommandBufferBindings.gen.cs.ifdefed" startline="723" endline="732" pcid="31574">
    public void GetTemporaryRT (int nameID, int width, int height, int depthBuffer ) {
        bool useDynamicScale = false;
        RenderTextureMemoryless memorylessMode = RenderTextureMemoryless.None;
        bool enableRandomWrite = false;
        int antiAliasing = 1;
        RenderTextureReadWrite readWrite = RenderTextureReadWrite.Default;
        RenderTextureFormat format = RenderTextureFormat.Default;
        FilterMode filter = FilterMode.Point;
        GetTemporaryRT ( nameID, width, height, depthBuffer, filter, format, readWrite, antiAliasing, enableRandomWrite, memorylessMode, useDynamicScale );
    }
</source>
<source file="UnityCsReference/artifacts/generated/bindings_old/common/Core/RenderingCommandBufferBindings.gen.cs.ifdefed" startline="735" endline="745" pcid="31575">
    public void GetTemporaryRT (int nameID, int width, int height) {
        bool useDynamicScale = false;
        RenderTextureMemoryless memorylessMode = RenderTextureMemoryless.None;
        bool enableRandomWrite = false;
        int antiAliasing = 1;
        RenderTextureReadWrite readWrite = RenderTextureReadWrite.Default;
        RenderTextureFormat format = RenderTextureFormat.Default;
        FilterMode filter = FilterMode.Point;
        int depthBuffer = 0;
        GetTemporaryRT ( nameID, width, height, depthBuffer, filter, format, readWrite, antiAliasing, enableRandomWrite, memorylessMode, useDynamicScale );
    }
</source>
<source file="UnityCsReference/artifacts/generated/bindings_old/common/Core/RenderingCommandBufferBindings.gen.cs.ifdefed" startline="816" endline="825" pcid="31584">
    public void GetTemporaryRTArray (int nameID, int width, int height, int slices) {
        bool useDynamicScale = false;
        bool enableRandomWrite = false;
        int antiAliasing = 1;
        RenderTextureReadWrite readWrite = RenderTextureReadWrite.Default;
        RenderTextureFormat format = RenderTextureFormat.Default;
        FilterMode filter = FilterMode.Point;
        int depthBuffer = 0;
        GetTemporaryRTArray ( nameID, width, height, slices, depthBuffer, filter, format, readWrite, antiAliasing, enableRandomWrite, useDynamicScale );
    }
</source>
</class>

<class classid="178" nclones="2" nlines="12" similarity="76">
<source file="UnityCsReference/Modules/BuildPipeline/Editor/Managed/ContentBuildInterface.bindings.cs.ifdefed" startline="118" endline="128" pcid="33328">
        {
            if (IsBuildInProgress())
                throw new InvalidOperationException("Cannot call WriteSerializedFile while a build is in progress");
            if (string.IsNullOrEmpty(outputFolder))
                throw new ArgumentException("String is null or empty.", "outputFolder");
            if (writeCommand == null)
                throw new ArgumentNullException("writeCommand");
            if (referenceMap == null)
                throw new ArgumentNullException("referenceMap");
            return WriteSerializedFileRaw(outputFolder, writeCommand, settings, globalUsage, usageSet, referenceMap);
        }
</source>
<source file="UnityCsReference/Modules/BuildPipeline/Editor/Managed/ContentBuildInterface.bindings.cs.ifdefed" startline="131" endline="143" pcid="33329">
        {
            if (IsBuildInProgress())
                throw new InvalidOperationException("Cannot call WriteSerializedFile while a build is in progress");
            if (string.IsNullOrEmpty(outputFolder))
                throw new ArgumentException("String is null or empty.", "outputFolder");
            if (writeCommand == null)
                throw new ArgumentNullException("writeCommand");
            if (referenceMap == null)
                throw new ArgumentNullException("referenceMap");
            if (bundleInfo == null)
                throw new ArgumentNullException("bundleInfo");
            return WriteSerializedFileAssetBundle(outputFolder, writeCommand, settings, globalUsage, usageSet, referenceMap, bundleInfo);
        }
</source>
</class>

<class classid="179" nclones="3" nlines="18" similarity="76">
<source file="UnityCsReference/Modules/BuildPipeline/Editor/Managed/ContentBuildInterface.bindings.cs.ifdefed" startline="152" endline="168" pcid="33330">
        {
            if (IsBuildInProgress())
                throw new InvalidOperationException("Cannot call WriteSceneSerializedFile while a build is in progress");
            if (string.IsNullOrEmpty(outputFolder))
                throw new ArgumentException("String is null or empty.", "outputFolder");
            if (string.IsNullOrEmpty(scenePath))
                throw new ArgumentException("String is null or empty.", "scenePath");
            if (string.IsNullOrEmpty(processedScene))
                throw new ArgumentException("String is null or empty.", "processedScene");
            if (!File.Exists(processedScene))
                throw new ArgumentException(string.Format("File '{0}' does not exist.", processedScene), "processedScene");
            if (writeCommand == null)
                throw new ArgumentNullException("writeCommand");
            if (referenceMap == null)
                throw new ArgumentNullException("referenceMap");
            return WriteSceneSerializedFileRaw(outputFolder, scenePath, processedScene, writeCommand, settings, globalUsage, usageSet, referenceMap);
        }
</source>
<source file="UnityCsReference/Modules/BuildPipeline/Editor/Managed/ContentBuildInterface.bindings.cs.ifdefed" startline="192" endline="212" pcid="33332">
        {
            if (IsBuildInProgress())
                throw new InvalidOperationException("Cannot call WriteSceneSerializedFile while a build is in progress");
            if (string.IsNullOrEmpty(outputFolder))
                throw new ArgumentException("String is null or empty.", "outputFolder");
            if (string.IsNullOrEmpty(scenePath))
                throw new ArgumentException("String is null or empty.", "scenePath");
            if (string.IsNullOrEmpty(processedScene))
                throw new ArgumentException("String is null or empty.", "processedScene");
            if (!File.Exists(processedScene))
                throw new ArgumentException(string.Format("File '{0}' does not exist.", processedScene), "processedScene");
            if (writeCommand == null)
                throw new ArgumentNullException("writeCommand");
            if (referenceMap == null)
                throw new ArgumentNullException("referenceMap");
            if (preloadInfo == null)
                throw new ArgumentNullException("preloadInfo");
            if (sceneBundleInfo == null)
                throw new ArgumentNullException("sceneBundleInfo");
            return WriteSceneSerializedFileAssetBundle(outputFolder, scenePath, processedScene, writeCommand, settings, globalUsage, usageSet, referenceMap, preloadInfo, sceneBundleInfo);
        }
</source>
<source file="UnityCsReference/Modules/BuildPipeline/Editor/Managed/ContentBuildInterface.bindings.cs.ifdefed" startline="171" endline="189" pcid="33331">
        {
            if (IsBuildInProgress())
                throw new InvalidOperationException("Cannot call WriteSceneSerializedFile while a build is in progress");
            if (string.IsNullOrEmpty(outputFolder))
                throw new ArgumentException("String is null or empty.", "outputFolder");
            if (string.IsNullOrEmpty(scenePath))
                throw new ArgumentException("String is null or empty.", "scenePath");
            if (string.IsNullOrEmpty(processedScene))
                throw new ArgumentException("String is null or empty.", "processedScene");
            if (!File.Exists(processedScene))
                throw new ArgumentException(string.Format("File '{0}' does not exist.", processedScene), "processedScene");
            if (writeCommand == null)
                throw new ArgumentNullException("writeCommand");
            if (referenceMap == null)
                throw new ArgumentNullException("referenceMap");
            if (preloadInfo == null)
                throw new ArgumentNullException("preloadInfo");
            return WriteSceneSerializedFilePlayerData(outputFolder, scenePath, processedScene, writeCommand, settings, globalUsage, usageSet, referenceMap, preloadInfo);
        }
</source>
</class>

<class classid="180" nclones="2" nlines="16" similarity="100">
<source file="UnityCsReference/Modules/GraphViewEditor/Manipulators/Dragger.cs.ifdefed" startline="30" endline="51" pcid="33530">
        {
            var rect = new Rect(x, y, width, height);

            if (clampToParentEdges)
            {
                if (rect.x < target.parent.layout.xMin)
                    rect.x = target.parent.layout.xMin;
                else if (rect.xMax > target.parent.layout.xMax)
                    rect.x = target.parent.layout.xMax - rect.width;

                if (rect.y < target.parent.layout.yMin)
                    rect.y = target.parent.layout.yMin;
                else if (rect.yMax > target.parent.layout.yMax)
                    rect.y = target.parent.layout.yMax - rect.height;

                // Reset size, we never intended to change them in the first place
                rect.width = width;
                rect.height = height;
            }

            return rect;
        }
</source>
<source file="UnityCsReference/Modules/GraphViewEditor/Manipulators/ContentDragger.cs.ifdefed" startline="32" endline="53" pcid="33651">
        {
            var rect = new Rect(x, y, width, height);

            if (clampToParentEdges)
            {
                if (rect.x < target.parent.layout.xMin)
                    rect.x = target.parent.layout.xMin;
                else if (rect.xMax > target.parent.layout.xMax)
                    rect.x = target.parent.layout.xMax - rect.width;

                if (rect.y < target.parent.layout.yMin)
                    rect.y = target.parent.layout.yMin;
                else if (rect.yMax > target.parent.layout.yMax)
                    rect.y = target.parent.layout.yMax - rect.height;

                // Reset size, we never intended to change them in the first place
                rect.width = width;
                rect.height = height;
            }

            return rect;
        }
</source>
</class>

<class classid="181" nclones="2" nlines="12" similarity="75">
<source file="UnityCsReference/Modules/GraphViewEditor/Views/GraphView.cs.ifdefed" startline="520" endline="534" pcid="33711">
        {
            var graphElement = selectable as GraphElement;
            if (graphElement == null)
                return;

            AddToSelectionNoUndoRecord(graphElement);

            if (ShouldRecordUndo())
            {
                RecordSelectionUndoPre();
                m_GraphViewUndoRedoSelection.selectedElements.Add(graphElement.persistenceKey);
                m_PersistedSelection.selectedElements.Add(graphElement.persistenceKey);
                RecordSelectionUndoPost();
            }
        }
</source>
<source file="UnityCsReference/Modules/GraphViewEditor/Views/GraphView.cs.ifdefed" startline="562" endline="576" pcid="33715">
        {
            var graphElement = selectable as GraphElement;
            if (graphElement == null)
                return;

            RemoveFromSelectionNoUndoRecord(selectable);

            if (ShouldRecordUndo())
            {
                RecordSelectionUndoPre();
                m_GraphViewUndoRedoSelection.selectedElements.Remove(graphElement.persistenceKey);
                m_PersistedSelection.selectedElements.Remove(graphElement.persistenceKey);
                RecordSelectionUndoPost();
            }
        }
</source>
</class>

<class classid="182" nclones="4" nlines="12" similarity="91">
<source file="UnityCsReference/Modules/AssetBundle/Managed/AssetBundle.bindings.cs.ifdefed" startline="206" endline="221" pcid="34308">
        {
            if (name == null)
            {
                throw new System.NullReferenceException("The input asset name cannot be null.");
            }
            if (name.Length == 0)
            {
                throw new System.ArgumentException("The input asset name cannot be empty.");
            }
            if (type == null)
            {
                throw new System.NullReferenceException("The input type cannot be null.");
            }

            return LoadAsset_Internal(name, type);
        }
</source>
<source file="UnityCsReference/Modules/AssetBundle/Managed/AssetBundle.bindings.cs.ifdefed" startline="304" endline="319" pcid="34327">
        {
            if (name == null)
            {
                throw new System.NullReferenceException("The input asset name cannot be null.");
            }
            if (name.Length == 0)
            {
                throw new System.ArgumentException("The input asset name cannot be empty.");
            }
            if (type == null)
            {
                throw new System.NullReferenceException("The input type cannot be null.");
            }

            return LoadAssetWithSubAssetsAsync_Internal(name, type);
        }
</source>
<source file="UnityCsReference/Modules/AssetBundle/Managed/AssetBundle.bindings.cs.ifdefed" startline="239" endline="254" pcid="34314">
        {
            if (name == null)
            {
                throw new System.NullReferenceException("The input asset name cannot be null.");
            }
            if (name.Length == 0)
            {
                throw new System.ArgumentException("The input asset name cannot be empty.");
            }
            if (type == null)
            {
                throw new System.NullReferenceException("The input type cannot be null.");
            }

            return LoadAssetAsync_Internal(name, type);
        }
</source>
<source file="UnityCsReference/Modules/AssetBundle/Managed/AssetBundle.bindings.cs.ifdefed" startline="276" endline="291" pcid="34321">
        {
            if (name == null)
            {
                throw new System.NullReferenceException("The input asset name cannot be null.");
            }
            if (name.Length == 0)
            {
                throw new System.ArgumentException("The input asset name cannot be empty.");
            }
            if (type == null)
            {
                throw new System.NullReferenceException("The input type cannot be null.");
            }

            return LoadAssetWithSubAssets_Internal(name, type);
        }
</source>
</class>

<class classid="183" nclones="2" nlines="10" similarity="70">
<source file="UnityCsReference/Modules/TilemapEditor/Editor/Managed/Grid/GridBrushEditor.cs.ifdefed" startline="164" endline="174" pcid="34601">
                {
                    EditorGUI.showMixedValue = m_SelectionColors.Any(color => color != m_SelectionColors.First());
                    EditorGUI.BeginChangeCheck();
                    Color newColor = EditorGUILayout.ColorField(Styles.colorLabel, m_SelectionColors[0]);
                    if (EditorGUI.EndChangeCheck())
                    {
                        Undo.RecordObject(tilemap, "Edit Tilemap");
                        foreach (var p in selection.allPositionsWithin)
                            tilemap.SetColor(p, newColor);
                    }
                }
</source>
<source file="UnityCsReference/Modules/TilemapEditor/Editor/Managed/Grid/GridBrushEditor.cs.ifdefed" startline="178" endline="188" pcid="34603">
                {
                    EditorGUI.showMixedValue = m_SelectionMatrices.Any(matrix => matrix != m_SelectionMatrices.First());
                    EditorGUI.BeginChangeCheck();
                    Matrix4x4 newTransformMatrix = TileEditor.TransformMatrixOnGUI(m_SelectionMatrices[0]);
                    if (EditorGUI.EndChangeCheck())
                    {
                        Undo.RecordObject(tilemap, "Edit Tilemap");
                        foreach (var p in selection.allPositionsWithin)
                            tilemap.SetTransformMatrix(p, newTransformMatrix);
                    }
                }
</source>
</class>

<class classid="184" nclones="2" nlines="17" similarity="70">
<source file="UnityCsReference/Modules/TilemapEditor/Editor/Managed/Grid/GridBrush.cs.ifdefed" startline="286" endline="306" pcid="34972">
        {
            BrushCell[] oldCells = m_Cells.Clone() as BrushCell[];
            BoundsInt oldBounds = new BoundsInt(Vector3Int.zero, m_Size);

            foreach (Vector3Int oldPos in oldBounds.allPositionsWithin)
            {
                int newX = m_Size.x - oldPos.x - 1;
                int toIndex = GetCellIndex(newX, oldPos.y, oldPos.z);
                int fromIndex = GetCellIndex(oldPos);
                m_Cells[toIndex] = oldCells[fromIndex];
            }

            int newPivotX = m_Size.x - pivot.x - 1;
            pivot = new Vector3Int(newPivotX, pivot.y, pivot.z);
            Matrix4x4 flip = Matrix4x4.TRS(Vector3.zero, Quaternion.identity, new Vector3(-1f, 1f, 1f));
            foreach (BrushCell cell in m_Cells)
            {
                Matrix4x4 oldMatrix = cell.matrix;
                cell.matrix = oldMatrix * flip;
            }
        }
</source>
<source file="UnityCsReference/Modules/TilemapEditor/Editor/Managed/Grid/GridBrush.cs.ifdefed" startline="309" endline="329" pcid="34975">
        {
            BrushCell[] oldCells = m_Cells.Clone() as BrushCell[];
            BoundsInt oldBounds = new BoundsInt(Vector3Int.zero, m_Size);

            foreach (Vector3Int oldPos in oldBounds.allPositionsWithin)
            {
                int newY = m_Size.y - oldPos.y - 1;
                int toIndex = GetCellIndex(oldPos.x, newY, oldPos.z);
                int fromIndex = GetCellIndex(oldPos);
                m_Cells[toIndex] = oldCells[fromIndex];
            }

            int newPivotY = m_Size.y - pivot.y - 1;
            pivot = new Vector3Int(pivot.x, newPivotY, pivot.z);
            Matrix4x4 flip = Matrix4x4.TRS(Vector3.zero, Quaternion.identity, new Vector3(1f, -1f, 1f));
            foreach (BrushCell cell in m_Cells)
            {
                Matrix4x4 oldMatrix = cell.matrix;
                cell.matrix = oldMatrix * flip;
            }
        }
</source>
</class>

<class classid="185" nclones="2" nlines="14" similarity="73">
<source file="UnityCsReference/Modules/GridEditor/Managed/GridEditorUtility.cs.ifdefed" startline="146" endline="158" pcid="35226">
        {
            if (Event.current.type != EventType.Repaint)
                return;

            HandleUtility.ApplyWireMaterial();
            GL.PushMatrix();
            GL.MultMatrix(GUI.matrix);
            GL.Begin(GL.LINES);
            GL.Color(color);
            DrawBatchedLine(p1, p2);
            GL.End();
            GL.PopMatrix();
        }
</source>
<source file="UnityCsReference/Modules/GridEditor/Managed/GridEditorUtility.cs.ifdefed" startline="161" endline="176" pcid="35227">
        {
            if (Event.current.type != EventType.Repaint)
                return;

            HandleUtility.ApplyWireMaterial();
            GL.PushMatrix();
            GL.MultMatrix(GUI.matrix);
            GL.Begin(GL.LINES);
            GL.Color(color);
            DrawBatchedLine(new Vector3(r.xMin, r.yMin, 0f), new Vector3(r.xMax, r.yMin, 0f));
            DrawBatchedLine(new Vector3(r.xMax, r.yMin, 0f), new Vector3(r.xMax, r.yMax, 0f));
            DrawBatchedLine(new Vector3(r.xMax, r.yMax, 0f), new Vector3(r.xMin, r.yMax, 0f));
            DrawBatchedLine(new Vector3(r.xMin, r.yMax, 0f), new Vector3(r.xMin, r.yMin, 0f));
            GL.End();
            GL.PopMatrix();
        }
</source>
</class>

<class classid="186" nclones="2" nlines="11" similarity="90">
<source file="UnityCsReference/Modules/IMGUI/StylePainter.cs.ifdefed" startline="277" endline="288" pcid="35689">
        {
            string text = painterParams.text;
            float wordWrapWidth = painterParams.wordWrapWidth;
            bool wordWrap = painterParams.wordWrap;
            Font font = painterParams.font;
            int fontSize = painterParams.fontSize;
            FontStyle fontStyle = painterParams.fontStyle;
            TextAnchor anchor = painterParams.anchor;
            bool richText = painterParams.richText;

            return ComputeTextWidth(text, wordWrapWidth, wordWrap, font, fontSize, fontStyle, anchor, richText);
        }
</source>
<source file="UnityCsReference/Modules/IMGUI/StylePainter.cs.ifdefed" startline="291" endline="302" pcid="35690">
        {
            string text = painterParams.text;
            float wordWrapWidth = painterParams.wordWrapWidth;
            bool wordWrap = painterParams.wordWrap;
            Font font = painterParams.font;
            int fontSize = painterParams.fontSize;
            FontStyle fontStyle = painterParams.fontStyle;
            TextAnchor anchor = painterParams.anchor;
            bool richText = painterParams.richText;

            return ComputeTextHeight(text, wordWrapWidth, wordWrap, font, fontSize, fontStyle, anchor, richText);
        }
</source>
</class>

<class classid="187" nclones="2" nlines="12" similarity="75">
<source file="UnityCsReference/Modules/IMGUI/TextEditor.cs.ifdefed" startline="215" endline="229" pcid="35836">
        {
            if (hasSelection)
            {
                DeleteSelection();
                return true;
            }

            int nextWordStart = FindStartOfNextWord(cursorIndex);
            if (cursorIndex < text.Length)
            {
                m_Content.text = text.Remove(cursorIndex, nextWordStart - cursorIndex);
                return true;
            }
            return false;
        }
</source>
<source file="UnityCsReference/Modules/IMGUI/TextEditor.cs.ifdefed" startline="233" endline="245" pcid="35839">
        {
            if (hasSelection)
            {
                DeleteSelection();
                return true;
            }
            else if (cursorIndex < text.Length)
            {
                m_Content.text = text.Remove(cursorIndex, NextCodePointIndex(cursorIndex) - cursorIndex);
                return true;
            }
            return false;
        }
</source>
</class>

<class classid="188" nclones="2" nlines="11" similarity="72">
<source file="UnityCsReference/Modules/IMGUI/TextEditor.cs.ifdefed" startline="397" endline="407" pcid="35863">
        {
            if (selectIndex < cursorIndex)
                selectIndex = cursorIndex;
            else
                cursorIndex = selectIndex;
            GrabGraphicalCursorPos();
            graphicalCursorPos.y -=  1;
            cursorIndex = selectIndex = style.GetCursorStringIndex(localPosition, m_Content, graphicalCursorPos);
            if (cursorIndex <= 0)
                ClearCursorPos();
        }
</source>
<source file="UnityCsReference/Modules/IMGUI/TextEditor.cs.ifdefed" startline="411" endline="421" pcid="35864">
        {
            if (selectIndex > cursorIndex)
                selectIndex = cursorIndex;
            else
                cursorIndex = selectIndex;
            GrabGraphicalCursorPos();
            graphicalCursorPos.y += style.lineHeight + 5;
            cursorIndex = selectIndex = style.GetCursorStringIndex(localPosition, m_Content, graphicalCursorPos);
            if (cursorIndex == text.Length)
                ClearCursorPos();
        }
</source>
</class>

<class classid="189" nclones="2" nlines="10" similarity="80">
<source file="UnityCsReference/Modules/IMGUI/TextEditor.cs.ifdefed" startline="598" endline="609" pcid="35893">
        {
            if (m_bJustSelected)
                if (cursorIndex > selectIndex)
                { // swap
                    int tmp = cursorIndex;
                    cursorIndex = selectIndex;
                    selectIndex = tmp;
                }
            m_bJustSelected = false;

            cursorIndex = PreviousCodePointIndex(cursorIndex);
        }
</source>
<source file="UnityCsReference/Modules/IMGUI/TextEditor.cs.ifdefed" startline="612" endline="623" pcid="35895">
        {
            if (m_bJustSelected)
                if (cursorIndex < selectIndex)
                { // swap
                    int tmp = cursorIndex;
                    cursorIndex = selectIndex;
                    selectIndex = tmp;
                }
            m_bJustSelected = false;

            cursorIndex = NextCodePointIndex(cursorIndex);
        }
</source>
</class>

<class classid="190" nclones="2" nlines="14" similarity="71">
<source file="UnityCsReference/Modules/IMGUI/TextEditor.cs.ifdefed" startline="838" endline="852" pcid="35923">
        {
            ClearCursorPos();
            int cachedPos = selectIndex;
            if (cursorIndex < selectIndex)
            {
                selectIndex = cursorIndex;
                MoveWordRight();
                selectIndex = cachedPos;
                cursorIndex = cursorIndex < selectIndex ? cursorIndex : selectIndex;
                return;
            }
            selectIndex = cursorIndex;
            MoveWordRight();
            selectIndex = cachedPos;
        }
</source>
<source file="UnityCsReference/Modules/IMGUI/TextEditor.cs.ifdefed" startline="855" endline="869" pcid="35925">
        {
            ClearCursorPos();
            int cachedPos = selectIndex;
            if (cursorIndex > selectIndex)
            {
                selectIndex = cursorIndex;
                MoveWordLeft();
                selectIndex = cachedPos;
                cursorIndex = cursorIndex > selectIndex ? cursorIndex : selectIndex;
                return;
            }
            selectIndex = cursorIndex;
            MoveWordLeft();
            selectIndex = cachedPos;
        }
</source>
</class>

<class classid="191" nclones="2" nlines="10" similarity="70">
<source file="UnityCsReference/Modules/IMGUI/TextEditor.cs.ifdefed" startline="874" endline="884" pcid="35927">
        {
            ClearCursorPos();
            if (cursorIndex < selectIndex)
                cursorIndex = GetGraphicalLineStart(cursorIndex);
            else
            {
                int temp = cursorIndex;
                cursorIndex = GetGraphicalLineStart(selectIndex);
                selectIndex = temp;
            }
        }
</source>
<source file="UnityCsReference/Modules/IMGUI/TextEditor.cs.ifdefed" startline="889" endline="899" pcid="35929">
        {
            ClearCursorPos();
            if (cursorIndex > selectIndex)
                cursorIndex = GetGraphicalLineEnd(cursorIndex);
            else
            {
                int temp = cursorIndex;
                cursorIndex = GetGraphicalLineEnd(selectIndex);
                selectIndex = temp;
            }
        }
</source>
</class>

<class classid="192" nclones="3" nlines="11" similarity="83">
<source file="UnityCsReference/Modules/ShortcutManagerEditor/Directory.cs.ifdefed" startline="23" endline="39" pcid="36407">
        {
            outputShortcuts.Clear();

            Assert.IsNotNull(combinationSequence);
            Assert.IsTrue(combinationSequence.Count > 0, "Sequence can not be empty");

            foreach (var shortcutEntry in m_ShortcutEntries)
            {
                if (shortcutEntry.StartsWith(combinationSequence))
                {
                    if (context != null && Array.FindIndex(context, t => t == shortcutEntry.context || shortcutEntry.context != null && shortcutEntry.context.IsAssignableFrom(t)) < 0)
                        continue;

                    outputShortcuts.Add(shortcutEntry);
                }
            }
        }
</source>
<source file="UnityCsReference/Modules/ShortcutManagerEditor/Directory.cs.ifdefed" startline="60" endline="73" pcid="36413">
        {
            outputShortcuts.Clear();

            Assert.IsNotNull(combinationSequence);
            Assert.IsTrue(combinationSequence.Count > 0, "Sequence can not be empty");

            foreach (var shortcutEntry in m_ShortcutEntries)
            {
                if (shortcutEntry.StartsWith(combinationSequence))
                {
                    outputShortcuts.Add(shortcutEntry);
                }
            }
        }
</source>
<source file="UnityCsReference/Modules/ShortcutManagerEditor/Directory.cs.ifdefed" startline="42" endline="57" pcid="36410">
        {
            outputShortcuts.Clear();

            Assert.IsNotNull(combinationSequence);
            Assert.IsTrue(combinationSequence.Count > 0, "Sequence can not be empty");

            foreach (var shortcutEntry in m_ShortcutEntries)
            {
                if (shortcutEntry.StartsWith(combinationSequence))
                {
                    if (contextManager != null && !contextManager.HasAnyActiveContextOfType(shortcutEntry.context))
                        continue;
                    outputShortcuts.Add(shortcutEntry);
                }
            }
        }
</source>
</class>

<class classid="193" nclones="2" nlines="11" similarity="72">
<source file="UnityCsReference/Modules/Audio/Public/ScriptBindings/AudioExtensions.cs.ifdefed" startline="476" endline="490" pcid="36577">
        {
            foreach (AudioSpatializerExtensionDefinition definition in m_ListenerSpatializerExtensionDefinitions)
            {
                if (spatializerName == definition.spatializerName)
                {
                    Debug.Log("RegisterListenerSpatializerDefinition failed for " + extensionDefinition.GetExtensionType() + ". We only allow one audio listener extension to be registered for each spatializer.");
                    return false;
                }
            }

            AudioSpatializerExtensionDefinition newDefinition = new AudioSpatializerExtensionDefinition(spatializerName, extensionDefinition, editorDefinition);
            m_ListenerSpatializerExtensionDefinitions.Add(newDefinition);

            return true;
        }
</source>
<source file="UnityCsReference/Modules/Audio/Public/ScriptBindings/AudioExtensions.cs.ifdefed" startline="493" endline="507" pcid="36580">
        {
            foreach (AudioSpatializerExtensionDefinition definition in m_SourceSpatializerExtensionDefinitions)
            {
                if (spatializerName == definition.spatializerName)
                {
                    Debug.Log("RegisterSourceSpatializerDefinition failed for " + extensionDefinition.GetExtensionType() + ". We only allow one audio source extension to be registered for each spatializer.");
                    return false;
                }
            }

            AudioSpatializerExtensionDefinition newDefinition = new AudioSpatializerExtensionDefinition(spatializerName, extensionDefinition, editorDefinition);
            m_SourceSpatializerExtensionDefinitions.Add(newDefinition);

            return true;
        }
</source>
</class>

<class classid="194" nclones="2" nlines="14" similarity="92">
<source file="UnityCsReference/Modules/Audio/Public/ScriptBindings/AudioClipPlayable.bindings.cs.ifdefed" startline="137" endline="155" pcid="36605">
        {
            SetStartDelayInternal(ref m_Handle, startDelay);
            if (duration > 0)
            {
                // playable duration is the local time (without speed modifier applied)
                //  that it stops, since it will not advance time until the delay is complete
                m_Handle.SetDuration(duration + startTime);
                // start delay is offset by the length of the clip that plays
                SetPauseDelayInternal(ref m_Handle, startDelay + duration);
            }
            else
            {
                m_Handle.SetDuration(double.MaxValue);
                SetPauseDelayInternal(ref m_Handle, 0);
            }

            m_Handle.SetTime(startTime);
            m_Handle.Play();
        }
</source>
<source file="UnityCsReference/Modules/Video/Public/ScriptBindings/VideoClipPlayable.bindings.cs.ifdefed" startline="135" endline="154" pcid="37770">
        {
            ValidateStartDelayInternal(startDelay);
            SetStartDelayInternal(ref m_Handle, startDelay);
            if (duration > 0)
            {
                // playable duration is the local time (without speed modifier applied)
                //  that it stops, since it will not advance time until the delay is complete
                m_Handle.SetDuration(duration + startTime);
                // start delay is offset by the length of the clip that plays
                SetPauseDelayInternal(ref m_Handle, startDelay + duration);
            }
            else
            {
                m_Handle.SetDuration(double.MaxValue);
                SetPauseDelayInternal(ref m_Handle, 0);
            }

            m_Handle.SetTime(startTime);
            m_Handle.Play();
        }
</source>
</class>

<class classid="195" nclones="2" nlines="24" similarity="91">
<source file="UnityCsReference/Modules/ProfilerEditor/ProfilerWindow/NetworkDetailStats.cs.ifdefed" startline="139" endline="167" pcid="37081">
            {
                NetworkOperationEntryDetails entry;
                if (m_Entries.ContainsKey(entryName))
                {
                    entry = m_Entries[entryName];
                }
                else
                {
                    entry = new NetworkOperationEntryDetails();
                    entry.m_EntryName = entryName;
                    m_Entries[entryName] = entry;
                }
                entry.AddStat(direction, amount);

                switch (direction)
                {
                    case NetworkDirection.Incoming:
                    {
                        totalIn = amount;
                    }
                    break;

                    case NetworkDirection.Outgoing:
                    {
                        totalOut = amount;
                    }
                    break;
                }
            }
</source>
<source file="UnityCsReference/Modules/ProfilerEditor/ProfilerWindow/NetworkDetailStats.cs.ifdefed" startline="170" endline="198" pcid="37086">
            {
                NetworkOperationEntryDetails entry;
                if (m_Entries.ContainsKey(entryName))
                {
                    entry = m_Entries[entryName];
                }
                else
                {
                    entry = new NetworkOperationEntryDetails();
                    entry.m_EntryName = entryName;
                    m_Entries[entryName] = entry;
                }
                entry.AddStat(direction, amount);

                switch (direction)
                {
                    case NetworkDirection.Incoming:
                    {
                        totalIn += amount;
                    }
                    break;

                    case NetworkDirection.Outgoing:
                    {
                        totalOut += amount;
                    }
                    break;
                }
            }
</source>
</class>

<class classid="196" nclones="2" nlines="12" similarity="91">
<source file="UnityCsReference/Modules/ProfilerEditor/ProfilerWindow/NetworkDetailStats.cs.ifdefed" startline="219" endline="233" pcid="37094">
        {
            NetworkOperationDetails op;
            if (m_NetworkOperations.ContainsKey(msgId))
            {
                op = m_NetworkOperations[msgId];
            }
            else
            {
                op = new NetworkOperationDetails();
                op.MsgId = msgId;
                m_NetworkOperations[msgId] = op;
            }

            op.SetStat(direction, entryName, amount);
        }
</source>
<source file="UnityCsReference/Modules/ProfilerEditor/ProfilerWindow/NetworkDetailStats.cs.ifdefed" startline="236" endline="250" pcid="37097">
        {
            NetworkOperationDetails op;
            if (m_NetworkOperations.ContainsKey(msgId))
            {
                op = m_NetworkOperations[msgId];
            }
            else
            {
                op = new NetworkOperationDetails();
                op.MsgId = msgId;
                m_NetworkOperations[msgId] = op;
            }

            op.IncrementStat(direction, entryName, amount);
        }
</source>
</class>

<class classid="197" nclones="2" nlines="24" similarity="72">
<source file="UnityCsReference/Modules/ProfilerEditor/ProfilerWindow/AudioProfilerView.cs.ifdefed" startline="246" endline="282" pcid="37322">
        {
            if (m_HeaderStyle == null)
            {
                m_HeaderStyle = new GUIStyle("OL title");
            }

            m_HeaderStyle.alignment = TextAnchor.MiddleLeft;

            if (m_TreeView != null)
                return;

            m_Backend = backend;

            // Default widths
            if (m_TreeViewState.columnWidths == null || m_TreeViewState.columnWidths.Length == 0)
            {
                int numCols = AudioProfilerGroupInfoHelper.GetLastColumnIndex() + 1;
                m_TreeViewState.columnWidths = new float[numCols];
                for (int n = 2; n < numCols; n++)
                    m_TreeViewState.columnWidths[n] = (n == 2 || n == 3 || (n >= 11 && n <= 16)) ? 75 : 60;
                m_TreeViewState.columnWidths[0] = 140;
                m_TreeViewState.columnWidths[1] = 140;
            }

            m_TreeView = new TreeViewController(m_EditorWindow, m_TreeViewState);

            ITreeViewGUI gui = new AudioProfilerGroupViewGUI(m_TreeView);
            //ITreeViewDragging dragging = new TestDragging(m_TreeView);
            ITreeViewDataSource dataSource = new AudioProfilerDataSource(m_TreeView, m_Backend);
            m_TreeView.Init(rect, dataSource, gui, null);

            m_ColumnHeader = new AudioProfilerGroupViewColumnHeader(m_TreeViewState, m_Backend);
            m_ColumnHeader.columnWidths = m_TreeViewState.columnWidths;
            m_ColumnHeader.minColumnWidth = 30f;

            m_TreeView.selectionChangedCallback += OnTreeSelectionChanged;
        }
</source>
<source file="UnityCsReference/Modules/ProfilerEditor/ProfilerWindow/AudioProfilerView.cs.ifdefed" startline="895" endline="929" pcid="37387">
        {
            if (m_HeaderStyle == null)
            {
                m_HeaderStyle = new GUIStyle("OL title");
            }

            m_HeaderStyle.alignment = TextAnchor.MiddleLeft;

            if (m_TreeView != null)
                return;

            m_Backend = backend;

            // Default widths
            if (m_TreeViewState.columnWidths == null || m_TreeViewState.columnWidths.Length == 0)
            {
                int numCols = AudioProfilerClipInfoHelper.GetLastColumnIndex() + 1;
                m_TreeViewState.columnWidths = new float[numCols];
                for (int n = 0; n < numCols; n++)
                    m_TreeViewState.columnWidths[n] = (n == 0) ? 300 : (n == 2) ? 110 : 80;
            }

            m_TreeView = new TreeViewController(m_EditorWindow, m_TreeViewState);

            ITreeViewGUI gui = new AudioProfilerClipViewGUI(m_TreeView);
            //ITreeViewDragging dragging = new TestDragging(m_TreeView);
            ITreeViewDataSource dataSource = new AudioProfilerDataSource(m_TreeView, m_Backend);
            m_TreeView.Init(rect, dataSource, gui, null);

            m_ColumnHeader = new AudioProfilerClipViewColumnHeader(m_TreeViewState, m_Backend);
            m_ColumnHeader.columnWidths = m_TreeViewState.columnWidths;
            m_ColumnHeader.minColumnWidth = 30f;

            m_TreeView.selectionChangedCallback += OnTreeSelectionChanged;
        }
</source>
</class>

<class classid="198" nclones="2" nlines="10" similarity="90">
<source file="UnityCsReference/Modules/ProfilerEditor/ProfilerWindow/AudioProfilerView.cs.ifdefed" startline="307" endline="321" pcid="37329">
        {
            int keyboardControl = GUIUtility.GetControlID(FocusType.Keyboard, rect);

            Rect headerRect = new Rect(rect.x, rect.y, rect.width, m_HeaderStyle.fixedHeight);

            // Header
            GUI.Label(headerRect, "", m_HeaderStyle);
            m_ColumnHeader.OnGUI(headerRect, allowSorting, m_HeaderStyle);

            // TreeView
            rect.y += headerRect.height;
            rect.height -= headerRect.height;
            m_TreeView.OnEvent();
            m_TreeView.OnGUI(rect, keyboardControl);
        }
</source>
<source file="UnityCsReference/Modules/ProfilerEditor/ProfilerWindow/AudioProfilerView.cs.ifdefed" startline="945" endline="959" pcid="37393">
        {
            int keyboardControl = GUIUtility.GetControlID(FocusType.Keyboard, rect);

            Rect headerRect = new Rect(rect.x, rect.y, rect.width, m_HeaderStyle.fixedHeight);

            // Header
            GUI.Label(headerRect, "", m_HeaderStyle);
            m_ColumnHeader.OnGUI(headerRect, true, m_HeaderStyle);

            // TreeView
            rect.y += headerRect.height;
            rect.height -= headerRect.height;
            m_TreeView.OnEvent();
            m_TreeView.OnGUI(rect, keyboardControl);
        }
</source>
</class>

<class classid="199" nclones="2" nlines="27" similarity="96">
<source file="UnityCsReference/Modules/ProfilerEditor/ProfilerWindow/AudioProfilerView.cs.ifdefed" startline="410" endline="443" pcid="37340">
            {
                GUI.BeginClip(rect);
                const float dragAreaWidth = 3f;
                float columnPos = -m_TreeViewState.scrollPos.x;
                int lastColumnIndex = AudioProfilerGroupInfoHelper.GetLastColumnIndex();
                for (int i = 0; i <= lastColumnIndex; ++i)
                {
                    Rect columnRect = new Rect(columnPos, 0, columnWidths[i], rect.height - 1);
                    columnPos += columnWidths[i];
                    Rect dragRect = new Rect(columnPos - dragWidth / 2, 0, dragAreaWidth, rect.height);
                    float deltaX = EditorGUI.MouseDeltaReader(dragRect, true).x;
                    if (deltaX != 0f)
                    {
                        columnWidths[i] += deltaX;
                        columnWidths[i] = Mathf.Max(columnWidths[i], minColumnWidth);
                    }

                    string title = headers[i];
                    if (allowSorting && i == m_TreeViewState.selectedColumn)
                        title += m_TreeViewState.sortByDescendingOrder ? " \u25BC" : " \u25B2";

                    GUI.Box(columnRect, title, headerStyle);

                    if (allowSorting && Event.current.type == EventType.MouseDown && columnRect.Contains(Event.current.mousePosition))
                    {
                        m_TreeViewState.SetSelectedColumn(i);
                        m_Backend.UpdateSorting();
                    }

                    if (Event.current.type == EventType.Repaint)
                        EditorGUIUtility.AddCursorRect(dragRect, MouseCursor.SplitResizeLeftRight);
                }
                GUI.EndClip();
            }
</source>
<source file="UnityCsReference/Modules/ProfilerEditor/ProfilerWindow/AudioProfilerView.cs.ifdefed" startline="1038" endline="1071" pcid="37402">
            {
                GUI.BeginClip(rect);
                const float dragAreaWidth = 3f;
                float columnPos = -m_TreeViewState.scrollPos.x;
                int lastColumnIndex = AudioProfilerClipInfoHelper.GetLastColumnIndex();
                for (int i = 0; i <= lastColumnIndex; ++i)
                {
                    Rect columnRect = new Rect(columnPos, 0, columnWidths[i], rect.height - 1);
                    columnPos += columnWidths[i];
                    Rect dragRect = new Rect(columnPos - dragWidth / 2, 0, dragAreaWidth, rect.height);
                    float deltaX = EditorGUI.MouseDeltaReader(dragRect, true).x;
                    if (deltaX != 0f)
                    {
                        columnWidths[i] += deltaX;
                        columnWidths[i] = Mathf.Max(columnWidths[i], minColumnWidth);
                    }

                    string title = headers[i];
                    if (allowSorting && i == m_TreeViewState.selectedColumn)
                        title += m_TreeViewState.sortByDescendingOrder ? " \u25BC" : " \u25B2";

                    GUI.Box(columnRect, title, headerStyle);

                    if (allowSorting && Event.current.type == EventType.MouseDown && columnRect.Contains(Event.current.mousePosition))
                    {
                        m_TreeViewState.SetSelectedColumn(i);
                        m_Backend.UpdateSorting();
                    }

                    if (Event.current.type == EventType.Repaint)
                        EditorGUIUtility.AddCursorRect(dragRect, MouseCursor.SplitResizeLeftRight);
                }
                GUI.EndClip();
            }
</source>
</class>

<class classid="200" nclones="2" nlines="21" similarity="76">
<source file="UnityCsReference/Modules/ProfilerEditor/ProfilerWindow/AudioProfilerView.cs.ifdefed" startline="477" endline="503" pcid="37349">
            {
                if (Event.current.type != EventType.Repaint)
                    return;

                GUIStyle lineStyle = useBoldFont ? Styles.lineBoldStyle : Styles.lineStyle;
                var orgAlignment = lineStyle.alignment;

                lineStyle.alignment = TextAnchor.MiddleLeft;
                lineStyle.padding.left = 0;

                int margin = 2;
                base.OnContentGUI(new Rect(rect.x, rect.y, columnWidths[0] - margin, rect.height), row, item, label, selected, focused, useBoldFont, isPinging);

                rect.x += columnWidths[0] + margin;
                var profilerItem = item as AudioProfilerGroupTreeViewItem;
                for (int i = 1; i < columnWidths.Length; i++)
                {
                    rect.width = columnWidths[i] - 2 * margin;
                    lineStyle.Draw(rect, AudioProfilerGroupInfoHelper.GetColumnString(profilerItem.info, (AudioProfilerGroupInfoHelper.ColumnIndices)i), false, false, selected, focused);
                    Handles.color = Color.black;
                    Handles.DrawLine(new Vector3(rect.x - margin + 1, rect.y, 0), new Vector3(rect.x - margin + 1, rect.y + rect.height, 0));
                    rect.x += columnWidths[i];
                    lineStyle.alignment = TextAnchor.MiddleRight;
                }

                lineStyle.alignment = orgAlignment;
            }
</source>
<source file="UnityCsReference/Modules/ProfilerEditor/ProfilerWindow/AudioProfilerView.cs.ifdefed" startline="1105" endline="1129" pcid="37411">
            {
                if (Event.current.type != EventType.Repaint)
                    return;

                GUIStyle lineStyle = useBoldFont ? Styles.lineBoldStyle : Styles.lineStyle;
                lineStyle.alignment = TextAnchor.MiddleLeft;
                lineStyle.padding.left = 0;

                int margin = 2;
                base.OnContentGUI(new Rect(rect.x, rect.y, columnWidths[0] - margin, rect.height), row, item, label, selected, focused, useBoldFont, isPinging);

                rect.x += columnWidths[0] + margin;
                var profilerItem = item as AudioProfilerClipTreeViewItem;
                for (int i = 1; i < columnWidths.Length; i++)
                {
                    rect.width = columnWidths[i] - 2 * margin;
                    lineStyle.alignment = TextAnchor.MiddleRight;
                    lineStyle.Draw(rect, AudioProfilerClipInfoHelper.GetColumnString(profilerItem.info, (AudioProfilerClipInfoHelper.ColumnIndices)i), false, false, selected, focused);
                    Handles.color = Color.black;
                    Handles.DrawLine(new Vector3(rect.x - margin + 1, rect.y, 0), new Vector3(rect.x - margin + 1, rect.y + rect.height, 0));
                    rect.x += columnWidths[i];
                }

                lineStyle.alignment = TextAnchor.MiddleLeft;
            }
</source>
</class>

<class classid="201" nclones="2" nlines="17" similarity="82">
<source file="UnityCsReference/Modules/ProfilerEditor/ProfilerWindow/ProfilerFrameDataTreeView.cs.ifdefed" startline="246" endline="269" pcid="37507">
            {
                foreach (var marker in m_SelectedItemMarkerIdPath.Value.markerIds)
                {
                    if (m_FrameDataView.HasItemChildren(newSelectedId))
                    {
                        m_FrameDataView.GetItemChildren(newSelectedId, m_ReusableChildrenIds);
                        foreach (var childId in m_ReusableChildrenIds)
                        {
                            if (marker == m_FrameDataView.GetItemMarkerID(childId))
                            {
                                // check if the parent is expanded
                                if (!IsExpanded(newSelectedId))
                                    selectedItemsPathIsExpanded = false;

                                newSelectedId = childId;
                                break;
                            }
                        }
                    }

                    if (newSelectedId == 0)
                        break;
                }
            }
</source>
<source file="UnityCsReference/Modules/ProfilerEditor/ProfilerWindow/ProfilerFrameDataTreeView.cs.ifdefed" startline="275" endline="296" pcid="37513">
                {
                    if (m_FrameDataView.HasItemChildren(newSelectedId))
                    {
                        m_FrameDataView.GetItemChildren(newSelectedId, m_ReusableChildrenIds);
                        foreach (var childId in m_ReusableChildrenIds)
                        {
                            if (markerName == m_FrameDataView.GetItemFunctionName(childId))
                            {
                                // check if the parent is expanded
                                if (!IsExpanded(newSelectedId))
                                    selectedItemsPathIsExpanded = false;

                                newSelectedId = childId;
                                markerIdPath.Add(m_FrameDataView.GetItemMarkerID(childId));
                                break;
                            }
                        }
                    }

                    if (newSelectedId == 0)
                        break;
                }
</source>
</class>

<class classid="202" nclones="2" nlines="10" similarity="80">
<source file="UnityCsReference/Modules/AI/Builder/NavMeshBuilder.bindings.cs.ifdefed" startline="16" endline="25" pcid="37864">
        {
            if (markups == null) throw new ArgumentNullException("markups");
            if (results == null) throw new ArgumentNullException("results");

            // Ensure strictly positive extents
            includedWorldBounds.extents = Vector3.Max(includedWorldBounds.extents, 0.001f * Vector3.one);
            NavMeshBuildSource[] resultsArray = CollectSourcesInternal(includedLayerMask, includedWorldBounds, null, true, geometry, defaultArea, markups.ToArray());
            results.Clear();
            results.AddRange(resultsArray);
        }
</source>
<source file="UnityCsReference/Modules/AI/Builder/NavMeshBuilder.bindings.cs.ifdefed" startline="28" endline="37" pcid="37865">
        {
            if (markups == null) throw new ArgumentNullException("markups");
            if (results == null) throw new ArgumentNullException("results");
            // root == null is a valid argument

            var empty = new Bounds();
            NavMeshBuildSource[] resultsArray = CollectSourcesInternal(includedLayerMask, empty, root, false, geometry, defaultArea, markups.ToArray());
            results.Clear();
            results.AddRange(resultsArray);
        }
</source>
</class>

<class classid="203" nclones="2" nlines="15" similarity="70">
<source file="UnityCsReference/Modules/UIElements/EventDispatcher.cs.ifdefed" startline="286" endline="303" pcid="38114">
                    {
                        IMGUIContainer imguiContainer = panel.focusController.focusedElement as IMGUIContainer;

                        if (imguiContainer != null)
                        {
                            // THINK ABOUT THIS PF: shoudln't we allow for the capture dispatch phase?
                            if (imguiContainer != evt.skipElement && imguiContainer.HandleIMGUIEvent(evt.imguiEvent))
                            {
                                evt.StopPropagation();
                                evt.PreventDefault();
                            }
                        }
                        else
                        {
                            evt.target = panel.focusController.focusedElement;
                            PropagateEvent(evt);
                        }
                    }
</source>
<source file="UnityCsReference/Modules/UIElements/EventDispatcher.cs.ifdefed" startline="366" endline="387" pcid="38127">
                {
                    IMGUIContainer imguiContainer = panel.focusController.focusedElement as IMGUIContainer;

                    eventHandled = true;
                    if (imguiContainer != null)
                    {
                        if (imguiContainer != evt.skipElement && imguiContainer.HandleIMGUIEvent(evt.imguiEvent))
                        {
                            evt.StopPropagation();
                            evt.PreventDefault();
                        }
                    }
                    else if (panel.focusController.focusedElement != null)
                    {
                        evt.target = panel.focusController.focusedElement;
                        PropagateEvent(evt);
                    }
                    else
                    {
                        PropagateToIMGUIContainer(panel.visualTree, evt);
                    }
                }
</source>
</class>

<class classid="204" nclones="3" nlines="11" similarity="72">
<source file="UnityCsReference/Modules/UIElements/ListView.cs.ifdefed" startline="274" endline="288" pcid="38365">
        {
            if (!HasValidDataAndBindings())
                return;

            foreach (var recycledItem in m_Pool)
                if (recycledItem.index == index)
                    recycledItem.SetSelected(true);

            if (!m_SelectedIndices.Contains(index))
                m_SelectedIndices.Add(index);

            SelectionChanged();

            SavePersistentData();
        }
</source>
<source file="UnityCsReference/Modules/UIElements/ListView.cs.ifdefed" startline="308" endline="321" pcid="38367">
        {
            if (!HasValidDataAndBindings())
                return;

            foreach (var recycledItem in m_Pool)
                recycledItem.SetSelected(recycledItem.index == index);
            m_SelectedIndices.Clear();
            if (index >= 0)
                m_SelectedIndices.Add(index);

            SelectionChanged();

            SavePersistentData();
        }
</source>
<source file="UnityCsReference/Modules/UIElements/ListView.cs.ifdefed" startline="291" endline="305" pcid="38366">
        {
            if (!HasValidDataAndBindings())
                return;

            foreach (var recycledItem in m_Pool)
                if (recycledItem.index == index)
                    recycledItem.SetSelected(false);

            if (m_SelectedIndices.Contains(index))
                m_SelectedIndices.Remove(index);

            SelectionChanged();

            SavePersistentData();
        }
</source>
</class>

<class classid="205" nclones="2" nlines="10" similarity="80">
<source file="UnityCsReference/Modules/UIElements/VisualElementHierarchy.cs.ifdefed" startline="351" endline="363" pcid="38777">
            {
                if (childCount > 1)
                {
                    int index = m_Owner.m_Children.IndexOf(child);

                    if (index >= 0 && index < childCount - 1)
                    {
                        RemoveChildAtIndex(index);
                        PutChildAtIndex(child, childCount);
                        m_Owner.Dirty(ChangeType.Layout);
                    }
                }
            }
</source>
<source file="UnityCsReference/Modules/UIElements/VisualElementHierarchy.cs.ifdefed" startline="366" endline="378" pcid="38780">
            {
                if (childCount > 1)
                {
                    int index = m_Owner.m_Children.IndexOf(child);

                    if (index > 0)
                    {
                        RemoveChildAtIndex(index);
                        PutChildAtIndex(child, 0);
                        m_Owner.Dirty(ChangeType.Layout);
                    }
                }
            }
</source>
</class>

<class classid="206" nclones="2" nlines="13" similarity="71">
<source file="UnityCsReference/Modules/UIElements/VisualElementHierarchy.cs.ifdefed" startline="381" endline="400" pcid="38783">
            {
                if (childCount > 0)
                {
                    int index = m_Owner.m_Children.IndexOf(child);
                    if (index < 0)
                        return;

                    RemoveChildAtIndex(index);

                    index = m_Owner.m_Children.IndexOf(over);

                    if (index < 0) //how can this happen?
                    {
                        index = 0;
                    }

                    PutChildAtIndex(child, index);
                    m_Owner.Dirty(ChangeType.Layout);
                }
            }
</source>
<source file="UnityCsReference/Modules/UIElements/VisualElementHierarchy.cs.ifdefed" startline="403" endline="417" pcid="38786">
            {
                if (childCount > 0)
                {
                    int index = m_Owner.m_Children.IndexOf(child);
                    if (index < 0)
                        return;

                    RemoveChildAtIndex(index);

                    index = m_Owner.m_Children.IndexOf(under) + 1;

                    PutChildAtIndex(child, index);
                    m_Owner.Dirty(ChangeType.Layout);
                }
            }
</source>
</class>

<class classid="207" nclones="2" nlines="12" similarity="91">
<source file="UnityCsReference/Modules/PresetsEditor/PresetContextMenu.cs.ifdefed" startline="41" endline="57" pcid="39396">
                {
                    // We need to filter out .Array.* properties and use the parent one instead,
                    // because changing .Array.size from CopyFromSerializedProperty will corrupt the SerializedObject data.
                    if (!string.IsNullOrEmpty(propertyPath) && propertyModification.propertyPath.StartsWith(propertyPath + ".Array."))
                    {
                        continue;
                    }
                    if (propertyModification.propertyPath.Contains(".Array."))
                    {
                        propertyPath = propertyModification.propertyPath.Substring(0, propertyModification.propertyPath.IndexOf(".Array."));
                    }
                    else
                    {
                        propertyPath = propertyModification.propertyPath;
                    }
                    instance.m_ImporterSerialized.CopyFromSerializedProperty(currentEditorValues.FindProperty(propertyPath));
                }
</source>
<source file="UnityCsReference/Modules/PresetsEditor/PresetContextMenu.cs.ifdefed" startline="83" endline="99" pcid="39403">
                {
                    // We need to filter out .Array.* properties and use the parent one instead,
                    // because changing .Array.size from CopyFromSerializedProperty will corrupt the SerializedObject data.
                    if (!string.IsNullOrEmpty(propertyPath) && propertyModification.propertyPath.StartsWith(propertyPath + ".Array."))
                    {
                        continue;
                    }
                    if (propertyModification.propertyPath.Contains(".Array."))
                    {
                        propertyPath = propertyModification.propertyPath.Substring(0, propertyModification.propertyPath.IndexOf(".Array."));
                    }
                    else
                    {
                        propertyPath = propertyModification.propertyPath;
                    }
                    importerEditor.m_SerializedObject.CopyFromSerializedPropertyIfDifferent(m_ImporterSerialized.FindProperty(propertyPath));
                }
</source>
</class>

</clones>
